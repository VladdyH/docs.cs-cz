---
title: Synchronizace vláken (Visual Basic)
ms.date: 07/20/2015
ms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e
ms.openlocfilehash: 3278ed1e98f71e11d47f55a0d4cb50f44ae02027
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/01/2018
ms.locfileid: "43406621"
---
# <a name="thread-synchronization-visual-basic"></a><span data-ttu-id="3e1ec-102">Synchronizace vláken (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="3e1ec-102">Thread Synchronization (Visual Basic)</span></span>
<span data-ttu-id="3e1ec-103">Následující části popisují funkce a třídy, které slouží k synchronizaci přístupu k prostředkům ve vícevláknových aplikacích.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="3e1ec-104">Jednou z výhod používání více vláken v aplikaci je, že se každý podproces spustí asynchronně.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="3e1ec-105">Pro aplikace Windows díky tomu časově náročné úlohy provádět na pozadí při okna aplikace a ovládací prvky stále reagovat.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="3e1ec-106">Pro server aplikace multithreading poskytuje možnost pro zpracování jednotlivých příchozích požadavků s jiném vlákně.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="3e1ec-107">V opačném případě nebude získat každému novému požadavku Údržba až do předchozí požadavek nebyl plně spokojeni.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="3e1ec-108">Ale musí být koordinované asynchronní povaze vlákna znamená, že přístup k prostředkům, jako jsou popisovače souborů, připojení k síti a paměti.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="3e1ec-109">V opačném případě dvě či více vláken může přistupovat k stejný prostředek ve stejnou dobu, každý vědět o druhé strany akce.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="3e1ec-110">Výsledkem je poškození dat nepředvídatelné.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="3e1ec-111">Pro jednoduché operace na integrální číselné datové typy, synchronizaci vláken můžete docílit, když se členy <xref:System.Threading.Interlocked> třídy.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="3e1ec-112">Pro všechna ostatní data typů a prostředků, není bezpečná pro vlákno, multithreading lze bezpečně provést pouze pomocí konstrukce v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="3e1ec-113">Základní informace o programování s více vlákny naleznete v tématu:</span><span class="sxs-lookup"><span data-stu-id="3e1ec-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="3e1ec-114">Základy dělení na spravovaná vlákna</span><span class="sxs-lookup"><span data-stu-id="3e1ec-114">Managed Threading Basics</span></span>](../../../../standard/threading/managed-threading-basics.md)  
  
-   [<span data-ttu-id="3e1ec-115">Použití vláken a dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="3e1ec-115">Using Threads and Threading</span></span>](../../../../standard/threading/using-threads-and-threading.md)  
  
-   [<span data-ttu-id="3e1ec-116">Doporučené postupy dělení na spravovaná vlákna</span><span class="sxs-lookup"><span data-stu-id="3e1ec-116">Managed Threading Best Practices</span></span>](../../../../standard/threading/managed-threading-best-practices.md)  
  
## <a name="the-lock-and-synclock-keywords"></a><span data-ttu-id="3e1ec-117">Uzamčení a klíčová slova SyncLock</span><span class="sxs-lookup"><span data-stu-id="3e1ec-117">The lock and SyncLock Keywords</span></span>  
 <span data-ttu-id="3e1ec-118">Visual Basic `SyncLock` příkaz lze použít k zajištění, že blok kódu úloha poběží do konce bez přerušení jiných vláken.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-118">The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="3e1ec-119">Toho lze dosáhnout získání zámku vzájemné vyloučení pro daný objekt po dobu trvání bloku kódu.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="3e1ec-120">A `SyncLock` příkaz je zadaný objekt jako argument a následuje blok kódu, který je provádět najednou pouze jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-120">A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="3e1ec-121">Příklad:</span><span class="sxs-lookup"><span data-stu-id="3e1ec-121">For example:</span></span>  
  
```vb  
Public Class TestThreading  
    Dim lockThis As New Object  
  
    Public Sub Process()  
        SyncLock lockThis  
            ' Access thread-sensitive resources.  
        End SyncLock  
    End Sub  
End Class  
```  
  
 <span data-ttu-id="3e1ec-122">Argument uvedený pro `SyncLock` – klíčové slovo musí být objekt podle typu odkazu a slouží k definování oboru zámek.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-122">The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="3e1ec-123">V předchozím příkladu zámek rozsah je omezen na tuto funkci, protože žádné odkazy na objekt `lockThis` existují mimo funkci.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="3e1ec-124">Pokud takový odkaz, obor zámků i na tento objekt.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="3e1ec-125">Přesněji řečeno zadaný objekt slouží pouze k jednoznačné identifikaci sdílený mezi více vlákny, pak se instance libovolné třídy bude prostředek.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="3e1ec-126">V praxi, ale tento objekt obvykle představuje prostředek, pro které vlákno je nezbytné synchronizace.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="3e1ec-127">Pokud objekt kontejneru se použije ve víc vláknech, potom kontejner může být předán Zamknout a blok synchronizované kódu po uzamčení bude přístup ke kontejneru.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="3e1ec-128">Tak dlouho, dokud jiná vlákna uzamkne na stejném obsahuje před přístupem k jeho, pak se bezpečně synchronizuje přístup k objektu.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="3e1ec-129">Obecně je vhodné vyhnout zamykání `public` typ, nebo na instance objektů mimo kontrolu vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="3e1ec-130">Například `lockThis` může být problematické, pokud instance je přístupná veřejně, protože mohou na objekt i uzamknout kódu mimo vaši kontrolu.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-130">For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="3e1ec-131">To může vytvořit zablokování situací, ve kterém dvě či více vláken čeká na uvolnění na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="3e1ec-132">Uzamčení na veřejné datový typ, na rozdíl od objektu, může způsobit problémy ze stejného důvodu.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="3e1ec-133">Uzamčení na literál řetězce je zejména riskantní, protože řetězcové literály jsou *internovány* modulem common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="3e1ec-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="3e1ec-134">To znamená, že jednu instanci libovolné daný řetězec je literál celého programu, přesně stejný objekt představuje literál ve všech spuštění aplikační domény, na všech vláknech.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="3e1ec-135">V důsledku toho uzamknout řetězec s použitím stejného obsahu kdekoli v procesu uzamčení aplikace všechny výskyty tohoto řetězce do aplikace.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="3e1ec-136">V důsledku toho je nejlepší soukromé nebo chráněné člena, který není internovány zamknout.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="3e1ec-137">Některé třídy poskytovaly členy speciálně pro uzamčení.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="3e1ec-138"><xref:System.Array> Typ, například poskytuje <xref:System.Array.SyncRoot%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="3e1ec-139">Poskytuje mnoho typů kolekce `SyncRoot` také člena.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="3e1ec-140">Další informace o `SyncLock` příkaz, naleznete v následujících tématech:</span><span class="sxs-lookup"><span data-stu-id="3e1ec-140">For more information about the `SyncLock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="3e1ec-141">Příkaz SyncLock</span><span class="sxs-lookup"><span data-stu-id="3e1ec-141">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
  
-   <xref:System.Threading.Monitor>  
  
## <a name="monitors"></a><span data-ttu-id="3e1ec-142">Sledování</span><span class="sxs-lookup"><span data-stu-id="3e1ec-142">Monitors</span></span>  
 <span data-ttu-id="3e1ec-143">Podobně jako `SyncLock` – klíčové slovo, monitorování předcházet bloky kódu z souběžné provádění více vláken.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-143">Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="3e1ec-144"><xref:System.Threading.Monitor.Enter%2A> Metoda umožňuje jeden a pouze jeden vláknu pokračovat na následující příkazy – všechny ostatní vlákna jsou zablokována až do spuštěné vlákno vyvolá <xref:System.Threading.Monitor.Exit%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="3e1ec-145">Toto je stejně jako kdybyste službu `SyncLock` – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-145">This is just like using the `SyncLock` keyword.</span></span> <span data-ttu-id="3e1ec-146">Příklad:</span><span class="sxs-lookup"><span data-stu-id="3e1ec-146">For example:</span></span>  
  
```vb  
SyncLock x  
    DoSomething()  
End SyncLock  
```  
  
 <span data-ttu-id="3e1ec-147">To je ekvivalentní:</span><span class="sxs-lookup"><span data-stu-id="3e1ec-147">This is equivalent to:</span></span>  
  
```vb  
Dim obj As Object = CType(x, Object)  
System.Threading.Monitor.Enter(obj)  
Try  
    DoSomething()  
Finally  
    System.Threading.Monitor.Exit(obj)  
End Try  
```  
  
 <span data-ttu-id="3e1ec-148">Pomocí `SyncLock` – klíčové slovo je obecně upřednostňované nad pomocí <xref:System.Threading.Monitor> přímo třídu, obě protože `SyncLock` je stručnější a protože `SyncLock` zajistí, že základní monitorování vydání, i v případě chráněných kód vyvolá výjimku došlo k výjimce.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-148">Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="3e1ec-149">Toho se dosahuje pomocí `Finally` – klíčové slovo, která spustí bloku přidružený kód bez ohledu na to, zda je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-149">This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="3e1ec-150">Synchronizace události a obslužné rutiny čekání</span><span class="sxs-lookup"><span data-stu-id="3e1ec-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="3e1ec-151">Použití uzamčení nebo monitorování je k zamezení souběžné provádění vlákna zohledňující bloky kódu, ale tyto konstrukce neumožňují jedno vlákno pro komunikaci událost do jiného.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="3e1ec-152">To vyžaduje, aby *synchronizace události*, které jsou objekty, které mají jednu ze dvou stavů, signalizovaného a zrušení signalizovaného, který slouží k aktivaci a pozastavení vlákna.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="3e1ec-153">Vlákna pozastaví pomocí provádí čekání na událost synchronizace, která je unsignaled a je možné aktivovat tak, že změníte stav událostí na signál.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="3e1ec-154">Pokud vlákno se pokusí čekání na událost, která je již signalizována, vlákno pokračuje k provedení bez zpoždění.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="3e1ec-155">Existují dva typy událostí synchronizace: <xref:System.Threading.AutoResetEvent>, a <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="3e1ec-156">Se liší pouze v dané <xref:System.Threading.AutoResetEvent> změny z signalizován na unsignaled automaticky pokaždé, když se aktivuje vlákno.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="3e1ec-157">Naopak <xref:System.Threading.ManualResetEvent> umožňuje libovolný počet vláken aktivováno signalizovaného stavu a bude pouze používat unsignaled stav, kdy jeho <xref:System.Threading.EventWaitHandle.Reset%2A> metoda je volána.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="3e1ec-158">Vlákna můžete provést pro čekání na události ve volání jedné z metod čekání, jako například <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, nebo <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="3e1ec-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> způsobí, že vlákno počkat, až bude signál, jedna událost, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> blokuje vlákno, dokud jeden nebo více uvedené události stát signalizovanými, a <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> blokuje vlákno, dokud všechny uvedené události signálování.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="3e1ec-160">Událost se stane signál, když jeho <xref:System.Threading.EventWaitHandle.Set%2A> metoda je volána.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="3e1ec-161">V následujícím příkladu se vytvoří a tím, že vlákno `Main` funkce.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="3e1ec-162">Nové vlákno čeká na událost pomocí <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="3e1ec-163">Vlákno je pozastaveno, dokud události stane primární vlákno, které provádí signál, `Main` funkce.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="3e1ec-164">Jakmile bude signál události, vrátí pomocné vlákno.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="3e1ec-165">V tomto případě protože událost se používá jenom pro jedno vlákno aktivace, buď <xref:System.Threading.AutoResetEvent> nebo <xref:System.Threading.ManualResetEvent> třídy může používat.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```vb  
Imports System.Threading  
  
Module Module1  
    Dim autoEvent As AutoResetEvent  
  
    Sub DoWork()  
        Console.WriteLine("   worker thread started, now waiting on event...")  
        autoEvent.WaitOne()  
        Console.WriteLine("   worker thread reactivated, now exiting...")  
    End Sub  
  
    Sub Main()  
        autoEvent = New AutoResetEvent(False)  
  
        Console.WriteLine("main thread starting worker thread...")  
        Dim t As New Thread(AddressOf DoWork)  
        t.Start()  
  
        Console.WriteLine("main thread sleeping for 1 second...")  
        Thread.Sleep(1000)  
  
        Console.WriteLine("main thread signaling worker thread...")  
        autoEvent.Set()  
    End Sub  
End Module  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="3e1ec-166">Objekt mutex</span><span class="sxs-lookup"><span data-stu-id="3e1ec-166">Mutex Object</span></span>  
 <span data-ttu-id="3e1ec-167">A *mutex* se podobá monitorování, zabrání současné spuštění bloku kódu ve více než jedno vlákno v čase.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="3e1ec-168">Název "mutex" se ve skutečnosti zkráceným tvarem termín "vzájemně se vylučuje."</span><span class="sxs-lookup"><span data-stu-id="3e1ec-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="3e1ec-169">Na rozdíl od monitorování ale objekt mutex slouží k synchronizaci vláken napříč procesy.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="3e1ec-170">Objekt mutex je reprezentována <xref:System.Threading.Mutex> třídy.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="3e1ec-171">Když se použije pro synchronizaci mezi procesy, se nazývá mutex *pojmenovaný vzájemně vyloučený přístup* vzhledem k tomu je možné použít v jiné aplikaci, a proto není možné sdílet prostřednictvím globální nebo statická proměnná.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="3e1ec-172">To se musí předávat název, aby obě aplikace přístup na stejný objekt mutex.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="3e1ec-173">Objekt mutex lze pro synchronizaci vláken uvnitř procesu, ale pomocí <xref:System.Threading.Monitor> je obecně upřednostňované, protože monitorování byly navrženy specificky pro rozhraní .NET Framework a proto lépe využívat zdroje.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="3e1ec-174">Naproti tomu <xref:System.Threading.Mutex> třídy tvoří obálku pro konstrukci Win32.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="3e1ec-175">I když je výkonnější než monitorování, mutex vyžaduje vzájemné spolupráce přechody, která jsou než ty, které vyžadují více výpočetně náročné <xref:System.Threading.Monitor> třídy.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="3e1ec-176">Příklad použití objektu mutex, naleznete v tématu [mutexů](../../../../standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="3e1ec-176">For an example of using a mutex, see [Mutexes](../../../../standard/threading/mutexes.md).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="3e1ec-177">Interlocked – třída</span><span class="sxs-lookup"><span data-stu-id="3e1ec-177">Interlocked Class</span></span>  
 <span data-ttu-id="3e1ec-178">Můžete použít metody <xref:System.Threading.Interlocked> třídy, aby se zabránilo problémům, které může dojít, pokud více vláken pokusí zároveň aktualizovat nebo porovnání stejnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="3e1ec-179">Metody této třídy umožňují bezpečně přírůstek, snížení, exchange a porovnat hodnoty z libovolného vlákna.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="3e1ec-180">Zámky ReaderWriter</span><span class="sxs-lookup"><span data-stu-id="3e1ec-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="3e1ec-181">V některých případech můžete uzamknout prostředek pouze v případě, že se zápisem dat a povolit víc klientů současně číst data, když se aktualizuje data.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="3e1ec-182"><xref:System.Threading.ReaderWriterLock> Třídě vynucuje exkluzivní přístup k prostředku vlákno upravuje prostředek, ale umožní přístup neexkluzivní při čtení prostředku.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="3e1ec-183">Zámky ReaderWriter jsou užitečnou alternativou pro výhradní zámek, které způsobují ostatní vlákna čekat, i když tato vlákna není potřeba aktualizovat data.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="3e1ec-184">Zablokování</span><span class="sxs-lookup"><span data-stu-id="3e1ec-184">Deadlocks</span></span>  
 <span data-ttu-id="3e1ec-185">Synchronizace vláken je neocenitelný při řízení aplikací s více vlákny, ale je vždy nebezpečí vytvoření `deadlock`, kde více vláken čekají na sebe navzájem a aplikace jde o zastavení.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="3e1ec-186">Zablokování je podobná situace, ve kterém auta se zastaví na zarážku čtyř směrů a každý uživatel, který čeká na další přechod.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="3e1ec-187">Předcházení zablokování je důležité. klíč je pečlivé plánování.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="3e1ec-188">Často můžete předpovídat situace zablokování pomocí diagramů vícevláknové aplikace před spuštěním kódu.</span><span class="sxs-lookup"><span data-stu-id="3e1ec-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3e1ec-189">Viz také</span><span class="sxs-lookup"><span data-stu-id="3e1ec-189">See Also</span></span>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.WaitHandle.WaitOne%2A>  
 <xref:System.Threading.WaitHandle.WaitAny%2A>  
 <xref:System.Threading.WaitHandle.WaitAll%2A>  
 <xref:System.Threading.Thread.Join%2A>  
 <xref:System.Threading.Thread.Start%2A>  
 <xref:System.Threading.Thread.Sleep%2A>  
 <xref:System.Threading.Monitor>  
 <xref:System.Threading.Mutex>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 <xref:System.Threading.Interlocked>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading>  
 <xref:System.Threading.EventWaitHandle.Set%2A>  
 <xref:System.Threading.Monitor>  
 [<span data-ttu-id="3e1ec-190">Příkaz SyncLock</span><span class="sxs-lookup"><span data-stu-id="3e1ec-190">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
 [<span data-ttu-id="3e1ec-191">Mutex – třídy</span><span class="sxs-lookup"><span data-stu-id="3e1ec-191">Mutexes</span></span>](../../../../standard/threading/mutexes.md)  
 [<span data-ttu-id="3e1ec-192">Propojené operace</span><span class="sxs-lookup"><span data-stu-id="3e1ec-192">Interlocked Operations</span></span>](../../../../standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="3e1ec-193">AutoResetEvent</span><span class="sxs-lookup"><span data-stu-id="3e1ec-193">AutoResetEvent</span></span>](../../../../standard/threading/autoresetevent.md)  
 [<span data-ttu-id="3e1ec-194">Synchronizace dat pro vícevláknové zpracování</span><span class="sxs-lookup"><span data-stu-id="3e1ec-194">Synchronizing Data for Multithreading</span></span>](../../../../standard/threading/synchronizing-data-for-multithreading.md)
