---
title: "Try...Catch....Finally – příkaz (Visual Basic)"
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: devlang-visual-basic
ms.topic: article
f1_keywords:
- vb.Try...Catch...Finally
- vb.when
- vb.Finally
- vb.Catch
- vb.Try
helpviewer_keywords:
- Try...Catch...Finally statements
- Try statement [Visual Basic]
- try-catch exception handling, Try...Catch...Finally statements
- error handling, while running code
- Try statement [Visual Basic], Try...Catch...Finally
- Finally keyword [Visual Basic], Try...Catch...Finally
- Catch statement [Visual Basic]
- When keyword [Visual Basic]
- Visual Basic code, handling errors while running
- structured exception handling, Try...Catch...Finally statements
ms.assetid: d6488026-ccb3-42b8-a810-0d97b9d6472b
caps.latest.revision: "69"
author: dotnet-bot
ms.author: dotnetcontent
ms.openlocfilehash: 08de4939960d8297269c82b1b040537dd43f3038
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/21/2017
---
# <a name="trycatchfinally-statement-visual-basic"></a><span data-ttu-id="158d2-102">Try...Catch....Finally – příkaz (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="158d2-102">Try...Catch...Finally Statement (Visual Basic)</span></span>
<span data-ttu-id="158d2-103">Poskytuje způsob, jak zpracovávat některé nebo všechny možné chyby, které mohou nastat v každém bloku kódu, při stále běhu kódu.</span><span class="sxs-lookup"><span data-stu-id="158d2-103">Provides a way to handle some or all possible errors that may occur in a given block of code, while still running code.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="158d2-104">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="158d2-104">Syntax</span></span>  
  
```  
Try  
    [ tryStatements ]  
    [ Exit Try ]  
[ Catch [ exception [ As type ] ] [ When expression ]  
    [ catchStatements ]  
    [ Exit Try ] ]  
[ Catch ... ]  
[ Finally  
    [ finallyStatements ] ]  
End Try  
```  
  
## <a name="parts"></a><span data-ttu-id="158d2-105">Součásti</span><span class="sxs-lookup"><span data-stu-id="158d2-105">Parts</span></span>  
  
|<span data-ttu-id="158d2-106">Termín</span><span class="sxs-lookup"><span data-stu-id="158d2-106">Term</span></span>|<span data-ttu-id="158d2-107">Definice</span><span class="sxs-lookup"><span data-stu-id="158d2-107">Definition</span></span>|  
|---|---|  
|`tryStatements`|<span data-ttu-id="158d2-108">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-108">Optional.</span></span> <span data-ttu-id="158d2-109">Příkazy, kde může dojít k chybě.</span><span class="sxs-lookup"><span data-stu-id="158d2-109">Statement(s) where an error can occur.</span></span> <span data-ttu-id="158d2-110">Může být složený příkaz.</span><span class="sxs-lookup"><span data-stu-id="158d2-110">Can be a compound statement.</span></span>|  
|`Catch`|<span data-ttu-id="158d2-111">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-111">Optional.</span></span> <span data-ttu-id="158d2-112">Více `Catch` bloky povolené.</span><span class="sxs-lookup"><span data-stu-id="158d2-112">Multiple `Catch` blocks permitted.</span></span> <span data-ttu-id="158d2-113">Pokud dojde k výjimce při zpracování `Try` blokovat, každý `Catch` v textové pořadí k určení, zda ji s ošetří výjimku, je zkontrolován příkaz `exception` představující výjimku, která byla vyvolána.</span><span class="sxs-lookup"><span data-stu-id="158d2-113">If an exception occurs when processing the `Try` block, each `Catch` statement is examined in textual order to determine whether it handles the exception, with `exception` representing the exception that has been thrown.</span></span>|  
|`exception`|<span data-ttu-id="158d2-114">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-114">Optional.</span></span> <span data-ttu-id="158d2-115">Libovolný název proměnné.</span><span class="sxs-lookup"><span data-stu-id="158d2-115">Any variable name.</span></span> <span data-ttu-id="158d2-116">Počáteční hodnota `exception` je hodnota této výjimce dojde chyby.</span><span class="sxs-lookup"><span data-stu-id="158d2-116">The initial value of `exception` is the value of the thrown error.</span></span> <span data-ttu-id="158d2-117">Použít s `Catch` k určení chyba zachycena.</span><span class="sxs-lookup"><span data-stu-id="158d2-117">Used with `Catch` to specify the error caught.</span></span> <span data-ttu-id="158d2-118">Pokud tento parametr vynechán, `Catch` příkaz zachytí všechny výjimky.</span><span class="sxs-lookup"><span data-stu-id="158d2-118">If omitted, the `Catch` statement catches any exception.</span></span>|  
|`type`|<span data-ttu-id="158d2-119">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-119">Optional.</span></span> <span data-ttu-id="158d2-120">Určuje typ třídy filtru.</span><span class="sxs-lookup"><span data-stu-id="158d2-120">Specifies the type of class filter.</span></span> <span data-ttu-id="158d2-121">Pokud hodnota `exception` je v typu zadaném pomocí `type` nebo odvozený typ se změní na identifikátor vázaná na objekt výjimky.</span><span class="sxs-lookup"><span data-stu-id="158d2-121">If the value of `exception` is of the type specified by `type` or of a derived type, the identifier becomes bound to the exception object.</span></span>|  
|`When`|<span data-ttu-id="158d2-122">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-122">Optional.</span></span> <span data-ttu-id="158d2-123">A `Catch` příkaz s `When` klauzule zachytí výjimky pouze tehdy, když `expression` vyhodnocuje `True`.</span><span class="sxs-lookup"><span data-stu-id="158d2-123">A `Catch` statement with a `When` clause catches exceptions only when `expression` evaluates to `True`.</span></span> <span data-ttu-id="158d2-124">A `When` klauzule se použije pouze po zkontrolování typ výjimky, a `expression` mohou odkazovat na identifikátor reprezentující výjimku.</span><span class="sxs-lookup"><span data-stu-id="158d2-124">A `When` clause is applied only after checking the type of the exception, and `expression` may refer to the identifier representing the exception.</span></span>|  
|`expression`|<span data-ttu-id="158d2-125">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-125">Optional.</span></span> <span data-ttu-id="158d2-126">Musí být implicitně převést na `Boolean`.</span><span class="sxs-lookup"><span data-stu-id="158d2-126">Must be implicitly convertible to `Boolean`.</span></span> <span data-ttu-id="158d2-127">Všechny výraz, který popisuje obecný filtru.</span><span class="sxs-lookup"><span data-stu-id="158d2-127">Any expression that describes a generic filter.</span></span> <span data-ttu-id="158d2-128">Obvykle se používá k filtrování podle číslo chyby.</span><span class="sxs-lookup"><span data-stu-id="158d2-128">Typically used to filter by error number.</span></span> <span data-ttu-id="158d2-129">Použít s `When` – klíčové slovo k určení podmínek, za kterých je chyba zachycena.</span><span class="sxs-lookup"><span data-stu-id="158d2-129">Used with `When` keyword to specify circumstances under which the error is caught.</span></span>|  
|`catchStatements`|<span data-ttu-id="158d2-130">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-130">Optional.</span></span> <span data-ttu-id="158d2-131">Příkazy se budou zpracovávat chyby, ke kterým došlo v přidruženém `Try` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-131">Statement(s) to handle errors that occur in the associated `Try` block.</span></span> <span data-ttu-id="158d2-132">Může být složený příkaz.</span><span class="sxs-lookup"><span data-stu-id="158d2-132">Can be a compound statement.</span></span>|  
|`Exit Try`|<span data-ttu-id="158d2-133">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-133">Optional.</span></span> <span data-ttu-id="158d2-134">Klíčové slovo, které dělí mimo `Try...Catch...Finally` struktura.</span><span class="sxs-lookup"><span data-stu-id="158d2-134">Keyword that breaks out of the `Try...Catch...Finally` structure.</span></span> <span data-ttu-id="158d2-135">Provádění pokračuje hned za kódem `End Try` příkaz.</span><span class="sxs-lookup"><span data-stu-id="158d2-135">Execution resumes with the code immediately following the `End Try` statement.</span></span> <span data-ttu-id="158d2-136">`Finally` Stále bude třeba spustit příkaz.</span><span class="sxs-lookup"><span data-stu-id="158d2-136">The `Finally` statement will still be executed.</span></span> <span data-ttu-id="158d2-137">Není povoleno v `Finally` bloky.</span><span class="sxs-lookup"><span data-stu-id="158d2-137">Not allowed in `Finally` blocks.</span></span>|  
|`Finally`|<span data-ttu-id="158d2-138">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-138">Optional.</span></span> <span data-ttu-id="158d2-139">A `Finally` bloku je vždy provést při spuštění opustí libovolná součást `Try...Catch` příkaz.</span><span class="sxs-lookup"><span data-stu-id="158d2-139">A `Finally` block is always executed when execution leaves any part of the `Try...Catch` statement.</span></span>|  
|`finallyStatements`|<span data-ttu-id="158d2-140">Volitelné.</span><span class="sxs-lookup"><span data-stu-id="158d2-140">Optional.</span></span> <span data-ttu-id="158d2-141">Příkazy, které jsou spouštěny po další zpracování chyby došlo k chybě.</span><span class="sxs-lookup"><span data-stu-id="158d2-141">Statement(s) that are executed after all other error processing has occurred.</span></span>|  
|`End Try`|<span data-ttu-id="158d2-142">Ukončí `Try...Catch...Finally` struktura.</span><span class="sxs-lookup"><span data-stu-id="158d2-142">Terminates the `Try...Catch...Finally` structure.</span></span>|  
  
## <a name="remarks"></a><span data-ttu-id="158d2-143">Poznámky</span><span class="sxs-lookup"><span data-stu-id="158d2-143">Remarks</span></span>  
 <span data-ttu-id="158d2-144">Pokud očekáváte, že konkrétní výjimka mohou nastat během určité části kódu, vložte kód `Try` blokovat a použít `Catch` blok k uchování kontroly a zpracovat výjimku, pokud k němu dojde.</span><span class="sxs-lookup"><span data-stu-id="158d2-144">If you expect that a particular exception might occur during a particular section of code, put the code in a `Try` block and use a `Catch` block to retain control and handle the exception if it occurs.</span></span>  
  
 <span data-ttu-id="158d2-145">A `Try…Catch` příkaz se skládá z `Try` bloku, za nímž následuje jeden nebo více `Catch` klauzule, které určují obslužné rutiny pro různé výjimky.</span><span class="sxs-lookup"><span data-stu-id="158d2-145">A `Try…Catch` statement consists of a `Try` block followed by one or more `Catch` clauses, which specify handlers for various exceptions.</span></span> <span data-ttu-id="158d2-146">Pokud je vyvolána výjimka `Try` bloku [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] hledá `Catch` příkaz, který zpracovává výjimku.</span><span class="sxs-lookup"><span data-stu-id="158d2-146">When an exception is thrown in a `Try` block, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] looks for the `Catch` statement that handles the exception.</span></span> <span data-ttu-id="158d2-147">Pokud odpovídající `Catch` příkaz nebyl nalezen, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] prozkoumá metodu, která volá metodu aktuální, a tak dále zásobníkem volání.</span><span class="sxs-lookup"><span data-stu-id="158d2-147">If a matching `Catch` statement is not found, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] examines the method that called the current method, and so on up the call stack.</span></span> <span data-ttu-id="158d2-148">Pokud žádné `Catch` bloku nenajde, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] zobrazí uživateli zprávu neošetřené výjimky a zastaví provádění tohoto programu.</span><span class="sxs-lookup"><span data-stu-id="158d2-148">If no `Catch` block is found, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] displays an unhandled exception message to the user and stops execution of the program.</span></span>  
  
 <span data-ttu-id="158d2-149">Můžete použít více než jednu `Catch` příkaz v `Try…Catch` příkaz.</span><span class="sxs-lookup"><span data-stu-id="158d2-149">You can use more than one `Catch` statement in a `Try…Catch` statement.</span></span> <span data-ttu-id="158d2-150">Pokud použijete tento pořadí `Catch` klauzule je důležité, protože se zkontrolují v pořadí.</span><span class="sxs-lookup"><span data-stu-id="158d2-150">If you do this, the order of the `Catch` clauses is significant because they are examined in order.</span></span> <span data-ttu-id="158d2-151">Před méně konkrétní ty catch konkrétnější výjimky.</span><span class="sxs-lookup"><span data-stu-id="158d2-151">Catch the more specific exceptions before the less specific ones.</span></span>  
  
 <span data-ttu-id="158d2-152">Následující `Catch` příkaz podmínky jsou nejméně specifická a zachytí všechny výjimky, které jsou odvozeny od <xref:System.Exception> třídy.</span><span class="sxs-lookup"><span data-stu-id="158d2-152">The following `Catch` statement conditions are the least specific, and will catch all exceptions that derive from the <xref:System.Exception> class.</span></span> <span data-ttu-id="158d2-153">Jeden z těchto variant má obvykle použít jako poslední `Catch` blokovat `Try...Catch...Finally` struktura po zachycování specifických výjimek očekáváte.</span><span class="sxs-lookup"><span data-stu-id="158d2-153">You should ordinarily use one of these variations as the last `Catch` block in the `Try...Catch...Finally` structure, after catching all the specific exceptions you expect.</span></span> <span data-ttu-id="158d2-154">Tok řízení nikdy dosáhnout `Catch` blok, který odpovídá některé z těchto variant.</span><span class="sxs-lookup"><span data-stu-id="158d2-154">Control flow can never reach a `Catch` block that follows either of these variations.</span></span>  
  
-   <span data-ttu-id="158d2-155">`type` Je `Exception`, například:`Catch ex As Exception`</span><span class="sxs-lookup"><span data-stu-id="158d2-155">The `type` is `Exception`, for example: `Catch ex As Exception`</span></span>  
  
-   <span data-ttu-id="158d2-156">Příkaz neobsahuje žádné `exception` proměnných, například:`Catch`</span><span class="sxs-lookup"><span data-stu-id="158d2-156">The statement has no `exception` variable, for example: `Catch`</span></span>  
  
 <span data-ttu-id="158d2-157">Když `Try…Catch…Finally` příkaz vnořen v jiném `Try` bloku [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] nejprve zkontroluje každý `Catch` příkaz v nejvnitřnější `Try` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-157">When a `Try…Catch…Finally` statement is nested in another `Try` block, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] first examines each `Catch` statement in the innermost `Try` block.</span></span> <span data-ttu-id="158d2-158">Pokud neexistuje odpovídající `Catch` příkaz nenajde, vyhledávání pokračuje do `Catch` ve vnějším `Try…Catch…Finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-158">If no matching `Catch` statement is found, the search proceeds to the `Catch` statements of the outer `Try…Catch…Finally` block.</span></span>  
  
 <span data-ttu-id="158d2-159">Lokální proměnné z `Try` nejsou k dispozici v bloku `Catch` blokovat, protože jsou samostatné bloky.</span><span class="sxs-lookup"><span data-stu-id="158d2-159">Local variables from a `Try` block are not available in a `Catch` block because they are separate blocks.</span></span> <span data-ttu-id="158d2-160">Pokud chcete použití proměnné v více než jeden blok, deklarovat proměnnou mimo `Try...Catch...Finally` struktura.</span><span class="sxs-lookup"><span data-stu-id="158d2-160">If you want to use a variable in more than one block, declare the variable outside the `Try...Catch...Finally` structure.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="158d2-161">`Try…Catch…Finally` Údajů je k dispozici jako fragment kódu technologie IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="158d2-161">The `Try…Catch…Finally` statement is available as an IntelliSense code snippet.</span></span> <span data-ttu-id="158d2-162">Ve Správci fragmentů kódu, rozbalte položku **kód vzory – Pokud pro každou, zkuste Catch, vlastnost atd**a potom **chyba zpracování (výjimek)**.</span><span class="sxs-lookup"><span data-stu-id="158d2-162">In the Code Snippets Manager, expand **Code Patterns - If, For Each, Try Catch, Property, etc**, and then **Error Handling (Exceptions)**.</span></span> <span data-ttu-id="158d2-163">Další informace najdete v tématu [fragmenty kódu](/visualstudio/ide/code-snippets).</span><span class="sxs-lookup"><span data-stu-id="158d2-163">For more information, see [Code Snippets](/visualstudio/ide/code-snippets).</span></span>  
  
## <a name="finally-block"></a><span data-ttu-id="158d2-164">Nakonec bloku</span><span class="sxs-lookup"><span data-stu-id="158d2-164">Finally Block</span></span>  
 <span data-ttu-id="158d2-165">Pokud máte jeden nebo více příkazů, které musí spustit před ukončení `Try` struktury, použijte `Finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-165">If you have one or more statements that must run before you exit the `Try` structure, use a `Finally` block.</span></span> <span data-ttu-id="158d2-166">Ovládací prvek předává do `Finally` blokovat těsně před předává mimo `Try…Catch` struktura.</span><span class="sxs-lookup"><span data-stu-id="158d2-166">Control passes to the `Finally` block just before it passes out of the `Try…Catch` structure.</span></span> <span data-ttu-id="158d2-167">To platí i v případě, že dojde k výjimce uvnitř kdekoli `Try` struktura.</span><span class="sxs-lookup"><span data-stu-id="158d2-167">This is true even if an exception occurs anywhere inside the `Try` structure.</span></span>  
  
 <span data-ttu-id="158d2-168">A `Finally` blok je užitečné pro spuštění jakékoli kódu, které musí spustit i v případě, že dojde k výjimce.</span><span class="sxs-lookup"><span data-stu-id="158d2-168">A `Finally` block is useful for running any code that must execute even if there is an exception.</span></span> <span data-ttu-id="158d2-169">Ovládací prvek je předána `Finally` bloku bez ohledu na to, jak `Try...Catch` blokovat ukončí.</span><span class="sxs-lookup"><span data-stu-id="158d2-169">Control is passed to the `Finally` block regardless of how the `Try...Catch` block exits.</span></span>  
  
 <span data-ttu-id="158d2-170">Kód v `Finally` blokovat spustí i v případě, že váš kód zjistí `Return` příkaz v `Try` nebo `Catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-170">The code in a `Finally` block runs even if your code encounters a `Return` statement in a `Try` or `Catch` block.</span></span> <span data-ttu-id="158d2-171">Ovládací prvek z nepředává `Try` nebo `Catch` blokovat do odpovídajících `Finally` blokovat v následujících případech:</span><span class="sxs-lookup"><span data-stu-id="158d2-171">Control does not pass from a `Try` or `Catch` block to the corresponding `Finally` block in the following cases:</span></span>  
  
-   <span data-ttu-id="158d2-172">[End – příkaz](../../../visual-basic/language-reference/statements/end-statement.md) se vyskytuje v `Try` nebo `Catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-172">An [End Statement](../../../visual-basic/language-reference/statements/end-statement.md) is encountered in the `Try` or `Catch` block.</span></span>  
  
-   <span data-ttu-id="158d2-173">A <xref:System.StackOverflowException> je vyvolána `Try` nebo `Catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-173">A <xref:System.StackOverflowException> is thrown in the `Try` or `Catch` block.</span></span>  
  
 <span data-ttu-id="158d2-174">Není platný pro explicitně přenos provádění do `Finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-174">It is not valid to explicitly transfer execution into a `Finally` block.</span></span> <span data-ttu-id="158d2-175">Přenos provádění mimo `Finally` blok není platný, s výjimkou prostřednictvím výjimku.</span><span class="sxs-lookup"><span data-stu-id="158d2-175">Transferring execution out of a `Finally` block is not valid, except through an exception.</span></span>  
  
 <span data-ttu-id="158d2-176">Pokud `Try` příkaz neobsahuje alespoň jeden `Catch` bloku musí obsahovat `Finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-176">If a `Try` statement does not contain at least one `Catch` block, it must contain a `Finally` block.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="158d2-177">Pokud nemáte zachytit specifické výjimky `Using` příkaz chová jako `Try…Finally` bloku a zaručuje uvolnění prostředků, bez ohledu na to, jak byl ukončen blok.</span><span class="sxs-lookup"><span data-stu-id="158d2-177">If you do not have to catch specific exceptions, the `Using` statement behaves like a `Try…Finally` block, and guarantees disposal of the resources, regardless of how you exit the block.</span></span> <span data-ttu-id="158d2-178">To platí i s k neošetřené výjimce.</span><span class="sxs-lookup"><span data-stu-id="158d2-178">This is true even with an unhandled exception.</span></span> <span data-ttu-id="158d2-179">Další informace najdete v tématu [pomocí příkazu](../../../visual-basic/language-reference/statements/using-statement.md).</span><span class="sxs-lookup"><span data-stu-id="158d2-179">For more information, see [Using Statement](../../../visual-basic/language-reference/statements/using-statement.md).</span></span>  
  
## <a name="exception-argument"></a><span data-ttu-id="158d2-180">Výjimky argumentu</span><span class="sxs-lookup"><span data-stu-id="158d2-180">Exception Argument</span></span>  
 <span data-ttu-id="158d2-181">`Catch` Bloku `exception` argument je instance <xref:System.Exception> nebo třída odvozená z `Exception` třídy.</span><span class="sxs-lookup"><span data-stu-id="158d2-181">The `Catch` block `exception` argument is an instance of the <xref:System.Exception> class or a class that derives from the `Exception` class.</span></span> <span data-ttu-id="158d2-182">`Exception` Odpovídá chybu, která došlo k chybě v instanci třídy `Try` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-182">The `Exception` class instance corresponds to the error that occurred in the `Try` block.</span></span>  
  
 <span data-ttu-id="158d2-183">Vlastnosti `Exception` objektu nápovědy k identifikaci příčina a umístění výjimku.</span><span class="sxs-lookup"><span data-stu-id="158d2-183">The properties of the `Exception` object help to identify the cause and location of an exception.</span></span> <span data-ttu-id="158d2-184">Například <xref:System.Exception.StackTrace%2A> seznamů vlastností vyvolání metody, které vedly k výjimce a pomáhá vám zjistit, kde došlo k chybě v kódu.</span><span class="sxs-lookup"><span data-stu-id="158d2-184">For example, the <xref:System.Exception.StackTrace%2A> property lists the called methods that led to the exception, helping you find where the error occurred in the code.</span></span> <span data-ttu-id="158d2-185"><xref:System.Exception.Message%2A>vrátí zprávu, která popisuje výjimku.</span><span class="sxs-lookup"><span data-stu-id="158d2-185"><xref:System.Exception.Message%2A> returns a message that describes the exception.</span></span> <span data-ttu-id="158d2-186"><xref:System.Exception.HelpLink%2A>Vrátí odkaz na související soubor nápovědy.</span><span class="sxs-lookup"><span data-stu-id="158d2-186"><xref:System.Exception.HelpLink%2A> returns a link to an associated Help file.</span></span> <span data-ttu-id="158d2-187"><xref:System.Exception.InnerException%2A>Vrátí `Exception` objektu, která způsobila, že aktuální výjimku nebo vrátí `Nothing` Pokud neexistuje žádné původní `Exception`.</span><span class="sxs-lookup"><span data-stu-id="158d2-187"><xref:System.Exception.InnerException%2A> returns the `Exception` object that caused the current exception, or it returns `Nothing` if there is no original `Exception`.</span></span>  
  
## <a name="considerations-when-using-a-trycatch-statement"></a><span data-ttu-id="158d2-188">Informace týkající se použití bloku Try... Catch – příkaz</span><span class="sxs-lookup"><span data-stu-id="158d2-188">Considerations When Using a Try…Catch Statement</span></span>  
 <span data-ttu-id="158d2-189">Použití `Try…Catch` příkaz pouze na signalizaci výskytem program neobvyklou nebo neočekávané události.</span><span class="sxs-lookup"><span data-stu-id="158d2-189">Use a `Try…Catch` statement only to signal the occurrence of unusual or unanticipated program events.</span></span> <span data-ttu-id="158d2-190">Důvody zahrnují následující:</span><span class="sxs-lookup"><span data-stu-id="158d2-190">Reasons for this include the following:</span></span>  
  
-   <span data-ttu-id="158d2-191">Zachytávání výjimek v době běhu vytvoří další režii a může být pomalejší než předem kontrola předejdete výjimky.</span><span class="sxs-lookup"><span data-stu-id="158d2-191">Catching exceptions at runtime creates additional overhead, and is likely to be slower than pre-checking to avoid exceptions.</span></span>  
  
-   <span data-ttu-id="158d2-192">Pokud `Catch` blok není správně zpracovává, výjimka nemusí být správně hlášené uživatelům.</span><span class="sxs-lookup"><span data-stu-id="158d2-192">If a `Catch` block is not handled correctly, the exception might not be reported correctly to users.</span></span>  
  
-   <span data-ttu-id="158d2-193">Zpracovávání výjimek v jazyce díky program složitější.</span><span class="sxs-lookup"><span data-stu-id="158d2-193">Exception handling makes a program more complex.</span></span>  
  
 <span data-ttu-id="158d2-194">Není vždy nutné `Try…Catch` příkaz zkontrolujte podmínku, která může dojít.</span><span class="sxs-lookup"><span data-stu-id="158d2-194">You do not always need a `Try…Catch` statement to check for a condition that is likely to occur.</span></span> <span data-ttu-id="158d2-195">Následující příklad zkontroluje, zda soubor existuje, než se pokusíte otevřít.</span><span class="sxs-lookup"><span data-stu-id="158d2-195">The following example checks whether a file exists before trying to open it.</span></span> <span data-ttu-id="158d2-196">Tím se snižuje potřebu zachytávání výjimka vyvolaná objektem <xref:System.IO.File.OpenText%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="158d2-196">This reduces the need for catching an exception thrown by the <xref:System.IO.File.OpenText%2A> method.</span></span>  
  
 [!code-vb[VbVbalrStatements#94](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_1.vb)]  
  
 <span data-ttu-id="158d2-197">Ujistěte se, že kód v `Catch` bloky může hlásit výjimky pro uživatele, správně prostřednictvím bezpečné pro přístup z více vláken protokolování nebo odpovídající zprávy.</span><span class="sxs-lookup"><span data-stu-id="158d2-197">Ensure that code in `Catch` blocks can properly report exceptions to users, whether through thread-safe logging or appropriate messages.</span></span> <span data-ttu-id="158d2-198">Výjimky, jinak může zůstat neznámé.</span><span class="sxs-lookup"><span data-stu-id="158d2-198">Otherwise, exceptions might remain unknown.</span></span>  
  
## <a name="async-methods"></a><span data-ttu-id="158d2-199">Asynchronní metody</span><span class="sxs-lookup"><span data-stu-id="158d2-199">Async Methods</span></span>  
 <span data-ttu-id="158d2-200">Pokud označíte metodu s [asynchronní](../../../visual-basic/language-reference/modifiers/async.md) modifikátor, můžete použít [Await](../../../visual-basic/language-reference/operators/await-operator.md) operátor v metodě.</span><span class="sxs-lookup"><span data-stu-id="158d2-200">If you mark a method with the [Async](../../../visual-basic/language-reference/modifiers/async.md) modifier, you can use the [Await](../../../visual-basic/language-reference/operators/await-operator.md) operator in the method.</span></span> <span data-ttu-id="158d2-201">Příkaz s `Await` operátor pozastaví spuštění metody až do dokončení awaited úloh.</span><span class="sxs-lookup"><span data-stu-id="158d2-201">A statement with the `Await` operator suspends execution of the method until the awaited task completes.</span></span> <span data-ttu-id="158d2-202">Úloha reprezentuje probíhající práce.</span><span class="sxs-lookup"><span data-stu-id="158d2-202">The task represents ongoing work.</span></span> <span data-ttu-id="158d2-203">Když úloha, která je přidružená `Await` operátor dokončí, obnoví spuštění ve stejnou metodu.</span><span class="sxs-lookup"><span data-stu-id="158d2-203">When the task that's associated with the `Await` operator finishes, execution resumes in the same method.</span></span> <span data-ttu-id="158d2-204">Další informace najdete v tématu [řízení toku v asynchronních programech](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md).</span><span class="sxs-lookup"><span data-stu-id="158d2-204">For more information, see [Control Flow in Async Programs](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md).</span></span>  
  
 <span data-ttu-id="158d2-205">Úlohu vrácený asynchronní metody může se stát v chybovém stavu, která udává, zda byla dokončena z důvodu neošetřené výjimky.</span><span class="sxs-lookup"><span data-stu-id="158d2-205">A task returned by an Async method may end in a faulted state, indicating that it completed due to an unhandled exception.</span></span> <span data-ttu-id="158d2-206">Úloha může také končit zrušené stavu, což vede `OperationCanceledException` hlášeny mimo await výraz.</span><span class="sxs-lookup"><span data-stu-id="158d2-206">A task may also end in a canceled state, which results in an `OperationCanceledException` being thrown out of the await expression.</span></span> <span data-ttu-id="158d2-207">K zachycení buď typ výjimky, umístit `Await` výraz, který je spojen s úloha v `Try` blokovat a zachycení výjimky v `Catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-207">To catch either type of exception, place the `Await` expression that's associated with the task in a `Try` block, and catch the exception in the `Catch` block.</span></span> <span data-ttu-id="158d2-208">Příklad je k dispozici dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="158d2-208">An example is provided later in this topic.</span></span>  
  
 <span data-ttu-id="158d2-209">Úloha může být v chybovém stavu, protože byly zodpovědná za jeho chybující více výjimek.</span><span class="sxs-lookup"><span data-stu-id="158d2-209">A task can be in a faulted state because multiple exceptions were responsible for its faulting.</span></span> <span data-ttu-id="158d2-210">Úloha může být například výsledek volání <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="158d2-210">For example, the task might be the result of a call to <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="158d2-211">Pokud jste await takových úloh, zachycená výjimka je pouze jeden z výjimky a nemůžete předpovědět, které k výjimce.</span><span class="sxs-lookup"><span data-stu-id="158d2-211">When you await such a task, the caught exception is only one of the exceptions, and you can't predict which exception will be caught.</span></span> <span data-ttu-id="158d2-212">Příklad je k dispozici dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="158d2-212">An example is provided later in this topic.</span></span>  
  
 <span data-ttu-id="158d2-213">`Await` Výraz nesmí být uvnitř `Catch` bloku nebo `Finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-213">An `Await` expression can't be inside a `Catch` block or `Finally` block.</span></span>  
  
## <a name="iterators"></a><span data-ttu-id="158d2-214">Iterátory</span><span class="sxs-lookup"><span data-stu-id="158d2-214">Iterators</span></span>  
 <span data-ttu-id="158d2-215">Iterator funkce nebo `Get` přistupujícího objektu provede vlastní iteraci přes kolekci.</span><span class="sxs-lookup"><span data-stu-id="158d2-215">An iterator function or `Get` accessor performs a custom iteration over a collection.</span></span> <span data-ttu-id="158d2-216">Používá iterovat [Yield](../../../visual-basic/language-reference/statements/yield-statement.md) příkaz vrátit každý prvek kolekce, jeden v čase.</span><span class="sxs-lookup"><span data-stu-id="158d2-216">An iterator uses a [Yield](../../../visual-basic/language-reference/statements/yield-statement.md) statement to return each element of the collection one at a time.</span></span> <span data-ttu-id="158d2-217">Volání funkce iterator pomocí [For Each... Další příkaz](../../../visual-basic/language-reference/statements/for-each-next-statement.md).</span><span class="sxs-lookup"><span data-stu-id="158d2-217">You call an iterator function by using a [For Each...Next Statement](../../../visual-basic/language-reference/statements/for-each-next-statement.md).</span></span>  
  
 <span data-ttu-id="158d2-218">A `Yield` příkaz může být uvnitř `Try` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-218">A `Yield` statement can be inside a `Try` block.</span></span> <span data-ttu-id="158d2-219">A `Try` blok, který obsahuje `Yield` příkaz může mít `Catch` blokuje a může mít `Finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-219">A `Try` block that contains a `Yield` statement can have `Catch` blocks, and can have a `Finally` block.</span></span> <span data-ttu-id="158d2-220">Najdete v části "zkuste bloky v jazyce Visual Basic" [iterátory](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7) příklad.</span><span class="sxs-lookup"><span data-stu-id="158d2-220">See the "Try Blocks in Visual Basic" section of [Iterators](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7) for an example.</span></span>  
  
 <span data-ttu-id="158d2-221">A `Yield` příkaz nemůže být uvnitř `Catch` bloku nebo `Finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-221">A `Yield` statement cannot be inside a `Catch` block or a `Finally` block.</span></span>  
  
 <span data-ttu-id="158d2-222">Pokud `For Each` textu (mimo funkci iterator) vyvolá výjimku, `Catch` bloku ve funkci iterator není proveden, ale `Finally` bloku ve funkci iterator se spustí.</span><span class="sxs-lookup"><span data-stu-id="158d2-222">If the `For Each` body (outside of the iterator function) throws an exception, a `Catch` block in the iterator function is not executed, but a `Finally` block in the iterator function is executed.</span></span> <span data-ttu-id="158d2-223">A `Catch` bloku uvnitř funkce iterator zachytí pouze výjimky, které nastat uvnitř funkce iterator.</span><span class="sxs-lookup"><span data-stu-id="158d2-223">A `Catch` block inside an iterator function catches only exceptions that occur inside the iterator function.</span></span>  
  
## <a name="partial-trust-situations"></a><span data-ttu-id="158d2-224">Situace částečné důvěryhodnosti</span><span class="sxs-lookup"><span data-stu-id="158d2-224">Partial-Trust Situations</span></span>  
 <span data-ttu-id="158d2-225">V situacích, částečným vztahem důvěryhodnosti, například aplikace hostované ve sdílené síťové složce `Try...Catch...Finally` nezachytí výjimky zabezpečení, které dojít před vyvoláním metody, která obsahuje volání.</span><span class="sxs-lookup"><span data-stu-id="158d2-225">In partial-trust situations, such as an application hosted on a network share, `Try...Catch...Finally` does not catch security exceptions that occur before the method that contains the call is invoked.</span></span> <span data-ttu-id="158d2-226">Následující příklad, pokud jste pro něj na sdílené složky serveru a spustit z ní, vytváří chyba "System.Security.SecurityException: žádosti se nezdařilo."</span><span class="sxs-lookup"><span data-stu-id="158d2-226">The following example, when you put it on a server share and run from there, produces the error "System.Security.SecurityException: Request Failed."</span></span> <span data-ttu-id="158d2-227">Další informace o výjimkách zabezpečení najdete v tématu <xref:System.Security.SecurityException> třídy.</span><span class="sxs-lookup"><span data-stu-id="158d2-227">For more information about security exceptions, see the <xref:System.Security.SecurityException> class.</span></span>  
  
 [!code-vb[VbVbalrStatements#85](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_2.vb)]  
  
 <span data-ttu-id="158d2-228">V této částečným vztahem důvěryhodnosti situaci, budete muset uvést `Process.Start` příkaz v samostatném `Sub`.</span><span class="sxs-lookup"><span data-stu-id="158d2-228">In such a partial-trust situation, you have to put the `Process.Start` statement in a separate `Sub`.</span></span> <span data-ttu-id="158d2-229">Počáteční volání `Sub` se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="158d2-229">The initial call to the `Sub` will fail.</span></span> <span data-ttu-id="158d2-230">To umožňuje `Try...Catch` k zachycení ho před `Sub` obsahující `Process.Start` spuštění a vytváří výjimka zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="158d2-230">This enables `Try...Catch` to catch it before the `Sub` that contains `Process.Start` is started and the security exception produced.</span></span>  
  
## <a name="example"></a><span data-ttu-id="158d2-231">Příklad</span><span class="sxs-lookup"><span data-stu-id="158d2-231">Example</span></span>  
 <span data-ttu-id="158d2-232">Následující příklad ilustruje strukturu `Try...Catch...Finally` příkaz.</span><span class="sxs-lookup"><span data-stu-id="158d2-232">The following example illustrates the structure of the `Try...Catch...Finally` statement.</span></span>  
  
 [!code-vb[VbVbalrStatements#86](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_3.vb)]  
  
## <a name="example"></a><span data-ttu-id="158d2-233">Příklad</span><span class="sxs-lookup"><span data-stu-id="158d2-233">Example</span></span>  
 <span data-ttu-id="158d2-234">V následujícím příkladu `CreateException` metoda vrátí `NullReferenceException`.</span><span class="sxs-lookup"><span data-stu-id="158d2-234">In the following example, the `CreateException` method throws a `NullReferenceException`.</span></span> <span data-ttu-id="158d2-235">Kód, který generuje výjimky se nepoužívá `Try` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-235">The code that generates the exception is not in a `Try` block.</span></span> <span data-ttu-id="158d2-236">Proto `CreateException` metoda zpracovává výjimku.</span><span class="sxs-lookup"><span data-stu-id="158d2-236">Therefore, the `CreateException` method does not handle the exception.</span></span> <span data-ttu-id="158d2-237">`RunSample` Metoda ošetření výjimky, protože volání `CreateException` metoda je `Try` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-237">The `RunSample` method does handle the exception because the call to the `CreateException` method is in a `Try` block.</span></span>  
  
 <span data-ttu-id="158d2-238">Příklad obsahuje `Catch` příkazy pro několik typů výjimek, seřazené od nejvíce konkrétních k nejvíce Obecné.</span><span class="sxs-lookup"><span data-stu-id="158d2-238">The example includes `Catch` statements for several types of exceptions, ordered from the most specific to the most general.</span></span>  
  
 [!code-vb[VbVbalrStatements#91](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_4.vb)]  
  
## <a name="example"></a><span data-ttu-id="158d2-239">Příklad</span><span class="sxs-lookup"><span data-stu-id="158d2-239">Example</span></span>  
 <span data-ttu-id="158d2-240">Následující příklad ukazuje, jak používat `Catch When` příkaz pro filtrování podmíněným výrazem.</span><span class="sxs-lookup"><span data-stu-id="158d2-240">The following example shows how to use a `Catch When` statement to filter on a conditional expression.</span></span> <span data-ttu-id="158d2-241">Pokud je výsledkem podmíněným výrazem `True`, kód `Catch` blokovat spuštění.</span><span class="sxs-lookup"><span data-stu-id="158d2-241">If the conditional expression evaluates to `True`, the code in the `Catch` block runs.</span></span>  
  
 [!code-vb[VbVbalrStatements#92](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_5.vb)]  
  
## <a name="example"></a><span data-ttu-id="158d2-242">Příklad</span><span class="sxs-lookup"><span data-stu-id="158d2-242">Example</span></span>  
 <span data-ttu-id="158d2-243">V následujícím příkladu má `Try…Catch` příkaz, který je součástí `Try` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-243">The following example has a `Try…Catch` statement that is contained in a `Try` block.</span></span> <span data-ttu-id="158d2-244">Vnitřní `Catch` bloku vyvolá výjimku, která má jeho `InnerException` vlastností nastavenou na původní výjimka.</span><span class="sxs-lookup"><span data-stu-id="158d2-244">The inner `Catch` block throws an exception that has its `InnerException` property set to the original exception.</span></span> <span data-ttu-id="158d2-245">Vnější `Catch` bloku sestav svou vlastní výjimku a v popisu vnitřní výjimky.</span><span class="sxs-lookup"><span data-stu-id="158d2-245">The outer `Catch` block reports its own exception and the inner exception.</span></span>  
  
 [!code-vb[VbVbalrStatements#93](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_6.vb)]  
  
## <a name="example"></a><span data-ttu-id="158d2-246">Příklad</span><span class="sxs-lookup"><span data-stu-id="158d2-246">Example</span></span>  
 <span data-ttu-id="158d2-247">Následující příklad ilustruje zpracování výjimek pro asynchronní metody.</span><span class="sxs-lookup"><span data-stu-id="158d2-247">The following example illustrates exception handling for async methods.</span></span> <span data-ttu-id="158d2-248">Zachytit výjimku, která platí pro asynchronní úlohy, `Await` výraz `Try` je bloku volající a výjimka zachycena v `Catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="158d2-248">To catch an exception that applies to an async task, the `Await` expression is in a `Try` block of the caller, and the exception is caught in the `Catch` block.</span></span>  
  
 <span data-ttu-id="158d2-249">Zrušením komentáře u `Throw New Exception` řádku v příkladu za účelem ukázky zpracování výjimek.</span><span class="sxs-lookup"><span data-stu-id="158d2-249">Uncomment the `Throw New Exception` line in the example to demonstrate exception handling.</span></span> <span data-ttu-id="158d2-250">Výjimka je zachycena v `Catch` blok úkolu `IsFaulted` je nastavena na `True`a tato úloha `Exception.InnerException` je nastavena na výjimku.</span><span class="sxs-lookup"><span data-stu-id="158d2-250">The exception is caught in the `Catch` block, the task's `IsFaulted` property is set to `True`, and the task's `Exception.InnerException` property is set to the exception.</span></span>  
  
 <span data-ttu-id="158d2-251">Zrušením komentáře u `Throw New OperationCancelledException` řádku k předvedení toho, co se stane, když zrušíte asynchronní proces.</span><span class="sxs-lookup"><span data-stu-id="158d2-251">Uncomment the `Throw New OperationCancelledException` line to demonstrate what happens when you cancel an asynchronous process.</span></span> <span data-ttu-id="158d2-252">Výjimka je zachycena v `Catch` bloku a úkolu `IsCanceled` je nastavena na `True`.</span><span class="sxs-lookup"><span data-stu-id="158d2-252">The exception is caught in the `Catch` block, and the task's `IsCanceled` property is set to `True`.</span></span> <span data-ttu-id="158d2-253">Ale za určitých podmínek, které se nevztahují na tomto příkladu `IsFaulted` je nastaven na `True` a `IsCanceled` je nastaven na `False`.</span><span class="sxs-lookup"><span data-stu-id="158d2-253">However, under some conditions that don't apply to this example, `IsFaulted` is set to `True` and `IsCanceled` is set to `False`.</span></span>  
  
 [!code-vb[csAsyncExceptions#1](../../../csharp/language-reference/keywords/codesnippet/VisualBasic/try-catch-finally-statement_7.vb)]  
  
## <a name="example"></a><span data-ttu-id="158d2-254">Příklad</span><span class="sxs-lookup"><span data-stu-id="158d2-254">Example</span></span>  
 <span data-ttu-id="158d2-255">Následující příklad ukazuje zpracování výjimek, kde více úloh může mít za následek více výjimek.</span><span class="sxs-lookup"><span data-stu-id="158d2-255">The following example illustrates exception handling where multiple tasks can result in multiple exceptions.</span></span> <span data-ttu-id="158d2-256">`Try` Má bloku `Await` výraz pro úlohu, <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> vrátila.</span><span class="sxs-lookup"><span data-stu-id="158d2-256">The `Try` block has the `Await` expression for the task that <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> returned.</span></span> <span data-ttu-id="158d2-257">Úloha je dokončená, když jsou tři úlohy, ke kterému <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> platí jsou dokončeny.</span><span class="sxs-lookup"><span data-stu-id="158d2-257">The task is complete when the three tasks to which <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> is applied are complete.</span></span>  
  
 <span data-ttu-id="158d2-258">Jednotlivé tři úlohy dojde k výjimce.</span><span class="sxs-lookup"><span data-stu-id="158d2-258">Each of the three tasks causes an exception.</span></span> <span data-ttu-id="158d2-259">`Catch` Bloku iteruje výjimky, které jsou součástí `Exception.InnerExceptions` vlastnosti úlohy, `Task.WhenAll` vrátila.</span><span class="sxs-lookup"><span data-stu-id="158d2-259">The `Catch` block iterates through the exceptions, which are found in the `Exception.InnerExceptions` property of the task that `Task.WhenAll` returned.</span></span>  
  
 [!code-vb[csAsyncExceptions#3](../../../csharp/language-reference/keywords/codesnippet/VisualBasic/try-catch-finally-statement_8.vb)]  
  
## <a name="see-also"></a><span data-ttu-id="158d2-260">Viz také</span><span class="sxs-lookup"><span data-stu-id="158d2-260">See Also</span></span>  
 <xref:Microsoft.VisualBasic.Information.Err%2A>  
 <xref:System.Exception>  
 [<span data-ttu-id="158d2-261">Exit – příkaz</span><span class="sxs-lookup"><span data-stu-id="158d2-261">Exit Statement</span></span>](../../../visual-basic/language-reference/statements/exit-statement.md)  
 [<span data-ttu-id="158d2-262">On Error – příkaz</span><span class="sxs-lookup"><span data-stu-id="158d2-262">On Error Statement</span></span>](../../../visual-basic/language-reference/statements/on-error-statement.md)  
 [<span data-ttu-id="158d2-263">Osvědčené postupy pro používání fragmentů kódu</span><span class="sxs-lookup"><span data-stu-id="158d2-263">Best Practices for Using Code Snippets</span></span>](/visualstudio/ide/best-practices-for-using-code-snippets)  
 [<span data-ttu-id="158d2-264">Zpracování výjimek</span><span class="sxs-lookup"><span data-stu-id="158d2-264">Exception Handling</span></span>](https://msdn.microsoft.com/library/dd997415)  
 [<span data-ttu-id="158d2-265">Throw – příkaz</span><span class="sxs-lookup"><span data-stu-id="158d2-265">Throw Statement</span></span>](../../../visual-basic/language-reference/statements/throw-statement.md)
