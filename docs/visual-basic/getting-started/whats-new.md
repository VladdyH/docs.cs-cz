---
title: Co je nového v jazyce Visual Basic
ms.date: 02/15/2018
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: 145
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 34c7e7147ce7ae43926de1796bee433667f08331
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/26/2018
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="1b558-102">Co je nového v jazyce Visual Basic</span><span class="sxs-lookup"><span data-stu-id="1b558-102">What's new for Visual Basic</span></span>

<span data-ttu-id="1b558-103">Toto téma obsahuje seznam názvů klíčových funkcí pro každou verzi jazyka Visual Basic s podrobný popis nových a vylepšených funkcí v nejnovější verzi jazyka.</span><span class="sxs-lookup"><span data-stu-id="1b558-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="1b558-104">Aktuální verze</span><span class="sxs-lookup"><span data-stu-id="1b558-104">Current Version</span></span>

<span data-ttu-id="1b558-105">Visual Basic 15,5</span><span class="sxs-lookup"><span data-stu-id="1b558-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="1b558-106">Nové funkce, najdete v části [15,5 Visual Basic](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="1b558-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="1b558-107">Předchozí verze</span><span class="sxs-lookup"><span data-stu-id="1b558-107">Previous versions</span></span>

<span data-ttu-id="1b558-108">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="1b558-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="1b558-109">Nové funkce, najdete v části [15.3 jazyka Visual Basic](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="1b558-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="1b558-110">2017 Visual Basic</span><span class="sxs-lookup"><span data-stu-id="1b558-110">Visual Basic 2017</span></span>   
<span data-ttu-id="1b558-111">Nové funkce, najdete v části [2017 Visual Basic](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="1b558-111">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="1b558-112">Visual Basic / Visual Studio 2015 rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="1b558-112">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="1b558-113">Nové funkce, najdete v části [14 Visual Basic](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="1b558-113">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="1b558-114">Visual Basic / Visual Studio 2013 rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="1b558-114">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="1b558-115">Verze Preview technologie kompilátoru platformy .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="1b558-115">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="1b558-116">Visual Basic / Visual Studio 2012 rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="1b558-116">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="1b558-117">`Async` a `await` klíčová slova, iterátory, volající – atributy s informacemi</span><span class="sxs-lookup"><span data-stu-id="1b558-117">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="1b558-118">Visual Basic, Visual Studio 2010 rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="1b558-118">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="1b558-119">Automaticky implementované vlastnosti, Inicializátory kolekcí, implicitní pokračování řádku, dynamické, obecný co/opravné položky k odchylky, přístupu globální obor názvů</span><span class="sxs-lookup"><span data-stu-id="1b558-119">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="1b558-120">Visual Basic / Visual Studio 2008 rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="1b558-120">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="1b558-121">Jazyk integrovaného dotazu (LINQ), XML – literály, odvození místního typu objektu inicializátory, anonymní typy, rozšiřující metody, místní `var` odvození výrazy lambda typu `if` operátor, částečné metody, typy hodnot s povolenou hodnotou Null</span><span class="sxs-lookup"><span data-stu-id="1b558-121">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="1b558-122">Visual Basic / Visual Studio 2005 rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="1b558-122">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="1b558-123">`My` Typy typu a pomocné rutiny (přístup k aplikaci, počítače, systém souborů, sítě)</span><span class="sxs-lookup"><span data-stu-id="1b558-123">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="1b558-124">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="1b558-124">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="1b558-125">Bitové posunutí – operátory, smyčky deklarace proměnné</span><span class="sxs-lookup"><span data-stu-id="1b558-125">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="1b558-126">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="1b558-126">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="1b558-127">První verze součásti Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="1b558-127">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="1b558-128">Visual Basic 15,5</span><span class="sxs-lookup"><span data-stu-id="1b558-128">Visual Basic 15.5</span></span>

[<span data-ttu-id="1b558-129">Bez koncové pojmenované argumenty</span><span class="sxs-lookup"><span data-stu-id="1b558-129">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="1b558-130">V 15.3 jazyka Visual Basic a starší verze, při volání metody zahrnuté argumentů podle pozice a podle názvu, poziční argumenty obsahovaly předcházet pojmenované argumenty.</span><span class="sxs-lookup"><span data-stu-id="1b558-130">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="1b558-131">Od verze Visual Basic 15,5, poziční a pojmenované argumenty se může zobrazit v libovolném pořadí, pokud jsou všechny argumenty až poslední poziční argument na správném místě.</span><span class="sxs-lookup"><span data-stu-id="1b558-131">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="1b558-132">To je zvlášť užitečné, když pojmenované argumenty se používají k zvýšit kódu.</span><span class="sxs-lookup"><span data-stu-id="1b558-132">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="1b558-133">Například následující volání metody, které má dva argumenty poziční mezi argumentem.</span><span class="sxs-lookup"><span data-stu-id="1b558-133">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="1b558-134">Pojmenovaný argument umožňuje vymazat představující stáří hodnota 19.</span><span class="sxs-lookup"><span data-stu-id="1b558-134">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="1b558-135">**Úvodní šestnáctkově nebo binary nebo osmičková oddělovače**</span><span class="sxs-lookup"><span data-stu-id="1b558-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="1b558-136">Visual Basic 2017 přidala se podpora pro znak podtržítka (`_`) jako oddělovač číslice.</span><span class="sxs-lookup"><span data-stu-id="1b558-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="1b558-137">Počínaje 15,5 Visual Basic, můžete použít znak podtržítka jako počáteční oddělovač mezi předponu a hexadecimální, binary nebo osmičková číslice.</span><span class="sxs-lookup"><span data-stu-id="1b558-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="1b558-138">Následující příklad používá oddělovač úvodní číslice se definovat 3,271,948,384 šestnáctkové číslo:</span><span class="sxs-lookup"><span data-stu-id="1b558-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="1b558-139">Pokud chcete použít jako počáteční oddělovací znak podtržítka, musíte přidat následující element do projektu jazyka Visual Basic (\*.vbproj) souboru:</span><span class="sxs-lookup"><span data-stu-id="1b558-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="1b558-140">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="1b558-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="1b558-141">**Odvození pojmenované řazené kolekce členů**</span><span class="sxs-lookup"><span data-stu-id="1b558-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="1b558-142">Přiřadíte-li hodnota řazené kolekce členů elementy z proměnných, Visual Basic odvodí, že název elementů řazené kolekce členů z odpovídající názvy proměnných; není nutné explicitně název element řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="1b558-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="1b558-143">Následující příklad používá k vytvoření řazené kolekce členů s tři prvky s názvem, odvození `state`, `stateName`, a `capital`.</span><span class="sxs-lookup"><span data-stu-id="1b558-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="1b558-144">**Další přepínače kompilátoru**</span><span class="sxs-lookup"><span data-stu-id="1b558-144">**Additional compiler switches**</span></span>  

<span data-ttu-id="1b558-145">Teď podporuje příkazového řádku kompilátoru Visual Basicu [ **- refout** ](../reference/command-line-compiler/refout-compiler-option.md) a [ **- refonly** ](../reference/command-line-compiler/refonly-compiler-option.md) – možnosti kompilátoru k řízení výstup referenční sestavení.</span><span class="sxs-lookup"><span data-stu-id="1b558-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="1b558-146">**-refout** definuje výstupního adresáře sestavení odkaz a **- refonly** Určuje, že je referenční sestavení být výstupem kompilace.</span><span class="sxs-lookup"><span data-stu-id="1b558-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="1b558-147">2017 Visual Basic</span><span class="sxs-lookup"><span data-stu-id="1b558-147">Visual Basic 2017</span></span>

[<span data-ttu-id="1b558-148">**Řazené kolekce členů**</span><span class="sxs-lookup"><span data-stu-id="1b558-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="1b558-149">Řazené kolekce členů jsou jednoduché datové struktury, které se nejčastěji používá k vrácení více hodnot z volání jedné metody.</span><span class="sxs-lookup"><span data-stu-id="1b558-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="1b558-150">Normálně vrátit více hodnot z metody, je nutné provést jednu z těchto možností:</span><span class="sxs-lookup"><span data-stu-id="1b558-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="1b558-151">Definování vlastních typů ( `Class` nebo `Structure`).</span><span class="sxs-lookup"><span data-stu-id="1b558-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="1b558-152">Toto je těžké řešení.</span><span class="sxs-lookup"><span data-stu-id="1b558-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="1b558-153">Zadejte jednu nebo více `ByRef` parametry, kromě vrací hodnotu z metody.</span><span class="sxs-lookup"><span data-stu-id="1b558-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="1b558-154">Podpora jazyka Visual Basic pro řazené kolekce členů umožňuje rychle definovat řazené kolekce členů, volitelně přiřadit jeho hodnoty sémantického názvy a rychle načíst jeho hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1b558-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="1b558-155">Následující příklad zabalí volání <xref:System.Int32.TryParse%2A> metodu a vrátí řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="1b558-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="1b558-156">Potom můžete volat metodu a zpracování vrácená řazené kolekce členů s kódem podobně jako tento.</span><span class="sxs-lookup"><span data-stu-id="1b558-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="1b558-157">**Binární literály a oddělovačů číslice**</span><span class="sxs-lookup"><span data-stu-id="1b558-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="1b558-158">Binární literálu můžete definovat pomocí předponu `&B` nebo `&b`.</span><span class="sxs-lookup"><span data-stu-id="1b558-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="1b558-159">Kromě toho můžete použít znak podtržítka `_`, jako oddělovač číslice za účelem zlepšení čitelnosti.</span><span class="sxs-lookup"><span data-stu-id="1b558-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="1b558-160">Následující příklad používá obě přiřadit `Byte` hodnotu a pro zobrazení jako decimal, hexadecimální a binární číslo.</span><span class="sxs-lookup"><span data-stu-id="1b558-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="1b558-161">Další informace najdete v části "Přiřazení literálu" [bajtů](../language-reference/data-types/byte-data-type.md#literal-assignments), [celé číslo](../language-reference/data-types/integer-data-type.md#literal-assignments), [dlouho](../language-reference/data-types/long-data-type.md#literal-assignments), [krátké](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte – ](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [Uinteger –](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), a [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) datové typy.</span><span class="sxs-lookup"><span data-stu-id="1b558-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="1b558-162">**Podpora pro C# odkaz návratové hodnoty**</span><span class="sxs-lookup"><span data-stu-id="1b558-162">**Support for C# reference return values**</span></span>

<span data-ttu-id="1b558-163">Od verze 7.0 C#, podporuje referenční dokumentace jazyka C# návratové hodnoty.</span><span class="sxs-lookup"><span data-stu-id="1b558-163">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="1b558-164">To znamená při volání metody obdrží hodnotu vrácený odkaz, můžete změnit hodnotu odkazu.</span><span class="sxs-lookup"><span data-stu-id="1b558-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="1b558-165">Metody s odkazem na vytváření obsahu návratové hodnoty, ale možné využívat a upravit vrácené hodnoty referenční dokumentace jazyka Visual Basic není povoleno.</span><span class="sxs-lookup"><span data-stu-id="1b558-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="1b558-166">Například následující `Sentence` zahrnuje třídy, které jsou napsané v C# `FindNext` metoda, která vyhledá další aplikace word ve větě, která začíná je určený dílčí řetězec.</span><span class="sxs-lookup"><span data-stu-id="1b558-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="1b558-167">Řetězec se vrátí jako odkaz vrátí hodnotu a `Boolean` předaná odkazu na metodu proměnná Určuje, zda byla hledání úspěšné.</span><span class="sxs-lookup"><span data-stu-id="1b558-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="1b558-168">To znamená, že volající nelze číst jenom vrácená hodnota; potvrdí také ho upravit, a že změna se odrazí v `Sentence` třídy.</span><span class="sxs-lookup"><span data-stu-id="1b558-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="1b558-169">V nejjednodušší podobě můžete upravit slovo nalezené ve větě pomocí kódu podobně jako tento.</span><span class="sxs-lookup"><span data-stu-id="1b558-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="1b558-170">Všimněte si, že jste nejsou přiřazení hodnoty metodě, ale spíše výraz, metoda vrátí, které je odkaz na vrátit hodnotu.</span><span class="sxs-lookup"><span data-stu-id="1b558-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="1b558-171">Problém s tímto kódem, ale je, pokud není nalezena shoda, vrátí metoda první slovo.</span><span class="sxs-lookup"><span data-stu-id="1b558-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="1b558-172">Vzhledem k tomu, že v příkladu není zkontrolujte hodnotu `Boolean` argument k určení, zda je nalezena shoda, upraví první slovo Pokud není nalezena žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="1b558-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="1b558-173">Následující příklad opraví to nahrazením první slovo sama se sebou, pokud není nalezena žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="1b558-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="1b558-174">Lepším řešením je použití Pomocná metoda, ke kterému je předán odkaz návratovou hodnotu odkazem.</span><span class="sxs-lookup"><span data-stu-id="1b558-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="1b558-175">Pomocná metoda pak můžete upravovat argument předaný odkazem.</span><span class="sxs-lookup"><span data-stu-id="1b558-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="1b558-176">Následující příklad nemá který.</span><span class="sxs-lookup"><span data-stu-id="1b558-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="1b558-177">Další informace najdete v tématu [hodnoty vrátí odkaz na](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="1b558-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="1b558-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="1b558-178">Visual Basic 14</span></span>

[<span data-ttu-id="1b558-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="1b558-179">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="1b558-180">Pro použití v chybovou zprávu můžete získat název nekvalifikované řetězce na typ nebo člen bez pevné kódování řetězec.</span><span class="sxs-lookup"><span data-stu-id="1b558-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="1b558-181">To umožňuje kód a dál správné refaktoring.</span><span class="sxs-lookup"><span data-stu-id="1b558-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="1b558-182">Tato funkce je také užitečné pro zapojování model-view-controller MVC odkazy a ohlásí události změněné vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="1b558-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="1b558-183">Interpolace řetězců</span><span class="sxs-lookup"><span data-stu-id="1b558-183">String Interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)  
 <span data-ttu-id="1b558-184">Řetězec interpolace výrazy můžete vytvářet řetězce.</span><span class="sxs-lookup"><span data-stu-id="1b558-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="1b558-185">Interpolované řetězce výrazu vypadá jako šablona řetězec, který obsahuje výrazy.</span><span class="sxs-lookup"><span data-stu-id="1b558-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="1b558-186">Interpolované řetězce je jednodušší zjistit, s ohledem na argumenty než [složené formátování](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="1b558-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="1b558-187">Člen NULL podmíněného přístupu a indexování</span><span class="sxs-lookup"><span data-stu-id="1b558-187">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="1b558-188">Můžete otestovat pro null velmi malé syntaktické způsobem před provedením přístup ke členu (`?.`) nebo index (`?[]`) operaci.</span><span class="sxs-lookup"><span data-stu-id="1b558-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="1b558-189">Tyto operátory usnadňuje psaní, méně kód pro zpracování null kontroly, zejména pro sestupné řazení do datové struktury.</span><span class="sxs-lookup"><span data-stu-id="1b558-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="1b558-190">Pokud levý operand nebo objekt odkaz má hodnotu null, vrátí hodnotu null operace.</span><span class="sxs-lookup"><span data-stu-id="1b558-190">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="1b558-191">Víceřádkový textové literály</span><span class="sxs-lookup"><span data-stu-id="1b558-191">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="1b558-192">Textové literály může obsahovat pořadí nový řádek.</span><span class="sxs-lookup"><span data-stu-id="1b558-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="1b558-193">Je již nebude nutné starý obejít použití `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="1b558-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="1b558-194">Komentáře</span><span class="sxs-lookup"><span data-stu-id="1b558-194">Comments</span></span>  
<span data-ttu-id="1b558-195">Komentáře můžete vložit po implicitní řádku pokračování, uvnitř inicializátoru výrazy a mezi podmínky výrazu LINQ.</span><span class="sxs-lookup"><span data-stu-id="1b558-195">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="1b558-196">Chytřejší plně kvalifikovaný název řešení</span><span class="sxs-lookup"><span data-stu-id="1b558-196">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="1b558-197">Zadaný kód například `Threading.Thread.Sleep(1000)`, Visual Basic použita k vyhledání oboru názvů "Dělení na vlákna", zjistit byl nejednoznačný mezi System.Threading – a System.Windows.Threading a potom nahlásit chybu.</span><span class="sxs-lookup"><span data-stu-id="1b558-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="1b558-198">Visual Basic nyní brány v úvahu oba obory názvů možné společně.</span><span class="sxs-lookup"><span data-stu-id="1b558-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="1b558-199">Pokud můžete zobrazit seznam dokončení, editoru Visual Studio uvádí členy z obou typů v seznamu dokončení.</span><span class="sxs-lookup"><span data-stu-id="1b558-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="1b558-200">Datum prvního roku literály</span><span class="sxs-lookup"><span data-stu-id="1b558-200">Year-first Date Literals</span></span>  
 <span data-ttu-id="1b558-201">Máte literály data ve formátu rrrr mm-dd `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="1b558-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="1b558-202">Vlastnosti rozhraní určené jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="1b558-202">Readonly Interface Properties</span></span>  
 <span data-ttu-id="1b558-203">Můžete implementovat pomocí vlastnosti readwrite vlastností rozhraní určené jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="1b558-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="1b558-204">Rozhraní zaručuje minimální funkční a nezastaví implementující třídu z povolení vlastnosti, která má být nastavena.</span><span class="sxs-lookup"><span data-stu-id="1b558-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="1b558-205">TypeOf \<expr > IsNot \<typ ></span><span class="sxs-lookup"><span data-stu-id="1b558-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="1b558-206">Pro další čitelnost kódu, teď můžete použít `TypeOf` s `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="1b558-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="1b558-207">Upozornění #Disable \<ID > a upozornění #Enable \<ID ></span><span class="sxs-lookup"><span data-stu-id="1b558-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="1b558-208">Můžete zakázat a povolit konkrétní varování pro oblasti v rámci zdrojového souboru.</span><span class="sxs-lookup"><span data-stu-id="1b558-208">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="1b558-209">Vylepšení komentáře Doc XML</span><span class="sxs-lookup"><span data-stu-id="1b558-209">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="1b558-210">Při zápisu komentáře doc, můžete získat inteligentní editoru a podpora pro ověření názvy parametrů, správné zpracování sestavení `crefs` (obecné typy, operátory, atd.), barevné a refaktoring.</span><span class="sxs-lookup"><span data-stu-id="1b558-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="1b558-211">Částečné modulu a definic rozhraní</span><span class="sxs-lookup"><span data-stu-id="1b558-211">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="1b558-212">Kromě třídy a struktury můžou deklarovat částečné moduly a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="1b558-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="1b558-213">#Region direktivy uvnitř těla – metoda</span><span class="sxs-lookup"><span data-stu-id="1b558-213">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="1b558-214">Můžete vložit #Region... #End Region oddělovače kdekoli v souboru uvnitř funkce a to i v pokrývání uzlů napříč funkce subjektů.</span><span class="sxs-lookup"><span data-stu-id="1b558-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="1b558-215">Definice přepsání jsou implicitně přetížení</span><span class="sxs-lookup"><span data-stu-id="1b558-215">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="1b558-216">Pokud přidáte `Overrides` modifikátor k definici kompilátor implicitně přidá `Overloads` tak, aby méně kódu můžete zadat společné případů.</span><span class="sxs-lookup"><span data-stu-id="1b558-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="1b558-217">CObj povolené v argumentech atributy</span><span class="sxs-lookup"><span data-stu-id="1b558-217">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="1b558-218">Kompilátor dávat chybu CObj(...) nebyla při použití v konstrukce atribut konstantní.</span><span class="sxs-lookup"><span data-stu-id="1b558-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="1b558-219">Deklarování a použití nejednoznačný metody z různých rozhraní</span><span class="sxs-lookup"><span data-stu-id="1b558-219">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="1b558-220">Dříve poskytuje následující kód chyby, které zabránily deklarace `IMock` nebo z volání `GetDetails` (pokud tyto byly přihlášeny v jazyce C#):</span><span class="sxs-lookup"><span data-stu-id="1b558-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="1b558-221">Teď kompilátor použije pravidel řešení normální přetížení zvolit nejvhodnější `GetDetails` volat, a vztahy rozhraní v jazyce Visual Basic jako ty, můžou deklarovat uvedené v ukázce.</span><span class="sxs-lookup"><span data-stu-id="1b558-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1b558-222">Viz také</span><span class="sxs-lookup"><span data-stu-id="1b558-222">See also</span></span>  
 [<span data-ttu-id="1b558-223">Co je nového ve Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="1b558-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
