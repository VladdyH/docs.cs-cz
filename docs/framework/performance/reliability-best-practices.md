---
title: "Spolehlivost – doporučené postupy"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
caps.latest.revision: "11"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: ad218e8f87c2a04a9df6f67a918097de20296d0c
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/22/2017
---
# <a name="reliability-best-practices"></a><span data-ttu-id="c97c2-102">Spolehlivost – doporučené postupy</span><span class="sxs-lookup"><span data-stu-id="c97c2-102">Reliability Best Practices</span></span>
<span data-ttu-id="c97c2-103">Následující pravidla spolehlivost jsou orientované na SQL Server; však také použijí na všechny aplikace založené na hostiteli serveru.</span><span class="sxs-lookup"><span data-stu-id="c97c2-103">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="c97c2-104">Je velmi důležité, aby servery, jako je SQL Server není úniku prostředky a nesmí být snížila.</span><span class="sxs-lookup"><span data-stu-id="c97c2-104">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="c97c2-105">Nicméně, nelze provést napsáním zálohující kód pro každou metodu, která mění stav daného objektu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-105">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="c97c2-106">Cílem je nechcete napsat 100 procent spolehlivé spravovaný kód, který bude zotavit všechny chyby v každé umístění zálohující kód.</span><span class="sxs-lookup"><span data-stu-id="c97c2-106">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="c97c2-107">Který by složitý úkol s menší riziko úspěch.</span><span class="sxs-lookup"><span data-stu-id="c97c2-107">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="c97c2-108">Modul CLR (CLR) nelze snadno poskytnout dostatečně silné záruky do spravovaného kódu, aby zápis ideální kódu v rámci výpočetních procesů.</span><span class="sxs-lookup"><span data-stu-id="c97c2-108">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="c97c2-109">Všimněte si, že na rozdíl od ASP.NET, používá systém SQL Server pouze jeden proces, který nemůže být recyklována bez nutnosti převádět databáze nepřijatelně dlouhou dobu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-109">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>  
  
 <span data-ttu-id="c97c2-110">Tyto slabší záruky a spuštěn v jednom procesu je spolehlivost založené na ukončení vláken nebo recyklace aplikační domény, pokud nejsou neuniknou potřebné a přijímá opatření, aby prostředky operačního systému, například obslužné rutiny, paměť.</span><span class="sxs-lookup"><span data-stu-id="c97c2-110">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="c97c2-111">I když toto omezení jednodušší spolehlivost stále existuje požadavek významné spolehlivosti:</span><span class="sxs-lookup"><span data-stu-id="c97c2-111">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>  
  
-   <span data-ttu-id="c97c2-112">Nikdy se nevrací prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-112">Never leak operating system resources.</span></span>  
  
-   <span data-ttu-id="c97c2-113">Identifikujte všechny spravované uzamčená všech formulářů modulu CLR.</span><span class="sxs-lookup"><span data-stu-id="c97c2-113">Identify all managed locks in all forms to the CLR.</span></span>  
  
-   <span data-ttu-id="c97c2-114">Nikdy zalomení domény mezi aplikacemi – sdílené stavu, což <xref:System.AppDomain> recyklace řádně fungovat.</span><span class="sxs-lookup"><span data-stu-id="c97c2-114">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>  
  
 <span data-ttu-id="c97c2-115">Přestože je možné teoreticky napsat spravovaný kód pro zpracování <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, a <xref:System.OutOfMemoryException> výjimky, byla očekávána vývojářům psát nepřiměřený takový robustní kód v celé aplikaci.</span><span class="sxs-lookup"><span data-stu-id="c97c2-115">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="c97c2-116">Z tohoto důvodu out-of-band výjimky za následek provádění vlákna ukončovány; a pokud ukončil podproces byl úpravy sdílený stav, který lze určit podle jestli vlákno obsahuje zámek, pak se <xref:System.AppDomain> je odpojen.</span><span class="sxs-lookup"><span data-stu-id="c97c2-116">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="c97c2-117">Při ukončení metodu, která je úpravy sdíleného stavu, bude stav poškozen, protože není možné zapsat do sdíleného stavu spolehlivé zálohující kód pro aktualizace.</span><span class="sxs-lookup"><span data-stu-id="c97c2-117">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>  
  
 <span data-ttu-id="c97c2-118">V rozhraní .NET Framework verze 2.0 je jediným hostitele, který vyžaduje spolehlivost systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c97c2-118">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="c97c2-119">Pokud vaše sestavení bude spuštěna v systému SQL Server, měli byste udělat pracovní spolehlivost pro každou součást sestavení, i když nejsou specifické funkce, které jsou zakázány při spuštění v databázi.</span><span class="sxs-lookup"><span data-stu-id="c97c2-119">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="c97c2-120">Toto není nutná modulu analýzy kódu zkontroluje kód na úrovni sestavení a nelze rozlišit zakázané kódu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-120">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="c97c2-121">Jiný Server SQL programovací problém je, že systém SQL Server všechno běží v jednom procesu, a <xref:System.AppDomain> recyklace se používá pro čištění všechny prostředky, jako je například obslužné rutiny paměti a operačního systému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-121">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>  
  
 <span data-ttu-id="c97c2-122">Nemůže záviset na finalizační metody nebo destruktory nebo `try/finally` bloků zálohující kód.</span><span class="sxs-lookup"><span data-stu-id="c97c2-122">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="c97c2-123">Může být přerušeny nebo není volána.</span><span class="sxs-lookup"><span data-stu-id="c97c2-123">They might be interrupted or not called.</span></span>  
  
 <span data-ttu-id="c97c2-124">Může být vyvolána asynchronní výjimky v neočekávaných umístěních, může být každý počítač instrukcí: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, a <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-124">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>  
  
 <span data-ttu-id="c97c2-125">Spravovaných vláknech, nemusí nutně být Win32 vláken v SQL; mohou být jsou vlákna.</span><span class="sxs-lookup"><span data-stu-id="c97c2-125">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>  
  
 <span data-ttu-id="c97c2-126">Měnitelný sdílený stav procesy nebo mezi aplikacemi domény je velmi obtížné alter bezpečně a je nutno kdykoli je to možné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-126">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>  
  
 <span data-ttu-id="c97c2-127">Z důvodu nedostatku paměti podmínky nejsou výjimečných v systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c97c2-127">Out-of-memory conditions are not rare in SQL Server.</span></span>  
  
 <span data-ttu-id="c97c2-128">Pokud knihovny hostované v systému SQL Server správně nelze aktualizovat jejich sdíleného stavu, je vysoká pravděpodobnost, že nebude obnovit kód až po restartování databáze.</span><span class="sxs-lookup"><span data-stu-id="c97c2-128">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="c97c2-129">Kromě toho v některých výjimečných případech je možné, že to může způsobit chybu procesu systému SQL Server způsobuje databázi na restartování.</span><span class="sxs-lookup"><span data-stu-id="c97c2-129">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="c97c2-130">Restartování databáze můžete vypnout webovou stránku nebo ovlivnily provoz společnosti, nespokojené dostupnosti.</span><span class="sxs-lookup"><span data-stu-id="c97c2-130">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="c97c2-131">Pomalé úniku prostředků operačního systému, třeba paměti nebo popisovače může způsobit selhání nakonec vyhrazování popisovače s žádná možnost obnovení serveru nebo potenciálně pomalou může snížit výkon serveru a snižuje zákazníka aplikace dostupnost.</span><span class="sxs-lookup"><span data-stu-id="c97c2-131">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="c97c2-132">Jasně chceme, aby se zabránilo tyto scénáře.</span><span class="sxs-lookup"><span data-stu-id="c97c2-132">Clearly we want to avoid these scenarios.</span></span>  
  
## <a name="best-practice-rules"></a><span data-ttu-id="c97c2-133">Pravidly osvědčených postupů</span><span class="sxs-lookup"><span data-stu-id="c97c2-133">Best Practice Rules</span></span>  
 <span data-ttu-id="c97c2-134">Zavedení zaměřuje na co by mít revize kódu pro spravovaný kód, který běží na serveru k zachycení ke zvýšení stability a spolehlivost rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c97c2-134">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="c97c2-135">Všechny tyto kontroly jsou obecně osvědčených postupů a absolutní musí na serveru.</span><span class="sxs-lookup"><span data-stu-id="c97c2-135">All these checks are good practice in general and an absolute must on the server.</span></span>  
  
 <span data-ttu-id="c97c2-136">Při krátkodobém neaktivní uzamčení nebo prostředek omezení systému SQL Server bude zrušení vlákna nebo přerušit <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-136">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="c97c2-137">V takovém případě pouze zálohující kód v oblasti omezeného provádění (CER) záruku, že chcete spustit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-137">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>  
  
### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="c97c2-138">Použijte SafeHandle předejdete nedostatku prostředků</span><span class="sxs-lookup"><span data-stu-id="c97c2-138">Use SafeHandle to Avoid Resource Leaks</span></span>  
 <span data-ttu-id="c97c2-139">U <xref:System.AppDomain> uvolnění, nemůže záviset na `finally` bloky nebo finalizační metody spouštění, proto je důležité abstraktní veškerý přístup prostředek operačního systému pomocí <xref:System.Runtime.InteropServices.SafeHandle> třída místo <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, nebo Podobně jako třídy.</span><span class="sxs-lookup"><span data-stu-id="c97c2-139">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="c97c2-140">To umožňuje CLR sledovat a zavřete obslužné rutiny, můžete použít i při <xref:System.AppDomain> úplné rozbalovací případu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-140">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="c97c2-141"><xref:System.Runtime.InteropServices.SafeHandle>budou používat kritické finalizační metodu, která modul CLR bude vždy spuštěn.</span><span class="sxs-lookup"><span data-stu-id="c97c2-141"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>  
  
 <span data-ttu-id="c97c2-142">Popisovač operačního systému jsou uloženy v bezpečné popisovač od okamžiku, kdy se vytvoří až do okamžiku, kdy je vydání.</span><span class="sxs-lookup"><span data-stu-id="c97c2-142">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="c97c2-143">Během kterého není okno <xref:System.Threading.ThreadAbortException> může dojít k úniku popisovač.</span><span class="sxs-lookup"><span data-stu-id="c97c2-143">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="c97c2-144">Kromě toho vyvolání platformy bude odkaz count popisovač, což umožňuje zavřít sledování doba života popisovače, brání chyba zabezpečení s časování mezi `Dispose` a metodu, která je aktuálně používá popisovač.</span><span class="sxs-lookup"><span data-stu-id="c97c2-144">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>  
  
 <span data-ttu-id="c97c2-145">Většina tříd, které máte aktuálně finalizační metodu jednoduše vyčištění operační systém zpracování finalizační metodu už nepotřebují.</span><span class="sxs-lookup"><span data-stu-id="c97c2-145">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="c97c2-146">Místo toho finalizační metodu bude na <xref:System.Runtime.InteropServices.SafeHandle> odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="c97c2-146">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>  
  
 <span data-ttu-id="c97c2-147">Všimněte si, že <xref:System.Runtime.InteropServices.SafeHandle> není to náhrada za <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-147">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="c97c2-148">Má stále potenciální prostředků kolizí a výkonu výhod explicitně dispose prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-148">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="c97c2-149">Právě Pamatujte si, že `finally` dokončení nemusí provést bloků, které explicitně uvolnění prostředků.</span><span class="sxs-lookup"><span data-stu-id="c97c2-149">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>  
  
 <span data-ttu-id="c97c2-150"><xref:System.Runtime.InteropServices.SafeHandle>umožňuje implementovat vlastní <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metoda, která provede práci na uvolnění popisovač, jako je například stav předávání popisovač operačního systému uvolnění rutiny nebo uvolnění sada popisovačů ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="c97c2-150"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="c97c2-151">Modul CLR zaručuje, že se tato metoda spustit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-151">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="c97c2-152">Je zodpovědností autora <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementace zajistit, že popisovač vydání za všech okolností.</span><span class="sxs-lookup"><span data-stu-id="c97c2-152">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="c97c2-153">Tak neučiníte způsobí, že popisovač uniknout, což často vede k úniku nativní prostředky přidružené k popisovač.</span><span class="sxs-lookup"><span data-stu-id="c97c2-153">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="c97c2-154">Proto je důležité pro strukturu <xref:System.Runtime.InteropServices.SafeHandle> odvozených třídách tak, aby <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementace nevyžaduje přidělení všechny prostředky, které nemusí být k dispozici v čase volání.</span><span class="sxs-lookup"><span data-stu-id="c97c2-154">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="c97c2-155">Všimněte si, že je přípustné volání metody, které může dojít k selhání v rámci implementace <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> za předpokladu, že váš kód může zpracovat takové chyby a dokončení smlouvy k uvolnění nativní popisovač.</span><span class="sxs-lookup"><span data-stu-id="c97c2-155">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="c97c2-156">Pro účely ladění <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> má <xref:System.Boolean> vrátit hodnotu, která může být nastavena na `false` Pokud tomu vydání prostředku je došlo k závažné chybě.</span><span class="sxs-lookup"><span data-stu-id="c97c2-156">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="c97c2-157">Díky tomu se budou aktivovat [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) (mda), pokud je povoleno, které pomáhají při identifikaci problému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-157">Doing so will activate the [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="c97c2-158">Nemá vliv na modulu runtime jiným způsobem; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nebude volán znovu pro stejný prostředek a v důsledku toho budou úniku popisovač.</span><span class="sxs-lookup"><span data-stu-id="c97c2-158">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>  
  
 <span data-ttu-id="c97c2-159"><xref:System.Runtime.InteropServices.SafeHandle>není vhodné v některých kontextech.</span><span class="sxs-lookup"><span data-stu-id="c97c2-159"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="c97c2-160">Vzhledem k tomu <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metoda se dá spustit na <xref:System.GC> finalizační metodu přístup z více vláken, všechny popisovače, které je potřeba uvolnit na konkrétní vlákno by neměl být uzavřen do <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-160">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
 <span data-ttu-id="c97c2-161">Běhové obálky s možností (RCWs) mohou být vyčištěny CLR bez další kód.</span><span class="sxs-lookup"><span data-stu-id="c97c2-161">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="c97c2-162">Pro kód, který používá platformy vyvolání a jsou považovány za objektu COM `IUnknown*` nebo <xref:System.IntPtr>, kód by měl být přepsána pro použití RCW.</span><span class="sxs-lookup"><span data-stu-id="c97c2-162">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="c97c2-163"><xref:System.Runtime.InteropServices.SafeHandle>nemusí být pro tento scénář z důvodu možnost metodu nespravované verze zpětné volání do spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-163"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-164">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-164">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-165">Použití <xref:System.Runtime.InteropServices.SafeHandle> pro zapouzdření prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-165">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="c97c2-166">Nepoužívejte <xref:System.Runtime.InteropServices.HandleRef> nebo pole typu <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-166">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>  
  
### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="c97c2-167">Ujistěte se, že finalizační metody není nutné spustit, aby se zabránilo úniku prostředky operačního systému</span><span class="sxs-lookup"><span data-stu-id="c97c2-167">Ensure Finalizers Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="c97c2-168">Zkontrolujte vaše finalizační metody pečlivě a ujistěte se, že i v případě, že se nespustí, není k úniku prostředek kritické operačního systému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-168">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="c97c2-169">Na rozdíl od normální <xref:System.AppDomain> uvolnění, když se aplikace spouští v stabilního stavu, nebo když serveru, jako je vypnutí systému SQL Server, objekty nejsou dokončené během náhlému <xref:System.AppDomain> uvolnit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-169">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="c97c2-170">Zajistěte, aby prostředky nejsou úniku v případě náhlému odpojit, protože nejde zaručit správnost aplikace, ale musí být zachová integrita serveru tím, že není vracena prostředky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-170">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="c97c2-171">Použití <xref:System.Runtime.InteropServices.SafeHandle> uvolnit všechny prostředky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-171">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>  
  
### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="c97c2-172">Ujistěte se, že nakonec klauzule není nutné spustit a zabránit úniku prostředky operačního systému</span><span class="sxs-lookup"><span data-stu-id="c97c2-172">Ensure That finally Clauses Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="c97c2-173">`finally`klauzule se nezaručuje, že ke spuštění mimo CERs, vyžadování vývojářům knihovna není závislý na kód v rámci `finally` blok k uvolnění nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="c97c2-173">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="c97c2-174">Pomocí <xref:System.Runtime.InteropServices.SafeHandle> je doporučená řešení.</span><span class="sxs-lookup"><span data-stu-id="c97c2-174">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-175">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-175">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-176">Použití <xref:System.Runtime.InteropServices.SafeHandle> pro čištění prostředky operačního systému místo `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="c97c2-176">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="c97c2-177">Nepoužívejte <xref:System.IntPtr>; použít <xref:System.Runtime.InteropServices.SafeHandle> k zapouzdření prostředky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-177">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="c97c2-178">Pokud nakonec klauzule musí spustit, umístěte CER.</span><span class="sxs-lookup"><span data-stu-id="c97c2-178">If the finally clause must run, place it in a CER.</span></span>  
  
### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="c97c2-179">Všechny zámky by měl projít existující spravovaného kódu uzamčení</span><span class="sxs-lookup"><span data-stu-id="c97c2-179">All Locks Should Go Through Existing Managed Locking Code</span></span>  
 <span data-ttu-id="c97c2-180">Modul CLR musí vědět, pokud kód je v zámek tak, aby věděli, aby byl <xref:System.AppDomain> místo právě probíhá rušení vlákno.</span><span class="sxs-lookup"><span data-stu-id="c97c2-180">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="c97c2-181">Přerušení vlákno může být nebezpečný, protože data provozují na vlákno může být v nekonzistentním stavu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-181">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="c97c2-182">Proto celý <xref:System.AppDomain> má recyklace.</span><span class="sxs-lookup"><span data-stu-id="c97c2-182">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="c97c2-183">Důsledky selhání k identifikaci zámek může být blokování nebo nesprávné výsledky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-183">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="c97c2-184">Použít metody <xref:System.Threading.Thread.BeginCriticalRegion%2A> a <xref:System.Threading.Thread.EndCriticalRegion%2A> k identifikaci uzamčení oblasti.</span><span class="sxs-lookup"><span data-stu-id="c97c2-184">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="c97c2-185">Jsou statické metody na <xref:System.Threading.Thread> třídu, která se vztahují pouze na aktuální vlákno, pomáhá zabránit v úpravách počet zámků jiné vlákno jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="c97c2-185">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>  
  
 <span data-ttu-id="c97c2-186"><xref:System.Threading.Monitor.Enter%2A>a <xref:System.Threading.Monitor.Exit%2A> mají toto oznámení CLR integrovanou, takže jejich použití se doporučuje a také použití [lock – příkaz](~/docs/csharp/language-reference/keywords/lock-statement.md), který používá tyto metody.</span><span class="sxs-lookup"><span data-stu-id="c97c2-186"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>  
  
 <span data-ttu-id="c97c2-187">Další uzamčení mechanismy, například otočení zámky a <xref:System.Threading.AutoResetEvent> musí volat tyto metody oznámit modulu CLR zadávání kritická sekce.</span><span class="sxs-lookup"><span data-stu-id="c97c2-187">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="c97c2-188">Tyto metody nepřebírají žádné zámky; informovat o tom, spuštění kódu v kritická sekce modulu CLR a přerušení vlákno může způsobit sdíleného stavu nekonzistentní.</span><span class="sxs-lookup"><span data-stu-id="c97c2-188">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="c97c2-189">Pokud jste definovali vlastní typ zámku, jako je například vlastní <xref:System.Threading.ReaderWriterLock> třídy, použijte tyto metody počtu uzamčení.</span><span class="sxs-lookup"><span data-stu-id="c97c2-189">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-190">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-190">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-191">Označit a identifikovat všechny zámky pomocí <xref:System.Threading.Thread.BeginCriticalRegion%2A> a <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-191">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="c97c2-192">Nepoužívejte <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, a <xref:System.Threading.Interlocked.Decrement%2A> ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="c97c2-192">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="c97c2-193">Udělat platformu vyvolání variant Win32 z těchto metod.</span><span class="sxs-lookup"><span data-stu-id="c97c2-193">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="c97c2-194">Nepoužívejte <xref:System.Threading.Thread.Sleep%2A> ve smyčce.</span><span class="sxs-lookup"><span data-stu-id="c97c2-194">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="c97c2-195">Nepoužívejte volatile pole.</span><span class="sxs-lookup"><span data-stu-id="c97c2-195">Do not use volatile fields.</span></span>  
  
### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="c97c2-196">Vyčištění kód musí být v a nakonec nebo catch bloku není následující catch</span><span class="sxs-lookup"><span data-stu-id="c97c2-196">Cleanup Code Must Be in a finally or a catch Block, Not Following a catch</span></span>  
 <span data-ttu-id="c97c2-197">Kód čištění nikdy postupujte podle `catch` blokovat; musí být ve `finally` nebo `catch` blokovat sám sebe.</span><span class="sxs-lookup"><span data-stu-id="c97c2-197">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span>  <span data-ttu-id="c97c2-198">To by měl být normální vhodné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-198">This should be a normal good practice.</span></span>  <span data-ttu-id="c97c2-199">A `finally` bloku je obecně preferovaná, protože běží stejný kód, pokud je vyvolána výjimka i když konec `try` bloku je obvykle došlo.</span><span class="sxs-lookup"><span data-stu-id="c97c2-199">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="c97c2-200">V případě k neočekávané výjimce se, například <xref:System.Threading.ThreadAbortException>, je kód čištění, nelze spustit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-200">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="c97c2-201">Všechny prostředky, které by vyčištění v nespravované `finally` v ideálním případě by měl být uzavřen ve <xref:System.Runtime.InteropServices.SafeHandle> k prevence úniků.</span><span class="sxs-lookup"><span data-stu-id="c97c2-201">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="c97c2-202">Všimněte si, jazyka C# `using` – klíčové slovo lze účinně k uvolnění objektů, včetně obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="c97c2-202">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>  
  
 <span data-ttu-id="c97c2-203">I když <xref:System.AppDomain> recyklace může odstranit systémové prostředky ve vlákně finalizační metodu, je důležité put kód čištění na správné místo.</span><span class="sxs-lookup"><span data-stu-id="c97c2-203">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span>  <span data-ttu-id="c97c2-204">Všimněte si, že pokud vlákno obdrží výjimku asynchronní bez zámek, modulu CLR pokusí o ukončení vlákna samotné bez nutnosti recyklace <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-204">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="c97c2-205">Zajištění, že prostředky jsou vyčistit dříve místo novější pomáhá tím, že k dispozici více prostředků a lepší správu dobu životnosti.</span><span class="sxs-lookup"><span data-stu-id="c97c2-205">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span>  <span data-ttu-id="c97c2-206">Pokud explicitně nezavřete popisovač pro soubor v cestě kódu některé chyby potom počkejte <xref:System.Runtime.InteropServices.SafeHandle> finalizační metodu pro při příštím spuštění kódu čištění, může dojít k selhání pokusu o přístup k přesně stejný soubor, pokud finalizační metodu již nebyla spuštěna.</span><span class="sxs-lookup"><span data-stu-id="c97c2-206">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="c97c2-207">Z tohoto důvodu vám pomůže zajistit, že kód čištění existuje a zda správně funguje obnovení v případě selhání více řádně a rychle, i když není nezbytně nutné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-207">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-208">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-208">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-209">Kód čištění po `catch` musí být ve `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="c97c2-209">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="c97c2-210">Volání k uvolnění v a nakonec blokovat.</span><span class="sxs-lookup"><span data-stu-id="c97c2-210">Place calls to dispose in a finally block.</span></span>  <span data-ttu-id="c97c2-211">`catch`bloky musí končit throw nebo opětovné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-211">`catch` blocks should end in a throw or rethrow.</span></span>  <span data-ttu-id="c97c2-212">Zatímco bude výjimky, například kód zjišťování, zda lze vytvořit připojení k síti kde může získat žádné velký počet výjimek, kód, který vyžaduje zachytávání počet výjimek za normálních okolností měl dát indikace toho, zda kód by měl být testována, pokud chcete zobrazit, pokud bude úspěšné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-212">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>  
  
### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="c97c2-213">Měnitelný sdíleného stavu procesy mezi doménami aplikací by měly být odstraněny nebo použijte oblasti omezeného provádění</span><span class="sxs-lookup"><span data-stu-id="c97c2-213">Process-Wide Mutable Shared State Between Application Domains Should Be Eliminated or Use a Constrained Execution Region</span></span>  
 <span data-ttu-id="c97c2-214">Jak je popsáno v úvodu, může být velmi obtížné napsat spravovaného kódu, který monitoruje procesy sdíleného stavu napříč doménami aplikací spolehlivé způsobem.</span><span class="sxs-lookup"><span data-stu-id="c97c2-214">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="c97c2-215">Sdílený stav procesy je žádné řazení struktura dat, které jsou sdílené mezi doménami aplikací, buď v kódu Win32 uvnitř modulu CLR nebo ve spravovaném kódu pomocí vzdálené komunikace.</span><span class="sxs-lookup"><span data-stu-id="c97c2-215">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="c97c2-216">Žádný měnitelný sdílený stav je velmi obtížné správně zápisu ve spravovaném kódu a všechny statické sdíleného stavu může provést pouze s pozor.</span><span class="sxs-lookup"><span data-stu-id="c97c2-216">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="c97c2-217">Pokud máte procesy nebo celého systému sdíleného stavu, najděte některé způsob, jak jej odstranit nebo chránit sdílené stavu pomocí oblasti omezeného provádění (CER).</span><span class="sxs-lookup"><span data-stu-id="c97c2-217">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="c97c2-218">Všimněte si, že všechny knihovny s sdíleného stavu, který není zjistila a opravila by mohlo způsobit hostitele, jako je SQL Server, který vyžaduje čištění <xref:System.AppDomain> uvolnění chyby.</span><span class="sxs-lookup"><span data-stu-id="c97c2-218">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>  
  
 <span data-ttu-id="c97c2-219">Pokud kód používá objekt modelu COM, vyhněte se sdílení tohoto objektu COM mezi doménami aplikací.</span><span class="sxs-lookup"><span data-stu-id="c97c2-219">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>  
  
### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="c97c2-220">Zámky nefungují procesy nebo mezi doménami aplikací.</span><span class="sxs-lookup"><span data-stu-id="c97c2-220">Locks Do Not Work Process-Wide or Between Application Domains.</span></span>  
 <span data-ttu-id="c97c2-221">V minulosti <xref:System.Threading.Monitor.Enter%2A> a [lock – příkaz](~/docs/csharp/language-reference/keywords/lock-statement.md) byl použit pro vytvoření globální proces zámky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-221">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="c97c2-222">Například k tomu dojde při zamykání na <xref:System.AppDomain> agilní třídy, jako například <xref:System.Type> instancí z nesdílené sestavení, <xref:System.Threading.Thread> interned řetězce, objektů a některé řetězce sdílené mezi doménami aplikací pomocí vzdálené komunikace.</span><span class="sxs-lookup"><span data-stu-id="c97c2-222">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="c97c2-223">Tyto zámky již nejsou procesy.</span><span class="sxs-lookup"><span data-stu-id="c97c2-223">These locks are no longer process-wide.</span></span>  <span data-ttu-id="c97c2-224">K identifikaci přítomnost uzamčení procesy domény mezi aplikacemi, zjistit, zda kód v rámci zámek používá jakémukoli prostředku, externí, trvalé jako je soubor na disku, nebo může být databáze.</span><span class="sxs-lookup"><span data-stu-id="c97c2-224">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>  
  
 <span data-ttu-id="c97c2-225">Všimněte si, trvá zámku v rámci <xref:System.AppDomain> může způsobit problémy, pokud kód chráněné používá externí zdroj, protože tento kód může běžet současně napříč více domén aplikací.</span><span class="sxs-lookup"><span data-stu-id="c97c2-225">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="c97c2-226">To může být problém při zápisu do jednoho souboru protokolu nebo vazbu na soket pro celý proces.</span><span class="sxs-lookup"><span data-stu-id="c97c2-226">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="c97c2-227">Tyto změny znamenají, neexistuje žádný snadný způsob, pomocí spravovaného kódu, získat zámek globální proces, než pomocí pojmenovaná <xref:System.Threading.Mutex> nebo <xref:System.Threading.Semaphore> instance.</span><span class="sxs-lookup"><span data-stu-id="c97c2-227">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="c97c2-228">Vytvoření kódu, který není v dvě domény aplikace běžet současně, nebo použijte <xref:System.Threading.Mutex> nebo <xref:System.Threading.Semaphore> třídy.</span><span class="sxs-lookup"><span data-stu-id="c97c2-228">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="c97c2-229">Pokud existující kód nemůže být změněn, nepoužívejte k dosažení této synchronizace, protože spuštěna v režimu vlákének znamená, že nebudete moct zaručit stejném vlákně, v operačním systému bude získat a verzí mutex Win32, pojmenovaný vzájemně vyloučený přístup.</span><span class="sxs-lookup"><span data-stu-id="c97c2-229">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="c97c2-230">Je nutné použít spravovaný <xref:System.Threading.Mutex> třídu nebo pojmenovaná <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, nebo <xref:System.Threading.Semaphore> synchronizovat zámek kód tak, aby si je vědoma namísto synchronizace ze zařízení zámek pomocí nespravovaného kódu modulu CLR.</span><span class="sxs-lookup"><span data-stu-id="c97c2-230">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>  
  
#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="c97c2-231">Vyhněte se lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="c97c2-231">Avoid lock(typeof(MyType))</span></span>  
 <span data-ttu-id="c97c2-232">Privátní a veřejné <xref:System.Type> objekty v sdílená sestavení s pouze jedné kopie kód sdílený všechny domény aplikace k dispozici také problémy.</span><span class="sxs-lookup"><span data-stu-id="c97c2-232">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="c97c2-233">Sdílená sestavení je pouze jedna instance <xref:System.Type> podle procesu, což znamená, že více domén aplikací sdílet přesný stejné <xref:System.Type> instance.</span><span class="sxs-lookup"><span data-stu-id="c97c2-233">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="c97c2-234">Pořízení Zámek <xref:System.Type> instance trvá zámku, která má vliv na celý proces, není právě v <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-234">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="c97c2-235">Pokud <xref:System.AppDomain> přebírá Zámek <xref:System.Type> objektu pak, získá náhle přerušena přístup z více vláken, nebude ho uvolní zámek.</span><span class="sxs-lookup"><span data-stu-id="c97c2-235">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="c97c2-236">Tato zámku pak může způsobit jiných domén aplikace k zablokování.</span><span class="sxs-lookup"><span data-stu-id="c97c2-236">This lock then may cause other application domains to deadlock.</span></span>  
  
 <span data-ttu-id="c97c2-237">Dobrým způsobem, jak provádět zámky v statických metod zahrnuje přidání objektu statické vnitřní synchronizace ke kódu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-237">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="c97c2-238">To může být inicializován v konstruktoru třídy, pokud je k dispozici, ale pokud ho nelze inicializovat takto:</span><span class="sxs-lookup"><span data-stu-id="c97c2-238">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>  
  
```  
private static Object s_InternalSyncObject;  
private static Object InternalSyncObject   
{  
    get   
    {  
        if (s_InternalSyncObject == null)   
        {  
            Object o = new Object();  
            Interlocked.CompareExchange(  
                ref s_InternalSyncObject, o, null);  
        }  
        return s_InternalSyncObject;  
    }  
}  
```  
  
 <span data-ttu-id="c97c2-239">Potom při přepnutí zámek, použijte `InternalSyncObject` vlastnost k získání objektu k uzamčení na.</span><span class="sxs-lookup"><span data-stu-id="c97c2-239">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="c97c2-240">Není nutné používat vlastnost, když jste inicializovali objekt interní synchronizace v konstruktoru vaší třídy.</span><span class="sxs-lookup"><span data-stu-id="c97c2-240">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="c97c2-241">Dvojité kontrola, zda kód inicializace zámku by měl vypadat jako tento ukázkový:</span><span class="sxs-lookup"><span data-stu-id="c97c2-241">The double checking lock initialization code should look like this example:</span></span>  
  
```  
public static MyClass SingletonProperty   
{  
    get   
    {  
        if (s_SingletonProperty == null)   
        {  
            lock(InternalSyncObject)   
            {  
                // Do not use lock(typeof(MyClass))   
                if (s_SingletonProperty == null)   
                {  
                    MyClass tmp = new MyClass(…);     
                    // Do all initialization before publishing  
                    s_SingletonProperty = tmp;  
                }  
            }  
        }  
        return s_SingletonProperty;  
    }  
}  
```  
  
#### <a name="a-note-about-lockthis"></a><span data-ttu-id="c97c2-242">Poznámka o Lock(this)</span><span class="sxs-lookup"><span data-stu-id="c97c2-242">A Note About Lock(this)</span></span>  
 <span data-ttu-id="c97c2-243">Je obecně přijatelné trvat zámek na jednotlivé objekt, který je veřejně přístupná.</span><span class="sxs-lookup"><span data-stu-id="c97c2-243">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="c97c2-244">Pokud se objekt typu singleton objektu, který může dojít celé subsystému ke vzájemnému zablokování, zvažte však pomocí také výše vzoru návrhu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-244">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="c97c2-245">Například zámku na ten <xref:System.Security.SecurityManager> objekt může způsobit zablokování v rámci <xref:System.AppDomain> provedení celý <xref:System.AppDomain> nepoužitelný.</span><span class="sxs-lookup"><span data-stu-id="c97c2-245">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="c97c2-246">Je dobrým zvykem nemusí provádět žádné zámek na veřejně přístupný objekt tohoto typu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-246">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="c97c2-247">Uzamčení na jednotlivé kolekce nebo pole nesmí ale obecně dostupné k problému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-247">However a lock on an individual collection or array should generally not present a problem.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-248">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-248">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-249">Nepřebírají typy, které by mohly používat napříč doménami aplikací nebo nemáte silné smysl identity zámky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-249">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="c97c2-250">Nevolejte <xref:System.Threading.Monitor.Enter%2A> na <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, nebo libovolný objekt, který je odvozen od <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-250">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>  
  
### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="c97c2-251">Odeberte GC. Volání funkce KeepAlive</span><span class="sxs-lookup"><span data-stu-id="c97c2-251">Remove GC.KeepAlive Calls</span></span>  
 <span data-ttu-id="c97c2-252">Významné množství existující kód buď nepoužívá <xref:System.GC.KeepAlive%2A> , pokud by měl nebo použije, když není vhodné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-252">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="c97c2-253">Po převodu na <xref:System.Runtime.InteropServices.SafeHandle>, není nutné volat třídy <xref:System.GC.KeepAlive%2A>, za předpokladu, že nemají finalizační metody, ale závisí na <xref:System.Runtime.InteropServices.SafeHandle> finalizace operační systém zpracovává.</span><span class="sxs-lookup"><span data-stu-id="c97c2-253">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="c97c2-254">Při zachování volání náklady výkonu <xref:System.GC.KeepAlive%2A> může být nepatrné, vnímání, volání <xref:System.GC.KeepAlive%2A> je nezbytné nebo dostatečná vyřešit problém, který již neexistuje díky kód obtížnější údržbu životnost.</span><span class="sxs-lookup"><span data-stu-id="c97c2-254">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="c97c2-255">Ale, že při použití modelu COM spolupráce CLR obálky s možností (RCWs), <xref:System.GC.KeepAlive%2A> stále vyžadují kódu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-255">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-256">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-256">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-257">Odebrat <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-257">Remove <xref:System.GC.KeepAlive%2A>.</span></span>  
  
### <a name="use-the-host-protection-attribute"></a><span data-ttu-id="c97c2-258">Použít atribut ochrany hostitele</span><span class="sxs-lookup"><span data-stu-id="c97c2-258">Use the Host Protection Attribute</span></span>  
 <span data-ttu-id="c97c2-259"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) poskytuje použití akce deklarativní zabezpečení určit požadavky na ochranu hostitele, umožňuje na hostiteli a zabránit i plně důvěryhodný kód volání některé metody, které nejsou vhodné pro daného hostitele, jako je například <xref:System.Environment.Exit%2A>nebo <xref:System.Windows.Forms.MessageBox.Show%2A> pro SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c97c2-259">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>  
  
 <span data-ttu-id="c97c2-260">HPA ovlivňuje pouze nespravovaná aplikace, které hostují běžné language runtime a implementace hostitele ochranu, jako je SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c97c2-260">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="c97c2-261">Při použití výsledky akce zabezpečení při vytváření požadavku na propojení na základě prostředky hostitele zpřístupňuje třída nebo metoda.</span><span class="sxs-lookup"><span data-stu-id="c97c2-261">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="c97c2-262">Pokud je kód spuštěn v aplikaci klienta nebo na serveru, který není chráněný hostitele, atribut "se odpaří"; to není zjištěna a proto nebyly použity.</span><span class="sxs-lookup"><span data-stu-id="c97c2-262">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c97c2-263">Účelem tohoto atributu je vynutit konkrétního hostitele programovací model pokyny, není chování zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="c97c2-263">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="c97c2-264">I když požadavek propojení se používá k ověření pro shodu programovací model požadavky <xref:System.Security.Permissions.HostProtectionAttribute> není oprávnění zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="c97c2-264">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>  
  
 <span data-ttu-id="c97c2-265">Pokud hostitel nemá programovací model požadavky, nedojde k požadavky propojení.</span><span class="sxs-lookup"><span data-stu-id="c97c2-265">If the host does not have programming model requirements, the link demands do not occur.</span></span>  
  
 <span data-ttu-id="c97c2-266">Tento atribut určuje následující:</span><span class="sxs-lookup"><span data-stu-id="c97c2-266">This attribute identifies the following:</span></span>  
  
-   <span data-ttu-id="c97c2-267">Metody nebo třídy, které se nehodí hostitele programovací model, ale jinak jsou neškodné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-267">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>  
  
-   <span data-ttu-id="c97c2-268">Metody nebo třídy, které se nehodí programovací model hostitele a může vést k destabilizing serveru spravované uživatelského kódu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-268">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>  
  
-   <span data-ttu-id="c97c2-269">Metody nebo třídy, které se nehodí hostitele programování modelu a může vést k destabilizaci samotný proces serveru.</span><span class="sxs-lookup"><span data-stu-id="c97c2-269">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c97c2-270">Pokud vytváříte třídy knihovny, která je k volání aplikace, které může být spuštěn v prostředí hostitele chráněné, byste měli použít tento atribut na členy, které zveřejňují <xref:System.Security.Permissions.HostProtectionResource> prostředků kategorií.</span><span class="sxs-lookup"><span data-stu-id="c97c2-270">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="c97c2-271">Členové knihovny tříd rozhraní .NET Framework se tento atribut způsobit pouze bezprostředního volajícího ke kontrole.</span><span class="sxs-lookup"><span data-stu-id="c97c2-271">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="c97c2-272">Vaše knihovna člen musí také způsobit kontrolu jeho bezprostředního volajícího stejným způsobem.</span><span class="sxs-lookup"><span data-stu-id="c97c2-272">Your library member must also cause a check of its immediate caller in the same manner.</span></span>  
  
 <span data-ttu-id="c97c2-273">Prosím najít další informace o HPA v <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-273">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-274">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-274">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-275">Pro systém SQL Server musí všechny metody použité k zavedení synchronizace nebo dělení na vlákna označeny HPA.</span><span class="sxs-lookup"><span data-stu-id="c97c2-275">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="c97c2-276">To zahrnuje metody, které sdílejí stavu, jsou synchronizovány nebo spravovat externí procesy.</span><span class="sxs-lookup"><span data-stu-id="c97c2-276">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="c97c2-277"><xref:System.Security.Permissions.HostProtectionResource> Hodnoty, které mají vliv systému SQL Server jsou <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, a <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-277">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="c97c2-278">Ale libovolné metody, která zveřejňuje žádné <xref:System.Security.Permissions.HostProtectionResource> by měl být identifikovaný HPA, nikoli pouze ty pomocí prostředků, které mají vliv na SQL.</span><span class="sxs-lookup"><span data-stu-id="c97c2-278">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>  
  
### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="c97c2-279">Po neomezenou dobu nebrání v nespravovaném kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-279">Do Not Block Indefinitely in Unmanaged Code</span></span>  
 <span data-ttu-id="c97c2-280">Blokování v nespravovaném kódu místo ve spravovaném kódu může způsobit odepření služby, protože není možné přerušit vlákno modulu CLR.</span><span class="sxs-lookup"><span data-stu-id="c97c2-280">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="c97c2-281">Blokované vlákno brání uvolnění modulu CLR <xref:System.AppDomain>, alespoň bez provádění některých operací velmi nebezpečné.</span><span class="sxs-lookup"><span data-stu-id="c97c2-281">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="c97c2-282">Blokování používání Win32 synchronizace primitivní je zrušte příklad něco, co jsme nelze povolit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-282">Blocking using a Win32 synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="c97c2-283">Blokování v nástroji volání `ReadFile` na soket je nutno Pokud je to možné – v ideálním případě by měl rozhraní API Win32 poskytují mechanismus pro určité operace, jako je to vypršení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-283">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Win32 API should provide a mechanism for an operation like this to time out.</span></span>  
  
 <span data-ttu-id="c97c2-284">Libovolné metody, která volá do nativní by v ideálním případě pomocí přiměřené omezený časový limit volání Win32.</span><span class="sxs-lookup"><span data-stu-id="c97c2-284">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="c97c2-285">Pokud uživatel může určit časový limit, by neměl být uživatel moci zadat neomezený časový limit bez některé konkrétní bezpečnostní oprávnění.</span><span class="sxs-lookup"><span data-stu-id="c97c2-285">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="c97c2-286">Jako vodítko Pokud metoda bude blokovat pro více než ~ 10 sekund, musíte používat verzi, která podporuje vypršení časových limitů nebo potřebujete pomoc CLR.</span><span class="sxs-lookup"><span data-stu-id="c97c2-286">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>  
  
 <span data-ttu-id="c97c2-287">Zde jsou některé příklady problematické rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c97c2-287">Here are some examples of problematic API’s.</span></span>  <span data-ttu-id="c97c2-288">Kanály (anonymní i s názvem) může být vytvořen pomocí vypršení časového limitu; ale kódu musí měli jistotu, že nikdy volání `CreateNamedPipe` ani `WaitNamedPipe` s NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="c97c2-288">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="c97c2-289">Kromě toho může neočekávaná blokování i v případě, že je zadaný časový limit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-289">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="c97c2-290">Volání metody `WriteFile` na anonymní kanálu se zablokuje, dokud se zapisují všechny bajtů, což znamená, pokud má vyrovnávací paměť nepřečtená data v něm `WriteFile` volání zablokuje, dokud má čtečka uvolnění místa ve vyrovnávací paměti do kanálu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-290">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="c97c2-291">Sokety měli vždycky používat některé rozhraní API, které ctí mechanismus časový limit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-291">Sockets should always use some API that honors a timeout mechanism.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-292">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-292">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-293">Blokování bez vypršení časového limitu v nespravovaném kódu se útoku DOS.</span><span class="sxs-lookup"><span data-stu-id="c97c2-293">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="c97c2-294">Neprovádějte platformy vyvolat volání `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, a `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="c97c2-294">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="c97c2-295">Nepoužívejte NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="c97c2-295">Do not use NMPWAIT_WAIT_FOREVER.</span></span>  
  
### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="c97c2-296">Identifikujte všechny STA – závislé funkce.</span><span class="sxs-lookup"><span data-stu-id="c97c2-296">Identify Any STA-Dependent Features.</span></span>  
 <span data-ttu-id="c97c2-297">Určete kód, který používá COM single-threaded Apartment (STAs).</span><span class="sxs-lookup"><span data-stu-id="c97c2-297">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="c97c2-298">V procesu systému SQL Server jsou zakázány STAs.</span><span class="sxs-lookup"><span data-stu-id="c97c2-298">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="c97c2-299">Funkce, které jsou závislé na `CoInitialize`, jako například čítače výkonu nebo do schránky, musí se zakázat v rámci systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c97c2-299">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>  
  
### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="c97c2-300">Ujistěte se, že jsou bez problémů synchronizace finalizační metody</span><span class="sxs-lookup"><span data-stu-id="c97c2-300">Ensure Finalizers Are Free of Synchronization Problems</span></span>  
 <span data-ttu-id="c97c2-301">Více vláken finalizační metodu může existovat v budoucích verzích rozhraní .NET Framework pro různé instance stejného typu běžet současně, což znamená finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="c97c2-301">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="c97c2-302">Nemají být zcela vláken; uvolňování paměti zaručuje, že pouze jedno vlákno spustí finalizační metodu pro instanci daného objektu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-302">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="c97c2-303">Však finalizační metody musí být zakódované vyhnout časování a blokování, pokud se používá současně na několik instancí jiný objekt.</span><span class="sxs-lookup"><span data-stu-id="c97c2-303">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="c97c2-304">Při použití jakékoli externí stavu, například zápis do souboru protokolu v finalizační metodu, problémy dělení na vlákna musí být zpracován.</span><span class="sxs-lookup"><span data-stu-id="c97c2-304">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="c97c2-305">Nespoléhejte na dokončení zajistit bezpečný přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="c97c2-305">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="c97c2-306">Lokální úložiště vláken, spravovaným nebo nativním, nepoužívejte k uložení stavu ve vlákně finalizační metodu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-306">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-307">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-307">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-308">Finalizační metody musí být bez problémů synchronizace.</span><span class="sxs-lookup"><span data-stu-id="c97c2-308">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="c97c2-309">Nepoužívejte statické měnitelný stavu finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="c97c2-309">Do not use a static mutable state in a finalizer.</span></span>  
  
### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="c97c2-310">Pokud je to možné vyhnout nespravované paměti</span><span class="sxs-lookup"><span data-stu-id="c97c2-310">Avoid Unmanaged Memory If Possible</span></span>  
 <span data-ttu-id="c97c2-311">Nespravované paměti můžou uniknout, stejně jako popisovač operačního systému.</span><span class="sxs-lookup"><span data-stu-id="c97c2-311">Unmanaged memory can be leaked, just like an operating system handle.</span></span>  <span data-ttu-id="c97c2-312">Pokud je to možné, zkuste použít paměti na použití zásobníku [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) nebo definovaného spravovaný objekt, jako [příkazu pevnou](~/docs/csharp/language-reference/keywords/fixed-statement.md) nebo <xref:System.Runtime.InteropServices.GCHandle> pomocí byte [].</span><span class="sxs-lookup"><span data-stu-id="c97c2-312">If possible, try to use memory on the stack using [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) or a pinned managed object such as the [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span>  <span data-ttu-id="c97c2-313"><xref:System.GC> Nakonec tyto vyčistí.</span><span class="sxs-lookup"><span data-stu-id="c97c2-313">The <xref:System.GC> eventually cleans these up.</span></span>  <span data-ttu-id="c97c2-314">Pokud však je třeba přiřadit nespravovanou paměť, zvažte použití třídy, která je odvozena od <xref:System.Runtime.InteropServices.SafeHandle> zabalit přidělení paměti.</span><span class="sxs-lookup"><span data-stu-id="c97c2-314">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>  
  
 <span data-ttu-id="c97c2-315">Všimněte si, že je alespoň jeden případ kde <xref:System.Runtime.InteropServices.SafeHandle> není dostatečný.</span><span class="sxs-lookup"><span data-stu-id="c97c2-315">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span>  <span data-ttu-id="c97c2-316">Pro volání metod modelu COM, které přidělit nebo uvolnit paměť, je běžné pro jednu knihovnu DLL přidělit paměť prostřednictvím `CoTaskMemAlloc` pak jiné DLL uvolní této paměti se `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="c97c2-316">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="c97c2-317">Pomocí <xref:System.Runtime.InteropServices.SafeHandle> na těchto místech by nevhodných vzhledem k tomu, že se pokusí ke svázání životnost nespravované paměti pro dobu životnosti <xref:System.Runtime.InteropServices.SafeHandle> místo toho, abyste jiné knihovny DLL řízení životního cyklu paměti.</span><span class="sxs-lookup"><span data-stu-id="c97c2-317">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>  
  
### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="c97c2-318">Zkontrolujte všechny používá Catch(Exception)</span><span class="sxs-lookup"><span data-stu-id="c97c2-318">Review All Uses of Catch(Exception)</span></span>  
 <span data-ttu-id="c97c2-319">Catch – bloky catch všechny výjimky místo jednu konkrétní výjimku bude nyní catch asynchronní výjimky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-319">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span>  <span data-ttu-id="c97c2-320">Zkontrolujte všechny catch(Exception) bloku, hledá žádné důležité prostředků vydání nebo obnovení kód, který může být přeskočeny, a také potenciálně nesprávné chování v bloku catch pro zpracování <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, nebo <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-320">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="c97c2-321">Všimněte si, že je možné, může být tento kód protokolování nebo některé odhad, že se zobrazí pouze určité výjimky, nebo že vždy, když se stane výjimku, je pro právě jeden konkrétní důvod se nezdařilo.</span><span class="sxs-lookup"><span data-stu-id="c97c2-321">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="c97c2-322">Tyto předpoklady muset být aktualizováno, aby zahrnovalo <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-322">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>  
  
 <span data-ttu-id="c97c2-323">Vezměte v úvahu všechny změna umístí této catch všechny výjimky pro zachytávání určitý typ výjimky, které očekáváte, že bude vyvolána, například <xref:System.FormatException> z řetězce formátování metody.</span><span class="sxs-lookup"><span data-stu-id="c97c2-323">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="c97c2-324">Tento blok catch zabrání spuštění na neočekávané výjimky a pomůže zajistit, že kód není Skrýt chyby tak, že zachytávání neočekávané výjimky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-324">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="c97c2-325">Obecně platí nikdy zpracování výjimky v kódu knihovny (kód, který vyžaduje, abyste k zachycení výjimek může znamenat závadu návrhu v kódu jsou volání).</span><span class="sxs-lookup"><span data-stu-id="c97c2-325">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="c97c2-326">V některých případech můžete chtít zachytit výjimku a vyvolat typ různé výjimky poskytující další data.</span><span class="sxs-lookup"><span data-stu-id="c97c2-326">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="c97c2-327">V takovém případě použijte vnořené výjimky ukládání skutečné příčinu selhání v <xref:System.Exception.InnerException%2A> vlastnost novou výjimku.</span><span class="sxs-lookup"><span data-stu-id="c97c2-327">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-328">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-328">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-329">Zkontrolujte všechny bloky catch ve spravovaném kódu, že catch všechny objekty nebo catch všechny výjimky.</span><span class="sxs-lookup"><span data-stu-id="c97c2-329">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="c97c2-330">V jazyce C#, to znamená i označování `catch` {} a `catch(Exception)` {}.</span><span class="sxs-lookup"><span data-stu-id="c97c2-330">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="c97c2-331">Zvažte velmi konkrétní typ výjimky, nebo zkontrolujte kód, který Ujistěte se, že ho neprovede chybný způsob Pokud zachytávalo typ došlo k neočekávané výjimce.</span><span class="sxs-lookup"><span data-stu-id="c97c2-331">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>  
  
### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="c97c2-332">Nepředpokládejte, spravované vlákno je vlákna Win32 – je vlákna</span><span class="sxs-lookup"><span data-stu-id="c97c2-332">Do Not Assume a Managed Thread Is a Win32 Thread – It Is a Fiber</span></span>  
 <span data-ttu-id="c97c2-333">Pomocí spravovaného místní úložiště funguje, ale nemusí použít místní úložiště vláken nespravované nebo předpokládají, že kód bude znovu spusťte na aktuální vlákno operačního systému pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="c97c2-333">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span>  <span data-ttu-id="c97c2-334">Neměňte nastavení, jako je národní prostředí vlákna.</span><span class="sxs-lookup"><span data-stu-id="c97c2-334">Do not change settings like the thread’s locale.</span></span>  <span data-ttu-id="c97c2-335">Nevolejte `InitializeCriticalSection` nebo `CreateMutex` prostřednictvím platformy vyvolat, protože vyžadují vláknu operačního systému, který zadá zámek také ukončete zámek.</span><span class="sxs-lookup"><span data-stu-id="c97c2-335">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span>  <span data-ttu-id="c97c2-336">Vzhledem k tomu, že to nebude tak při použití jsou vlákna, kritické oddíly Win32 a mutex – třídy nelze použít v SQL přímo.</span><span class="sxs-lookup"><span data-stu-id="c97c2-336">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="c97c2-337">Všimněte si, že spravovanou <xref:System.Threading.Mutex> třída nezpracovává tyto problémy spřažení podprocesu.</span><span class="sxs-lookup"><span data-stu-id="c97c2-337">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>  
  
 <span data-ttu-id="c97c2-338">Většina stavu můžete bezpečně použít ve spravované <xref:System.Threading.Thread> objektu, včetně lokální úložiště vláken spravované a vlákna aktuální jazykové verze uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c97c2-338">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span>  <span data-ttu-id="c97c2-339">Můžete také <xref:System.ThreadStaticAttribute>, takže hodnotu existující proměnné statické přístupné jenom pomocí spravovaného aktuální vlákno (to je další způsob plnění fiber místní úložiště v modulu CLR).</span><span class="sxs-lookup"><span data-stu-id="c97c2-339">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span>  <span data-ttu-id="c97c2-340">Pro programování modelu důvodů, nelze změnit jazykové verze aktuálního vlákna při spuštění v systému SQL.</span><span class="sxs-lookup"><span data-stu-id="c97c2-340">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-341">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-341">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-342">SQL Server běží v režimu vlákének; Nepoužívejte lokální úložiště vláken.</span><span class="sxs-lookup"><span data-stu-id="c97c2-342">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="c97c2-343">Vyhněte se platformy vyvolat volání `TlsAlloc`, `TlsFree`, `TlsGetValue`, a`TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="c97c2-343">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>  
  
### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="c97c2-344">Umožní zosobnění popisovač SQL serveru</span><span class="sxs-lookup"><span data-stu-id="c97c2-344">Let SQL Server Handle Impersonation</span></span>  
 <span data-ttu-id="c97c2-345">Vzhledem k tomu, že zosobnění pracuje na úrovni přístup z více vláken a SQL můžete spustit v režimu vlákének, by neměl zosobnit uživatele spravovaného kódu a nesmí volání `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="c97c2-345">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-346">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-346">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-347">Umožní zpracování zosobnění systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c97c2-347">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="c97c2-348">Nepoužívejte `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, nebo `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="c97c2-348">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>  
  
### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="c97c2-349">Nevolejte Thread::Suspend</span><span class="sxs-lookup"><span data-stu-id="c97c2-349">Do Not Call Thread::Suspend</span></span>  
 <span data-ttu-id="c97c2-350">Umožňuje pozastavit vlákno, může se zobrazit jednoduchá operace, ale může to způsobit zablokování.</span><span class="sxs-lookup"><span data-stu-id="c97c2-350">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="c97c2-351">Pokud vlákno podržíte, že získá zámek pozastavil druhý vláken a pak druhý vlákno pokusí trvá stejné zámek, dojde k zablokování.</span><span class="sxs-lookup"><span data-stu-id="c97c2-351">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="c97c2-352"><xref:System.Threading.Thread.Suspend%2A>může narušovat zabezpečení, třída načítání, vzdálenou komunikaci a reflexe aktuálně.</span><span class="sxs-lookup"><span data-stu-id="c97c2-352"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="c97c2-353">Pravidel nástroje Analýza kódu</span><span class="sxs-lookup"><span data-stu-id="c97c2-353">Code Analysis Rule</span></span>  
 <span data-ttu-id="c97c2-354">Nevolejte <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-354">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="c97c2-355">Zvažte použití skutečné synchronizace primitivní místo toho jako <xref:System.Threading.Semaphore> nebo <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="c97c2-355">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>  
  
### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="c97c2-356">Chránit kritické operace s omezené oblasti provádění a kontrakty spolehlivosti</span><span class="sxs-lookup"><span data-stu-id="c97c2-356">Protect Critical Operations with Constrained Execution Regions and Reliability Contracts</span></span>  
 <span data-ttu-id="c97c2-357">Při provádění operace s komplexní, aktualizuje sdílený stav nebo potřebného pro nepodmíněně buď plně úspěšné nebo plně nezdaří, ujistěte se, že je chráněn v oblasti omezeného provádění (CER).</span><span class="sxs-lookup"><span data-stu-id="c97c2-357">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="c97c2-358">To zaručuje, že spuštění kódu v každém případě i náhlému vlákno přerušení nebo náhlému <xref:System.AppDomain> uvolnit.</span><span class="sxs-lookup"><span data-stu-id="c97c2-358">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>  
  
 <span data-ttu-id="c97c2-359">CER je konkrétní `try/finally` bloku bezprostředně před voláním <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="c97c2-359">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>  
  
 <span data-ttu-id="c97c2-360">To proto dá pokyn kompilátoru za běhu k přípravě všech kód v nakonec blokovat dřív, než spustíte `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="c97c2-360">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="c97c2-361">To zaručuje, že kód nakonec bloku vychází a spustí ve všech případech.</span><span class="sxs-lookup"><span data-stu-id="c97c2-361">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="c97c2-362">Je běžné v CER mít prázdnou `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="c97c2-362">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="c97c2-363">Použití CER chrání před asynchronní vlákno přerušení a výjimky nedostatku paměti.</span><span class="sxs-lookup"><span data-stu-id="c97c2-363">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="c97c2-364">V tématu <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> pro formulář CER, který kromě přetečení zásobníku obslužné rutiny pro mimořádně hloubkové kód.</span><span class="sxs-lookup"><span data-stu-id="c97c2-364">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c97c2-365">Viz také</span><span class="sxs-lookup"><span data-stu-id="c97c2-365">See Also</span></span>  
 <xref:System.Runtime.ConstrainedExecution>  
 [<span data-ttu-id="c97c2-366">Programování serveru SQL Server a atributy ochrany hostitele</span><span class="sxs-lookup"><span data-stu-id="c97c2-366">SQL Server Programming and Host Protection Attributes</span></span>](../../../docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)
