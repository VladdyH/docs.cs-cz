---
title: Nejčastější dotazy
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 252ed666-0679-4eea-b71b-2f14117ef443
ms.openlocfilehash: 5f556c46823bd867709e8c53b59f7ac53201d242
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33365485"
---
# <a name="frequently-asked-questions"></a><span data-ttu-id="d3fc7-102">Nejčastější dotazy</span><span class="sxs-lookup"><span data-stu-id="d3fc7-102">Frequently Asked Questions</span></span>
<span data-ttu-id="d3fc7-103">V následujících částech zodpovědět některé běžné problémy, které se mohou vyskytnout při implementaci [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d3fc7-103">The following sections answer some common issues that you might encounter when you implement [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)].</span></span>  
  
 <span data-ttu-id="d3fc7-104">Další problémy jsou řešeny v [Poradce při potížích s](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-104">Additional issues are addressed in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).</span></span>  
  
## <a name="cannot-connect"></a><span data-ttu-id="d3fc7-105">Nelze se připojit</span><span class="sxs-lookup"><span data-stu-id="d3fc7-105">Cannot Connect</span></span>  
 <span data-ttu-id="d3fc7-106">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-106">Q.</span></span> <span data-ttu-id="d3fc7-107">Nelze se připojit k databázi.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-107">I cannot connect to my database.</span></span>  
  
 <span data-ttu-id="d3fc7-108">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-108">A.</span></span> <span data-ttu-id="d3fc7-109">Ujistěte se, že je připojovací řetězec správný a že je spuštěna instance systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-109">Make sure your connection string is correct and that your SQL Server instance is running.</span></span> <span data-ttu-id="d3fc7-110">Všimněte si také, že [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] vyžaduje, aby byl povolen protokol pojmenovaných kanálů.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-110">Note also that [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] requires the Named Pipes protocol to be enabled.</span></span> <span data-ttu-id="d3fc7-111">Další informace najdete v tématu [učení podle návody](../../../../../../docs/framework/data/adonet/sql/linq/learning-by-walkthroughs.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-111">For more information, see [Learning by Walkthroughs](../../../../../../docs/framework/data/adonet/sql/linq/learning-by-walkthroughs.md).</span></span>  
  
## <a name="changes-to-database-lost"></a><span data-ttu-id="d3fc7-112">Změny databáze ztráty</span><span class="sxs-lookup"><span data-stu-id="d3fc7-112">Changes to Database Lost</span></span>  
 <span data-ttu-id="d3fc7-113">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-113">Q.</span></span> <span data-ttu-id="d3fc7-114">Změny provedené k datům v databázi, ale při I reran Moje aplikace, tato změna byla již existuje.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-114">I made a change to data in the database, but when I reran my application, the change was no longer there.</span></span>  
  
 <span data-ttu-id="d3fc7-115">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-115">A.</span></span> <span data-ttu-id="d3fc7-116">Ujistěte se, že zavoláte <xref:System.Data.Linq.DataContext.SubmitChanges%2A> výsledky uložit do databáze.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-116">Make sure that you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A> to save results to the database.</span></span>  
  
## <a name="database-connection-open-how-long"></a><span data-ttu-id="d3fc7-117">Připojení k databázi: Otevřete jak dlouho?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-117">Database Connection: Open How Long?</span></span>  
 <span data-ttu-id="d3fc7-118">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-118">Q.</span></span> <span data-ttu-id="d3fc7-119">Jak dlouho připojení k databázi zůstanou otevřené?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-119">How long does my database connection remain open?</span></span>  
  
 <span data-ttu-id="d3fc7-120">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-120">A.</span></span> <span data-ttu-id="d3fc7-121">Připojení obvykle zůstane otevřená, dokud nebude využívat výsledky dotazu.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-121">A connection typically remains open until you consume the query results.</span></span> <span data-ttu-id="d3fc7-122">Pokud plánujete časově zpracovat všechny výsledky a jsou není nikoli ukládání do mezipaměti výsledky, použít <xref:System.Linq.Enumerable.ToList%2A> do dotazu.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-122">If you expect to take time to process all the results and are not opposed to caching the results, apply <xref:System.Linq.Enumerable.ToList%2A> to the query.</span></span> <span data-ttu-id="d3fc7-123">V běžné scénáře, kde každý objekt zpracovává jenom jednou, streamování model je nadřízená v obou `DataReader` a [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d3fc7-123">In common scenarios where each object is processed only one time, the streaming model is superior in both `DataReader` and [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span>  
  
 <span data-ttu-id="d3fc7-124">Přesné údaje o využití připojení závisí na následujících:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-124">The exact details of connection usage depend on the following:</span></span>  
  
-   <span data-ttu-id="d3fc7-125">Stav připojení Pokud <xref:System.Data.Linq.DataContext> je vytvořený pomocí objekt připojení.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-125">Connection status if the <xref:System.Data.Linq.DataContext> is constructed with a connection object.</span></span>  
  
-   <span data-ttu-id="d3fc7-126">Nastavení připojovacího řetězce (například povolení více Active výsledek sady (MARS).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-126">Connection string settings (for example, enabling Multiple Active Result Sets (MARS).</span></span> <span data-ttu-id="d3fc7-127">Další informace najdete v tématu [více sad Active výsledek (MARS)](../../../../../../docs/framework/data/adonet/sql/multiple-active-result-sets-mars.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-127">For more information, see [Multiple Active Result Sets (MARS)](../../../../../../docs/framework/data/adonet/sql/multiple-active-result-sets-mars.md).</span></span>  
  
## <a name="updating-without-querying"></a><span data-ttu-id="d3fc7-128">Aktualizace bez dotazování</span><span class="sxs-lookup"><span data-stu-id="d3fc7-128">Updating Without Querying</span></span>  
 <span data-ttu-id="d3fc7-129">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-129">Q.</span></span> <span data-ttu-id="d3fc7-130">Můžete aktualizovat data tabulky bez první dotaz na databázi?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-130">Can I update table data without first querying the database?</span></span>  
  
 <span data-ttu-id="d3fc7-131">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-131">A.</span></span> <span data-ttu-id="d3fc7-132">I když [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] nemá aktualizace založená na sadu příkazů, některý z následujících postupů můžete aktualizovat bez první dotazování:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-132">Although [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not have set-based update commands, you can use either of the following techniques to update without first querying:</span></span>  
  
-   <span data-ttu-id="d3fc7-133">Použití <xref:System.Data.Linq.DataContext.ExecuteCommand%2A> k odeslání kódu SQL.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-133">Use <xref:System.Data.Linq.DataContext.ExecuteCommand%2A> to send SQL code.</span></span>  
  
-   <span data-ttu-id="d3fc7-134">Vytvoření nové instance objektu a inicializace všech aktuální hodnoty (pole) ovlivňující aktualizace.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-134">Create a new instance of the object and initialize all the current values (fields) that affect the update.</span></span> <span data-ttu-id="d3fc7-135">Pak připojte objekt, který má <xref:System.Data.Linq.DataContext> pomocí <xref:System.Data.Linq.Table%601.Attach%2A> a upravte pole, které chcete změnit.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-135">Then attach the object to the <xref:System.Data.Linq.DataContext> by using <xref:System.Data.Linq.Table%601.Attach%2A> and modify the field you want to change.</span></span>  
  
## <a name="unexpected-query-results"></a><span data-ttu-id="d3fc7-136">Neočekávaný dotaz výsledky</span><span class="sxs-lookup"><span data-stu-id="d3fc7-136">Unexpected Query Results</span></span>  
 <span data-ttu-id="d3fc7-137">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-137">Q.</span></span> <span data-ttu-id="d3fc7-138">Můj dotaz vrací neočekávané výsledky.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-138">My query is returning unexpected results.</span></span> <span data-ttu-id="d3fc7-139">Jak můžete I prohlédnout co dochází?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-139">How can I inspect what is occurring?</span></span>  
  
 <span data-ttu-id="d3fc7-140">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-140">A.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d3fc7-141"> poskytuje několik nástrojů pro zkontrolujete kód SQL, který generuje.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-141"> provides several tools for inspecting the SQL code it generates.</span></span> <span data-ttu-id="d3fc7-142">Jedním z nejdůležitějších je <xref:System.Data.Linq.DataContext.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-142">One of the most important is <xref:System.Data.Linq.DataContext.Log%2A>.</span></span> <span data-ttu-id="d3fc7-143">Další informace najdete v tématu [podpora ladění](../../../../../../docs/framework/data/adonet/sql/linq/debugging-support.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-143">For more information, see [Debugging Support](../../../../../../docs/framework/data/adonet/sql/linq/debugging-support.md).</span></span>  
  
## <a name="unexpected-stored-procedure-results"></a><span data-ttu-id="d3fc7-144">Neočekávané uložených výsledcích procedur</span><span class="sxs-lookup"><span data-stu-id="d3fc7-144">Unexpected Stored Procedure Results</span></span>  
 <span data-ttu-id="d3fc7-145">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-145">Q.</span></span> <span data-ttu-id="d3fc7-146">Je nutné uložené procedury, jejichž návratová hodnota je vypočítána `MAX()`.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-146">I have a stored procedure whose return value is calculated by `MAX()`.</span></span> <span data-ttu-id="d3fc7-147">Při přetahování uložené procedury, která [!INCLUDE[vs_ordesigner_short](../../../../../../includes/vs-ordesigner-short-md.md)] prostor, návratová hodnota není správná.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-147">When I drag the stored procedure to the [!INCLUDE[vs_ordesigner_short](../../../../../../includes/vs-ordesigner-short-md.md)] surface, the return value is not correct.</span></span>  
  
 <span data-ttu-id="d3fc7-148">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-148">A.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d3fc7-149"> nabízí dva způsoby, jak vrátit generované hodnoty prostřednictvím uložené procedury:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-149"> provides two ways to return database-generated values by way of stored procedures:</span></span>  
  
-   <span data-ttu-id="d3fc7-150">Pojmenováním výsledných výstupů.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-150">By naming the output result.</span></span>  
  
-   <span data-ttu-id="d3fc7-151">Explicitním zadáním výstupní parametr.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-151">By explicitly specifying an output parameter.</span></span>  
  
 <span data-ttu-id="d3fc7-152">Následuje příklad výstupu nesprávné.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-152">The following is an example of incorrect output.</span></span> <span data-ttu-id="d3fc7-153">Protože [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] nelze mapovat na výsledcích vždy vrátí hodnotu 0:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-153">Because [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] cannot map the results, it always returns 0:</span></span>  
  
 `create procedure proc2`  
  
 `as`  
  
 `begin`  
  
 `select max(i) from t where name like 'hello'`  
  
 `end`  
  
 <span data-ttu-id="d3fc7-154">Následuje příklad výstupu správné v pomocí výstupní parametr:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-154">The following is an example of correct output by using an output parameter:</span></span>  
  
 `create procedure proc2`  
  
 `@result int OUTPUT`  
  
 `as`  
  
 `select @result = MAX(i) from t where name like 'hello'`  
  
 `go`  
  
 <span data-ttu-id="d3fc7-155">Následuje příklad výstupu správné v pojmenováním výsledných výstupů:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-155">The following is an example of correct output by naming the output result:</span></span>  
  
 `create procedure proc2`  
  
 `as`  
  
 `begin`  
  
 `select nax(i) AS MaxResult from t where name like 'hello'`  
  
 `end`  
  
 <span data-ttu-id="d3fc7-156">Další informace najdete v tématu [přizpůsobení Operations podle pomocí uložené procedury](../../../../../../docs/framework/data/adonet/sql/linq/customizing-operations-by-using-stored-procedures.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-156">For more information, see [Customizing Operations By Using Stored Procedures](../../../../../../docs/framework/data/adonet/sql/linq/customizing-operations-by-using-stored-procedures.md).</span></span>  
  
## <a name="serialization-errors"></a><span data-ttu-id="d3fc7-157">Serializace chyby</span><span class="sxs-lookup"><span data-stu-id="d3fc7-157">Serialization Errors</span></span>  
 <span data-ttu-id="d3fc7-158">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-158">Q.</span></span> <span data-ttu-id="d3fc7-159">Při serializaci se zobrazí následující chybová zpráva: "zadejte... 'System.Data.Linq.ChangeTracker+StandardChangeTracker' není označen jako serializovatelný."</span><span class="sxs-lookup"><span data-stu-id="d3fc7-159">When I try to serialize, I get the following error: "Type 'System.Data.Linq.ChangeTracker+StandardChangeTracker' ... is not marked as serializable."</span></span>  
  
 <span data-ttu-id="d3fc7-160">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-160">A.</span></span> <span data-ttu-id="d3fc7-161">Generování v kódu [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] podporuje <xref:System.Runtime.Serialization.DataContractSerializer> serializace.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-161">Code generation in [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] supports <xref:System.Runtime.Serialization.DataContractSerializer> serialization.</span></span> <span data-ttu-id="d3fc7-162">Nepodporuje <xref:System.Xml.Serialization.XmlSerializer> nebo <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-162">It does not support <xref:System.Xml.Serialization.XmlSerializer> or <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.</span></span> <span data-ttu-id="d3fc7-163">Další informace najdete v tématu [serializace](../../../../../../docs/framework/data/adonet/sql/linq/serialization.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-163">For more information, see [Serialization](../../../../../../docs/framework/data/adonet/sql/linq/serialization.md).</span></span>  
  
## <a name="multiple-dbml-files"></a><span data-ttu-id="d3fc7-164">Více souborů DBML</span><span class="sxs-lookup"><span data-stu-id="d3fc7-164">Multiple DBML Files</span></span>  
 <span data-ttu-id="d3fc7-165">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-165">Q.</span></span> <span data-ttu-id="d3fc7-166">Při budu potřebovat více DBML souborů, které sdílejí společnou některé tabulky, zobrazí chyba kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-166">When I have multiple DBML files that share some tables in common, I get a compiler error.</span></span>  
  
 <span data-ttu-id="d3fc7-167">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-167">A.</span></span> <span data-ttu-id="d3fc7-168">Nastavte **kontextu Namespace** a **Entity Namespace** vlastnosti z [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] na hodnotu odlišné pro každého souboru DBML.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-168">Set the **Context Namespace** and **Entity Namespace** properties from the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] to a distinct value for each DBML file.</span></span> <span data-ttu-id="d3fc7-169">Tento přístup eliminuje kolizí název nebo oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-169">This approach eliminates the name/namespace collision.</span></span>  
  
## <a name="avoiding-explicit-setting-of-database-generated-values-on-insert-or-update"></a><span data-ttu-id="d3fc7-170">Zamezení explicitní nastavení generované hodnoty v příkazu Insert nebo Update</span><span class="sxs-lookup"><span data-stu-id="d3fc7-170">Avoiding Explicit Setting of Database-Generated Values on Insert or Update</span></span>  
 <span data-ttu-id="d3fc7-171">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-171">Q.</span></span> <span data-ttu-id="d3fc7-172">Je nutné databázové tabulky s `DateCreated` sloupec, který použije se výchozí hodnota SQL `Getdate()`.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-172">I have a database table with a `DateCreated` column that defaults to SQL `Getdate()`.</span></span> <span data-ttu-id="d3fc7-173">Při pokusu vložit nový záznam pomocí [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], získá nastaven na hodnotu `NULL`.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-173">When I try to insert a new record by using [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], the value gets set to `NULL`.</span></span> <span data-ttu-id="d3fc7-174">Očekávaný by mohla být nastavenou na výchozí databázi.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-174">I would expect it to be set to the database default.</span></span>  
  
 <span data-ttu-id="d3fc7-175">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-175">A.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d3fc7-176"> zpracuje tuto situaci automaticky pro identitu (automatického přírůstku) a rowguidcol (generované GUID) a sloupce časového razítka.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-176"> handles this situation automatically for identity (auto-increment) and rowguidcol (database-generated GUID) and timestamp columns.</span></span> <span data-ttu-id="d3fc7-177">V ostatních případech byste měli ručně nastavit <xref:System.Data.Linq.Mapping.ColumnAttribute.IsDbGenerated%2A> = `true` a <xref:System.Data.Linq.Mapping.ColumnAttribute.AutoSync%2A> = <xref:System.Data.Linq.Mapping.AutoSync.Always> / <xref:System.Data.Linq.Mapping.AutoSync.OnInsert> / <xref:System.Data.Linq.Mapping.AutoSync.OnUpdate> vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-177">In other cases, you should manually set <xref:System.Data.Linq.Mapping.ColumnAttribute.IsDbGenerated%2A>=`true` and <xref:System.Data.Linq.Mapping.ColumnAttribute.AutoSync%2A>=<xref:System.Data.Linq.Mapping.AutoSync.Always>/<xref:System.Data.Linq.Mapping.AutoSync.OnInsert>/<xref:System.Data.Linq.Mapping.AutoSync.OnUpdate> properties.</span></span>  
  
## <a name="multiple-dataloadoptions"></a><span data-ttu-id="d3fc7-178">Více DataLoadOptions</span><span class="sxs-lookup"><span data-stu-id="d3fc7-178">Multiple DataLoadOptions</span></span>  
 <span data-ttu-id="d3fc7-179">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-179">Q.</span></span> <span data-ttu-id="d3fc7-180">Můžete zadat možnosti další zátěž bez přepsal první?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-180">Can I specify additional load options without overwriting the first?</span></span>  
  
 <span data-ttu-id="d3fc7-181">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-181">A.</span></span> <span data-ttu-id="d3fc7-182">Ano.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-182">Yes.</span></span> <span data-ttu-id="d3fc7-183">První není přepsán jako v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-183">The first is not overwritten, as in the following example:</span></span>  
  
```vb  
Dim dlo As New DataLoadOptions()  
dlo.LoadWith(Of Order)(Function(o As Order) o.Customer)  
dlo.LoadWith(Of Order)(Function(o As Order) o.OrderDetails)  
```  
  
```csharp  
DataLoadOptions dlo = new DataLoadOptions();  
dlo.LoadWith<Order>(o => o.Customer);  
dlo.LoadWith<Order>(o => o.OrderDetails);  
```  
  
## <a name="errors-using-sql-compact-35"></a><span data-ttu-id="d3fc7-184">Chyby jazyka SQL Compact 3.5</span><span class="sxs-lookup"><span data-stu-id="d3fc7-184">Errors Using SQL Compact 3.5</span></span>  
 <span data-ttu-id="d3fc7-185">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-185">Q.</span></span> <span data-ttu-id="d3fc7-186">Dojde k chybě při přetahování z tabulky [!INCLUDE[ssEW](../../../../../../includes/ssew-md.md)] databáze.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-186">I get an error when I drag tables out of a [!INCLUDE[ssEW](../../../../../../includes/ssew-md.md)] database.</span></span>  
  
 <span data-ttu-id="d3fc7-187">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-187">A.</span></span> <span data-ttu-id="d3fc7-188">[!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] Nepodporuje [!INCLUDE[ssEW](../../../../../../includes/ssew-md.md)], i když [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] nemá modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-188">The [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] does not support [!INCLUDE[ssEW](../../../../../../includes/ssew-md.md)], although the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime does.</span></span> <span data-ttu-id="d3fc7-189">V takovém případě musíte vytvořit vlastní třídy entity a přidejte příslušné atributy.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-189">In this situation, you must create your own entity classes and add the appropriate attributes.</span></span>  
  
## <a name="errors-in-inheritance-relationships"></a><span data-ttu-id="d3fc7-190">Chyby v dědičnosti relací</span><span class="sxs-lookup"><span data-stu-id="d3fc7-190">Errors in Inheritance Relationships</span></span>  
 <span data-ttu-id="d3fc7-191">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-191">Q.</span></span> <span data-ttu-id="d3fc7-192">Použití tvaru dědičnosti sady nástrojů v [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] připojení dvě entity, ale I docházet k chybám.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-192">I used the toolbox inheritance shape in the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] to connect two entities, but I get errors.</span></span>  
  
 <span data-ttu-id="d3fc7-193">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-193">A.</span></span> <span data-ttu-id="d3fc7-194">Vytvoření relace není dost.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-194">Creating the relationship is not enough.</span></span> <span data-ttu-id="d3fc7-195">Je třeba zadat informace, jako je například sloupce diskriminátoru, hodnota diskriminátoru základní třídy a jsou odvozené třídy diskriminátoru hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-195">You must provide information such as the discriminator column, base class discriminator value, and derived class discriminator value.</span></span>  
  
## <a name="provider-model"></a><span data-ttu-id="d3fc7-196">Zprostředkovatel modelu</span><span class="sxs-lookup"><span data-stu-id="d3fc7-196">Provider Model</span></span>  
 <span data-ttu-id="d3fc7-197">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-197">Q.</span></span> <span data-ttu-id="d3fc7-198">Model veřejného poskytovatele je k dispozici?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-198">Is a public provider model available?</span></span>  
  
 <span data-ttu-id="d3fc7-199">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-199">A.</span></span> <span data-ttu-id="d3fc7-200">Bez veřejného poskytovatele modelu je k dispozici.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-200">No public provider model is available.</span></span> <span data-ttu-id="d3fc7-201">V tomto okamžiku [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] podporuje SQL Server a [!INCLUDE[ssEW](../../../../../../includes/ssew-md.md)] pouze.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-201">At this time, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] supports SQL Server and [!INCLUDE[ssEW](../../../../../../includes/ssew-md.md)] only.</span></span>  
  
## <a name="sql-injection-attacks"></a><span data-ttu-id="d3fc7-202">Útok prostřednictvím injektáže SQL</span><span class="sxs-lookup"><span data-stu-id="d3fc7-202">SQL-Injection Attacks</span></span>  
 <span data-ttu-id="d3fc7-203">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-203">Q.</span></span> <span data-ttu-id="d3fc7-204">Jak je [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] chránit před útoky Injektáž SQL?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-204">How is [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] protected from SQL-injection attacks?</span></span>  
  
 <span data-ttu-id="d3fc7-205">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-205">A.</span></span> <span data-ttu-id="d3fc7-206">Injektáž SQL byl významné riziko pro tradiční dotazy SQL tvořena zřetězením vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-206">SQL injection has been a significant risk for traditional SQL queries formed by concatenating user input.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d3fc7-207"> zabraňuje takové vkládání pomocí <xref:System.Data.SqlClient.SqlParameter> v dotazech.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-207"> avoids such injection by using <xref:System.Data.SqlClient.SqlParameter> in queries.</span></span> <span data-ttu-id="d3fc7-208">Uživatelský vstup bude převedena na hodnoty parametrů.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-208">User input is turned into parameter values.</span></span> <span data-ttu-id="d3fc7-209">Tento přístup škodlivý příkazy brání použití ze vstupu zákazníka.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-209">This approach prevents malicious commands from being used from customer input.</span></span>  
  
## <a name="changing-read-only-flag-in-dbml-files"></a><span data-ttu-id="d3fc7-210">Změna příznak jen pro čtení ve soubory DBML</span><span class="sxs-lookup"><span data-stu-id="d3fc7-210">Changing Read-only Flag in DBML Files</span></span>  
 <span data-ttu-id="d3fc7-211">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-211">Q.</span></span> <span data-ttu-id="d3fc7-212">Jak se po vytvoření model objektů ze souboru DBML eliminovat setter z některé vlastnosti?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-212">How do I eliminate setters from some properties when I create an object model from a DBML file?</span></span>  
  
 <span data-ttu-id="d3fc7-213">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-213">A.</span></span> <span data-ttu-id="d3fc7-214">Pomocí následujících kroků pro tento scénář rozšířené:</span><span class="sxs-lookup"><span data-stu-id="d3fc7-214">Take the following steps for this advanced scenario:</span></span>  
  
1.  <span data-ttu-id="d3fc7-215">V souboru DBML, upravte vlastnost změnou <xref:System.Data.Linq.ITable.IsReadOnly%2A> příznak, který `True`.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-215">In the .dbml file, modify the property by changing the <xref:System.Data.Linq.ITable.IsReadOnly%2A> flag to `True`.</span></span>  
  
2.  <span data-ttu-id="d3fc7-216">Přidejte konkrétní třídu.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-216">Add a partial class.</span></span> <span data-ttu-id="d3fc7-217">Vytvořte konstruktor s parametry pro členy jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-217">Create a constructor with parameters for the read-only members.</span></span>  
  
3.  <span data-ttu-id="d3fc7-218">Zkontrolujte výchozí <xref:System.Data.Linq.Mapping.UpdateCheck> hodnotu (<xref:System.Data.Linq.Mapping.UpdateCheck.Never>) k určení, zda se jedná o správnou hodnotu pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-218">Review the default <xref:System.Data.Linq.Mapping.UpdateCheck> value (<xref:System.Data.Linq.Mapping.UpdateCheck.Never>) to determine whether that is the correct value for your application.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="d3fc7-219">Pokud používáte [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] v sadě Visual Studio, může být přepsána změny.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-219">If you are using the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] in Visual Studio, your changes might be overwritten.</span></span>  
  
## <a name="aptca"></a><span data-ttu-id="d3fc7-220">APTCA</span><span class="sxs-lookup"><span data-stu-id="d3fc7-220">APTCA</span></span>  
 <span data-ttu-id="d3fc7-221">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-221">Q.</span></span> <span data-ttu-id="d3fc7-222">Je System.Data.Linq označen pro použití částečně důvěryhodným kódem?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-222">Is System.Data.Linq marked for use by partially trusted code?</span></span>  
  
 <span data-ttu-id="d3fc7-223">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-223">A.</span></span> <span data-ttu-id="d3fc7-224">Ano, je sestavení knihovně System.Data.Linq.dll z těch, které [!INCLUDE[dnprdnshort](../../../../../../includes/dnprdnshort-md.md)] sestavení označené jako <xref:System.Security.AllowPartiallyTrustedCallersAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-224">Yes, the System.Data.Linq.dll assembly is among those [!INCLUDE[dnprdnshort](../../../../../../includes/dnprdnshort-md.md)] assemblies marked with the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> attribute.</span></span> <span data-ttu-id="d3fc7-225">Bez této označení, sestavení v [!INCLUDE[dnprdnshort](../../../../../../includes/dnprdnshort-md.md)] jsou určeny k použití pouze ve plně důvěryhodný kód.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-225">Without this marking, assemblies in the [!INCLUDE[dnprdnshort](../../../../../../includes/dnprdnshort-md.md)] are intended for use only by fully trusted code.</span></span>  
  
 <span data-ttu-id="d3fc7-226">Hlavní scénáře v [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] pro povolení částečně důvěryhodné volající je umožnit [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] sestavení nelze přistupovat ze webových aplikací, kde *důvěryhodnosti* konfigurace je střední.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-226">The principal scenario in [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] for allowing partially trusted callers is to enable the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] assembly to be accessed from Web applications, where the *trust* configuration is Medium.</span></span>  
  
## <a name="mapping-data-from-multiple-tables"></a><span data-ttu-id="d3fc7-227">Mapování dat z více tabulek</span><span class="sxs-lookup"><span data-stu-id="d3fc7-227">Mapping Data from Multiple Tables</span></span>  
 <span data-ttu-id="d3fc7-228">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-228">Q.</span></span> <span data-ttu-id="d3fc7-229">Data v mé entity pocházejí z různých tabulek.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-229">The data in my entity comes from multiple tables.</span></span> <span data-ttu-id="d3fc7-230">Jak namapovat je?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-230">How do I map it?</span></span>  
  
 <span data-ttu-id="d3fc7-231">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-231">A.</span></span> <span data-ttu-id="d3fc7-232">Můžete vytvořit zobrazení v databázi a mapovat entitu na zobrazení.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-232">You can create a view in a database and map the entity to the view.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d3fc7-233"> generuje stejné SQL pro zobrazení jako v případě tabulek.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-233"> generates the same SQL for views as it does for tables.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3fc7-234">Použití zobrazení v tomto scénáři má určitá omezení.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-234">The use of views in this scenario has limitations.</span></span> <span data-ttu-id="d3fc7-235">Tento postup funguje nejvíce bezpečně provést, pokud operace na <xref:System.Data.Linq.Table%601> podporuje podkladového zobrazení.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-235">This approach works most safely when the operations performed on <xref:System.Data.Linq.Table%601> are supported by the underlying view.</span></span> <span data-ttu-id="d3fc7-236">Pouze víte operací, které jsou určené.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-236">Only you know which operations are intended.</span></span> <span data-ttu-id="d3fc7-237">Například většina aplikací jsou jen pro čtení, a provádět jiné výraznou číslo `Create` / `Update` / `Delete` operací pouze pomocí uložené procedury proti zobrazení.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-237">For example, most applications are read-only, and another sizeable number perform `Create`/`Update`/`Delete` operations only by using stored procedures against views.</span></span>  
  
## <a name="connection-pooling"></a><span data-ttu-id="d3fc7-238">Sdružování připojení</span><span class="sxs-lookup"><span data-stu-id="d3fc7-238">Connection Pooling</span></span>  
 <span data-ttu-id="d3fc7-239">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-239">Q.</span></span> <span data-ttu-id="d3fc7-240">Je k dispozici konstrukce, které vám pomohou při <xref:System.Data.Linq.DataContext> sdružování?</span><span class="sxs-lookup"><span data-stu-id="d3fc7-240">Is there a construct that can help with <xref:System.Data.Linq.DataContext> pooling?</span></span>  
  
 <span data-ttu-id="d3fc7-241">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-241">A.</span></span> <span data-ttu-id="d3fc7-242">Nepokoušejte se použít instancí <xref:System.Data.Linq.DataContext>.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-242">Do not try to reuse instances of <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="d3fc7-243">Každý <xref:System.Data.Linq.DataContext> Udržovat stav (včetně mezipaměti identity) pro jednu relaci konkrétní upravit nebo dotazu.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-243">Each <xref:System.Data.Linq.DataContext> maintains state (including an identity cache) for one particular edit/query session.</span></span> <span data-ttu-id="d3fc7-244">Chcete-li získat nové instance na základě aktuálního stavu databáze, použijte nové <xref:System.Data.Linq.DataContext>.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-244">To obtain new instances based on the current state of the database, use a new <xref:System.Data.Linq.DataContext>.</span></span>  
  
 <span data-ttu-id="d3fc7-245">Můžete dál používat základní [!INCLUDE[vstecado](../../../../../../includes/vstecado-md.md)] sdružování připojení.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-245">You can still use underlying [!INCLUDE[vstecado](../../../../../../includes/vstecado-md.md)] connection pooling.</span></span> <span data-ttu-id="d3fc7-246">Další informace najdete v tématu [SQL sdružování připojení serveru (ADO.NET)](../../../../../../docs/framework/data/adonet/sql-server-connection-pooling.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-246">For more information, see [SQL Server Connection Pooling (ADO.NET)](../../../../../../docs/framework/data/adonet/sql-server-connection-pooling.md).</span></span>  
  
## <a name="second-datacontext-is-not-updated"></a><span data-ttu-id="d3fc7-247">Druhý DataContext se neaktualizuje</span><span class="sxs-lookup"><span data-stu-id="d3fc7-247">Second DataContext Is Not Updated</span></span>  
 <span data-ttu-id="d3fc7-248">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-248">Q.</span></span> <span data-ttu-id="d3fc7-249">Mohu použít jednu instanci <xref:System.Data.Linq.DataContext> pro uložení hodnot v databázi.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-249">I used one instance of <xref:System.Data.Linq.DataContext> to store values in the database.</span></span> <span data-ttu-id="d3fc7-250">Ale druhý <xref:System.Data.Linq.DataContext> na stejnou databázi nezohledňuje aktualizovanými hodnotami.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-250">However, a second <xref:System.Data.Linq.DataContext> on the same database does not reflect the updated values.</span></span> <span data-ttu-id="d3fc7-251">Druhý <xref:System.Data.Linq.DataContext> instance zdá se, že k návratu hodnot v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-251">The second <xref:System.Data.Linq.DataContext> instance seems to return cached values.</span></span>  
  
 <span data-ttu-id="d3fc7-252">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-252">A.</span></span> <span data-ttu-id="d3fc7-253">Toto chování je záměrné.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-253">This behavior is by design.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d3fc7-254"> nadále vrátí stejné instance nebo hodnoty, které jste viděli v první instance.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-254"> continues to return the same instances/values that you saw in the first instance.</span></span> <span data-ttu-id="d3fc7-255">Pokud provedete aktualizace, je použít optimistickou metodu souběžného.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-255">When you make updates, you use optimistic concurrency.</span></span> <span data-ttu-id="d3fc7-256">Původní data se používá ke kontrole proti aktuální stav databáze k vyhodnocení, zda je ve skutečnosti stále beze změny.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-256">The original data is used to check against the current database state to assert that it is in fact still unchanged.</span></span> <span data-ttu-id="d3fc7-257">Pokud se změnila, dojde ke konfliktu a aplikace ho musí vyřešit.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-257">If it has changed, a conflict occurs and your application must resolve it.</span></span> <span data-ttu-id="d3fc7-258">Jednou z možností aplikace je potřeba obnovit původní stav aktuální stav databáze a opakujte aktualizaci.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-258">One option of your application is to reset the original state to the current database state and to try the update again.</span></span> <span data-ttu-id="d3fc7-259">Další informace najdete v tématu [postupy: Správa konfliktů změnu](../../../../../../docs/framework/data/adonet/sql/linq/how-to-manage-change-conflicts.md).</span><span class="sxs-lookup"><span data-stu-id="d3fc7-259">For more information, see [How to: Manage Change Conflicts](../../../../../../docs/framework/data/adonet/sql/linq/how-to-manage-change-conflicts.md).</span></span>  
  
 <span data-ttu-id="d3fc7-260">Můžete také nastavit <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> na hodnotu false, které oplátku vypnout ukládání do mezipaměti a sledování změn.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-260">You can also set <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> to false, which turns off caching and change tracking.</span></span> <span data-ttu-id="d3fc7-261">Poté můžete získat nejnovější hodnoty pokaždé, když dotazujete.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-261">You can then retrieve the latest values every time that you query.</span></span>  
  
## <a name="cannot-call-submitchanges-in-read-only-mode"></a><span data-ttu-id="d3fc7-262">Nelze volat SubmitChanges v režimu jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="d3fc7-262">Cannot Call SubmitChanges in Read-only Mode</span></span>  
 <span data-ttu-id="d3fc7-263">OTÁZKY.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-263">Q.</span></span> <span data-ttu-id="d3fc7-264">Při volání <xref:System.Data.Linq.DataContext.SubmitChanges%2A> v režimu jen pro čtení, zobrazí chybová zpráva.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-264">When I try to call <xref:System.Data.Linq.DataContext.SubmitChanges%2A> in read-only mode, I get an error.</span></span>  
  
 <span data-ttu-id="d3fc7-265">A.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-265">A.</span></span> <span data-ttu-id="d3fc7-266">Jen pro čtení režimu vypne schopnost kontext sledování změn.</span><span class="sxs-lookup"><span data-stu-id="d3fc7-266">Read-only mode turns off the ability of the context to track changes.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d3fc7-267">Viz také</span><span class="sxs-lookup"><span data-stu-id="d3fc7-267">See Also</span></span>  
 [<span data-ttu-id="d3fc7-268">Referenční informace</span><span class="sxs-lookup"><span data-stu-id="d3fc7-268">Reference</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/reference.md)  
 [<span data-ttu-id="d3fc7-269">Odstraňování potíží</span><span class="sxs-lookup"><span data-stu-id="d3fc7-269">Troubleshooting</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md)  
 [<span data-ttu-id="d3fc7-270">Zabezpečení v LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="d3fc7-270">Security in LINQ to SQL</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/security-in-linq-to-sql.md)
