---
title: Definování vlastních typů pro práci s technologií .NET Framework XAML Services
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 9edc7baa1a540a71997cf5b1ed010ad5c7960d17
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566493"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="abc05-102">Definování vlastních typů pro práci s technologií .NET Framework XAML Services</span><span class="sxs-lookup"><span data-stu-id="abc05-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="abc05-103">Při definování vlastních typů, které jsou objekty firmy nebo jsou typy, které nemají závislost na konkrétní architektury, existují některé osvědčené postupy pro jazyk XAML můžete provést.</span><span class="sxs-lookup"><span data-stu-id="abc05-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="abc05-104">Pokud budete postupovat podle těchto postupech, můžete zjistit charakteristiky XAML vašeho typu a dejte mu odpovídající reprezentace v datový proud uzlu XAML pomocí systému XAML typ rozhraní .NET Framework XAML Services a jeho XAML čtení a zápis XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="abc05-105">Toto téma popisuje osvědčené postupy pro definice typů, člen definice a CLR zapisujících typů nebo členy.</span><span class="sxs-lookup"><span data-stu-id="abc05-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="abc05-106">Konstruktor vzory a definic typů pro jazyk XAML</span><span class="sxs-lookup"><span data-stu-id="abc05-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="abc05-107">Chcete-li být vytvořena instance jako element objektu v jazyce XAML, vlastní třídu musí splňovat následující požadavky:</span><span class="sxs-lookup"><span data-stu-id="abc05-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="abc05-108">Vlastní třída musí být veřejná a musí vystavit výchozí veřejný konstruktor (bez parametrů).</span><span class="sxs-lookup"><span data-stu-id="abc05-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="abc05-109">(Viz následující části poznámky týkající se struktury).</span><span class="sxs-lookup"><span data-stu-id="abc05-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="abc05-110">Vlastní třída nesmí být vnořená třída.</span><span class="sxs-lookup"><span data-stu-id="abc05-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="abc05-111">Navíc "bod" v cestě název úplné vytvoří obor názvů třídy dělení nejednoznačný a naruší to jinými XAML funkcemi, jako je přidružené vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="abc05-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="abc05-112">Pokud objekt se dá vytvořit instance jako element objektu, vytvořený objekt vyplnit formu všechny vlastnosti, které trvat objekt jako svoje základní typ pro element vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="abc05-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="abc05-113">Pokud povolíte převaděč hodnoty, můžete zadejte stále objekt hodnoty pro typy, které tato kritéria nesplňují.</span><span class="sxs-lookup"><span data-stu-id="abc05-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="abc05-114">Další informace najdete v tématu [převaděče typů a rozšíření značek pro jazyk XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="abc05-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="abc05-115">Struktury</span><span class="sxs-lookup"><span data-stu-id="abc05-115">Structures</span></span>  
 <span data-ttu-id="abc05-116">Struktury dokážou vždy v jazyce XAML, zkonstruovat podle definice CLR.</span><span class="sxs-lookup"><span data-stu-id="abc05-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="abc05-117">To je proto CLR kompilátoru implicitně vytvoří výchozí konstruktor pro strukturu.</span><span class="sxs-lookup"><span data-stu-id="abc05-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="abc05-118">Tento konstruktor inicializuje všechny hodnoty vlastností pro jejich výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="abc05-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="abc05-119">V některých případech není výchozí chování konstrukce pro strukturu žádoucí.</span><span class="sxs-lookup"><span data-stu-id="abc05-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="abc05-120">Může to být proto strukturu slouží k vyplnění hodnoty a funkce koncepčně jako spojení.</span><span class="sxs-lookup"><span data-stu-id="abc05-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="abc05-121">Jako union obsahují hodnoty může mít vzájemně se vylučuje interpretace, a proto nejsou žádná z jeho vlastnosti nastavit.</span><span class="sxs-lookup"><span data-stu-id="abc05-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="abc05-122">Příklad struktury ve slovníku WPF je <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="abc05-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="abc05-123">Tyto struktury by měla implementovat převaděče typů tak, aby hodnoty mohou být vyjádřeny v atributu formuláře pomocí názvů řetězec vytvořit různé interpretace nebo režimy hodnoty strukturu.</span><span class="sxs-lookup"><span data-stu-id="abc05-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="abc05-124">Struktura by měl vystavit také podobné chování pro vytváření kódu prostřednictvím jiné než výchozí konstruktor.</span><span class="sxs-lookup"><span data-stu-id="abc05-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="abc05-125">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="abc05-125">Interfaces</span></span>  
 <span data-ttu-id="abc05-126">Rozhraní slouží jako základní typy členů.</span><span class="sxs-lookup"><span data-stu-id="abc05-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="abc05-127">Systém typů XAML zkontroluje seznamu přiřadit a očekává, že objekt, který je zadaný jako hodnota může být přiřazen rozhraní.</span><span class="sxs-lookup"><span data-stu-id="abc05-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="abc05-128">Neexistuje žádná koncepce jak musí být rozhraní zobrazovat jako typ jazyka XAML typu relevantní Přiřaditelné podporuje požadavky na vytváření XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="abc05-129">Metody vytváření</span><span class="sxs-lookup"><span data-stu-id="abc05-129">Factory Methods</span></span>  
 <span data-ttu-id="abc05-130">Metody vytváření jsou funkce jazyka XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="abc05-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="abc05-131">Jejich upravit Princip XAML, objekty musí mít výchozí konstruktory.</span><span class="sxs-lookup"><span data-stu-id="abc05-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="abc05-132">Metody vytváření nejsou popsané v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="abc05-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="abc05-133">V tématu [x: factorymethod – direktiva](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="abc05-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="abc05-134">Výčty</span><span class="sxs-lookup"><span data-stu-id="abc05-134">Enumerations</span></span>  
 <span data-ttu-id="abc05-135">Výčty chovají XAML nativní typ převodu.</span><span class="sxs-lookup"><span data-stu-id="abc05-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="abc05-136">Výčet konstantní názvy zadané v jazyce XAML se přeloží proti základní typ výčtu a obnoví hodnota výčtu zapisovač objekt XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="abc05-137">XAML podporuje použití příznaky stylu pro výčty s <xref:System.FlagsAttribute> použít.</span><span class="sxs-lookup"><span data-stu-id="abc05-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="abc05-138">Další informace najdete v tématu [XAML syntaxe v podrobností](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="abc05-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="abc05-139">([XAML syntaxe v podrobností](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) je napsán pro cílovou skupinu WPF, ale většina informací v tomto tématu je relevantní pro jazyk XAML, které nejsou specifické pro konkrétní rozhraní implementuje.)</span><span class="sxs-lookup"><span data-stu-id="abc05-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="abc05-140">Definice člena</span><span class="sxs-lookup"><span data-stu-id="abc05-140">Member Definitions</span></span>  
 <span data-ttu-id="abc05-141">Typy můžete definovat členy pro použití XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="abc05-142">Je možné pro typy, které definují členů, které jsou použitelné XAML, i když tento konkrétní typ není použitelné XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="abc05-143">To je možné z důvodu dědičnosti CLR.</span><span class="sxs-lookup"><span data-stu-id="abc05-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="abc05-144">Tak dlouho, dokud nějaký typ, který dědí člen podporuje použití XAML jako typ a člen podporuje použití XAML pro jeho zdrojovým typem nebo má k dispozici nativní XAML syntaxi, je daný člen XAML použitelné.</span><span class="sxs-lookup"><span data-stu-id="abc05-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="abc05-145">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="abc05-145">Properties</span></span>  
 <span data-ttu-id="abc05-146">Pokud definujete vlastnosti jako veřejné vlastnosti CLR pomocí typické CLR `get` a `set` přistupujícího objektu vzory a používání jazyka vhodné, můžete sestavu systém typů XAML vlastnost jako člena s příslušné informace k dispozici pro <xref:System.Xaml.XamlMember> vlastnosti, jako například <xref:System.Xaml.XamlMember.IsReadPublic%2A> a <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="abc05-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="abc05-147">Specifické vlastnosti můžete povolit syntaxe textu s použitím <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="abc05-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="abc05-148">Další informace najdete v tématu [převaděče typů a rozšíření značek pro jazyk XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="abc05-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="abc05-149">Chybí textových syntaxi nebo nativní převod XAML a bez další dereference, jako je například rozšíření použití značek, typ vlastnosti (<xref:System.Xaml.XamlMember.TargetType%2A> v XAML systém typů) musí být schopen vrátit instanci objektu zapisovač XAML podle práce t Typ arget jako typ CLR.</span><span class="sxs-lookup"><span data-stu-id="abc05-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="abc05-150">Pokud používáte XAML 2009 [x: Reference – rozšíření značek](../../../docs/framework/xaml-services/x-reference-markup-extension.md) slouží k zadání hodnot, pokud nejsou splněné předchozí aspekty; je však informace o využití problém než problémem definice typu.</span><span class="sxs-lookup"><span data-stu-id="abc05-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="abc05-151">Události</span><span class="sxs-lookup"><span data-stu-id="abc05-151">Events</span></span>  
 <span data-ttu-id="abc05-152">Pokud definujete události jako veřejná událost CLR, systém typů XAML ohlásit událost jako člena s <xref:System.Xaml.XamlMember.IsEvent%2A> jako `true`.</span><span class="sxs-lookup"><span data-stu-id="abc05-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="abc05-153">Vzájemné propojení obslužné rutiny událostí není v rámci oboru funkce rozhraní .NET Framework XAML Services; je to zleva implementace a konkrétní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="abc05-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="abc05-154">Metody</span><span class="sxs-lookup"><span data-stu-id="abc05-154">Methods</span></span>  
 <span data-ttu-id="abc05-155">Vložený kód pro metody není výchozí XAML možnost.</span><span class="sxs-lookup"><span data-stu-id="abc05-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="abc05-156">Ve většině případů je přímo neodkazujte metoda členy z XAML a roli metody v jazyce XAML je pouze k zajištění podpory pro určité vzory XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="abc05-157">[x: factorymethod – direktiva](../../../docs/framework/xaml-services/x-factorymethod-directive.md) je výjimku.</span><span class="sxs-lookup"><span data-stu-id="abc05-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="abc05-158">Pole</span><span class="sxs-lookup"><span data-stu-id="abc05-158">Fields</span></span>  
 <span data-ttu-id="abc05-159">Pokyny pro návrh CLR bránit nestatické pole.</span><span class="sxs-lookup"><span data-stu-id="abc05-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="abc05-160">Statická pole, dostanete statické pole hodnot pouze prostřednictvím [x: Static – rozšíření značek](../../../docs/framework/xaml-services/x-static-markup-extension.md); v takovém případě nejsou žádné zvláštní v definici CLR vystavit pole pro provádění [x: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) použití.</span><span class="sxs-lookup"><span data-stu-id="abc05-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="abc05-161">Připojitelné členy</span><span class="sxs-lookup"><span data-stu-id="abc05-161">Attachable Members</span></span>  
 <span data-ttu-id="abc05-162">Připojitelné členové jsou vystaveny XAML prostřednictvím vzor metoda přistupující objekt definující typu.</span><span class="sxs-lookup"><span data-stu-id="abc05-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="abc05-163">Definující vlastní typ nemusí být XAML použitelné jako objekt.</span><span class="sxs-lookup"><span data-stu-id="abc05-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="abc05-164">Ve skutečnosti je běžný vzor deklarovat třídu služby, který má roli vlastní připojitelné člen a implementovat související chování, ale poskytovat další funkce, jako je například znázornění uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="abc05-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="abc05-165">Na následující oddíly zástupného textu *PropertyName* představuje název vaší připojitelné člena.</span><span class="sxs-lookup"><span data-stu-id="abc05-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="abc05-166">Tento název musí být platný v [XamlName – gramatika](../../../docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="abc05-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="abc05-167">Věnujte pozornost kolize názvů mezi tyto vzory a jiné metody typu.</span><span class="sxs-lookup"><span data-stu-id="abc05-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="abc05-168">Pokud člena existuje odpovídající jednomu z vzory, ho můžete interpretovat jako cestu připojitelné člen využití procesoru XAML i v případě, která nebyla svůj záměr.</span><span class="sxs-lookup"><span data-stu-id="abc05-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="abc05-169">GetPropertyName přístupového objektu</span><span class="sxs-lookup"><span data-stu-id="abc05-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="abc05-170">Podpis pro `Get` *PropertyName* přistupujícího objektu musí být:</span><span class="sxs-lookup"><span data-stu-id="abc05-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="abc05-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="abc05-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="abc05-172">`target` Objekt lze zadat jako typu konkrétnější v implementaci.</span><span class="sxs-lookup"><span data-stu-id="abc05-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="abc05-173">Můžete použít k určení rozsahu využití vaší připojitelné člena; použití mimo zamýšlený rozsah vyvolá výjimku neplatné obsazení výjimky, které jsou pak prezentované podle chybu analýzy XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="abc05-174">Název parametru `target` není povinné, ale je s názvem `target` podle konvence většina implementací.</span><span class="sxs-lookup"><span data-stu-id="abc05-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="abc05-175">Návratovou hodnotu lze zadat jako typu konkrétnější v implementaci.</span><span class="sxs-lookup"><span data-stu-id="abc05-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="abc05-176">Pro podporu <xref:System.ComponentModel.TypeConverter> povoleno text syntaxe pro použití atributu připojitelné člena použít <xref:System.ComponentModel.TypeConverterAttribute> k `Get` *PropertyName* přistupujícího objektu.</span><span class="sxs-lookup"><span data-stu-id="abc05-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="abc05-177">Použití `get` místo `set` se může zdát nonintuitive; touto konvencí však může podporovat koncept jen pro čtení připojitelné členy, kteří jsou serializable, který je užitečný ve scénářích, návrháře.</span><span class="sxs-lookup"><span data-stu-id="abc05-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="abc05-178">SetPropertyName přístupového objektu</span><span class="sxs-lookup"><span data-stu-id="abc05-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="abc05-179">Podpis pro sadu*PropertyName* přistupujícího objektu musí být:</span><span class="sxs-lookup"><span data-stu-id="abc05-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="abc05-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="abc05-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="abc05-181">`target` Objekt lze zadat jako typu konkrétnější v implementaci pomocí stejné logiky a důsledky, jak je popsáno v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="abc05-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="abc05-182">`value` Objekt lze zadat jako typu konkrétnější v implementaci.</span><span class="sxs-lookup"><span data-stu-id="abc05-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="abc05-183">Mějte na paměti, že hodnota pro tuto metodu je vstupní pocházejících z použití XAML, obvykle v podobě atributu.</span><span class="sxs-lookup"><span data-stu-id="abc05-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="abc05-184">Z formuláře atributu musí být hodnota převaděč podpora textových syntaxi a atributu u `Get` *PropertyName* přistupujícího objektu.</span><span class="sxs-lookup"><span data-stu-id="abc05-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="abc05-185">Připojitelné člen úložiště</span><span class="sxs-lookup"><span data-stu-id="abc05-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="abc05-186">Metody přístupových objektů nejsou obvykle dostatek prostředků k umístěte hodnoty připojitelné členů do grafu objektu, nebo k načtení hodnoty z grafu objektů a je správně serializovat.</span><span class="sxs-lookup"><span data-stu-id="abc05-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="abc05-187">Tato funkce `target` objekty v předchozí signatury přistupujícího objektu musí být schopný ukládání hodnot.</span><span class="sxs-lookup"><span data-stu-id="abc05-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="abc05-188">Mechanismus úložiště musí být v souladu se zásadou připojitelné člen, který je člen připojitelné k cílům, kde připojitelné člen není v seznamu členů.</span><span class="sxs-lookup"><span data-stu-id="abc05-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="abc05-189">Rozhraní .NET framework XAML Services poskytuje implementaci technika pro připojitelné člen ukládá prostřednictvím rozhraní API <xref:System.Xaml.IAttachedPropertyStore> a <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="abc05-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="abc05-190"><xref:System.Xaml.IAttachedPropertyStore> XAML zapisovače používané ke zjišťování implementace úložiště a by měla být implementována na typ, který je `target` přistupujících objektů.</span><span class="sxs-lookup"><span data-stu-id="abc05-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="abc05-191">Statické <xref:System.Xaml.AttachablePropertyServices> rozhraní API se používají v textu přístupové objekty a připojitelné odkazujte podle jeho <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="abc05-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="abc05-192">Atributy CLR související s XAML</span><span class="sxs-lookup"><span data-stu-id="abc05-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="abc05-193">Správně zapisujících vaší typy, členů a sestavení je důležité, aby sestavy informace systému typ jazyka XAML pro rozhraní .NET Framework XAML Services.</span><span class="sxs-lookup"><span data-stu-id="abc05-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="abc05-194">To je důležité, pokud máte v úmyslu vaší typy pro použití s XAML systémy, které jsou přímo založené na rozhraní .NET Framework XAML Services XAML čtení a zápis XAML, nebo pokud můžete definovat, nebo pomocí rozhraní využívá XAML, které je založena na těchto XAML čtení a zápis XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="abc05-195">Seznam každý atribut související s jazykem XAML, které jsou důležité pro XAML podporuje vlastní typy najdete v tématu [XAML-Related CLR atributy pro vlastní typy a knihovny](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="abc05-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="abc05-196">Použití</span><span class="sxs-lookup"><span data-stu-id="abc05-196">Usage</span></span>  
 <span data-ttu-id="abc05-197">Použití vlastní typy vyžaduje, aby autor značek musí být mapována předponu pro sestavení a obor názvů CLR, které obsahují vlastní typ.</span><span class="sxs-lookup"><span data-stu-id="abc05-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="abc05-198">Tento postup není dokumentováno v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="abc05-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="abc05-199">Úroveň přístupu</span><span class="sxs-lookup"><span data-stu-id="abc05-199">Access Level</span></span>  
 <span data-ttu-id="abc05-200">XAML poskytuje prostředky ke spouštění a vytvoření instancí typy, které mají `internal` úroveň přístupu.</span><span class="sxs-lookup"><span data-stu-id="abc05-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="abc05-201">Tato funkce je k dispozici, aby uživatelský kód můžete definovat vlastní typy a potom vytvořte instanci tyto třídy z kód, který je také součástí oboru stejný kód uživatele.</span><span class="sxs-lookup"><span data-stu-id="abc05-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="abc05-202">Příklad z grafického subsystému WPF je vždy, když uživatel kód definuje <xref:System.Windows.Controls.UserControl> určený jako způsob, jak Refaktorovat chování uživatelského rozhraní, ale nikoli jako součást všechny možné rozšíření mechanismus, který může být implicitní deklarováním třídy podpůrné s `public` úroveň přístupu.</span><span class="sxs-lookup"><span data-stu-id="abc05-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="abc05-203">Takové <xref:System.Windows.Controls.UserControl> lze deklarovat s `internal` přístup, pokud je kód základní zkompilovat do stejného sestavení, ze které se odkazuje jako typ jazyka XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="abc05-204">Pro aplikaci, která načte XAML pod úplným vztahem důvěryhodnosti a používá <xref:System.Xaml.XamlObjectWriter>, načítání tříd pomocí `internal` úroveň přístupu je vždy povolena.</span><span class="sxs-lookup"><span data-stu-id="abc05-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="abc05-205">Pro aplikaci, která načte XAML v částečné důvěryhodnosti, můžete řídit charakteristiky úrovně přístupu pomocí <xref:System.Xaml.Permissions.XamlAccessLevel> rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="abc05-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="abc05-206">Navíc musí být schopen rozšířit žádné úrovně oprávnění k přístupu a zachování jejich pro hodnocení případné běhu; mechanismy odložení (například systém šablony WPF) To se interně zpracovává předáním <xref:System.Xaml.Permissions.XamlAccessLevel> informace.</span><span class="sxs-lookup"><span data-stu-id="abc05-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="abc05-207">Implementace WPF</span><span class="sxs-lookup"><span data-stu-id="abc05-207">WPF Implementation</span></span>  
 <span data-ttu-id="abc05-208">WPF XAML používá model částečným vztahem důvěryhodnosti přístupu, kde Pokud BAML je zavedený v částečné důvěryhodnosti, přístup je omezen na <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> pro sestavení, který je zdrojem BAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="abc05-209">Pro odložení, používá WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> jako mechanismus pro předávání informací úrovně přístupu.</span><span class="sxs-lookup"><span data-stu-id="abc05-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="abc05-210">V terminologii WPF XAML *interní typ* je typ, který je definován pomocí stejného sestavení, která zahrnuje i odkazující XAML.</span><span class="sxs-lookup"><span data-stu-id="abc05-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="abc05-211">Takové typ se dá namapovat prostřednictvím oboru názvů jazyka XAML, který úmyslně vynechá sestavení = část mapování, například `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="abc05-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="abc05-212">Pokud BAML odkazuje na interní typ a že má typ `internal` přístup úrovni, tím se vygeneruje `GeneratedInternalTypeHelper` třídu pro sestavení.</span><span class="sxs-lookup"><span data-stu-id="abc05-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="abc05-213">Pokud chcete, aby se zabránilo `GeneratedInternalTypeHelper`, buď musíte použít `public` přístup úroveň, nebo musí zohlednit příslušné třídě do samostatné sestavení a ujistěte se, že sestavení závislé.</span><span class="sxs-lookup"><span data-stu-id="abc05-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="abc05-214">Viz také</span><span class="sxs-lookup"><span data-stu-id="abc05-214">See Also</span></span>  
 [<span data-ttu-id="abc05-215">Atributy CLR související s jazykem XAML pro vlastní typy a knihovny</span><span class="sxs-lookup"><span data-stu-id="abc05-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="abc05-216">XAML Services</span><span class="sxs-lookup"><span data-stu-id="abc05-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)
