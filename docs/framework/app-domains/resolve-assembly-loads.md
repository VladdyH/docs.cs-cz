---
title: "Řešení načítání sestavení"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-bcl
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- assemblies [.NET Framework], resolving loads
- application domains, loading assemblies
- resolving assembly loads
- assemblies [.NET Framework], loading
- application domains, resolving assembly loads
ms.assetid: 5099e549-f4fd-49fb-a290-549edd456c6a
caps.latest.revision: "10"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 3eb975b7ee8fdbba8435937fcb6f976d464db932
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/22/2017
---
# <a name="resolving-assembly-loads"></a><span data-ttu-id="0cc64-102">Řešení načítání sestavení</span><span class="sxs-lookup"><span data-stu-id="0cc64-102">Resolving Assembly Loads</span></span>
<span data-ttu-id="0cc64-103">Poskytuje rozhraní .NET Framework <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> událost pro aplikace, které vyžadují větší kontrolu nad načítání sestavení.</span><span class="sxs-lookup"><span data-stu-id="0cc64-103">The .NET Framework provides the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event for applications that require greater control over assembly loading.</span></span> <span data-ttu-id="0cc64-104">Při zpracování této událost, můžete aplikaci načtení sestavení do zatížení kontextu z mimo normální testování cesty vyberte který několik verzí sestavení načíst, Emitování dynamických sestavení a obnoví v něm a tak dále.</span><span class="sxs-lookup"><span data-stu-id="0cc64-104">By handling this event, your application can load an assembly into the load context from outside the normal probing paths, select which of several assembly versions to load, emit a dynamic assembly and return it, and so on.</span></span> <span data-ttu-id="0cc64-105">Toto téma obsahuje pokyny pro zpracování <xref:System.AppDomain.AssemblyResolve> událostí.</span><span class="sxs-lookup"><span data-stu-id="0cc64-105">This topic provides guidance for handling the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0cc64-106">Řešení načítání sestavení v kontextu pouze pro reflexi, použijte <xref:System.AppDomain.ReflectionOnlyAssemblyResolve?displayProperty=nameWithType> událostí místo.</span><span class="sxs-lookup"><span data-stu-id="0cc64-106">For resolving assembly loads in the reflection-only context, use the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve?displayProperty=nameWithType> event instead.</span></span>  
  
## <a name="how-the-assemblyresolve-event-works"></a><span data-ttu-id="0cc64-107">Jak funguje AssemblyResolve události</span><span class="sxs-lookup"><span data-stu-id="0cc64-107">How the AssemblyResolve Event Works</span></span>  
 <span data-ttu-id="0cc64-108">Když se zaregistrujete obslužnou rutinu pro <xref:System.AppDomain.AssemblyResolve> událostí, obslužná rutina je volána vždy, když modul runtime nepodaří vytvořit vazbu k sestavení podle názvu.</span><span class="sxs-lookup"><span data-stu-id="0cc64-108">When you register a handler for the <xref:System.AppDomain.AssemblyResolve> event, the handler is invoked whenever the runtime fails to bind to an assembly by name.</span></span> <span data-ttu-id="0cc64-109">Například může způsobit následující metody volání z uživatelského kódu <xref:System.AppDomain.AssemblyResolve> událost, která má být vyvolána:</span><span class="sxs-lookup"><span data-stu-id="0cc64-109">For example, calling the following methods from user code can cause the <xref:System.AppDomain.AssemblyResolve> event to be raised:</span></span>  
  
-   <span data-ttu-id="0cc64-110"><xref:System.AppDomain.Load%2A?displayProperty=nameWithType> Přetížení metody nebo <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> přetížení metody, jejichž první argument je řetězec, který představuje zobrazovaný název sestavení načíst (tedy řetězec vrácený <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> vlastnost).</span><span class="sxs-lookup"><span data-stu-id="0cc64-110">An <xref:System.AppDomain.Load%2A?displayProperty=nameWithType> method overload or <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method overload whose first argument is a string that represents the display name of the assembly to load (that is, the string returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span>  
  
-   <span data-ttu-id="0cc64-111"><xref:System.AppDomain.Load%2A?displayProperty=nameWithType> Přetížení metody nebo <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> přetížení metody, jejichž první argument je <xref:System.Reflection.AssemblyName> objekt, který identifikuje sestavení načíst.</span><span class="sxs-lookup"><span data-stu-id="0cc64-111">An <xref:System.AppDomain.Load%2A?displayProperty=nameWithType> method overload or <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method overload whose first argument is an <xref:System.Reflection.AssemblyName> object that identifies the assembly to load.</span></span>  
  
-   <span data-ttu-id="0cc64-112"><xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> Přetížení metody.</span><span class="sxs-lookup"><span data-stu-id="0cc64-112">An <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method overload.</span></span>  
  
-   <span data-ttu-id="0cc64-113"><xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> Nebo <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> přetížení metody, která vytvoří instanci objektu v jiné doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="0cc64-113">An <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> or <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> method overload that instantiates an object in another application domain.</span></span>  
  
### <a name="what-the-event-handler-does"></a><span data-ttu-id="0cc64-114">Jaké jsou obslužné rutiny události</span><span class="sxs-lookup"><span data-stu-id="0cc64-114">What the Event Handler Does</span></span>  
 <span data-ttu-id="0cc64-115">Obslužná rutina pro <xref:System.AppDomain.AssemblyResolve> událostí obdrží zobrazovaný název sestavení, které má být načteno do <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="0cc64-115">The handler for the <xref:System.AppDomain.AssemblyResolve> event receives the display name of the assembly to be loaded, in the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0cc64-116">Pokud obslužná rutina nemůže rozpoznat název sestavení, vrátí hodnotu null (`Nothing` v jazyce Visual Basic `nullptr` v jazyce Visual C++).</span><span class="sxs-lookup"><span data-stu-id="0cc64-116">If the handler does not recognize the assembly name, it returns null (`Nothing` in Visual Basic, `nullptr` in Visual C++).</span></span>  
  
 <span data-ttu-id="0cc64-117">Pokud obslužná rutina rozpozná název sestavení, může zatížení a vrátí sestavení, které splňuje požadavek.</span><span class="sxs-lookup"><span data-stu-id="0cc64-117">If the handler recognizes the assembly name, it can load and return an assembly that satisfies the request.</span></span> <span data-ttu-id="0cc64-118">Následující seznam popisuje několik ukázkových scénářů.</span><span class="sxs-lookup"><span data-stu-id="0cc64-118">The following list describes some sample scenarios.</span></span>  
  
-   <span data-ttu-id="0cc64-119">Pokud obslužná rutina nezná umístění verze sestavení, můžete načíst sestavení pomocí <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> nebo <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metody a může vrátit načíst sestavení, pokud bylo úspěšné.</span><span class="sxs-lookup"><span data-stu-id="0cc64-119">If the handler knows the location of a version of the assembly, it can load the assembly by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method, and can return the loaded assembly if successful.</span></span>  
  
-   <span data-ttu-id="0cc64-120">Pokud obslužná rutina má přístup k databázi sestavení uložené jako bajtové pole, je možné načíst pole bajtů pomocí jedné z <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> přetížení metody, které provést bajtové pole.</span><span class="sxs-lookup"><span data-stu-id="0cc64-120">If the handler has access to a database of assemblies stored as byte arrays, it can load a byte array by using one of the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method overloads that take a byte array.</span></span>  
  
-   <span data-ttu-id="0cc64-121">Obslužná rutina může generovat dynamické sestavení a obnoví v něm.</span><span class="sxs-lookup"><span data-stu-id="0cc64-121">The handler can generate a dynamic assembly and return it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0cc64-122">Obslužná rutina musí načíst sestavení do načtení z kontextu, do kontextu zatížení nebo bez kontextu. Pokud obslužná rutina načte sestavení do kontextu pouze pro reflexi pomocí <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> nebo <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> pokus zatížení metody, která vyvolala <xref:System.AppDomain.AssemblyResolve> události nezdaří.</span><span class="sxs-lookup"><span data-stu-id="0cc64-122">The handler must load the assembly into the load-from context, into the load context, or without context.If the handler loads the assembly into the reflection-only context by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> or the <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> method, the load attempt that raised the <xref:System.AppDomain.AssemblyResolve> event fails.</span></span>  
  
 <span data-ttu-id="0cc64-123">Je zodpovědností obslužné rutiny události vrátit vhodný sestavení.</span><span class="sxs-lookup"><span data-stu-id="0cc64-123">It is the responsibility of the event handler to return a suitable assembly.</span></span> <span data-ttu-id="0cc64-124">Obslužná rutina může analyzovat zobrazovaný název požadované sestavení předáním <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> hodnotu vlastnosti <xref:System.Reflection.AssemblyName.%23ctor%28System.String%29> konstruktor.</span><span class="sxs-lookup"><span data-stu-id="0cc64-124">The handler can parse the display name of the requested assembly by passing the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property value to the <xref:System.Reflection.AssemblyName.%23ctor%28System.String%29> constructor.</span></span> <span data-ttu-id="0cc64-125">Počínaje [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], můžete použít obslužná rutina <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> vlastnosti k určení, zda je aktuální požadavek závislost sestavení.</span><span class="sxs-lookup"><span data-stu-id="0cc64-125">Beginning with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], the handler can use the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property to determine whether the current request is a dependency of another assembly.</span></span> <span data-ttu-id="0cc64-126">Tyto informace můžou pomoct identifikovat sestavení, které budou splňovat závislost.</span><span class="sxs-lookup"><span data-stu-id="0cc64-126">This information can help identify an assembly that will satisfy the dependency.</span></span>  
  
 <span data-ttu-id="0cc64-127">Obslužné rutiny události může vrátit jinou verzi než verze, který byl vyžádán sestavení.</span><span class="sxs-lookup"><span data-stu-id="0cc64-127">The event handler can return a different version of the assembly than the version that was requested.</span></span>  
  
 <span data-ttu-id="0cc64-128">Ve většině případů je sestavení, které se vrátí obslužnou rutinou se zobrazí v kontextu zatížení, bez ohledu na to, které obslužná rutina načte ji do kontextu.</span><span class="sxs-lookup"><span data-stu-id="0cc64-128">In most cases, the assembly that is returned by the handler appears in the load context, regardless of the context the handler loads it into.</span></span> <span data-ttu-id="0cc64-129">Například, pokud obslužná rutina používá <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> metodu pro načtení sestavení do kontextu zatížení z, sestavení se zobrazí v kontextu zatížení, když obslužná rutina vrátí ji.</span><span class="sxs-lookup"><span data-stu-id="0cc64-129">For example, if the handler uses the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load an assembly into the load-from context, the assembly appears in the load context when the handler returns it.</span></span> <span data-ttu-id="0cc64-130">Ale v případě, že následující sestavení se zobrazí bez kontextu při obslužná rutina vrátí ji:</span><span class="sxs-lookup"><span data-stu-id="0cc64-130">However, in the following case the assembly appears without context when the handler returns it:</span></span>  
  
-   <span data-ttu-id="0cc64-131">Obslužná rutina načte sestavení bez kontextu.</span><span class="sxs-lookup"><span data-stu-id="0cc64-131">The handler loads an assembly without context.</span></span>  
  
-   <span data-ttu-id="0cc64-132"><xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Vlastnost nemá hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="0cc64-132">The <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property is not null.</span></span>  
  
-   <span data-ttu-id="0cc64-133">Žádajícího sestavení (to znamená, sestavení, které je vrácený <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> vlastnost) byl načten bez kontextu.</span><span class="sxs-lookup"><span data-stu-id="0cc64-133">The requesting assembly (that is, the assembly that is returned by the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property) was loaded without context.</span></span>  
  
 <span data-ttu-id="0cc64-134">Informace o kontextu, najdete v článku <xref:System.Reflection.Assembly.LoadFrom%28System.String%29?displayProperty=nameWithType> přetížení metody.</span><span class="sxs-lookup"><span data-stu-id="0cc64-134">For information about contexts, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="0cc64-135">Několik verzí stejného sestavení je možné načíst do stejné domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="0cc64-135">Multiple versions of the same assembly can be loaded into the same application domain.</span></span> <span data-ttu-id="0cc64-136">Tento postup se nedoporučuje, protože může vést k typu přiřazení problémů.</span><span class="sxs-lookup"><span data-stu-id="0cc64-136">This practice is not recommended, because it can lead to type assignment problems.</span></span> <span data-ttu-id="0cc64-137">V tématu [osvědčené postupy pro načtení sestavení](../../../docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="0cc64-137">See [Best Practices for Assembly Loading](../../../docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
### <a name="what-the-event-handler-should-not-do"></a><span data-ttu-id="0cc64-138">Obslužné rutiny události není čemu slouží</span><span class="sxs-lookup"><span data-stu-id="0cc64-138">What the Event Handler Should Not Do</span></span>  
 <span data-ttu-id="0cc64-139">Primární pravidla pro zpracování <xref:System.AppDomain.AssemblyResolve> událostí je, že by se neměl pokoušet vrátit nepoznáváte sestavení.</span><span class="sxs-lookup"><span data-stu-id="0cc64-139">The primary rule for handling the <xref:System.AppDomain.AssemblyResolve> event is that you should not try to return an assembly you do not recognize.</span></span> <span data-ttu-id="0cc64-140">Když píšete obslužná rutina, byste měli vědět, které sestavení může způsobit událost, která má být vyvolána.</span><span class="sxs-lookup"><span data-stu-id="0cc64-140">When you write the handler, you should know which assemblies might cause the event to be raised.</span></span> <span data-ttu-id="0cc64-141">Vaší obslužné rutiny pro ostatních sestavení by měl vrátit hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="0cc64-141">Your handler should return null for other assemblies.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0cc64-142">Od verze [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], <xref:System.AppDomain.AssemblyResolve> událost se vyvolá pro satelitní sestavení.</span><span class="sxs-lookup"><span data-stu-id="0cc64-142">Beginning with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the <xref:System.AppDomain.AssemblyResolve> event is raised for satellite assemblies.</span></span> <span data-ttu-id="0cc64-143">Tato změna ovlivňuje obslužnou rutinu události, který byl vytvořen pro dřívější verzi rozhraní .NET Framework, pokud obslužná rutina se pokusí přeložit všechny požadavky na zatížení v sestavení.</span><span class="sxs-lookup"><span data-stu-id="0cc64-143">This change affects an event handler that was written for an earlier version of the .NET Framework, if the handler tries to resolve all assembly load requests.</span></span> <span data-ttu-id="0cc64-144">Tato změna nemá vliv obslužné rutiny, které ignorovat sestavení nerozpoznají: mohly vrátit hodnotu null a dodržíte normální záložní mechanismy.</span><span class="sxs-lookup"><span data-stu-id="0cc64-144">Event handlers that ignore assemblies they do not recognize are not affected by this change: They return null, and normal fallback mechanisms are followed.</span></span>  
  
 <span data-ttu-id="0cc64-145">Při načítání sestavení, obslužné rutiny události nesmí používat žádné z <xref:System.AppDomain.Load%2A?displayProperty=nameWithType> nebo <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> přetížení metody, které můžou způsobit <xref:System.AppDomain.AssemblyResolve> událost, která má být vyvolané rekurzivně, protože to může vést k přetečení zásobníku.</span><span class="sxs-lookup"><span data-stu-id="0cc64-145">When loading an assembly, the event handler must not use any of the <xref:System.AppDomain.Load%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method overloads that can cause the <xref:System.AppDomain.AssemblyResolve> event to be raised recursively, because this can lead to a stack overflow.</span></span> <span data-ttu-id="0cc64-146">(Viz seznam uvedené výše v tomto tématu.) K tomu dojde i v případě, že zadáte zpracování výjimek pro žádost o načtení, protože žádná výjimka je vyvolána, dokud všechny obslužné rutiny událostí, aby vrátil.</span><span class="sxs-lookup"><span data-stu-id="0cc64-146">(See the list provided earlier in this topic.) This happens even if you provide exception handling for the load request, because no exception is thrown until all event handlers have returned.</span></span> <span data-ttu-id="0cc64-147">Proto následující kód vede k přetečení zásobníku Pokud `MyAssembly` nebyl nalezen:</span><span class="sxs-lookup"><span data-stu-id="0cc64-147">Thus, the following code results in a stack overflow if `MyAssembly` is not found:</span></span>  
  
 [!code-cpp[AssemblyResolveRecursive#1](../../../samples/snippets/cpp/VS_Snippets_CLR/assemblyresolverecursive/cpp/example.cpp#1)]
 [!code-csharp[AssemblyResolveRecursive#1](../../../samples/snippets/csharp/VS_Snippets_CLR/assemblyresolverecursive/cs/example.cs#1)]
 [!code-vb[AssemblyResolveRecursive#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/assemblyresolverecursive/vb/example.vb#1)]  
  
## <a name="see-also"></a><span data-ttu-id="0cc64-148">Viz také</span><span class="sxs-lookup"><span data-stu-id="0cc64-148">See Also</span></span>  
 [<span data-ttu-id="0cc64-149">Doporučené postupy pro načtení sestavení</span><span class="sxs-lookup"><span data-stu-id="0cc64-149">Best Practices for Assembly Loading</span></span>](../../../docs/framework/deployment/best-practices-for-assembly-loading.md)  
 [<span data-ttu-id="0cc64-150">Používání domén aplikací</span><span class="sxs-lookup"><span data-stu-id="0cc64-150">Using Application Domains</span></span>](../../../docs/framework/app-domains/use.md)
