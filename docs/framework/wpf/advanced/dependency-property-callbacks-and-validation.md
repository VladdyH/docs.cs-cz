---
title: "Zpětné volání a ověření vlastností závislostí"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
caps.latest.revision: "17"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 0d1b62c7f49653627c626bce2583b2799df931dc
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/21/2017
---
# <a name="dependency-property-callbacks-and-validation"></a><span data-ttu-id="d76a2-102">Zpětné volání a ověření vlastností závislostí</span><span class="sxs-lookup"><span data-stu-id="d76a2-102">Dependency Property Callbacks and Validation</span></span>
<span data-ttu-id="d76a2-103">Toto téma popisuje postup vytvoření vlastností závislostí pomocí alternativní vlastních implementací vlastnosti související s funkcí, jako jsou ověřování rozhodnutí, zpětná volání, které jsou spuštěny po změně platnou hodnotu vlastnosti a přepsáním Chcete-li to možné mimo vlivy na hodnotu rozhodnutí.</span><span class="sxs-lookup"><span data-stu-id="d76a2-103">This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.</span></span> <span data-ttu-id="d76a2-104">Toto téma taky popisuje scénáře, kde rozšíření na výchozí chování systému vlastnost s použitím těchto postupů je vhodné.</span><span class="sxs-lookup"><span data-stu-id="d76a2-104">This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.</span></span>  
  
  
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="d76a2-105">Požadavky</span><span class="sxs-lookup"><span data-stu-id="d76a2-105">Prerequisites</span></span>  
 <span data-ttu-id="d76a2-106">Toto téma předpokládá, že chápete základní scénáře implementace vlastnost závislosti a jak je použito metadata pro vlastnost vlastní závislosti.</span><span class="sxs-lookup"><span data-stu-id="d76a2-106">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="d76a2-107">V tématu [vlastní závislosti vlastnosti](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) a [metadat vlastností závislostí](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) pro kontext.</span><span class="sxs-lookup"><span data-stu-id="d76a2-107">See [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for context.</span></span>  
  
<a name="Validation_Callbacks"></a>   
## <a name="validation-callbacks"></a><span data-ttu-id="d76a2-108">Zpětná volání ověření</span><span class="sxs-lookup"><span data-stu-id="d76a2-108">Validation Callbacks</span></span>  
 <span data-ttu-id="d76a2-109">Zpětná volání ověření lze přiřadit k vlastnosti závislosti při první registraci.</span><span class="sxs-lookup"><span data-stu-id="d76a2-109">Validation callbacks can be assigned to a dependency property when you first register it.</span></span> <span data-ttu-id="d76a2-110">Zpětné volání pro ověření není součástí metadata vlastnosti; je přímý vstup z <xref:System.Windows.DependencyProperty.Register%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="d76a2-110">The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="d76a2-111">Proto po vytvoření zpětné volání pro ověření pro vlastnost závislosti ho nebude možné přepsat novou implementací.</span><span class="sxs-lookup"><span data-stu-id="d76a2-111">Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="d76a2-112">Zpětná volání se implementují tak, že jsou k dispozici hodnota objektu.</span><span class="sxs-lookup"><span data-stu-id="d76a2-112">The callbacks are implemented such that they are provided an object value.</span></span> <span data-ttu-id="d76a2-113">Vracejí `true` Pokud zadaná hodnota je platná pro vlastnost; v opačném případě, že budou vracet `false`.</span><span class="sxs-lookup"><span data-stu-id="d76a2-113">They return `true` if the provided value is valid for the property; otherwise, they return `false`.</span></span> <span data-ttu-id="d76a2-114">Předpokládá se, že vlastnost není správného typu pro typ zaregistrována vlastnosti systému, aby kontrola typu v rámci zpětná volání není provedena normálně.</span><span class="sxs-lookup"><span data-stu-id="d76a2-114">It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.</span></span> <span data-ttu-id="d76a2-115">Vlastnost systému v řadě různých operací používají zpětných volání.</span><span class="sxs-lookup"><span data-stu-id="d76a2-115">The callbacks are used by the property system in a variety of different operations.</span></span> <span data-ttu-id="d76a2-116">To zahrnuje počáteční typ inicializace výchozí hodnotou, Programová změna vyvoláním <xref:System.Windows.DependencyObject.SetValue%2A>, nebo se pokusí o přepsání metadat poskytuje novou výchozí hodnotou.</span><span class="sxs-lookup"><span data-stu-id="d76a2-116">This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided.</span></span> <span data-ttu-id="d76a2-117">Pokud je některý z těchto operací vyvolané zpětné volání pro ověření a vrátí `false`, pak bude vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="d76a2-117">If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised.</span></span> <span data-ttu-id="d76a2-118">Autoři aplikace musí být připravené zpracování těchto výjimek.</span><span class="sxs-lookup"><span data-stu-id="d76a2-118">Application writers must be prepared to handle these exceptions.</span></span> <span data-ttu-id="d76a2-119">Běžně se používají zpětná volání ověření ověřování hodnot výčtu, nebo omezíte hodnoty celá čísla nebo hodnoty Double, když vlastnost nastaví měření, které musí být nula nebo větší.</span><span class="sxs-lookup"><span data-stu-id="d76a2-119">A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.</span></span>  
  
 <span data-ttu-id="d76a2-120">Zpětná volání ověření speciálně by měla být validátory třída, není instance validátorů.</span><span class="sxs-lookup"><span data-stu-id="d76a2-120">Validation callbacks specifically are intended to be class validators, not instance validators.</span></span> <span data-ttu-id="d76a2-121">Parametry zpětného volání nekomunikují konkrétní <xref:System.Windows.DependencyObject> na které jsou nastaveny vlastnosti k ověření.</span><span class="sxs-lookup"><span data-stu-id="d76a2-121">The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set.</span></span> <span data-ttu-id="d76a2-122">Proto zpětná volání ověření nejsou vhodné pro vynucování možné "závislosti", které by mohly ovlivnit hodnotu vlastnosti specifické pro instanci hodnota vlastnosti, kde jsou závislé na faktorech jako jsou specifické pro instanci hodnotách jiných vlastností, nebo stav běhu.</span><span class="sxs-lookup"><span data-stu-id="d76a2-122">Therefore the validation callbacks are not useful for enforcing the possible "dependencies" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.</span></span>  
  
 <span data-ttu-id="d76a2-123">Tady je ukázkový kód pro scénář zpětného volání velmi jednoduché ověřování: ověřování, která vlastnost, která je zadán jako <xref:System.Double> primitivní není <xref:System.Double.PositiveInfinity> nebo <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="d76a2-123">The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.</span></span>  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>   
## <a name="coerce-value-callbacks-and-property-changed-events"></a><span data-ttu-id="d76a2-124">Coerce – hodnota zpětná volání a vlastnost změnit události</span><span class="sxs-lookup"><span data-stu-id="d76a2-124">Coerce Value Callbacks and Property Changed Events</span></span>  
 <span data-ttu-id="d76a2-125">Coerce – hodnota zpětná volání předat konkrétní <xref:System.Windows.DependencyObject> instance pro vlastnosti, stejně jako <xref:System.Windows.PropertyChangedCallback> implementací, které jsou vyvolány vlastnost systému při každé změně hodnoty vlastnosti závislosti.</span><span class="sxs-lookup"><span data-stu-id="d76a2-125">Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes.</span></span> <span data-ttu-id="d76a2-126">Pomocí těchto dvou zpětná volání v kombinaci, můžete vytvořit řadu vlastnosti u elementů, kde budou změny v jednu vlastnost vynutit převod nebo přehodnocení jinou vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d76a2-126">Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.</span></span>  
  
 <span data-ttu-id="d76a2-127">Typický scénář použití propojení vlastností závislostí je v případě, kde element obsahuje jednu vlastnost každý minimální a maximální hodnoty vlastnost rozhraní řízené uživatele a třetí vlastnost, pro skutečné nebo aktuální hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d76a2-127">A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.</span></span> <span data-ttu-id="d76a2-128">Sem pokud maximální byla upravena tak, že aktuální hodnota překročila maximální nové, by chcete coerce aktuální hodnota, která má být větší než nové maximální a podobné vztah pro minimální na aktuální.</span><span class="sxs-lookup"><span data-stu-id="d76a2-128">Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.</span></span>  
  
 <span data-ttu-id="d76a2-129">Zde je velmi krátké ukázkový kód pro právě jeden z vlastností tři závislostí, které ilustrují tento vztah.</span><span class="sxs-lookup"><span data-stu-id="d76a2-129">The following is very brief example code for just one of the three dependency properties that illustrate this relationship.</span></span> <span data-ttu-id="d76a2-130">Příklad ukazuje jak `CurrentReading` vlastnost minimální/maximální/aktuální sadu související * čtení vlastnosti je zaregistrován.</span><span class="sxs-lookup"><span data-stu-id="d76a2-130">The example shows how the `CurrentReading` property of a Min/Max/Current set of related *Reading properties is registered.</span></span> <span data-ttu-id="d76a2-131">Ověření používá jak je uvedeno v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="d76a2-131">It uses the validation as shown in the previous section.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="d76a2-132">Zpětné volání změněné vlastnosti pro aktuální slouží k předávání změnu a další závislé vlastnosti explicitně vyvoláním hodnota coerce zpětná volání, které jsou registrovány těchto vlastností:</span><span class="sxs-lookup"><span data-stu-id="d76a2-132">The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:</span></span>  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 <span data-ttu-id="d76a2-133">Zpětné volání hodnotu coerce zkontroluje hodnoty vlastností, aby potenciálně závisí na aktuální vlastnost a převede aktuální hodnota v případě potřeby:</span><span class="sxs-lookup"><span data-stu-id="d76a2-133">The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:</span></span>  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
>  <span data-ttu-id="d76a2-134">Nejsou má výchozí hodnoty vlastností.</span><span class="sxs-lookup"><span data-stu-id="d76a2-134">Default values of properties are not coerced.</span></span> <span data-ttu-id="d76a2-135">Hodnotu vlastnosti, která je stejná jako výchozí hodnota může dojít, pokud stále svou počáteční výchozí hodnotu vlastnosti, nebo prostřednictvím vymazání dalších hodnot s <xref:System.Windows.DependencyObject.ClearValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="d76a2-135">A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.</span></span>  
  
 <span data-ttu-id="d76a2-136">Změnit hodnotu coerce a vlastnost zpětná volání jsou součástí metadat vlastností.</span><span class="sxs-lookup"><span data-stu-id="d76a2-136">The coerce value and property changed callbacks are part of property metadata.</span></span> <span data-ttu-id="d76a2-137">Proto můžete změnit zpětných volání pro vlastnost konkrétní závislosti uložených na typ, který je odvozen z typu, který vlastní vlastnost závislosti přepsáním metadata pro tuto vlastnost na typ vašeho.</span><span class="sxs-lookup"><span data-stu-id="d76a2-137">Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.</span></span>  
  
<a name="Advanced"></a>   
## <a name="advanced-coercion-and-callback-scenarios"></a><span data-ttu-id="d76a2-138">Scénáře zpětného volání a pokročilé převod</span><span class="sxs-lookup"><span data-stu-id="d76a2-138">Advanced Coercion and Callback Scenarios</span></span>  
  
### <a name="constraints-and-desired-values"></a><span data-ttu-id="d76a2-139">Omezení a požadované hodnoty</span><span class="sxs-lookup"><span data-stu-id="d76a2-139">Constraints and Desired Values</span></span>  
 <span data-ttu-id="d76a2-140"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Zpětná volání se použije v systému vlastnost k coerce hodnotu v souladu logiku je deklarovat, ale coerced hodnotu místně nastavte vlastnost stále zachovají "požadovanou hodnotu" interně.</span><span class="sxs-lookup"><span data-stu-id="d76a2-140">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a "desired value" internally.</span></span> <span data-ttu-id="d76a2-141">Jsou-li u dalších hodnot vlastností, které mohou změnit dynamicky během životního cyklu aplikace omezení, omezení převod se změní dynamicky také, a vlastnost omezené můžete změnit její hodnota získat co nejblíže požadovanou hodnotu jako nejlépe nové omezení.</span><span class="sxs-lookup"><span data-stu-id="d76a2-141">If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.</span></span> <span data-ttu-id="d76a2-142">Hodnota se stane požadovanou hodnotu, pokud jsou všechna omezení zrušeno.</span><span class="sxs-lookup"><span data-stu-id="d76a2-142">The value will become the desired value if all constraints are lifted.</span></span> <span data-ttu-id="d76a2-143">Pokud máte více vlastností, které jsou na sobě závislé cyklické způsobem lze potenciálně zavádět některé scénáře poměrně složitá závislostí.</span><span class="sxs-lookup"><span data-stu-id="d76a2-143">You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.</span></span> <span data-ttu-id="d76a2-144">Ve scénáři, Min nebo Max nebo aktuální, například může rozhodnout pro minimální a maximální možné nastavit uživatele.</span><span class="sxs-lookup"><span data-stu-id="d76a2-144">For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.</span></span> <span data-ttu-id="d76a2-145">Pokud ano, možná budete muset coerce, že maximální počet je vždy větší a než minimální a naopak.</span><span class="sxs-lookup"><span data-stu-id="d76a2-145">If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.</span></span> <span data-ttu-id="d76a2-146">Ale pokud tento převod je aktivní, a maximální převede na minimální, jeho aktuální ponechá v unsettable stavu, protože závisí na obou a je omezená na rozsahu od hodnoty, které je nulová.</span><span class="sxs-lookup"><span data-stu-id="d76a2-146">But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.</span></span> <span data-ttu-id="d76a2-147">Poté pokud jsou upraveny maximální nebo minimální, aktuální zobrazí jako "následovat" jednu z hodnot, protože požadovanou hodnotu aktuální je pořád uložená a pokouší se kontaktovat požadovanou hodnotu, jako jsou snížit omezení.</span><span class="sxs-lookup"><span data-stu-id="d76a2-147">Then, if Maximum or Minimum are adjusted, Current will seem to "follow" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.</span></span>  
  
 <span data-ttu-id="d76a2-148">Není co technicky problém se složitým závislostem, ale mohou být výkon mírnou úkor vyžadovat velké množství reevaluations, když a může být také pro uživatele matoucí Pokud přímo ovlivňují uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="d76a2-148">There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.</span></span> <span data-ttu-id="d76a2-149">Buďte opatrní se změněné vlastnosti a coerce zpětná volání hodnotu a ujistěte se, že lze zacházet jako jednoznačně převod probíhají pokusy o navázání a není "overconstrain".</span><span class="sxs-lookup"><span data-stu-id="d76a2-149">Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not "overconstrain".</span></span>  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a><span data-ttu-id="d76a2-150">Pomocí CoerceValue zrušit změny hodnot</span><span class="sxs-lookup"><span data-stu-id="d76a2-150">Using CoerceValue to Cancel Value Changes</span></span>  
 <span data-ttu-id="d76a2-151">Vlastnost systém bude považovat všechny <xref:System.Windows.CoerceValueCallback> , vrátí hodnotu <xref:System.Windows.DependencyProperty.UnsetValue> zvláštním způsobem.</span><span class="sxs-lookup"><span data-stu-id="d76a2-151">The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case.</span></span> <span data-ttu-id="d76a2-152">Tento zvláštní případ znamená, že změnu vlastnosti, jejichž výsledkem <xref:System.Windows.CoerceValueCallback> volané odmítl vlastnosti systému, a vlastnost systému měli místo toho sestavy jakékoli předchozí hodnotu vlastnosti měl.</span><span class="sxs-lookup"><span data-stu-id="d76a2-152">This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.</span></span> <span data-ttu-id="d76a2-153">Tento mechanismus může být vhodné, zkontrolujte, jestli jsou stále platné pro aktuální stav objektu změny vlastnosti, které byly zahájeny asynchronně a není-li potlačit změny.</span><span class="sxs-lookup"><span data-stu-id="d76a2-153">This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.</span></span> <span data-ttu-id="d76a2-154">Další možný způsob je můžete selektivně potlačit hodnotu podle toho, která komponenta vlastnosti je zodpovědná za hodnotu nehlásí hodnota rozhodnutí.</span><span class="sxs-lookup"><span data-stu-id="d76a2-154">Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.</span></span> <span data-ttu-id="d76a2-155">K tomuto účelu můžete použít <xref:System.Windows.DependencyProperty> předaná zpětného volání a identifikátor vlastnosti jako vstup pro <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>a pak zpracování <xref:System.Windows.ValueSource>.</span><span class="sxs-lookup"><span data-stu-id="d76a2-155">To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d76a2-156">Viz také</span><span class="sxs-lookup"><span data-stu-id="d76a2-156">See Also</span></span>  
 [<span data-ttu-id="d76a2-157">Přehled vlastností závislostí</span><span class="sxs-lookup"><span data-stu-id="d76a2-157">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="d76a2-158">Metadata vlastnosti závislosti</span><span class="sxs-lookup"><span data-stu-id="d76a2-158">Dependency Property Metadata</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)  
 [<span data-ttu-id="d76a2-159">Vlastnosti vlastní závislosti</span><span class="sxs-lookup"><span data-stu-id="d76a2-159">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)
