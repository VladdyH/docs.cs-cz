---
title: "Označení směrovaných událostí jako zpracovaných a zpracování tříd"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: b2c9a550e1423acb37da9645d09cdb4ccefcea66
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/22/2017
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="17cd8-102">Označení směrovaných událostí jako zpracovaných a zpracování tříd</span><span class="sxs-lookup"><span data-stu-id="17cd8-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="17cd8-103">Obslužné rutiny pro směrované události můžete označit události zpracovávaných v rámci data události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="17cd8-104">Zpracování události účinně zkracují trasy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="17cd8-105">Třída zpracování je programovací konceptu, které podporuje směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="17cd8-106">Obslužná rutina třída má možnost zpracování konkrétní směrované události na úrovni třídy obslužnou rutinu, která je volána před všechny instance obslužné rutiny na jakoukoli instanci třídy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="17cd8-107">Požadavky</span><span class="sxs-lookup"><span data-stu-id="17cd8-107">Prerequisites</span></span>  
 <span data-ttu-id="17cd8-108">Toto téma popisuje na koncepty představené v [směrovány Přehled událostí](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="17cd8-108">This topic elaborates on concepts introduced in the [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="17cd8-109">Když k označení událostí jako zpracování</span><span class="sxs-lookup"><span data-stu-id="17cd8-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="17cd8-110">Pokud nastavíte hodnotu <xref:System.Windows.RoutedEventArgs.Handled%2A> vlastnost `true` události data pro směrované události, to se označuje jako "označení událostí zpracovává".</span><span class="sxs-lookup"><span data-stu-id="17cd8-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="17cd8-111">Není absolutní pravidlo pro kdy byste měli jako zpracování označit směrované události, jako autor aplikace nebo jako ovládací prvek autora, který reaguje na stávající směrované události nebo nové implementuje směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="17cd8-112">Ve většině případů koncepci "zpracování" jak se provádí v datech události směrované události má být použit jako omezené protokol pro vaše vlastní aplikace odpovědi na různé směrované události, které jsou zveřejněné v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] i pro vlastní směrován události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] as well as for any custom routed events.</span></span> <span data-ttu-id="17cd8-113">Dalším způsobem vzít v úvahu "zpracovávaný" problém je, že byste měli označit obecně směrované události zpracovává Pokud váš kód odpověděl směrované události významné a relativně dokončení způsobem.</span><span class="sxs-lookup"><span data-stu-id="17cd8-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="17cd8-114">Obvykle by neměl být více než jeden významné odpovědi, která vyžaduje implementace samostatné obslužných rutin pro kterýkoli z výskytů jednoho směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="17cd8-115">Pokud je nutné provést další odpovědi, nezbytného kódu by měla být implementována prostřednictvím aplikační logiky, která je zřetězené v rámci jedné obslužné rutiny, a nikoli pomocí systému směrované události pro přesměrování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="17cd8-116">Co je "důležité" koncept je také subjektivní a závisí na vaší aplikace nebo kódu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="17cd8-117">Jako obecné pokyny zahrnují příklady "významné odpověď": nastavení fokusu, úprava veřejné stavu, nastavení vlastností, které ovlivňují vizuální znázornění a vyvolání jiné nové události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="17cd8-118">Příklady nonsignificant odpovědí: Úprava privátní stavu (bez visual dopad, nebo programové reprezentace), protokolování událostí, nebo prohlížení argumenty události a zvolíte možnost Odpovědět na ni.</span><span class="sxs-lookup"><span data-stu-id="17cd8-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="17cd8-119">Chování systému směrované události posiluje tento model "významné odpověď" pro použití zpracovávaný stavu směrované události, protože obslužné rutiny přidali v [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] nebo běžné podpis <xref:System.Windows.UIElement.AddHandler%2A> nejsou v reakci na směrované události vyvolat, kde události data je již označena jako zpracovaná.</span><span class="sxs-lookup"><span data-stu-id="17cd8-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="17cd8-120">Musíte přejít do další úsilí přidávání obslužná rutina s `handledEventsToo` parametr verze (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) ke zpracování události směrované události, které jsou označené zpracováván starší účastníky trasy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="17cd8-121">V některých případech vlastní ovládací prvky označit určité směrované události jako zpracování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="17cd8-122">Zpracovávaný směrované události představuje rozhodnutí [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] řízení autoři, které akce ovládacího prvku v reakci na směrované události jsou důležité nebo úplný jako část implementaci ovládacího prvku a události musí žádné další zpracování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="17cd8-123">Obvykle to provádí přidáním třídy obslužnou rutinu pro událost nebo přepsáním mezi virtuals obslužná rutina třídy, který neexistuje na základní třídě.</span><span class="sxs-lookup"><span data-stu-id="17cd8-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="17cd8-124">Můžete stále obejít Tato událost zpracování v případě potřeby; v tématu [práce kolem událostí potlačení z ovládacích prvků](#WorkingAroundEventSuppressionByControls) dál v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="17cd8-125">"Náhled" vs události (tunelové připojení). Šíření události a zpracování událostí</span><span class="sxs-lookup"><span data-stu-id="17cd8-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="17cd8-126">Preview směrované události jsou události, které následují tunelu směrovat přes stromu element.</span><span class="sxs-lookup"><span data-stu-id="17cd8-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="17cd8-127">"Náhled" vyjádřené v zásady vytváření názvů svědčí o obecnou zásadu pro vstupní události, preview (tunelování) směrované události jsou vyvolány před ekvivalentní probublávání směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="17cd8-128">Vstupní směrované události, které mají probublávání pár tunelu také mít odlišné zpracování logiky.</span><span class="sxs-lookup"><span data-stu-id="17cd8-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="17cd8-129">Pokud tunelové propojení nebo preview směrované události je označena jako zpracovávaných naslouchací proces událostí, pak šíření, které budou označeny směrované události zpracovává i předtím, než ji přijmou všechny moduly pro naslouchání probublávání směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="17cd8-130">Tunelové a probublávání směrované události jsou technicky samostatné události, ale úmyslně sdílejí stejnou instanci data události povolit toto chování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="17cd8-131">Připojení mezi směrované události tunelového propojení a probublávání provádí vnitřní implementace jak všechny zadané [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] třída vyvolá vlastní deklarované směrované události, a to platí spárované vstupní směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="17cd8-132">Ale pokud tato implementace úrovni třídy existuje, neexistuje žádné připojení mezi tunelu směrované události a probublávání směrované události, které sdílejí schéma pojmenování: bez těchto implementace by dvě zcela samostatné směrované události a nebude vyvolána v pořadí nebo ve sdílené složce data události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="17cd8-133">Další informace o tom, jak implementovat vlastní třídu tunelové propojení nebo bublin vstupní směrované události páry najdete v tématu [vytvořit vlastní směrované události](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="17cd8-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="17cd8-134">Obslužné rutiny třídy a Instance obslužné rutiny</span><span class="sxs-lookup"><span data-stu-id="17cd8-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="17cd8-135">Směrované události zvážit dva různé typy moduly pro naslouchání na událost: třídy naslouchací procesy a moduly pro naslouchání instance.</span><span class="sxs-lookup"><span data-stu-id="17cd8-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="17cd8-136">Třída naslouchací procesy neexistuje, protože typy mají volat konkrétní <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, v jejich statického konstruktoru, nebo mají přepsat virtuální metody třídy obslužné rutiny ze základní třída prvku.</span><span class="sxs-lookup"><span data-stu-id="17cd8-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="17cd8-137">Moduly pro naslouchání instance jsou určité třídy nebo instance elementy, kde připojen minimálně jeden obslužné rutiny pro tento směrované události voláním <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="17cd8-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="17cd8-138">Existující [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] směrované události volat <xref:System.Windows.UIElement.AddHandler%2A> jako součást [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] událostí obálku {} přidávat a odebírat {} implementace událost, která je také jak jednoduché [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanismus připojení obslužné rutiny událostí prostřednictvím atributu Syntaxe je povolena.</span><span class="sxs-lookup"><span data-stu-id="17cd8-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="17cd8-139">Proto i v jednoduchém [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] využití nakonec rovná <xref:System.Windows.UIElement.AddHandler%2A> volání.</span><span class="sxs-lookup"><span data-stu-id="17cd8-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="17cd8-140">Elementy v rámci stromu visual jsou zaškrtnutá políčka pro implementace registrovanou obslužnou rutinu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="17cd8-141">Obslužné rutiny jsou vyvolány potenciálně v rámci trasy, v pořadí, ve kterém je vlastní typ směrování strategie pro tento směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="17cd8-142">Například probublávání směrované události bude nejprve vyvolání těchto obslužných rutin, které jsou připojené k stejného elementu, který vyvolal směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="17cd8-143">Potom směrované události "bublinách" Další nadřazený prvek, a tak dále, dokud je dosaženo kořenový element aplikace.</span><span class="sxs-lookup"><span data-stu-id="17cd8-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="17cd8-144">Z pohledu kořenový element v probublávání trasy Pokud třída zpracování nebo libovolný element blíž ke zdroji směrované události vyvolání obslužných rutin, které označit argumenty událostí jako zpracovanou, obslužné rutiny na kořenový adresář, který elementy nejsou vyvolat a události směrovat bude zkráceno efektivně před dosažením tohoto kořenový element.</span><span class="sxs-lookup"><span data-stu-id="17cd8-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="17cd8-145">Ale trasy, která není zastavilo úplně, protože mohou být přidány pomocí speciální podmíněného, že by měla stále být volána, i když obslužná rutina třídy nebo instance obslužné rutiny označila směrované události jako zpracování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="17cd8-146">To je vysvětleno v [přidání Instance obslužné rutiny, vyvolá i při události jsou označené zpracovává](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)dál v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="17cd8-147">Na podrobnější úrovni než trasy událostí existují také potenciálně více třídu obslužné rutiny na jakoukoli instanci dané třídy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="17cd8-148">To je vzhledem k tomu model zpracování třídy pro směrované události umožňuje všechny možné třídy v hierarchie tříd pro každé zaregistrovat vlastní třídu obslužné rutiny pro každý směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="17cd8-149">Každá třída obslužná rutina se přidá do interní úložiště, když se události trasy pro aplikace, obslužné rutiny třídy jsou všechny přidat do trasy událostí.</span><span class="sxs-lookup"><span data-stu-id="17cd8-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="17cd8-150">Obslužné rutiny třídy jsou přidány do trasy tak, aby obslužná rutina většinou odvozených tříd je vyvolána první a třídu obslužné rutiny z každé následných základní třídy jsou vyvolány Další.</span><span class="sxs-lookup"><span data-stu-id="17cd8-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="17cd8-151">Obecně platí obslužné rutiny třídy nejsou registrované tak, aby také reakce na směrované události, které již byly označeny zpracovává.</span><span class="sxs-lookup"><span data-stu-id="17cd8-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="17cd8-152">Tato třída mechanismu pro zpracování proto umožňuje mezi dvě možnosti:</span><span class="sxs-lookup"><span data-stu-id="17cd8-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
-   <span data-ttu-id="17cd8-153">Odvozené třídy lze rozšířit zpracování třídy, který je zděděn ze základní třídy přidáním obslužných rutin, které nejsou označeny směrované události zpracovat, protože obslužná rutina základní třídy, který bude vyvolán zopakovat po obslužná rutina odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
-   <span data-ttu-id="17cd8-154">Odvozené třídy můžete nahradit třída zpracování ze základní třídy přidáním třídy obslužná rutina, která označuje směrované události zpracovává.</span><span class="sxs-lookup"><span data-stu-id="17cd8-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="17cd8-155">Buďte opatrní s tímto přístupem, protože potenciálně změní návrhu určený základního ovládacího prvku v oblastech, jako je například vzhled, stav logiku, vstupní zpracování a zpracování příkazu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="17cd8-156">Třída zpracování směrované události podle základní třídy ovládacích prvků</span><span class="sxs-lookup"><span data-stu-id="17cd8-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="17cd8-157">Na každém uzlu daného elementu v trasu událostí moduly pro naslouchání – třída mít příležitost reagovat na směrované události před všechny instance naslouchací proces ve může element.</span><span class="sxs-lookup"><span data-stu-id="17cd8-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="17cd8-158">Z tohoto důvodu se někdy používají třídu obslužné rutiny pro potlačení směrované události, které na určitý ovládací prvek třída implementace nechce potřebný k šíření další, nebo zajistit zvláštní zpracování této směrované události, který je funkce třídy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="17cd8-159">Třídy pro instanci může vyvolat vlastní událost specifické pro třídu, která obsahuje další podrobnosti o některé vstupní podmínku uživatele znamená v kontextu této konkrétní třídy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="17cd8-160">Implementace třídy může pak označit obecnější směrované události jako zpracování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="17cd8-161">Třída přidat obslužné rutiny jsou obvykle tak, aby jejich nejsou volána pro směrovány zpracovává události, kde již byla označena data sdílené událostí, ale netypických případech je také <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> podpisu, který zaregistruje třídu obslužné rutiny pro vyvolání i, když jsou směrované události Označit zpracovávaný.</span><span class="sxs-lookup"><span data-stu-id="17cd8-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="17cd8-162">Obslužná rutina Virtuals – třída</span><span class="sxs-lookup"><span data-stu-id="17cd8-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="17cd8-163">Některé prvky, zejména základní prvky, jako <xref:System.Windows.UIElement>, zveřejněte prázdný "na * událostí" a "OnPreview\*událostí" virtuální metody, které odpovídají jejich seznam veřejné směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="17cd8-164">Tyto virtuální metody může být potlačena za účelem implementace třídy obslužnou rutinu pro tuto směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="17cd8-165">Třídy base element zaregistrovat tyto virtuální metody, protože jejich třídu obslužné rutiny pro každý například směrovány událostí pomocí <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> jak bylo popsáno výše.</span><span class="sxs-lookup"><span data-stu-id="17cd8-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="17cd8-166">On\*událostí virtuální metody zkontrolujte mnohem jednodušší implementaci třídy zpracování pro příslušnou směrované události, bez nutnosti speciální inicializace v statické konstruktory pro každý typ.</span><span class="sxs-lookup"><span data-stu-id="17cd8-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="17cd8-167">Například můžete přidat třídu zpracování <xref:System.Windows.UIElement.DragEnter> událostí v žádném <xref:System.Windows.UIElement> odvozené třídy přepsáním <xref:System.Windows.UIElement.OnDragEnter%2A> virtuální metoda.</span><span class="sxs-lookup"><span data-stu-id="17cd8-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="17cd8-168">V rámci přepsání může zpracovat směrované události, vyvolat další události, zahájení logiky specifické pro třídu, která může změnit vlastnosti element na instancích nebo libovolnou kombinaci těchto akcí.</span><span class="sxs-lookup"><span data-stu-id="17cd8-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="17cd8-169">By měl obvykle volat základní implementaci takové přepsání i v případě, že označit zpracovává událost.</span><span class="sxs-lookup"><span data-stu-id="17cd8-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="17cd8-170">Volání metody základní implementaci důrazně doporučujeme vzhledem k tomu, že je virtuální metody pro základní třídu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="17cd8-171">Chráněné vzor standardní virtuální volání základní implementace z každý virtuální v podstatě nahrazuje a paralelní s podobnou mechanismus, který je nativní směrované události třídy zpracování úloh, jimiž jsou třídu obslužné rutiny pro všechny třídy v hierarchii – třída volá se v dané instanci, počínaje obslužná rutina většinou odvozených tříd a pokračovat v obslužná rutina základní třídy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="17cd8-172">Základní implementaci volání by měla pouze vynechat, pokud vaše třída má záměrné požadavek, chcete-li změnit základní třídy zpracování logiky.</span><span class="sxs-lookup"><span data-stu-id="17cd8-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="17cd8-173">Jestli volat základní implementaci před nebo po přepsání kód bude záviset na povaze vaší implementace.</span><span class="sxs-lookup"><span data-stu-id="17cd8-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="17cd8-174">Vstupní událost třídy zpracování</span><span class="sxs-lookup"><span data-stu-id="17cd8-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="17cd8-175">Virtuální metody třídy obslužné rutiny jsou všechny registrované tak, aby se volat jenom v případech, kde nejsou žádná data události sdílené již označena zpracovává.</span><span class="sxs-lookup"><span data-stu-id="17cd8-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="17cd8-176">Také pro vstupní události jednoznačně, verze tunelového propojení a probublávání obvykle jsou vyvolány v pořadí a sdílet data události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="17cd8-177">To má za následek, že pro zadané dvojice třídu obslužné rutiny vstupní událostí, kde jeden je tunelové verze a druhá je probublávání verze, nemusí chcete označit události okamžitě zpracovávat.</span><span class="sxs-lookup"><span data-stu-id="17cd8-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="17cd8-178">Pokud budete implementovat třídu tunelu zpracování virtuální metoda označit zpracovává událost, která vyvolání (i brání žádné normálně registrované instance obslužné rutiny pro buď tunelu nebo probublávání události z zabrání obslužná rutina probublávání – třída Volaná).</span><span class="sxs-lookup"><span data-stu-id="17cd8-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="17cd8-179">Po dokončení zpracování na uzlu třídy jsou považovány za instance naslouchací procesy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="17cd8-180">Přidání obslužných rutin Instance, které jsou vyvolány i v případě, že jsou označeny události zpracovává</span><span class="sxs-lookup"><span data-stu-id="17cd8-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="17cd8-181"><xref:System.Windows.UIElement.AddHandler%2A> Konkrétní přetížení, které slouží k přidání obslužné rutiny, které bude vyvolán systém událostí vždy, když událost dosáhne zpracování elementu v postupu, i když některé jiné obslužná rutina má již upravit data události k označení, která poskytuje – metoda událost jako zpracování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="17cd8-182">Není to obvykle.</span><span class="sxs-lookup"><span data-stu-id="17cd8-182">This is not typically done.</span></span> <span data-ttu-id="17cd8-183">Obecně platí může být napsán obslužné rutiny upravit všechny oblasti aplikační kód, který může mít vliv událost, bez ohledu na to, kde ji byla zpracována ve stromu element i v případě potřeby více výsledků end.</span><span class="sxs-lookup"><span data-stu-id="17cd8-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="17cd8-184">Také obvykle je skutečně pouze jeden element, který potřebuje reagovat na tuto událost a příslušné aplikační logiku měl již bylo provedeno.</span><span class="sxs-lookup"><span data-stu-id="17cd8-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="17cd8-185">Ale `handledEventsToo` je k dispozici pro výjimečných případech, kde objektem jiného elementu skládání stromu nebo ovládací prvek elementu je již označena jako událost jako zpracování, ale další prvky vyšší nebo nižší v elementu stromu (v závislosti na trasu) stále přetížení Chcete mít svoje vlastní obslužné rutiny vyvolat.</span><span class="sxs-lookup"><span data-stu-id="17cd8-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="17cd8-186">Když k označení události spravovány jako neošetřené</span><span class="sxs-lookup"><span data-stu-id="17cd8-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="17cd8-187">Obecně platí, by neměl být směrované události, které jsou označené zpracovávaný označena neošetřené (<xref:System.Windows.RoutedEventArgs.Handled%2A> zpět `false`) i pomocí obslužných rutin, které fungují v `handledEventsToo`.</span><span class="sxs-lookup"><span data-stu-id="17cd8-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="17cd8-188">Ale některé vstupní události mít reprezentace vysoké úrovně a nižší úrovni událostí, které může dojít k překrytí při vysoké úrovně událostí je vidět na jednu pozici ve stromové struktuře a nízké úrovně událostí na jinou pozici.</span><span class="sxs-lookup"><span data-stu-id="17cd8-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="17cd8-189">Tento případ, kdy podřízený element naslouchá na vysoké úrovni klíče události, jako například vezměte v úvahu <xref:System.Windows.UIElement.TextInput> při nadřazený element naslouchá nízké úrovně události, jako <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="17cd8-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="17cd8-190">Pokud nadřazený element zpracovává událost nízké úrovně, vyšší úrovně události lze potlačit i v podřízený element, který by měl být intuitivně první příležitostí ke zpracování události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="17cd8-191">V těchto situacích může být nutné přidat do nadřazené elementy a podřízené elementy pro nízké úrovně událost obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="17cd8-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="17cd8-192">Implementace obslužné rutiny podřízený element můžete označit nízké úrovně událostí jako zpracování, ale implementace nadřazený element obslužnou rutinu by sadu, do které neošetřená znovu, aby další prvky až stromu (stejně jako nejdůležitější události) může mít možnost reagovat.</span><span class="sxs-lookup"><span data-stu-id="17cd8-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="17cd8-193">Tato situace by měla být poměrně výjimečných.</span><span class="sxs-lookup"><span data-stu-id="17cd8-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="17cd8-194">Záměrně potlačení vstupní události pro ovládací prvek skládání</span><span class="sxs-lookup"><span data-stu-id="17cd8-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="17cd8-195">Hlavní scénáře, kde se používá třída zpracování směrované události je vstupních událostech a kompletní složený ovládacích prvků.</span><span class="sxs-lookup"><span data-stu-id="17cd8-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="17cd8-196">Kompletní složený řízení je podle definice skládá z několika praktické ovládací prvky nebo základní třídy ovládacích prvků.</span><span class="sxs-lookup"><span data-stu-id="17cd8-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="17cd8-197">Často chce amalgamate všechny možné vstupní události autora ovládacího prvku, aby každý tyto dílčí součásti může vyvolat, za účelem hlášení celý ovládací prvek jako zdroj singulární události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="17cd8-198">V některých případech řízení autorovi chtít události ze součásti zcela potlačit, nebo nahraďte definována součást událostí, který představuje další informace nebo znamená více konkrétní chování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="17cd8-199">Kanonický příklad, který je okamžitě viditelné pro všechny součásti Autor je jak [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> zpracovává událostí myši, které bude nakonec vyřešte intuitivní události splnit všechny tlačítka: <xref:System.Windows.Controls.Primitives.ButtonBase.Click> událostí.</span><span class="sxs-lookup"><span data-stu-id="17cd8-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="17cd8-200"><xref:System.Windows.Controls.Button> Základní třída (<xref:System.Windows.Controls.Primitives.ButtonBase>) je odvozena z <xref:System.Windows.Controls.Control> která naopak je odvozena z <xref:System.Windows.FrameworkElement> a <xref:System.Windows.UIElement>a mnoho událostí infrastrukturu potřebnou pro zpracování vstupního ovládacího prvku je k dispozici <xref:System.Windows.UIElement> úroveň.</span><span class="sxs-lookup"><span data-stu-id="17cd8-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="17cd8-201">Konkrétně <xref:System.Windows.UIElement> zpracovává Obecné <xref:System.Windows.Input.Mouse> události, které zpracovávají přístupů testování myší v rámci jeho hranice. a poskytuje odlišné události pro nejběžnější tlačítko akce, jako například <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="17cd8-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="17cd8-202"><xref:System.Windows.UIElement>také poskytuje prázdnou virtuální <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> jako obslužná rutina preregistered třídy pro <xref:System.Windows.UIElement.MouseLeftButtonDown>, a <xref:System.Windows.Controls.Primitives.ButtonBase> přepíše ji.</span><span class="sxs-lookup"><span data-stu-id="17cd8-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="17cd8-203">Podobně <xref:System.Windows.Controls.Primitives.ButtonBase> používá třídu obslužné rutiny pro <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="17cd8-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="17cd8-204">Přepsání, které se předávají data události, který označit implementace <xref:System.Windows.RoutedEventArgs> instance jako ošetřena nastavením <xref:System.Windows.RoutedEventArgs.Handled%2A> k `true`, a že je stejná data událostí, co pokračuje podél zbytek trasy, která má ostatních obslužných rutin třída a také do instance obslužné rutiny nebo událostí setter.</span><span class="sxs-lookup"><span data-stu-id="17cd8-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="17cd8-205">Navíc <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> přepsání budou vedle vyvolat <xref:System.Windows.Controls.Primitives.ButtonBase.Click> událostí.</span><span class="sxs-lookup"><span data-stu-id="17cd8-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="17cd8-206">Konečný výsledek pro většinu naslouchací procesy budou <xref:System.Windows.UIElement.MouseLeftButtonDown> a <xref:System.Windows.UIElement.MouseLeftButtonUp> události "zmizí" a nahrazují místo <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, událost, která obsahuje další znamená, protože z true tlačítko a nejsou některé se ví, že došlo k této události složené zcela část tlačítko nebo z některé jiného elementu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="17cd8-207">Alternativní řešení potlačení událostí z ovládacích prvků</span><span class="sxs-lookup"><span data-stu-id="17cd8-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="17cd8-208">Toto chování potlačení události v rámci jednotlivých ovládacích prvků v některých případech může narušovat některé další obecné záměry logiku pro vaši aplikaci zpracování událostí.</span><span class="sxs-lookup"><span data-stu-id="17cd8-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="17cd8-209">Například pokud z nějakého důvodu vaše aplikace měla obslužnou rutinu pro <xref:System.Windows.UIElement.MouseLeftButtonDown> umístěný v kořenovém elementu aplikace, by zjistíte, že by vyvolání jakékoli myši klikněte na tlačítko <xref:System.Windows.UIElement.MouseLeftButtonDown> nebo <xref:System.Windows.UIElement.MouseLeftButtonUp> obslužné rutiny na kořenové úrovni.</span><span class="sxs-lookup"><span data-stu-id="17cd8-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="17cd8-210">Samotné události ve skutečnosti vyvolat (znovu, trasy událostí nejsou skutečně skončila, ale systém směrované události změní jejich chování volání obslužné rutiny po bude označena jako zpracovaná).</span><span class="sxs-lookup"><span data-stu-id="17cd8-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="17cd8-211">Po dosažení směrované události na tlačítko <xref:System.Windows.Controls.Primitives.ButtonBase> označena třída zpracování <xref:System.Windows.UIElement.MouseLeftButtonDown> zpracovat, protože si přeje, aby nahraďte <xref:System.Windows.Controls.Primitives.ButtonBase.Click> událost s další význam.</span><span class="sxs-lookup"><span data-stu-id="17cd8-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="17cd8-212">Proto všechny standardní <xref:System.Windows.UIElement.MouseLeftButtonDown> nebude vyvolat obslužnou rutinu další až trasy.</span><span class="sxs-lookup"><span data-stu-id="17cd8-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="17cd8-213">Existují dvě techniky, které můžete použít k zajištění, že vaše obslužné rutiny by být volána v této situaci.</span><span class="sxs-lookup"><span data-stu-id="17cd8-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="17cd8-214">První způsob je úmyslně přidání obslužné rutiny pomocí `handledEventsToo` podpis <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="17cd8-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="17cd8-215">Omezení tohoto přístupu je, že tato technika pro připojení obslužné rutiny události je možné pouze kód, nikoli z značek.</span><span class="sxs-lookup"><span data-stu-id="17cd8-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="17cd8-216">Zadání názvu obslužné rutiny událostí jako hodnota atributu událostí pomocí jednoduché syntaxe [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] neumožňuje daná chování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="17cd8-217">Druhý způsob spočívá funguje pouze pro vstupní událostí, kde jsou spárovat tunelového propojení a probublávání verzích směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="17cd8-218">Pro tyto směrované události můžete přidat obslužné rutiny na preview nebo tunelové propojení ekvivalentní směrované události.</span><span class="sxs-lookup"><span data-stu-id="17cd8-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="17cd8-219">Tento směrované události bude tunelování prostřednictvím trasy od kořenové, tak třída tlačítko kód pro zpracování nebude zachytávat, za předpokladu, že jste připojili, aby obslužná rutina náhled na určité úrovni nadřazený element ve stromu aplikace elementu.</span><span class="sxs-lookup"><span data-stu-id="17cd8-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="17cd8-220">Pokud použijete tuto metodu, buďte opatrní označení libovolnou událost Preview zpracovává.</span><span class="sxs-lookup"><span data-stu-id="17cd8-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="17cd8-221">Například danou s <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> zpracovanou v kořenovém elementu, pokud jste označili jako událost <xref:System.Windows.RoutedEventArgs.Handled%2A> k implementaci obslužné rutiny by skutečně potlačit <xref:System.Windows.Controls.Primitives.ButtonBase.Click> událostí.</span><span class="sxs-lookup"><span data-stu-id="17cd8-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="17cd8-222">Který je obvykle žádoucí chování.</span><span class="sxs-lookup"><span data-stu-id="17cd8-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="17cd8-223">Viz také</span><span class="sxs-lookup"><span data-stu-id="17cd8-223">See Also</span></span>  
 <xref:System.Windows.EventManager>  
 [<span data-ttu-id="17cd8-224">Události náhledu</span><span class="sxs-lookup"><span data-stu-id="17cd8-224">Preview Events</span></span>](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [<span data-ttu-id="17cd8-225">Vytvoření vlastní směrované události</span><span class="sxs-lookup"><span data-stu-id="17cd8-225">Create a Custom Routed Event</span></span>](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [<span data-ttu-id="17cd8-226">Přehled směrovaných událostí</span><span class="sxs-lookup"><span data-stu-id="17cd8-226">Routed Events Overview</span></span>](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
