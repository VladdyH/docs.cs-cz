---
title: "Model vláken"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
caps.latest.revision: "33"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: f598cecef2d0994692f197df09e9befc39a58723
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/22/2017
---
# <a name="threading-model"></a><span data-ttu-id="7f8df-102">Model vláken</span><span class="sxs-lookup"><span data-stu-id="7f8df-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="7f8df-103">slouží k uložení vývojáři z obtíže dělení na vlákna.</span><span class="sxs-lookup"><span data-stu-id="7f8df-103"> is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="7f8df-104">V důsledku toho většina [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] vývojáři nebudete muset psát rozhraní, které používá více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="7f8df-105">Protože programy s více vlákny složitá a obtížná k ladění, by měla při řešení jednovláknové existovat vyloučeno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="7f8df-106">Bez ohledu na tom, jak dobře navržen, ale ne [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework někdy budou moci poskytuje řešení s jedním podprocesem pro každý řazení problému.</span><span class="sxs-lookup"><span data-stu-id="7f8df-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="7f8df-107">dodává zavřít, ale jsou stále situacích, kde více vláken zvýšit [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] výkonu odezvy nebo aplikace.</span><span class="sxs-lookup"><span data-stu-id="7f8df-107"> comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="7f8df-108">Tento dokument po hovoříte o některé základní informace, jsou zde popsány některé z těchto situací a je uzavřen, přičemž se zabývat některé podrobnosti nižší úrovně.</span><span class="sxs-lookup"><span data-stu-id="7f8df-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  
  

  
> [!NOTE]
>  <span data-ttu-id="7f8df-109">Toto téma popisuje dělení na vlákna pomocí <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> metody pro asynchronní volání.</span><span class="sxs-lookup"><span data-stu-id="7f8df-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="7f8df-110">Můžete také provést asynchronní volání voláním <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> metodu, která trvat <xref:System.Action> nebo <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="7f8df-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="7f8df-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> Metoda vrátí <xref:System.Windows.Threading.DispatcherOperation> nebo <xref:System.Windows.Threading.DispatcherOperation%601>, který má <xref:System.Windows.Threading.DispatcherOperation.Task%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="7f8df-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="7f8df-112">Můžete použít `await` – klíčové slovo s buď <xref:System.Windows.Threading.DispatcherOperation> nebo s přiřazenou třídou <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="7f8df-113">Pokud potřebujete synchronně čekat <xref:System.Threading.Tasks.Task> , je vrácen rutinou <xref:System.Windows.Threading.DispatcherOperation> nebo <xref:System.Windows.Threading.DispatcherOperation%601>, volání <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> metoda rozšíření.</span><span class="sxs-lookup"><span data-stu-id="7f8df-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="7f8df-114">Volání metody <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> bude mít za následek vzájemné zablokování.</span><span class="sxs-lookup"><span data-stu-id="7f8df-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="7f8df-115">Další informace o používání <xref:System.Threading.Tasks.Task> k provedení asynchronních operací, najdete v části paralelismus.</span><span class="sxs-lookup"><span data-stu-id="7f8df-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="7f8df-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> Metoda má také přetížení, které provést <xref:System.Action> nebo <xref:System.Func%601> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="7f8df-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="7f8df-117">Můžete použít <xref:System.Windows.Threading.Dispatcher.Invoke%2A> metoda aby synchronní volání předáním v delegáta, <xref:System.Action> nebo <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="7f8df-118">Přehled a dispečera</span><span class="sxs-lookup"><span data-stu-id="7f8df-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="7f8df-119">Obvykle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] spustit aplikace se dvěma vlákny: jeden pro zpracování vykreslování a druhou pro správu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="7f8df-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="7f8df-120">Vlákno vykreslování efektivně spustí skrytě na pozadí při [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno obdrží vstup, zpracovává události, vybarví obrazovky a spouští kód aplikace.</span><span class="sxs-lookup"><span data-stu-id="7f8df-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="7f8df-121">Většina aplikací používá jeden [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláken, i když v některých případech je nejvhodnější použít několik.</span><span class="sxs-lookup"><span data-stu-id="7f8df-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="7f8df-122">Probereme to na příkladu později.</span><span class="sxs-lookup"><span data-stu-id="7f8df-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="7f8df-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Vlákno fronty pracovní položky v rámci objektu s názvem <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="7f8df-124"><xref:System.Windows.Threading.Dispatcher> Vybere pracovních položek na základě priority a spustí každé z nich k dokončení.</span><span class="sxs-lookup"><span data-stu-id="7f8df-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="7f8df-125">Každý [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno musí mít alespoň jeden <xref:System.Windows.Threading.Dispatcher>a každou <xref:System.Windows.Threading.Dispatcher> můžete spustit pracovní položky v přesně jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="7f8df-126">Základem pro vytváření aplikací reakce, uživatelsky přívětivý je maximalizovat <xref:System.Windows.Threading.Dispatcher> propustnost udržováním malé pracovní položky.</span><span class="sxs-lookup"><span data-stu-id="7f8df-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="7f8df-127">Tento způsob, jak položky nikdy získat zastaralé uložený ve <xref:System.Windows.Threading.Dispatcher> fronty čekání na zpracování.</span><span class="sxs-lookup"><span data-stu-id="7f8df-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="7f8df-128">Jakékoli patrná zpoždění mezi vstup a odpovědí může frustrovat uživatele.</span><span class="sxs-lookup"><span data-stu-id="7f8df-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="7f8df-129">Jak pak jsou [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikace by měl pro zpracování velkých operací?</span><span class="sxs-lookup"><span data-stu-id="7f8df-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="7f8df-130">Co když kódu zahrnuje velké výpočtu nebo potřebuje k dotazování databáze na některé vzdáleného serveru?</span><span class="sxs-lookup"><span data-stu-id="7f8df-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="7f8df-131">Obvykle je pro zpracování velkých operace v samostatné vlákno, a odpověď [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno volné zpravidla položky v <xref:System.Windows.Threading.Dispatcher> fronty.</span><span class="sxs-lookup"><span data-stu-id="7f8df-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="7f8df-132">Po dokončení operace big ho může hlásit svůj výsledek zpět [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno pro zobrazení.</span><span class="sxs-lookup"><span data-stu-id="7f8df-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="7f8df-133">V minulosti [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] umožňuje [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementy, aby měly přístup jenom vlákno, které byly vytvořeny.</span><span class="sxs-lookup"><span data-stu-id="7f8df-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="7f8df-134">To znamená, že vlákna na pozadí starosti některé dlouho běžící úlohy nelze aktualizovat v textovém poli Po dokončení.</span><span class="sxs-lookup"><span data-stu-id="7f8df-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="7f8df-135">k tomu k zajištění integrity [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] součásti.</span><span class="sxs-lookup"><span data-stu-id="7f8df-135"> does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="7f8df-136">Pole se seznamem může vypadat neobvyklé, pokud jeho obsah aktualizoval vlákna na pozadí během vykreslování.</span><span class="sxs-lookup"><span data-stu-id="7f8df-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="7f8df-137">má integrovanou vzájemné vyloučení mechanismus, který vynucuje tato spolupráce.</span><span class="sxs-lookup"><span data-stu-id="7f8df-137"> has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="7f8df-138">Většina tříd v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] odvozena od <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="7f8df-139">Při vytváření <xref:System.Windows.Threading.DispatcherObject> ukládá odkaz na <xref:System.Windows.Threading.Dispatcher> propojené s aktuálně spuštěných vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="7f8df-140">V důsledku toho <xref:System.Windows.Threading.DispatcherObject> přidruží vlákno, které ji vytvoří.</span><span class="sxs-lookup"><span data-stu-id="7f8df-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="7f8df-141">Při spuštění programu <xref:System.Windows.Threading.DispatcherObject> můžete volat jeho veřejné <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="7f8df-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="7f8df-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>prozkoumá <xref:System.Windows.Threading.Dispatcher> přidružené k aktuální vlákno a porovná ho do <xref:System.Windows.Threading.Dispatcher> odkazovat na uložené během vytváření.</span><span class="sxs-lookup"><span data-stu-id="7f8df-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="7f8df-143">Pokud se neshodují, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> vyvolá výjimku.</span><span class="sxs-lookup"><span data-stu-id="7f8df-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="7f8df-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>je určena k volání na začátku každé metody, které patří k <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="7f8df-145">Pokud pouze jedno vlákno můžete upravit [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], jak vlákna na pozadí komunikovat s uživatelem?</span><span class="sxs-lookup"><span data-stu-id="7f8df-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="7f8df-146">Vlákna na pozadí můžete pokládat [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno k provedení určité operace jeho jménem.</span><span class="sxs-lookup"><span data-stu-id="7f8df-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="7f8df-147">Dělá to tak, že zaregistrujete pracovní položky pomocí <xref:System.Windows.Threading.Dispatcher> z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-148"><xref:System.Windows.Threading.Dispatcher> Třída nabízí dvě metody pro registraci pracovní položky: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="7f8df-149">Obě metody naplánovat delegáta pro provedení.</span><span class="sxs-lookup"><span data-stu-id="7f8df-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="7f8df-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>je synchronní volání – to znamená, nevrací až [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken ve skutečnosti dokončí provádění delegát.</span><span class="sxs-lookup"><span data-stu-id="7f8df-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="7f8df-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>je asynchronní a vrátí okamžitě.</span><span class="sxs-lookup"><span data-stu-id="7f8df-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="7f8df-152"><xref:System.Windows.Threading.Dispatcher> Řadí elementy v příslušné fronty podle priority.</span><span class="sxs-lookup"><span data-stu-id="7f8df-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="7f8df-153">Existují deset úrovně, které může být určen při přidávání se element <xref:System.Windows.Threading.Dispatcher> fronty.</span><span class="sxs-lookup"><span data-stu-id="7f8df-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="7f8df-154">Tyto priority jsou zachována ve <xref:System.Windows.Threading.DispatcherPriority> výčtu.</span><span class="sxs-lookup"><span data-stu-id="7f8df-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="7f8df-155">Podrobné informace o <xref:System.Windows.Threading.DispatcherPriority> úrovně lze nalézt v [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] dokumentaci.</span><span class="sxs-lookup"><span data-stu-id="7f8df-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="7f8df-156">Vlákna v akci: ukázky</span><span class="sxs-lookup"><span data-stu-id="7f8df-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="7f8df-157">Aplikace jednovláknové s dlouho běžící výpočtu</span><span class="sxs-lookup"><span data-stu-id="7f8df-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="7f8df-158">Většina [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] tráví velkou část doba pro jejich nečinnosti při čekání na události, které jsou generovány v odpovědi na akce uživatelů.</span><span class="sxs-lookup"><span data-stu-id="7f8df-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="7f8df-159">Pečlivě programování s dobu nečinnosti lze konstruktivně, aniž by to ovlivnilo schopnost reagovat [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="7f8df-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="7f8df-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Model vláken neumožňuje vstup pro přerušení děje v operace [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-161">To znamená, že je nutné zajistit se vrátíte do <xref:System.Windows.Threading.Dispatcher> pravidelně do procesu čekající na vyřízení vstupních událostech předtím, než získají zastaralé.</span><span class="sxs-lookup"><span data-stu-id="7f8df-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="7f8df-162">Podívejte se na následující příklad:</span><span class="sxs-lookup"><span data-stu-id="7f8df-162">Consider the following example:</span></span>  
  
 <span data-ttu-id="7f8df-163">![Snímek obrazovky prvočísel](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span><span class="sxs-lookup"><span data-stu-id="7f8df-163">![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span></span>  
  
 <span data-ttu-id="7f8df-164">Tato jednoduchá aplikace počty směrem nahoru ze tří, hledání prvočísel.</span><span class="sxs-lookup"><span data-stu-id="7f8df-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="7f8df-165">Když uživatel klikne **spustit** tlačítko hledání začne.</span><span class="sxs-lookup"><span data-stu-id="7f8df-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="7f8df-166">Když program vyhledá prime, aktualizuje uživatelské rozhraní pomocí jeho zjišťování.</span><span class="sxs-lookup"><span data-stu-id="7f8df-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="7f8df-167">V libovolném bodě uživatel vyhledávání ukončit.</span><span class="sxs-lookup"><span data-stu-id="7f8df-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="7f8df-168">I když je dostatečně jednoduchá, hledání prime číslo může přejít na navždy, který představuje některé problémy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="7f8df-169">Pokud jsme zpracovat celý hledání uvnitř obslužné rutiny události klikněte na tlačítko, jsme by nikdy poskytnout [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláken příležitosti pro zpracování další události.</span><span class="sxs-lookup"><span data-stu-id="7f8df-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="7f8df-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] By být schopna odpovědět na vstupu nebo proces zprávy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="7f8df-171">By se nikdy překreslit a nikdy reakce na kliknutí na tlačítko.</span><span class="sxs-lookup"><span data-stu-id="7f8df-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="7f8df-172">Jsme mohli provádět vyhledávání prime číslo v samostatných podprocesu, ale pak je potřeba řešit problémy s synchronizací.</span><span class="sxs-lookup"><span data-stu-id="7f8df-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="7f8df-173">S přístupem jednovláknový jsme můžete přímo aktualizovat štítek, který uvádí největší prime nalezen.</span><span class="sxs-lookup"><span data-stu-id="7f8df-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="7f8df-174">Pokud jsme rozdělit úlohu výpočtu do spravovatelných blocích, můžeme pravidelně se vrátit <xref:System.Windows.Threading.Dispatcher> a zpracování události.</span><span class="sxs-lookup"><span data-stu-id="7f8df-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="7f8df-175">Bylo možné přidělit [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] příležitost překreslit a zpracovat vstup.</span><span class="sxs-lookup"><span data-stu-id="7f8df-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="7f8df-176">Nejlepší způsob, jak rozdělit doba zpracování mezi výpočtu a zpracování událostí je Správa výpočtu z <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="7f8df-177">Pomocí <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> metoda, jsme naplánovat prime číslo kontroly v stejné fronty, který [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] události jsou vykreslovány z.</span><span class="sxs-lookup"><span data-stu-id="7f8df-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="7f8df-178">V našem příkladu jsme naplánovat pouze jedno číslo prime kontrolu najednou.</span><span class="sxs-lookup"><span data-stu-id="7f8df-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="7f8df-179">Po dokončení kontroly prime číslo další kontroly jsme naplánovat okamžitě.</span><span class="sxs-lookup"><span data-stu-id="7f8df-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="7f8df-180">Tato kontrola pokračuje až poté, co čekající na vyřízení [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] události byly zpracovány.</span><span class="sxs-lookup"><span data-stu-id="7f8df-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 <span data-ttu-id="7f8df-181">![Obrázek fronty dispečera](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span><span class="sxs-lookup"><span data-stu-id="7f8df-181">![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span></span>  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="7f8df-182">provede kontrolu pravopisu pomocí tento mechanismus.</span><span class="sxs-lookup"><span data-stu-id="7f8df-182"> accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="7f8df-183">Kontrola pravopisu probíhá na pozadí pomocí čas nečinnosti [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-184">Podívejme se na kód.</span><span class="sxs-lookup"><span data-stu-id="7f8df-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="7f8df-185">Následující příklad ukazuje XAML, který vytváří uživatelské rozhraní.</span><span class="sxs-lookup"><span data-stu-id="7f8df-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="7f8df-186">Následující příklad ukazuje modelu code-behind.</span><span class="sxs-lookup"><span data-stu-id="7f8df-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="7f8df-187">Následující příklad ukazuje obslužné rutiny události pro <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="7f8df-188">Kromě aktualizace textu na <xref:System.Windows.Controls.Button>, tato obslužná rutina zodpovídá za plánování první kontrola prime číslo přidáním delegátovi, aby se <xref:System.Windows.Threading.Dispatcher> fronty.</span><span class="sxs-lookup"><span data-stu-id="7f8df-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="7f8df-189">Přetrvával po dokončení této obslužné rutiny události svou práci <xref:System.Windows.Threading.Dispatcher> vybere tohoto delegáta pro provedení.</span><span class="sxs-lookup"><span data-stu-id="7f8df-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="7f8df-190">Jak jsme už zmínili dřív, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> je <xref:System.Windows.Threading.Dispatcher> člen používají k plánování delegáta pro provedení.</span><span class="sxs-lookup"><span data-stu-id="7f8df-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="7f8df-191">V takovém případě vybereme možnost <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> s prioritou.</span><span class="sxs-lookup"><span data-stu-id="7f8df-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="7f8df-192"><xref:System.Windows.Threading.Dispatcher> Spustí jenom v případě, že neexistují žádné důležité události. ke zpracování tohoto delegáta.</span><span class="sxs-lookup"><span data-stu-id="7f8df-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="7f8df-193">rychlost reakce je důležitější než číslo kontrola.</span><span class="sxs-lookup"><span data-stu-id="7f8df-193"> responsiveness is more important than number checking.</span></span> <span data-ttu-id="7f8df-194">Také jsme předání nové delegáta představující rutiny kontrola číslo.</span><span class="sxs-lookup"><span data-stu-id="7f8df-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="7f8df-195">Tato metoda ověří, zda je číslo liché další prime.</span><span class="sxs-lookup"><span data-stu-id="7f8df-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="7f8df-196">Pokud je primární, metodu přímo aktualizací `bigPrime` <xref:System.Windows.Controls.TextBlock> tak, aby odrážela jeho zjišťování.</span><span class="sxs-lookup"><span data-stu-id="7f8df-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="7f8df-197">Jsme lze provést, protože výpočet dochází ve stejném vlákně, která byla použita k vytvoření komponentou.</span><span class="sxs-lookup"><span data-stu-id="7f8df-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="7f8df-198">Měli jsme vybrali možnost použít samostatné vlákno pro výpočet, nám používat složitější synchronizační mechanismus a provést aktualizaci v [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-199">Tuto situaci jsme budete ukazují další.</span><span class="sxs-lookup"><span data-stu-id="7f8df-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="7f8df-200">Úplný zdrojový kód pro tuto ukázku, najdete v článku [jedno vláknové objekty aplikace s ukázkou dlouho běžící výpočtu](http://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="7f8df-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="7f8df-201">Zpracování blokování operaci s vlákna na pozadí</span><span class="sxs-lookup"><span data-stu-id="7f8df-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="7f8df-202">Zpracování blokování operace v grafické aplikace může být obtížné.</span><span class="sxs-lookup"><span data-stu-id="7f8df-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="7f8df-203">Neradi volat metody blokování z obslužné rutiny událostí, protože aplikace se zobrazí na zmrazení.</span><span class="sxs-lookup"><span data-stu-id="7f8df-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="7f8df-204">Můžeme použít samostatné vlákna ke zpracování těchto operací, ale když máme Hotovo, musíme synchronizovat s [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláken, protože jsme nelze upravit přímo [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] z našich pracovní vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="7f8df-205">Můžeme použít <xref:System.Windows.Threading.Dispatcher.Invoke%2A> nebo <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> vložit delegáti do <xref:System.Windows.Threading.Dispatcher> z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-206">Nakonec se provede tyto delegáti oprávnění k úpravě [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="7f8df-207">V tomto příkladu jsme napodobovat vzdálené volání procedury, načte předpověď počasí.</span><span class="sxs-lookup"><span data-stu-id="7f8df-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="7f8df-208">Používáme samostatné pracovní vlákno provést toto volání a jsme naplánovat metodu aktualizace v <xref:System.Windows.Threading.Dispatcher> z [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláken, když jsme bylo dokončeno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 <span data-ttu-id="7f8df-209">![Informace o počasí snímek obrazovky uživatelského rozhraní](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span><span class="sxs-lookup"><span data-stu-id="7f8df-209">![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span></span>  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="7f8df-210">Toto jsou některé podrobnosti vhodné poznamenat.</span><span class="sxs-lookup"><span data-stu-id="7f8df-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="7f8df-211">Vytváření obslužná rutina tlačítko</span><span class="sxs-lookup"><span data-stu-id="7f8df-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="7f8df-212">Při kliknutí na tlačítko jsme zobrazit kreslení hodiny a spusťte ho animace.</span><span class="sxs-lookup"><span data-stu-id="7f8df-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="7f8df-213">Zakážeme tlačítko.</span><span class="sxs-lookup"><span data-stu-id="7f8df-213">We disable the button.</span></span> <span data-ttu-id="7f8df-214">Jsme vyvolání `FetchWeatherFromServer` metoda nové vlákno, a potom jsme návratový, což <xref:System.Windows.Threading.Dispatcher> ke zpracování událostí, když jsme čekat na shromažďování předpovědi počasí.</span><span class="sxs-lookup"><span data-stu-id="7f8df-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="7f8df-215">Načítání počasí</span><span class="sxs-lookup"><span data-stu-id="7f8df-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="7f8df-216">Pro zjednodušení nemáme ve skutečnosti sítě kód v tomto příkladu.</span><span class="sxs-lookup"><span data-stu-id="7f8df-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="7f8df-217">Místo toho jsme simulovat zpoždění přístup k síti umístěním naší nové vlákno do režimu spánku čtyři sekund.</span><span class="sxs-lookup"><span data-stu-id="7f8df-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="7f8df-218">V tuto chvíli původní [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno je stále spuštěna a reagování na události.</span><span class="sxs-lookup"><span data-stu-id="7f8df-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="7f8df-219">Ukážeme vám to, že jsme jste zbývajících animace spuštěna a minimalizovat a maximalizovat tlačítka také pokračovat v práci.</span><span class="sxs-lookup"><span data-stu-id="7f8df-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="7f8df-220">Po dokončení zpoždění, a rozhodli jsme se náhodně naše předpověď počasí, je čas zprávy zpět [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-221">Provedeme to pomocí naplánovaného volání `UpdateUserInterface` v [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vláken pomocí daném vláknu <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="7f8df-222">Jsme předat řetězec popisující počasí pro toto volání metody naplánované.</span><span class="sxs-lookup"><span data-stu-id="7f8df-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="7f8df-223">Aktualizace[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="7f8df-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="7f8df-224">Když <xref:System.Windows.Threading.Dispatcher> v [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno má čas, se provede plánované volání `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="7f8df-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="7f8df-225">Tato metoda zastaví animace hodiny a zvolí obrázek, který se popisují počasí.</span><span class="sxs-lookup"><span data-stu-id="7f8df-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="7f8df-226">Zobrazí tuto bitovou kopii a obnoví tlačítko "načítání forecast".</span><span class="sxs-lookup"><span data-stu-id="7f8df-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="7f8df-227">Více oken, více vláken</span><span class="sxs-lookup"><span data-stu-id="7f8df-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="7f8df-228">Některé [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikace vyžadují více oken nejvyšší úrovně.</span><span class="sxs-lookup"><span data-stu-id="7f8df-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="7f8df-229">Je zcela přijatelné pro jedno vlákno /<xref:System.Windows.Threading.Dispatcher> kombinace ke správě více oken, ale někdy několik vláken pracovat lépe.</span><span class="sxs-lookup"><span data-stu-id="7f8df-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="7f8df-230">To platí hlavně v že případě je pravděpodobné, že jedna z windows bude monopolizovat všechny vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="7f8df-231">Průzkumník funguje tímto způsobem.</span><span class="sxs-lookup"><span data-stu-id="7f8df-231"> Explorer works in this fashion.</span></span> <span data-ttu-id="7f8df-232">Každé nové okno Průzkumníka patří do procesu původní, ale se vytvoří pod kontrolou nezávislé vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="7f8df-233">Pomocí [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> řízení, zobrazuje se webové stránky.</span><span class="sxs-lookup"><span data-stu-id="7f8df-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="7f8df-234">Jsme můžete snadno vytvořit jednoduchou [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] nahradit.</span><span class="sxs-lookup"><span data-stu-id="7f8df-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="7f8df-235">Začneme s důležitou součást: možnost otevřete nové okno Průzkumníka.</span><span class="sxs-lookup"><span data-stu-id="7f8df-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="7f8df-236">Když uživatel klikne na tlačítko "nové okno" tlačítko jsme spustit kopii naše okna v samostatných podprocesu.</span><span class="sxs-lookup"><span data-stu-id="7f8df-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="7f8df-237">Tímto způsobem, dlouhodobé nebo blokování operací v jednom ze systému windows nebude uzamčení všechny ostatní systémy windows.</span><span class="sxs-lookup"><span data-stu-id="7f8df-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="7f8df-238">Ve skutečnosti webové prohlížeče model má vlastní složitý model vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="7f8df-239">Vzhledem k tomu, že by měla být pro většinu čtečky jsme jste vybrali ho.</span><span class="sxs-lookup"><span data-stu-id="7f8df-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="7f8df-240">Následující příklad ukazuje kód.</span><span class="sxs-lookup"><span data-stu-id="7f8df-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="7f8df-241">Jsou následující vláken segmenty tohoto kódu nejvíce zajímavé nám v tomto kontextu:</span><span class="sxs-lookup"><span data-stu-id="7f8df-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="7f8df-242">Tato metoda je volána, když "nové okno" po kliknutí na tlačítko.</span><span class="sxs-lookup"><span data-stu-id="7f8df-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="7f8df-243">Vytvoří nové vlákno. proto ji spustí asynchronně.</span><span class="sxs-lookup"><span data-stu-id="7f8df-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="7f8df-244">Tato metoda je výchozím bodem pro nové vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="7f8df-245">Vytvoříme nové okno pod kontrolou tohoto podprocesu.</span><span class="sxs-lookup"><span data-stu-id="7f8df-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="7f8df-246">automaticky vytvoří nový <xref:System.Windows.Threading.Dispatcher> ke správě nové vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-246"> automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="7f8df-247">Všechny budeme muset udělat, aby byly funkční okna je spustit <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="7f8df-248">Technické podrobnosti a Stumbling body</span><span class="sxs-lookup"><span data-stu-id="7f8df-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="7f8df-249">Zápis součásti pomocí dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="7f8df-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="7f8df-250">[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] – Příručka vývojáře popisuje vzor jak součást můžou zpřístupnit asynchronní chování svým klientům (najdete v části [na základě událostí přehled asynchronních vzorů](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="7f8df-250">The [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="7f8df-251">Předpokládejme například, jsme chtěli balíčku `FetchWeatherFromServer` metoda do komponenty opakovaně použitelný, které nepodporují grafiku.</span><span class="sxs-lookup"><span data-stu-id="7f8df-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="7f8df-252">Následující standardní [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] vzor, to by vypadat podobně jako následující.</span><span class="sxs-lookup"><span data-stu-id="7f8df-252">Following the standard [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="7f8df-253">`GetWeatherAsync`by použijte jeden z technik popsaných výše, jako je například vytváření vlákna na pozadí, které udělají tuto práci asynchronně, není blokování volající vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="7f8df-254">Jedna z vašich nejdůležitějších částí tohoto vzoru volá *MethodName* `Completed` metoda ve stejném vlákně, který volá *MethodName* `Async` metodu začínat.</span><span class="sxs-lookup"><span data-stu-id="7f8df-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="7f8df-255">Můžete tak učinit pomocí [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] poměrně snadno uložením <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>– ale pak komponentu které nepodporují grafiku může lze použít pouze ve [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplikace, není v [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] nebo [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="7f8df-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext> Třída adresy tohoto požadavku – jako zjednodušenou verzi <xref:System.Windows.Threading.Dispatcher> to funguje s jinými [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] také architektury.</span><span class="sxs-lookup"><span data-stu-id="7f8df-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="7f8df-257">Vnořené čerpání</span><span class="sxs-lookup"><span data-stu-id="7f8df-257">Nested Pumping</span></span>  
 <span data-ttu-id="7f8df-258">Někdy není možné úplně zamčení [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-259">Pojďme se podívat <xref:System.Windows.MessageBox.Show%2A> metodu <xref:System.Windows.MessageBox> třídy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="7f8df-260"><xref:System.Windows.MessageBox.Show%2A>nevrací, dokud uživatel klikne na tlačítko OK.</span><span class="sxs-lookup"><span data-stu-id="7f8df-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="7f8df-261">Vytváří však okno, které musí mít smyčku zpráva, aby byla interaktivní.</span><span class="sxs-lookup"><span data-stu-id="7f8df-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="7f8df-262">Když jsme čekají na uživatel kliknutím na tlačítko OK, neodpovídá původní okna aplikace na vstup uživatele.</span><span class="sxs-lookup"><span data-stu-id="7f8df-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="7f8df-263">Nicméně, pokračovat ke zpracování malovat zprávy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="7f8df-264">Okno původní překreslí samotná popsaná a zjištěny.</span><span class="sxs-lookup"><span data-stu-id="7f8df-264">The original window redraws itself when covered and revealed.</span></span>  
  
 <span data-ttu-id="7f8df-265">![MessageBox tlačítko "OK"](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span><span class="sxs-lookup"><span data-stu-id="7f8df-265">![MessageBox with an "OK" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span></span>  
  
 <span data-ttu-id="7f8df-266">Některé vlákno musí být starosti okno zprávy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="7f8df-267">vytvořit nové vlákno jenom pro okno zprávy, ale tohoto podprocesu by nemohl malovat zakázané elementy v okně původní (Nezapomeňte starší diskuzi o vzájemné vyloučení).</span><span class="sxs-lookup"><span data-stu-id="7f8df-267"> could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="7f8df-268">Místo toho [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] používá zprávu vnořené zpracování systému.</span><span class="sxs-lookup"><span data-stu-id="7f8df-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="7f8df-269"><xref:System.Windows.Threading.Dispatcher> Třída obsahuje speciální metodu s názvem <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, která ukládá aktuální bod spuštění aplikace pak začne smyčku nové zprávy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="7f8df-270">Po dokončení vnořené zpráva smyčky provádění obnoví po původní <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> volání.</span><span class="sxs-lookup"><span data-stu-id="7f8df-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="7f8df-271">V takovém případě <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> udržuje kontextu programu na volání <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, a zahájí cyklus nové zprávy překreslit okno pozadí a zpracovat vstup okno zprávy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="7f8df-272">Když uživatel klikne na tlačítko OK a vymaže místním okně, ukončení vnořených smyčky a řízení obnoví po volání <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="7f8df-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="7f8df-273">Zastaralé směrované události</span><span class="sxs-lookup"><span data-stu-id="7f8df-273">Stale Routed Events</span></span>  
 <span data-ttu-id="7f8df-274">Systém směrované události v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] upozorní celý stromy, když jsou vyvolány události.</span><span class="sxs-lookup"><span data-stu-id="7f8df-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="7f8df-275">Při stisknutí levé tlačítko myši nad se třemi tečkami `handler2` se spustí.</span><span class="sxs-lookup"><span data-stu-id="7f8df-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="7f8df-276">Po `handler2` skončí, události se předají <xref:System.Windows.Controls.Canvas> objekt, který používá `handler1` zpracovat.</span><span class="sxs-lookup"><span data-stu-id="7f8df-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="7f8df-277">K tomu dojde pouze v případě `handler2` nemá explicitně označit objekt událostí jako zpracování.</span><span class="sxs-lookup"><span data-stu-id="7f8df-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="7f8df-278">Je možné, který `handler2` bude trvat značnou část doby zpracování této události.</span><span class="sxs-lookup"><span data-stu-id="7f8df-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="7f8df-279">`handler2`může použít <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> zahájíte smyčku vnořené zpráv, který nevrací hodin.</span><span class="sxs-lookup"><span data-stu-id="7f8df-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="7f8df-280">Pokud `handler2` neobsahuje označit událost jako zpracování, pokud je tato zpráva smyčky dokončení, událost byla předána do stromu, i když je velmi staré.</span><span class="sxs-lookup"><span data-stu-id="7f8df-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="7f8df-281">Vícenásobný přístup a zamykání</span><span class="sxs-lookup"><span data-stu-id="7f8df-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="7f8df-282">Uzamčení mechanismus [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] není chovat přesně tak, jak může jeden Představte si; jeden můžou očekávat vlákna ke zcela zastaví operaci žádosti o zámek.</span><span class="sxs-lookup"><span data-stu-id="7f8df-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="7f8df-283">Ve skutečnosti vlákno nadále přijímat a zpracovávat zprávy s vysokou prioritou.</span><span class="sxs-lookup"><span data-stu-id="7f8df-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="7f8df-284">To pomáhá zabránit blokování a dosáhnete rozhraní minimálně reakce, ale přináší možnost pro jemně chyby.</span><span class="sxs-lookup"><span data-stu-id="7f8df-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="7f8df-285">Velká většina času nemusíte nic vědět o tom, ale za výjimečných podmínek (obvykle zahrnující [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] okno zprávy nebo komponenty COM STA) to může být vhodné s jistotou.</span><span class="sxs-lookup"><span data-stu-id="7f8df-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="7f8df-286">Většina rozhraní nejsou vytvořené s nástroji zabezpečení vlákna na paměti, protože vývojáři fungovat za předpokladu, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] nikdy přistupuje více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="7f8df-287">V tomto případě, že jedno vlákno může provést změny v prostředí v neočekávanou dobu, příčinou těchto nesprávně dopad, <xref:System.Windows.Threading.DispatcherObject> mechanismus vzájemné vyloučení by měla vyřešit.</span><span class="sxs-lookup"><span data-stu-id="7f8df-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="7f8df-288">Vezměte v úvahu následující pseudokódu:</span><span class="sxs-lookup"><span data-stu-id="7f8df-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="7f8df-289">![Dělení na vlákna vícenásobný přístup diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="7f8df-289">![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="7f8df-290">Ve většině případů, je správné věci, ale v určitých časech v [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kde takové neočekávané vícenásobný přístup skutečně způsobit problémy.</span><span class="sxs-lookup"><span data-stu-id="7f8df-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="7f8df-291">Ano, v určitých časech klíče [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] volání <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, pokyn zámek pro daném vláknu použít změny, které [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] opětovné zadání bez uzamčení, namísto obvyklého [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] zámku.</span><span class="sxs-lookup"><span data-stu-id="7f8df-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="7f8df-292">Ano důvod, proč se [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team zvolte toto chování?</span><span class="sxs-lookup"><span data-stu-id="7f8df-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="7f8df-293">Ho museli dělat s objekty COM STA a finalizace vlákno.</span><span class="sxs-lookup"><span data-stu-id="7f8df-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="7f8df-294">Když je objekt uvolnění z paměti, jeho `Finalize` metoda běží na vyhrazené finalizační metodu vlákno, není [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-295">A v něm je problém, protože COM STA objektu, který byl vytvořen na [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno může být uvolněn pouze ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="7f8df-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="7f8df-296">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] Nemá ekvivalent <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (v takovém případě používat na Win32 `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="7f8df-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="7f8df-297">Avšak v tom případě [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] vlákno je zaneprázdněný, vlákno finalizační metodu je zastaven a proces a objekt COM STA nelze uvolnit, vytváří závažné paměť.</span><span class="sxs-lookup"><span data-stu-id="7f8df-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="7f8df-298">Proto [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team provedené robustním volání aby zámky pracovat způsobem dělají.</span><span class="sxs-lookup"><span data-stu-id="7f8df-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="7f8df-299">Úloha [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] se vyhnete neočekávané opětovné zadání bez opětovného zavedení nevrácená paměť systému, proto jsme neblokovat everywhere vícenásobný přístup.</span><span class="sxs-lookup"><span data-stu-id="7f8df-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7f8df-300">Viz také</span><span class="sxs-lookup"><span data-stu-id="7f8df-300">See Also</span></span>  
 [<span data-ttu-id="7f8df-301">Jednovláknové aplikace s ukázkou dlouho běžící výpočtu</span><span class="sxs-lookup"><span data-stu-id="7f8df-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](http://go.microsoft.com/fwlink/?LinkID=160038)
