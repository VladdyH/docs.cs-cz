---
title: Kontrakty kódu
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 09bfa08589bda68258883e6f080392f534e8c5df
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33365875"
---
# <a name="code-contracts"></a><span data-ttu-id="988b5-102">Kontrakty kódu</span><span class="sxs-lookup"><span data-stu-id="988b5-102">Code Contracts</span></span>
<span data-ttu-id="988b5-103">Kontrakty kódu poskytují způsob, jak určit předpoklady, vstupních a výstupních podmínek objektu v kódu.</span><span class="sxs-lookup"><span data-stu-id="988b5-103">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="988b5-104">Předběžné podmínky jsou uvedeny požadavky, které musí být splněny, při zadávání metody nebo vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="988b5-104">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="988b5-105">Vstupních popisují očekávání v době, kdy bude ukončen kód metody nebo vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="988b5-105">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="988b5-106">Objekt výstupních podmínek popisují očekávanému stavu pro třídu, která je ve funkčním stavu.</span><span class="sxs-lookup"><span data-stu-id="988b5-106">Object invariants describe the expected state for a class that is in a good state.</span></span>  
  
 <span data-ttu-id="988b5-107">Kontrakty kódu zahrnují třídy pro označení kódu, statické analyzátor pro analýzu kompilaci a analyzátor modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="988b5-107">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="988b5-108">Třídy pro kontrakty kódu najdete v <xref:System.Diagnostics.Contracts> oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="988b5-108">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>  
  
 <span data-ttu-id="988b5-109">Mezi výhody kontrakty kódu patří následující:</span><span class="sxs-lookup"><span data-stu-id="988b5-109">The benefits of code contracts include the following:</span></span>  
  
-   <span data-ttu-id="988b5-110">Vylepšení testování: kontrakty kódu poskytovat statické ověření kontraktu, kontrola runtime a generování dokumentace.</span><span class="sxs-lookup"><span data-stu-id="988b5-110">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>  
  
-   <span data-ttu-id="988b5-111">Automatické testovací nástroje: kontrakty kódu můžete použít ke generování smysluplnější testy jednotek tím, smysl testovací argumenty, které nesplňují předběžné podmínky.</span><span class="sxs-lookup"><span data-stu-id="988b5-111">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>  
  
-   <span data-ttu-id="988b5-112">Statické ověření: statické kontrolu můžete rozhodnout, zda jsou všechny porušení smlouvy bez spuštění programu.</span><span class="sxs-lookup"><span data-stu-id="988b5-112">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="988b5-113">Vyhledává implicitní kontrakty, jako je například null dereferences a pole hranice a explicitní smlouvy.</span><span class="sxs-lookup"><span data-stu-id="988b5-113">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>  
  
-   <span data-ttu-id="988b5-114">Referenční dokumentace: dokumentace generátor rozšiřuje existující soubory dokumentace XML s informace o smlouvě.</span><span class="sxs-lookup"><span data-stu-id="988b5-114">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="988b5-115">Existují také šablony stylů, které lze použít s [aplikaci Sandcastle](https://github.com/EWSoftware/SHFB) tak, aby stránky generované dokumentace části kontrakt.</span><span class="sxs-lookup"><span data-stu-id="988b5-115">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>  
  
 <span data-ttu-id="988b5-116">Všechny jazyky rozhraní .NET Framework, můžete okamžitě využít výhod kontrakty; Nemáte k zápisu speciální analyzátor nebo kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="988b5-116">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="988b5-117">Doplněk sady Visual Studio vám umožní určit úroveň analýza kódu kontrakt provést.</span><span class="sxs-lookup"><span data-stu-id="988b5-117">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="988b5-118">Analyzátory můžete potvrdit, že jsou smluv ve správném formátu (Kontrola typu a překlad názvů) a může vytvářet kompilované formuláře smluv ve formátu Microsoft (MSIL intermediate language).</span><span class="sxs-lookup"><span data-stu-id="988b5-118">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="988b5-119">Vytváření smluv v sadě Visual Studio umožňuje využít výhod standardní IntelliSense poskytované nástroj.</span><span class="sxs-lookup"><span data-stu-id="988b5-119">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>  
  
 <span data-ttu-id="988b5-120">Většinu metod ve třídě, kontrakt podmíněně kompilované; To znamená, kompilátor vydává volání těchto metod jenom v případě, že definujete symbol speciální CONTRACTS_FULL, pomocí `#define` – direktiva.</span><span class="sxs-lookup"><span data-stu-id="988b5-120">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="988b5-121">CONTRACTS_FULL umožňuje zapisovat kontrakty ve vašem kódu bez použití `#ifdef` direktivy; může vytvářet různé verze, některé se smlouvami a některé bez.</span><span class="sxs-lookup"><span data-stu-id="988b5-121">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>  
  
 <span data-ttu-id="988b5-122">Nástroje a podrobné pokyny pro používání kontrakty kódu najdete v tématu [kontrakty kódu](http://go.microsoft.com/fwlink/?LinkId=152461) na webu MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="988b5-122">For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
## <a name="preconditions"></a><span data-ttu-id="988b5-123">Předběžné podmínky</span><span class="sxs-lookup"><span data-stu-id="988b5-123">Preconditions</span></span>  
 <span data-ttu-id="988b5-124">Předběžné podmínky lze vyjádřit pomocí <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-124">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="988b5-125">Předběžné podmínky zadejte stav, když je volána metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-125">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="988b5-126">Obecně se používají k určení platné hodnoty parametrů.</span><span class="sxs-lookup"><span data-stu-id="988b5-126">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="988b5-127">Všechny členy, které jsou uvedeny v předběžných podmínek musí být přístupné metoda sama; předpoklad, jinak hodnota nemusí být srozumitelné všech volajících metody.</span><span class="sxs-lookup"><span data-stu-id="988b5-127">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="988b5-128">Podmínka musí mít žádné vedlejší účinky.</span><span class="sxs-lookup"><span data-stu-id="988b5-128">The condition must have no side-effects.</span></span> <span data-ttu-id="988b5-129">Chování běhové selhání předběžné podmínky je určen podle analyzátor modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="988b5-129">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>  
  
 <span data-ttu-id="988b5-130">Například následující předběžnou vyjadřoval tento parametr `x` musí obsahovat hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="988b5-130">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>  
  
 `Contract.Requires( x != null );`  
  
 <span data-ttu-id="988b5-131">Pokud váš kód musí konkrétní výjimku vyvolat na selhání předběžné podmínky, můžete použít obecné přetížení <xref:System.Diagnostics.Contracts.Contract.Requires%2A> následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="988b5-131">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>  
  
 `Contract.Requires<ArgumentNullException>( x != null, "x" );`  
  
### <a name="legacy-requires-statements"></a><span data-ttu-id="988b5-132">Starší verze vyžaduje příkazy</span><span class="sxs-lookup"><span data-stu-id="988b5-132">Legacy Requires Statements</span></span>  
 <span data-ttu-id="988b5-133">Většinu kódu obsahuje některé ověření parametru ve formě `if` - `then` - `throw` kódu.</span><span class="sxs-lookup"><span data-stu-id="988b5-133">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="988b5-134">Nástroje pro kontrakt rozpoznat tyto příkazy jako předpoklady v následujících případech:</span><span class="sxs-lookup"><span data-stu-id="988b5-134">The contract tools recognize these statements as preconditions in the following cases:</span></span>  
  
-   <span data-ttu-id="988b5-135">Příkazy se zobrazí před jiné příkazy v metodě.</span><span class="sxs-lookup"><span data-stu-id="988b5-135">The statements appear before any other statements in a method.</span></span>  
  
-   <span data-ttu-id="988b5-136">Celá sada těchto příkazů následuje explicitního <xref:System.Diagnostics.Contracts.Contract> volání metody, jako je například volání <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, nebo <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-136">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>  
  
 <span data-ttu-id="988b5-137">Když `if` - `then` - `throw` příkazy zobrazí v tomto formuláři je nástroje rozpozná jako zastaralé `requires` příkazy.</span><span class="sxs-lookup"><span data-stu-id="988b5-137">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="988b5-138">Pokud postupovat podle žádné jiných smluv `if` - `then` - `throw` pořadí, koncová kód <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-138">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>  
  
```  
if ( x == null ) throw new ...  
Contract.EndContractBlock(); // All previous "if" checks are preconditions  
```  
  
 <span data-ttu-id="988b5-139">Všimněte si, že podmínka v předchozím testu posunut předběžnou podmínku.</span><span class="sxs-lookup"><span data-stu-id="988b5-139">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="988b5-140">(Skutečné předběžnou by `x != null`.) Posunut předběžné podmínky je vysoce omezenou: musí být napsané, jak je znázorněno v předchozím příkladu; To znamená, měl by obsahovat žádné `else` klauzule a text `then` klauzule musí být jediný `throw` příkaz.</span><span class="sxs-lookup"><span data-stu-id="988b5-140">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="988b5-141">`if` Testovací podléhá pravidla čistotu a viditelnost (najdete v části [pokyny týkající se používání](#usage_guidelines)), ale `throw` výrazu je podmíněno pouze čistotu pravidla.</span><span class="sxs-lookup"><span data-stu-id="988b5-141">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="988b5-142">Typ výjimky však musí být jako viditelné jako metodu dojde k kontrakt.</span><span class="sxs-lookup"><span data-stu-id="988b5-142">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>  
  
## <a name="postconditions"></a><span data-ttu-id="988b5-143">Vstupních</span><span class="sxs-lookup"><span data-stu-id="988b5-143">Postconditions</span></span>  
 <span data-ttu-id="988b5-144">Vstupních jsou kontrakty stavu metodu, když ho ukončí.</span><span class="sxs-lookup"><span data-stu-id="988b5-144">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="988b5-145">Těsně před ukončení metody se kontroluje koncová podmínka.</span><span class="sxs-lookup"><span data-stu-id="988b5-145">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="988b5-146">Chování běhové selhání vstupních je určen podle analyzátor modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="988b5-146">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>  
  
 <span data-ttu-id="988b5-147">Na rozdíl od předběžných podmínek vstupních odkazy na členy s menší viditelnosti.</span><span class="sxs-lookup"><span data-stu-id="988b5-147">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="988b5-148">Klient nemusí mít k pochopení nebo k používání některé z informací vyjádřená koncová podmínka pomocí privátní stavu, ale neovlivňuje to možnost klienta lze pomocí této metody správně.</span><span class="sxs-lookup"><span data-stu-id="988b5-148">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>  
  
### <a name="standard-postconditions"></a><span data-ttu-id="988b5-149">Standardní vstupních</span><span class="sxs-lookup"><span data-stu-id="988b5-149">Standard Postconditions</span></span>  
 <span data-ttu-id="988b5-150">Standardní vstupních lze vyjádřit pomocí <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-150">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="988b5-151">Vstupních express podmínku, která musí být `true` při normálním ukončení metody.</span><span class="sxs-lookup"><span data-stu-id="988b5-151">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>  
  
 `Contract.Ensures( this.F > 0 );`  
  
### <a name="exceptional-postconditions"></a><span data-ttu-id="988b5-152">Výjimečně vysoké počty vstupních</span><span class="sxs-lookup"><span data-stu-id="988b5-152">Exceptional Postconditions</span></span>  
 <span data-ttu-id="988b5-153">Výjimečně vysoké počty vstupních jsou vstupních, které by měly být `true` při je vyvolána výjimka konkrétní metodou.</span><span class="sxs-lookup"><span data-stu-id="988b5-153">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="988b5-154">Zadávat lze tyto vstupních pomocí <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> metoda, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="988b5-154">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>  
  
 `Contract.EnsuresOnThrow<T>( this.F > 0 );`  
  
 <span data-ttu-id="988b5-155">Argument je podmínku, která musí být `true` vždy, když výjimku, která je podtypem `T` je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="988b5-155">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>  
  
 <span data-ttu-id="988b5-156">Existují některé typy výjimky, které je obtížné používat ve výjimečných koncová podmínka.</span><span class="sxs-lookup"><span data-stu-id="988b5-156">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="988b5-157">Například pomocí typu <xref:System.Exception> pro `T` vyžaduje metoda zaručit podmínku bez ohledu na typ výjimky, která je vyvolána, i když je k přetečení zásobníku nebo jiné možné řízení výjimky.</span><span class="sxs-lookup"><span data-stu-id="988b5-157">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="988b5-158">Výjimečně vysoké počty vstupních byste měli použít pouze pro konkrétní výjimky, které mohou být vyvolány, když členem je volána, například když <xref:System.InvalidTimeZoneException> je vyvolána pro <xref:System.TimeZoneInfo> volání metody.</span><span class="sxs-lookup"><span data-stu-id="988b5-158">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>  
  
### <a name="special-postconditions"></a><span data-ttu-id="988b5-159">Speciální vstupních</span><span class="sxs-lookup"><span data-stu-id="988b5-159">Special Postconditions</span></span>  
 <span data-ttu-id="988b5-160">Pouze v rámci vstupních lze použít následující metody:</span><span class="sxs-lookup"><span data-stu-id="988b5-160">The following methods may be used only within postconditions:</span></span>  
  
-   <span data-ttu-id="988b5-161">Může být metoda návratové hodnoty v vstupních pomocí výrazu `Contract.Result<T>()`, kde `T` je nahrazena návratový typ metody.</span><span class="sxs-lookup"><span data-stu-id="988b5-161">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="988b5-162">Když kompilátor není schopen odvození typu, je nutné ho zadat explicitně.</span><span class="sxs-lookup"><span data-stu-id="988b5-162">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="988b5-163">Například se nepodařilo odvodit typy pro metody, které nepřebírají žádné argumenty, takže vyžaduje následující koncová podmínka kompilátor jazyka C#: `Contract.Ensures(0 <Contract.Result<int>())` metody s návratovým typem `void` nemůže odkazovat na `Contract.Result<T>()` v jejich vstupních.</span><span class="sxs-lookup"><span data-stu-id="988b5-163">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>  
  
-   <span data-ttu-id="988b5-164">Hodnotu prestate v koncová podmínka odkazuje na hodnotu výrazu na začátku metody nebo vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="988b5-164">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="988b5-165">Používá výraz `Contract.OldValue<T>(e)`, kde `T` je typ `e`.</span><span class="sxs-lookup"><span data-stu-id="988b5-165">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="988b5-166">Vždy, když je schopen odvodit typ kompilátor, můžete vynechat argument obecného typu.</span><span class="sxs-lookup"><span data-stu-id="988b5-166">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="988b5-167">(Například kompilátor jazyka C# vždy odvodí typ vzhledem k tomu, jak dlouho trvá argument.) Existuje několik omezení na co se může objevit v `e` a kontexty, ve kterých se může zobrazit staré výrazu.</span><span class="sxs-lookup"><span data-stu-id="988b5-167">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="988b5-168">Původní výraz nemůže obsahovat další původní výraz.</span><span class="sxs-lookup"><span data-stu-id="988b5-168">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="988b5-169">Co je nejdůležitější – původní výraz musí odkazovat na hodnotu, které existovalo v metody předběžnou stavu.</span><span class="sxs-lookup"><span data-stu-id="988b5-169">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="988b5-170">Jinými slovy, musí být výraz, který lze vyhodnotit tak dlouho, dokud je předběžnou metody `true`.</span><span class="sxs-lookup"><span data-stu-id="988b5-170">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="988b5-171">Tady jsou několik instancí daného pravidla.</span><span class="sxs-lookup"><span data-stu-id="988b5-171">Here are several instances of that rule.</span></span>  
  
    -   <span data-ttu-id="988b5-172">Hodnota musí existovat ve stavu metoda předběžnou podmínku.</span><span class="sxs-lookup"><span data-stu-id="988b5-172">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="988b5-173">Chcete-li odkazovat na pole v objektu, musí zaručit předběžných podmínek, tento objekt je vždy nesmí být nulová.</span><span class="sxs-lookup"><span data-stu-id="988b5-173">In order to reference a field on an object, the preconditions must guarantee that that object is always non-null.</span></span>  
  
    -   <span data-ttu-id="988b5-174">Nemůže odkazovat na návratovou hodnotu metody ve staré výrazu:</span><span class="sxs-lookup"><span data-stu-id="988b5-174">You cannot refer to the method's return value in an old expression:</span></span>  
  
        ```  
        Contract.OldValue(Contract.Result<int>() + x) // ERROR  
        ```  
  
    -   <span data-ttu-id="988b5-175">Nemůže odkazovat na `out` parametry v původním výrazu.</span><span class="sxs-lookup"><span data-stu-id="988b5-175">You cannot refer to `out` parameters in an old expression.</span></span>  
  
    -   <span data-ttu-id="988b5-176">Původní výraz nemůže záviset na vázané proměnná kvantifikátor, pokud rozsah kvantifikátoru závisí na návratovou hodnotu metody:</span><span class="sxs-lookup"><span data-stu-id="988b5-176">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>  
  
        ```  
        Contract. ForAll (0,Contract. Result<int>(),  
        i => Contract.OldValue(xs[i]) > 3); // ERROR  
        ```  
  
    -   <span data-ttu-id="988b5-177">Původní výraz nemůže odkazovat na parametr anonymní delegáta v <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> nebo <xref:System.Diagnostics.Contracts.Contract.Exists%2A> volat, pokud se používá jako indexer nebo argument pro volání metody:</span><span class="sxs-lookup"><span data-stu-id="988b5-177">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>  
  
        ```  
        Contract. ForAll (0, xs .Length, i => Contract.OldValue(xs[i]) > 3); // OK  
        Contract. ForAll (0, xs .Length, i => Contract.OldValue(i) > 3); // ERROR  
        ```  
  
    -   <span data-ttu-id="988b5-178">Původní výraz nemůže proběhnout, v těle delegáta anonymní Pokud hodnotu staré výrazu závisí na některý z parametrů anonymní delegáta, není-li anonymní delegát argumentu <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> nebo <xref:System.Diagnostics.Contracts.Contract.Exists%2A> metoda:</span><span class="sxs-lookup"><span data-stu-id="988b5-178">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>  
  
        ```  
        Method( ... (T t) => Contract.OldValue(... t ...) ... ); // ERROR  
        ```  
  
    -   <span data-ttu-id="988b5-179">`Out` Parametry představovat problém, protože kontrakty zobrazí před těla metody a většina kompilátory neumožňují odkazy na `out` vstupních parametrů.</span><span class="sxs-lookup"><span data-stu-id="988b5-179">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="988b5-180">Chcete tento problém vyřešit <xref:System.Diagnostics.Contracts.Contract> třída poskytuje <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> metoda, která umožňuje koncová podmínka na základě `out` parametr.</span><span class="sxs-lookup"><span data-stu-id="988b5-180">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>  
  
        ```  
        public void OutParam(out int x) f  
        Contract.Ensures(Contract.ValueAtReturn(out x) == 3);  
        x = 3;  
        ```  
  
         <span data-ttu-id="988b5-181">Stejně jako u <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metodu, můžete vynechat parametr obecného typu vždy, když je schopen odvodit typ kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="988b5-181">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="988b5-182">Kontrakt RW nahradí hodnotu volání metody, které `out` parametr.</span><span class="sxs-lookup"><span data-stu-id="988b5-182">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="988b5-183"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> Metoda se mohou objevit pouze v vstupních.</span><span class="sxs-lookup"><span data-stu-id="988b5-183">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="988b5-184">Argument pro metodu musí být `out` , nebo parametr pole strukturou `out` parametr.</span><span class="sxs-lookup"><span data-stu-id="988b5-184">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="988b5-185">Je také užitečná k odkazování na pole v koncová podmínka struktura konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="988b5-185">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
        > [!NOTE]
        >  <span data-ttu-id="988b5-186">V současné době nástrojů pro analýzu kontrakt kódu nekontrolují zda `out` parametry jsou správně inicializována a jejich zmínky v koncová podmínka ignorovat.</span><span class="sxs-lookup"><span data-stu-id="988b5-186">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="988b5-187">Proto v předchozím příkladu, řádek po kontrakt použití hodnotu `x` místo celé přiřazení k němu, kompilátor by vystavovat opravte chyby.</span><span class="sxs-lookup"><span data-stu-id="988b5-187">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="988b5-188">Ale na sestavení, kde je symbol preprocesoru CONTRACTS_FULL není definována (takové asa sestavení pro vydání), kompilátor dojde k chybě.</span><span class="sxs-lookup"><span data-stu-id="988b5-188">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>  
  
## <a name="invariants"></a><span data-ttu-id="988b5-189">Výstupních podmínek</span><span class="sxs-lookup"><span data-stu-id="988b5-189">Invariants</span></span>  
 <span data-ttu-id="988b5-190">Objekt výstupních podmínek jsou podmínky, které by měly být vždy, když je objekt viditelný pro klienta pro každou instanci třídy na hodnotu true.</span><span class="sxs-lookup"><span data-stu-id="988b5-190">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="988b5-191">Jejich express podmínky, za kterých se považuje za správný objekt.</span><span class="sxs-lookup"><span data-stu-id="988b5-191">They express the conditions under which the object is considered to be correct.</span></span>  
  
 <span data-ttu-id="988b5-192">Neutrální metody jsou určeny označit s <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="988b5-192">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="988b5-193">Neutrální metody musejí obsahovat žádný kód s výjimkou pořadí volání <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> metoda, z nichž každý určuje jednotlivé neutrální, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="988b5-193">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>  
  
```  
[ContractInvariantMethod]  
protected void ObjectInvariant ()   
{  
Contract.Invariant(this.y >= 0);  
Contract.Invariant(this.x > this.y);  
...  
}  
```  
  
 <span data-ttu-id="988b5-194">Výstupních podmínek jsou definovány podmíněně symbol preprocesoru CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="988b5-194">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="988b5-195">Při kontrole, spuštění, se kontroluje výstupních podmínek na konci každé veřejná metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-195">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="988b5-196">Pokud neutrální uvádí veřejná metoda ve stejné třídě, invariantní zkontrolujte, jestli by se stalo normálně na konci této veřejné metody je zakázané.</span><span class="sxs-lookup"><span data-stu-id="988b5-196">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="988b5-197">Místo toho kontrola probíhá pouze na konci volání nejkrajnější metody do třídy.</span><span class="sxs-lookup"><span data-stu-id="988b5-197">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="988b5-198">Také se to stane, když je třída opětovný vstup z důvodu volání metody na jiné třídy.</span><span class="sxs-lookup"><span data-stu-id="988b5-198">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="988b5-199">Výstupních podmínek není zaškrtnuta možnost pro finalizační metody objektu nebo pro všechny metody, které implementují <xref:System.IDisposable.Dispose%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-199">Invariants are not checked for object finalizers or for any methods that implement the <xref:System.IDisposable.Dispose%2A> method.</span></span>  
  
<a name="usage_guidelines"></a>   
## <a name="usage-guidelines"></a><span data-ttu-id="988b5-200">Pokyny týkající se používání</span><span class="sxs-lookup"><span data-stu-id="988b5-200">Usage Guidelines</span></span>  
  
### <a name="contract-ordering"></a><span data-ttu-id="988b5-201">Kontrakt řazení</span><span class="sxs-lookup"><span data-stu-id="988b5-201">Contract Ordering</span></span>  
 <span data-ttu-id="988b5-202">Následující tabulka uvádí prvky, které byste měli používat při zápisu metoda kontrakty pořadí.</span><span class="sxs-lookup"><span data-stu-id="988b5-202">The following table shows the order of elements you should use when you write method contracts.</span></span>  
  
|`If-then-throw statements`|<span data-ttu-id="988b5-203">Veřejné předběžné podmínky zpětně kompatibilní</span><span class="sxs-lookup"><span data-stu-id="988b5-203">Backward-compatible public preconditions</span></span>|  
|-|-|  
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="988b5-204">Všechny veřejné předběžné podmínky.</span><span class="sxs-lookup"><span data-stu-id="988b5-204">All public preconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="988b5-205">Všechny veřejné vstupních (normální).</span><span class="sxs-lookup"><span data-stu-id="988b5-205">All public (normal) postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="988b5-206">Všechny veřejné výjimečných vstupních.</span><span class="sxs-lookup"><span data-stu-id="988b5-206">All public exceptional postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="988b5-207">Všechny privátní nebo interní (normální) vstupních.</span><span class="sxs-lookup"><span data-stu-id="988b5-207">All private/internal (normal) postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="988b5-208">Všechny privátní nebo interní výjimečných vstupních.</span><span class="sxs-lookup"><span data-stu-id="988b5-208">All private/internal exceptional postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="988b5-209">Pokud používáte `if` - `then` - `throw` styl předběžné podmínky bez jiných smluv, umístěte volání <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> k označení, že všechny předchozí, pokud byly kontroly předběžné podmínky.</span><span class="sxs-lookup"><span data-stu-id="988b5-209">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|  
  
<a name="purity"></a>   
### <a name="purity"></a><span data-ttu-id="988b5-210">Čistotu</span><span class="sxs-lookup"><span data-stu-id="988b5-210">Purity</span></span>  
 <span data-ttu-id="988b5-211">Všechny metody, které se nazývají v rámci smlouvy musí být čistý; To znamená že nesmí aktualizovat všechny dříve existující stav.</span><span class="sxs-lookup"><span data-stu-id="988b5-211">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="988b5-212">Čistý metoda je dovoleno upravit objekty, které byly vytvořeny po vstupu v čistě metoda.</span><span class="sxs-lookup"><span data-stu-id="988b5-212">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>  
  
 <span data-ttu-id="988b5-213">Kód kontraktu nástroje aktuálně předpokládají, že jsou čistá následující elementy kódu:</span><span class="sxs-lookup"><span data-stu-id="988b5-213">Code contract tools currently assume that the following code elements are pure:</span></span>  
  
-   <span data-ttu-id="988b5-214">Metody, které jsou označené <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="988b5-214">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>  
  
-   <span data-ttu-id="988b5-215">Typy, které jsou označené <xref:System.Diagnostics.Contracts.PureAttribute> (atribut platí pro všechny metody tohoto typu).</span><span class="sxs-lookup"><span data-stu-id="988b5-215">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>  
  
-   <span data-ttu-id="988b5-216">Vlastnost získat přístupové objekty.</span><span class="sxs-lookup"><span data-stu-id="988b5-216">Property get accessors.</span></span>  
  
-   <span data-ttu-id="988b5-217">Operátory (statických metod, jejichž název začíná "op" a že máte jeden nebo dva parametry a návratový typ není void).</span><span class="sxs-lookup"><span data-stu-id="988b5-217">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>  
  
-   <span data-ttu-id="988b5-218">Libovolné metody, jejichž plně kvalifikovaný název začíná řetězcem "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path" nebo "System.Type".</span><span class="sxs-lookup"><span data-stu-id="988b5-218">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>  
  
-   <span data-ttu-id="988b5-219">Žádné vyvolání delegáta, za předpokladu, že je opatřená vlastní typ delegáta <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="988b5-219">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="988b5-220">Typy delegáta <xref:System.Predicate%601?displayProperty=nameWithType> a <xref:System.Comparison%601?displayProperty=nameWithType> jsou považovány za čistý.</span><span class="sxs-lookup"><span data-stu-id="988b5-220">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>  
  
<a name="visibility"></a>   
### <a name="visibility"></a><span data-ttu-id="988b5-221">Viditelnost</span><span class="sxs-lookup"><span data-stu-id="988b5-221">Visibility</span></span>  
 <span data-ttu-id="988b5-222">Všichni členové uvedených ve smlouvě musí být viditelné jako metodu, ve kterém se zobrazí.</span><span class="sxs-lookup"><span data-stu-id="988b5-222">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="988b5-223">Například soukromé pole nelze v uvést předpokladem pro veřejná metoda; klienty nelze ověřit takovou smlouvu, než se volat metodu.</span><span class="sxs-lookup"><span data-stu-id="988b5-223">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="988b5-224">Ale pokud je označené pole <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, je vyloučit z těchto pravidel.</span><span class="sxs-lookup"><span data-stu-id="988b5-224">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>  
  
## <a name="example"></a><span data-ttu-id="988b5-225">Příklad</span><span class="sxs-lookup"><span data-stu-id="988b5-225">Example</span></span>  
 <span data-ttu-id="988b5-226">Následující příklad ukazuje použití kontrakty kódu.</span><span class="sxs-lookup"><span data-stu-id="988b5-226">The following example shows the use of code contracts.</span></span>  
  
 [!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
 [!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
