---
title: Verze služby
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
caps.latest.revision: 19
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: fef65a4134f1cf526a7082b08aa4d8d1c6ea7f4d
ms.sourcegitcommit: 94d33cadc5ff81d2ac389bf5f26422c227832052
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/30/2018
---
# <a name="service-versioning"></a><span data-ttu-id="ef516-102">Verze služby</span><span class="sxs-lookup"><span data-stu-id="ef516-102">Service Versioning</span></span>
<span data-ttu-id="ef516-103">Po počátečním nasazení a potenciálně několikrát během své životnosti může potřebovat služby (a koncových bodů, které vystavují) se musí změnit z různých důvodů, jako je například změna obchodních potřeb, požadavků informačních technologií, nebo k jiné řešení problémy.</span><span class="sxs-lookup"><span data-stu-id="ef516-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="ef516-104">Každé změně zavádí novou verzi služby.</span><span class="sxs-lookup"><span data-stu-id="ef516-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="ef516-105">Toto téma vysvětluje, jak vzít v úvahu správu verzí v [!INCLUDE[indigo1](../../../includes/indigo1-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ef516-105">This topic explains how to consider versioning in [!INCLUDE[indigo1](../../../includes/indigo1-md.md)].</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="ef516-106">Čtyř kategorií změny služby</span><span class="sxs-lookup"><span data-stu-id="ef516-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="ef516-107">Změny služby, které mohou být vyžadovány lze rozdělit do několika kategorií:</span><span class="sxs-lookup"><span data-stu-id="ef516-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
-   <span data-ttu-id="ef516-108">Sbalit změny: například operace, které mohou být přidány nebo datový prvek ve zprávě může přidat nebo změnit.</span><span class="sxs-lookup"><span data-stu-id="ef516-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
-   <span data-ttu-id="ef516-109">Adresa změny: například služby přesune do jiného umístění, kde koncové body mají nové adresy.</span><span class="sxs-lookup"><span data-stu-id="ef516-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
-   <span data-ttu-id="ef516-110">Vazba změny: například změní mechanismus zabezpečení nebo změnit jeho nastavení.</span><span class="sxs-lookup"><span data-stu-id="ef516-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
-   <span data-ttu-id="ef516-111">Implementace změny: při implementaci interní metoda například změní.</span><span class="sxs-lookup"><span data-stu-id="ef516-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="ef516-112">Mezi tyto změny se používá označení "ukončování" a jiné jsou "Pevná".</span><span class="sxs-lookup"><span data-stu-id="ef516-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="ef516-113">Je změna *pevných* Pokud jsou v nové verzi úspěšně zpracovala všechny zprávy, které by byly zpracovány úspěšně v předchozí verzi.</span><span class="sxs-lookup"><span data-stu-id="ef516-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="ef516-114">Všechny změny, který nesplňuje splnění tohoto kritéria se *nejnovější* změnit.</span><span class="sxs-lookup"><span data-stu-id="ef516-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="ef516-115">Orientaci na služby a správa verzí</span><span class="sxs-lookup"><span data-stu-id="ef516-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="ef516-116">Jedním z principů orientaci na služby je, že jsou služby a klienti autonomního (nebo nezávislé).</span><span class="sxs-lookup"><span data-stu-id="ef516-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="ef516-117">Kromě jiných věcí to znamená, že vývojáři služeb nelze předpokládat, že řízení nebo i vědět o všech klientech služby.</span><span class="sxs-lookup"><span data-stu-id="ef516-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="ef516-118">Tím se eliminuje možnost znovu sestavit a znovu nasazovat všichni klienti, když service změny verze.</span><span class="sxs-lookup"><span data-stu-id="ef516-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="ef516-119">Toto téma předpokládá službu dodržuje tento principem a proto musí být změněné nebo "verzí" bez ohledu na jeho klienty.</span><span class="sxs-lookup"><span data-stu-id="ef516-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="ef516-120">V případě narušující změně neočekávaná a se nelze vyhnout spojení aplikace rozhodnout ignorovat tuto principem a vyžadovat, klienty znovu sestavit a znovu nasadit s novou verzí služby.</span><span class="sxs-lookup"><span data-stu-id="ef516-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="ef516-121">Správa verzí kontraktů</span><span class="sxs-lookup"><span data-stu-id="ef516-121">Contract Versioning</span></span>  
 <span data-ttu-id="ef516-122">Kontrakty používaný klientem nemusí být stejný jako kontrakt, který používá služba; potřebují pouze, aby byla kompatibilní.</span><span class="sxs-lookup"><span data-stu-id="ef516-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="ef516-123">Pro kontraktů služby kompatibility přidáním nových operací znamená vystavený službou, ale existující operace nelze odebrat nebo změnit sémanticky.</span><span class="sxs-lookup"><span data-stu-id="ef516-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="ef516-124">Pro datové kontrakty kompatibilita znamená nový typ schématu, které lze přidat definice ale existující definice typu schématu nelze změnit v nejnovější způsoby.</span><span class="sxs-lookup"><span data-stu-id="ef516-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="ef516-125">Nejnovější změny mohou zahrnovat odebrání datových členů nebo incompatibly Změna datového typu.</span><span class="sxs-lookup"><span data-stu-id="ef516-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="ef516-126">Tato funkce umožňuje službě některé zeměpisnou šířku při změně verze jeho kontrakty, aniž by vás klientů.</span><span class="sxs-lookup"><span data-stu-id="ef516-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="ef516-127">V následujících dvou oddílech se popisuje pevná a dodatečné změny, které můžete provedeny [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] kontraktů dat a služby.</span><span class="sxs-lookup"><span data-stu-id="ef516-127">The next two sections explain nonbreaking and breaking changes that can be made to [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="ef516-128">Správa verzí kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="ef516-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="ef516-129">Tato část pojednává o Správa verzí dat při použití <xref:System.Runtime.Serialization.DataContractSerializer> a <xref:System.Runtime.Serialization.DataContractAttribute> třídy.</span><span class="sxs-lookup"><span data-stu-id="ef516-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="ef516-130">Striktní Správa verzí</span><span class="sxs-lookup"><span data-stu-id="ef516-130">Strict Versioning</span></span>  
 <span data-ttu-id="ef516-131">V mnoha scénářích při změně verze je nějaký problém, developer služby nemá kontrolu nad klienty a proto nelze provést, předpoklady o tom, jak bude reagovat na změny ve zprávě XML nebo schéma.</span><span class="sxs-lookup"><span data-stu-id="ef516-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="ef516-132">V těchto případech musí zaručit, že bude nové zprávy ověření pro původní schéma, dvou důvodů:</span><span class="sxs-lookup"><span data-stu-id="ef516-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
-   <span data-ttu-id="ef516-133">Původní klienty byly vyvinuty s za předpokladu, že nedojde ke změně schématu.</span><span class="sxs-lookup"><span data-stu-id="ef516-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="ef516-134">Může se nepodaří zpracovat zprávy, které nebyly nikdy nebyl navržený pro.</span><span class="sxs-lookup"><span data-stu-id="ef516-134">They may fail to process messages that they were never designed for.</span></span>  
  
-   <span data-ttu-id="ef516-135">Původní klienti mohou provádět skutečné schéma ověřování pro původní schéma před i pokusu o zpracování zprávy.</span><span class="sxs-lookup"><span data-stu-id="ef516-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="ef516-136">Doporučený přístup v takových případech je považovat za existující kontrakty dat neměnné a vytvořit nové položky obsahující jedinečný XML kvalifikované názvy.</span><span class="sxs-lookup"><span data-stu-id="ef516-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="ef516-137">Vývojář služby by pak buď přidejte nové metody existující servisní smlouvou nebo vytvořit nový kontrakt služby s metodami, které používají nové kontrakt dat.</span><span class="sxs-lookup"><span data-stu-id="ef516-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="ef516-138">Často bude případě, že vývojář služby potřebuje k zápisu některé obchodní logiky, která by měla spustit ve všech verzích kontrakt dat plus specifické pro verzi obchodní kód pro každou verzi kontrakt dat.</span><span class="sxs-lookup"><span data-stu-id="ef516-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="ef516-139">Příloha na konci tohoto tématu vysvětluje, jak lze pomocí rozhraní splnění tohoto požadavku.</span><span class="sxs-lookup"><span data-stu-id="ef516-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="ef516-140">Hodnotě lax Správa verzí</span><span class="sxs-lookup"><span data-stu-id="ef516-140">Lax Versioning</span></span>  
 <span data-ttu-id="ef516-141">V mnoha jiných scénářích vývojáře služby můžete provést za předpokladu, že přidání nové, volitelné člena do kontrakt dat nebudou porušovat existující klienti.</span><span class="sxs-lookup"><span data-stu-id="ef516-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="ef516-142">To vyžaduje, aby služba vývojáři prozkoumat, jestli existující klienti nejsou provádění ověřování schématu a s jejich ignorovat členy dat je neznámý.</span><span class="sxs-lookup"><span data-stu-id="ef516-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="ef516-143">V těchto scénářích je možné využít výhod funkce kontraktu dat pro přidání nové členy pevných způsobem.</span><span class="sxs-lookup"><span data-stu-id="ef516-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="ef516-144">Vývojář služby mohou být tento předpoklad s jistotou, pokud funkce kontraktu dat pro správu verzí, již byly použity pro první verzi služby.</span><span class="sxs-lookup"><span data-stu-id="ef516-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]<span data-ttu-id="ef516-145">, Webových služeb ASP.NET a mnoho dalších podpora webové služby zásobníky *hodnotě lax Správa verzí*: to znamená, že nevyvolá výjimku výjimky pro nové členy dat je neznámý v přijatá data.</span><span class="sxs-lookup"><span data-stu-id="ef516-145">, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="ef516-146">Je snadné se omylem domnívat, že přidání nového člena nebudou porušovat existující klienti.</span><span class="sxs-lookup"><span data-stu-id="ef516-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="ef516-147">Pokud si nejste jistí, že všichni klienti dokáže zpracovat hodnotě lax Správa verzí, doporučuje se považovat data a postupujte podle pokynů striktní Správa verzí kontraktů jako neměnné.</span><span class="sxs-lookup"><span data-stu-id="ef516-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="ef516-148">Podrobné pokyny k hodnotě lax a striktní Správa verzí kontraktů dat najdete v části [osvědčené postupy: Správa verzí kontraktů dat](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="ef516-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="ef516-149">Rozlišit kontrakt dat a typů .NET</span><span class="sxs-lookup"><span data-stu-id="ef516-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="ef516-150">Rozhraní .NET třídu nebo strukturu můžete použít k projekci jako kontraktu dat s použitím <xref:System.Runtime.Serialization.DataContractAttribute> atribut třídy.</span><span class="sxs-lookup"><span data-stu-id="ef516-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="ef516-151">Typ formátu .NET a její projekce kontraktu dat jsou dvě odlišné záleží.</span><span class="sxs-lookup"><span data-stu-id="ef516-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="ef516-152">Je možné, že více typů .NET s stejné projekce kontrakt data.</span><span class="sxs-lookup"><span data-stu-id="ef516-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="ef516-153">Tento rozdíl je obzvláště užitečná při umožňuje změnit typ formátu .NET při zachování kontrakt předpokládané dat, a tím zachování kompatibility s existující klienty i v tom smyslu striktní aplikace word.</span><span class="sxs-lookup"><span data-stu-id="ef516-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="ef516-154">Existují dvě věci, které byste měli vždy udělat udržovat tento rozdíl mezi kontrakt .NET typu a data:</span><span class="sxs-lookup"><span data-stu-id="ef516-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
-   <span data-ttu-id="ef516-155">Zadejte <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> a <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="ef516-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="ef516-156">Musíte vždycky zadat název a obor názvů vaší kontrakt dat, aby se zabránilo typ formátu .NET název oboru názvů vystavení v kontraktu.</span><span class="sxs-lookup"><span data-stu-id="ef516-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="ef516-157">Tímto způsobem, pokud se později rozhodnete změnit obor názvů .NET nebo zadejte název, kontrakt dat se nezmění.</span><span class="sxs-lookup"><span data-stu-id="ef516-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
-   <span data-ttu-id="ef516-158">Zadejte <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="ef516-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="ef516-159">Musíte vždycky zadat název datových členů, aby název člena .NET vystavení v kontraktu.</span><span class="sxs-lookup"><span data-stu-id="ef516-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="ef516-160">Tímto způsobem, pokud se rozhodnete později změnit název .NET člena, vaše kontrakt dat se nezmění.</span><span class="sxs-lookup"><span data-stu-id="ef516-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="ef516-161">Změně nebo odebrání členů</span><span class="sxs-lookup"><span data-stu-id="ef516-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="ef516-162">Změna názvu nebo datového typu člena nebo odebrání datových členů je i v případě, že je povoleno hodnotě lax Správa verzí narušující změně.</span><span class="sxs-lookup"><span data-stu-id="ef516-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="ef516-163">Pokud je to nutné, vytvořte nové smlouvy data.</span><span class="sxs-lookup"><span data-stu-id="ef516-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="ef516-164">Pokud je služba kompatibility vysokou důležitost, můžete zvážit ignoruje nepoužívané datových členů v kódu a ponechejte je na místě.</span><span class="sxs-lookup"><span data-stu-id="ef516-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="ef516-165">Pokud jsou rozdělení členem data do více členů, můžete zvážit, a existujícího člena v místě jako vlastnost, která lze provést požadované rozdělením a opakované agregaci pro klienty nižší úrovně (klientů, které nejsou upgradovány na nejnovější verzi).</span><span class="sxs-lookup"><span data-stu-id="ef516-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="ef516-166">Podobně platí jsou změny název nebo obor názvů kontraktu dat nejnovější změny.</span><span class="sxs-lookup"><span data-stu-id="ef516-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="ef516-167">Uložení dat je neznámý</span><span class="sxs-lookup"><span data-stu-id="ef516-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="ef516-168">V některých případech je potřeba "odezvy" Neznámý data, která pochází z členů přidaných v nové verzi.</span><span class="sxs-lookup"><span data-stu-id="ef516-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="ef516-169">Například "versionNew" service odešle data pomocí některé nově přidat členy do klienta "versionOld".</span><span class="sxs-lookup"><span data-stu-id="ef516-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="ef516-170">Klient ignoruje nově přidaných členů při zpracování zprávy, ale opětovně odešle tato data, včetně nově přidaných členů zpět ke službě versionNew.</span><span class="sxs-lookup"><span data-stu-id="ef516-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="ef516-171">Typické scénáře je aktualizace dat, kde získaný ze služby, změnit a vrácená data.</span><span class="sxs-lookup"><span data-stu-id="ef516-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="ef516-172">Pokud chcete povolit odezvy pro určitý typ, musí typ implementovat <xref:System.Runtime.Serialization.IExtensibleDataObject> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="ef516-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="ef516-173">Rozhraní obsahuje jednu vlastnost <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> , který vrací <xref:System.Runtime.Serialization.ExtensionDataObject> typu.</span><span class="sxs-lookup"><span data-stu-id="ef516-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="ef516-174">Vlastnost se používá k ukládání dat v budoucích verzích kontrakt dat, který neznámý na aktuální verzi.</span><span class="sxs-lookup"><span data-stu-id="ef516-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="ef516-175">Tato data jsou neprůhledné klientovi, ale v případě, že instance je serializováno, obsah <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> vlastnosti zapisují se zbytkem datové kontrakt členy se data.</span><span class="sxs-lookup"><span data-stu-id="ef516-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="ef516-176">Doporučuje se, že všechny typy implementovat toto rozhraní pro uložení nové a neznámé budoucí členy.</span><span class="sxs-lookup"><span data-stu-id="ef516-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="ef516-177">Knihovny kontraktu dat</span><span class="sxs-lookup"><span data-stu-id="ef516-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="ef516-178">Může být knihovny kontraktů dat kontraktu je publikovaná v centrálním úložišti, kde služby a typ implementátory implementovat a vystavit kontrakty dat z tohoto úložiště.</span><span class="sxs-lookup"><span data-stu-id="ef516-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="ef516-179">V takovém případě při publikování kontraktu dat do úložiště, nemáte žádnou kontrolu nad kdo vytvoří typy, které implementují ho.</span><span class="sxs-lookup"><span data-stu-id="ef516-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="ef516-180">Proto se nedá změnit kontrakt po publikování, vykreslování efektivně neměnné.</span><span class="sxs-lookup"><span data-stu-id="ef516-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="ef516-181">Při používání třídy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="ef516-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="ef516-182">Při použití platí stejné zásady správy verzí <xref:System.Xml.Serialization.XmlSerializer> třídy.</span><span class="sxs-lookup"><span data-stu-id="ef516-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="ef516-183">Pokud se vyžaduje striktní Správa verzí, považovat za kontrakty dat neměnné a vytvořte nové kontrakty dat s jedinečná a kvalifikované názvy pro nové verze.</span><span class="sxs-lookup"><span data-stu-id="ef516-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="ef516-184">Pokud jste si jisti, že může být použita hodnotě lax Správa verzí, můžete přidat nové serializovatelné členy v nové verze, ale není změnit nebo odebrat existující členy.</span><span class="sxs-lookup"><span data-stu-id="ef516-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef516-185"><xref:System.Xml.Serialization.XmlSerializer> Používá <xref:System.Xml.Serialization.XmlAnyElementAttribute> a <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> atributy pro podporu odezvy dat je neznámý.</span><span class="sxs-lookup"><span data-stu-id="ef516-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="ef516-186">Správa verzí kontraktů zpráv</span><span class="sxs-lookup"><span data-stu-id="ef516-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="ef516-187">Pokyny pro Správa verzí kontraktů zpráv jsou velmi podobné kontrakty dat správy verzí.</span><span class="sxs-lookup"><span data-stu-id="ef516-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="ef516-188">Pokud se vyžaduje striktní Správa verzí, by měl nemění vaše tělo zprávy ale místo toho vytvořte nové kontrakt zprávy s jedinečným názvem kvalifikovaný.</span><span class="sxs-lookup"><span data-stu-id="ef516-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="ef516-189">Pokud víte, které můžete použít hodnotě lax Správa verzí, nelze přidat nové části textu zprávy, ale změnit nebo odebrat existující.</span><span class="sxs-lookup"><span data-stu-id="ef516-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="ef516-190">Tyto pokyny platí i pro úplné a zabalit kontrakty zpráv.</span><span class="sxs-lookup"><span data-stu-id="ef516-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="ef516-191">Hlavičky zpráv můžete kdykoli přidat, i když striktní správy verzí je používán.</span><span class="sxs-lookup"><span data-stu-id="ef516-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="ef516-192">Příznak MustUnderstand může mít vliv na správu verzí.</span><span class="sxs-lookup"><span data-stu-id="ef516-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="ef516-193">Obecně platí, Správa verzí model pro hlavičky v [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] je, jak je popsáno v specifikace protokolu SOAP.</span><span class="sxs-lookup"><span data-stu-id="ef516-193">In general, the versioning model for headers in [!INCLUDE[indigo2](../../../includes/indigo2-md.md)] is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="ef516-194">Správa verzí kontraktů služby</span><span class="sxs-lookup"><span data-stu-id="ef516-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="ef516-195">Podobně jako správa verzí kontraktů dat, Správa verzí kontraktů služby také zahrnuje přidání, změně a odebrání operace.</span><span class="sxs-lookup"><span data-stu-id="ef516-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="ef516-196">Zadání názvu, Namespace a akce</span><span class="sxs-lookup"><span data-stu-id="ef516-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="ef516-197">Ve výchozím nastavení je název kontraktu služby název rozhraní.</span><span class="sxs-lookup"><span data-stu-id="ef516-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="ef516-198">Jeho výchozí obor názvů je "http://tempuri.org", a každou operaci akce je "http://tempuri.org/contractname/methodname".</span><span class="sxs-lookup"><span data-stu-id="ef516-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="ef516-199">Doporučujeme explicitně zadáte název a obor názvů pro kontrakt služby a akci pro každou operaci zrušení "http://tempuri.org" a aby se zabránilo názvy rozhraní a metoda vystavení v kontrakt služby.</span><span class="sxs-lookup"><span data-stu-id="ef516-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="ef516-200">Přidání parametrů a operace</span><span class="sxs-lookup"><span data-stu-id="ef516-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="ef516-201">Přidání operací služby vystavené služby není pevných změnit, protože existující klienti nemusí být obavy o těchto nových operací.</span><span class="sxs-lookup"><span data-stu-id="ef516-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef516-202">Přidání operací do kontraktu duplexní zpětné volání je narušující změně.</span><span class="sxs-lookup"><span data-stu-id="ef516-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="ef516-203">Změna parametrů operaci nebo návratové typy</span><span class="sxs-lookup"><span data-stu-id="ef516-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="ef516-204">Změna, nebo parametr návratové typy obecně je narušující změně, pokud nový typ implementuje stejné kontrakt dat implementované původní typ.</span><span class="sxs-lookup"><span data-stu-id="ef516-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="ef516-205">Chcete-li tuto změnu, přidejte novou servisní smlouvou nebo definovat nové smlouvy o poskytování služeb.</span><span class="sxs-lookup"><span data-stu-id="ef516-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="ef516-206">Odebrání operace</span><span class="sxs-lookup"><span data-stu-id="ef516-206">Removing Operations</span></span>  
 <span data-ttu-id="ef516-207">Odebrání operace je také narušující změně.</span><span class="sxs-lookup"><span data-stu-id="ef516-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="ef516-208">Chcete-li tuto změnu, zadejte nové smlouvy o poskytování služeb a vystavit na nový koncový bod.</span><span class="sxs-lookup"><span data-stu-id="ef516-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="ef516-209">Kontrakty selhání</span><span class="sxs-lookup"><span data-stu-id="ef516-209">Fault Contracts</span></span>  
 <span data-ttu-id="ef516-210"><xref:System.ServiceModel.FaultContractAttribute> Atribut umožňuje vývojáři kontraktu služby zadejte informace o chyb, které mohou být vráceny z operace této smlouvy.</span><span class="sxs-lookup"><span data-stu-id="ef516-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="ef516-211">Seznam chyb, které jsou popsané v kontraktu služby není považováno za vyčerpávající.</span><span class="sxs-lookup"><span data-stu-id="ef516-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="ef516-212">V každém okamžiku může operace vrátí chyb, které nejsou popsané v její smlouvy.</span><span class="sxs-lookup"><span data-stu-id="ef516-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="ef516-213">Proto změna sadu chyb, které jsou popsané v kontraktu není považováno za nejnovější.</span><span class="sxs-lookup"><span data-stu-id="ef516-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="ef516-214">Například přidávání nové chybu kontrakt pomocí <xref:System.ServiceModel.FaultContractAttribute> nebo odebrání existující chyby ze smlouvy.</span><span class="sxs-lookup"><span data-stu-id="ef516-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="ef516-215">Knihovny kontrakt služby</span><span class="sxs-lookup"><span data-stu-id="ef516-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="ef516-216">Organizace můžou mít zavedené knihovny kontrakty kde kontraktu je publikovaná v centrálním úložišti a služby implementátory implementace kontraktů z tohoto úložiště.</span><span class="sxs-lookup"><span data-stu-id="ef516-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="ef516-217">Při publikování kontraktu služby do úložiště v tomto případě nemáte žádnou kontrolu nad kteří vytváří služby, které implementaci.</span><span class="sxs-lookup"><span data-stu-id="ef516-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="ef516-218">Proto nelze změnit po publikování, kontrakt služby vykreslování efektivně neměnné.</span><span class="sxs-lookup"><span data-stu-id="ef516-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> [!INCLUDE[indigo2](../../../includes/indigo2-md.md)]<span data-ttu-id="ef516-219"> podporuje smlouvy dědičnosti, který můžete použít k vytvoření nové smlouvy, které rozšiřuje stávající smlouvy.</span><span class="sxs-lookup"><span data-stu-id="ef516-219"> supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="ef516-220">Chcete-li tuto funkci používat, definujte nové rozhraní kontraktu služby, která dědí z původního rozhraní kontraktu služby a pak přidejte metody na nové rozhraní.</span><span class="sxs-lookup"><span data-stu-id="ef516-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="ef516-221">Služba, která implementuje staré kontrakt a implementaci nové smlouvy. Změňte definici koncového bodu "versionOld" používat nové smlouvy. změňte.</span><span class="sxs-lookup"><span data-stu-id="ef516-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="ef516-222">Klientům "versionOld" budou nadále vypadat jako zpřístupňuje "versionOld" kontrakt; koncový bod klientům "versionNew" zobrazí se koncový bod vystavit kontrakt "versionNew".</span><span class="sxs-lookup"><span data-stu-id="ef516-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="ef516-223">Adresa a správa verzí vazby</span><span class="sxs-lookup"><span data-stu-id="ef516-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="ef516-224">Změny adresa koncového bodu a vazby jsou nejnovější změny, pokud klienti podporují dynamicky zjišťování nové adresa koncového bodu nebo vazby.</span><span class="sxs-lookup"><span data-stu-id="ef516-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="ef516-225">Jeden mechanismus pro implementaci tato funkce je pomocí registru Universal popis zjišťování a integrace (UDDI) a vzor volání UDDI, kde klient pokoušet o komunikaci s koncovým bodem a, při selhání, dotazuje dobře známé UDDI v registru pro aktuální koncový bod metadat.</span><span class="sxs-lookup"><span data-stu-id="ef516-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="ef516-226">Klient potom použije adresu a vazbu z tato metadata ke komunikaci s koncovým bodem.</span><span class="sxs-lookup"><span data-stu-id="ef516-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="ef516-227">Pokud tato komunikace úspěšná, klient ukládá do mezipaměti informace o adresu a vazba pro budoucí použití.</span><span class="sxs-lookup"><span data-stu-id="ef516-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="ef516-228">Služba Směrování a správa verzí</span><span class="sxs-lookup"><span data-stu-id="ef516-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="ef516-229">Pokud na změny služby jsou nejnovější změny a musí mít minimálně dva různé verze služby spuštěné současně můžete služby WCF směrování pro směrování zpráv do instance příslušné služby.</span><span class="sxs-lookup"><span data-stu-id="ef516-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="ef516-230">Směrovací služby WCF používá směrování podle obsahu, jinými slovy, používá informace ve zprávě k určení, kam směrovat zprávy.</span><span class="sxs-lookup"><span data-stu-id="ef516-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="ef516-231">Další informace o směrování služby WCF najdete [směrovací služby](../../../docs/framework/wcf/feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="ef516-231">For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md).</span></span> <span data-ttu-id="ef516-232">Příklad toho, jak používat službu WCF směrování pro správu verzí služby naleznete v části [postupy: Správa verzí služeb](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="ef516-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="ef516-233">Příloha</span><span class="sxs-lookup"><span data-stu-id="ef516-233">Appendix</span></span>  
 <span data-ttu-id="ef516-234">Obecné data kontrakt Správa verzí pokyny potřeby striktní Správa verzí je považovat za kontrakty dat neměnné a vytvořit nové, když je nutné provést změny.</span><span class="sxs-lookup"><span data-stu-id="ef516-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="ef516-235">Novou třídu musí být vytvořen pro každý nový kontrakt dat, aby bylo vyhnout se nutnosti trvat existujícího kódu, která byla zapsána z hlediska mechanismus stará data smlouvy – třída a přepisování z hlediska novou třídu kontraktu dat.</span><span class="sxs-lookup"><span data-stu-id="ef516-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="ef516-236">Jeden takový mechanismus je použití rozhraní k definování členů každý kontrakt dat a napsat kód vnitřní implementace z hlediska rozhraní než třídy kontraktu dat, které implementují rozhraní.</span><span class="sxs-lookup"><span data-stu-id="ef516-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="ef516-237">Následující kód pro verze 1 služby ukazuje `IPurchaseOrderV1` rozhraní a `PurchaseOrderV1`:</span><span class="sxs-lookup"><span data-stu-id="ef516-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="ef516-238">Během operace kontrakt služby by byla zapsána z hlediska `PurchaseOrderV1`, skutečné obchodní logiky by být z hlediska `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="ef516-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="ef516-239">Potom v verze 2 by novou `IPurchaseOrderV2` rozhraní a nový `PurchaseOrderV2` třídy, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="ef516-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```  
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="ef516-240">Kontrakt služby by došlo k přidání nových operací, které jsou zapsány z hlediska `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="ef516-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="ef516-241">Existující obchodní logika napsaná z hlediska `IPurchaseOrderV1` bude pokračovat v práci pro `PurchaseOrderV2` a nové obchodní logiky, která potřebuje `OrderDate` vlastnost by byla zapsána z hlediska `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="ef516-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ef516-242">Viz také</span><span class="sxs-lookup"><span data-stu-id="ef516-242">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Runtime.Serialization.DataContractAttribute>  
 <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>  
 <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject>  
 <xref:System.Runtime.Serialization.ExtensionDataObject>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>  
 <xref:System.Xml.Serialization.XmlSerializer>  
 [<span data-ttu-id="ef516-243">Ekvivalence kontraktů dat</span><span class="sxs-lookup"><span data-stu-id="ef516-243">Data Contract Equivalence</span></span>](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)  
 [<span data-ttu-id="ef516-244">Zpětná volání serializace tolerantní k verzím</span><span class="sxs-lookup"><span data-stu-id="ef516-244">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)
