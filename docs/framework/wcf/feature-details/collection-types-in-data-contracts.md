---
title: "Typy kolekcí v kontraktech dat"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
caps.latest.revision: "19"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: 8591f1c7c3aa123acd17a9e3ab22cf950275f588
ms.sourcegitcommit: 5177d6ae2e9baf026f07ee0631556700a5a193f7
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/28/2017
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="8f57e-102">Typy kolekcí v kontraktech dat</span><span class="sxs-lookup"><span data-stu-id="8f57e-102">Collection Types in Data Contracts</span></span>
<span data-ttu-id="8f57e-103">A *kolekce* je seznam položek určitého typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="8f57e-104">V [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], jsou seznamy může být reprezentován pomocí pole nebo celou řadu dalších typů (obecný seznam, obecného <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, nebo <xref:System.Collections.ArrayList>).</span><span class="sxs-lookup"><span data-stu-id="8f57e-104">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="8f57e-105">Například kolekce může obsahovat seznam adres pro danou zákazníka.</span><span class="sxs-lookup"><span data-stu-id="8f57e-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="8f57e-106">Tato kolekce se nazývají *seznam kolekcí*, bez ohledu na to jejich skutečným typem.</span><span class="sxs-lookup"><span data-stu-id="8f57e-106">These collections are called *list collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="8f57e-107">Speciální formulář kolekce existuje, který představuje přidružení mezi jednu položku ("klíč") a jiné ("hodnota").</span><span class="sxs-lookup"><span data-stu-id="8f57e-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="8f57e-108">V [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], ty jsou reprezentované pomocí typy, jako <xref:System.Collections.Hashtable> a obecné slovníku.</span><span class="sxs-lookup"><span data-stu-id="8f57e-108">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="8f57e-109">Například může kolekci přidružení mapování města ("klíč") na jeho naplnění ("value").</span><span class="sxs-lookup"><span data-stu-id="8f57e-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="8f57e-110">Tato kolekce se nazývají *kolekce slovníku*, bez ohledu na to jejich skutečným typem.</span><span class="sxs-lookup"><span data-stu-id="8f57e-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="8f57e-111">Kolekce přijímat zvláštní zacházení v datovém modelu kontrakt.</span><span class="sxs-lookup"><span data-stu-id="8f57e-111">Collections receive special treatment in the data contract model.</span></span>  
  
 <span data-ttu-id="8f57e-112">Typy, které implementují <xref:System.Collections.IEnumerable> rozhraní, včetně polí a obecné kolekce, jsou rozpoznány jako kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="8f57e-113">Z nich, typy, které implementují <xref:System.Collections.IDictionary> nebo obecný <xref:System.Collections.Generic.IDictionary%602> rozhraní jsou kolekce slovníku; všechny ostatní jsou kolekce seznamu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>  
  
 <span data-ttu-id="8f57e-114">Další požadavky na typy kolekcí, jako je například s metodu s názvem `Add` a výchozí konstruktor, jsou podrobněji v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="8f57e-114">Additional requirements on collection types, such as having a method called `Add` and a default constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="8f57e-115">To zajistí, že typy kolekcí může být současně serializaci a deserializaci.</span><span class="sxs-lookup"><span data-stu-id="8f57e-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="8f57e-116">To znamená, že některé kolekce nepodporuje přímo, jako je například obecná <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (protože nemá žádné výchozí konstruktor).</span><span class="sxs-lookup"><span data-stu-id="8f57e-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no default constructor).</span></span> <span data-ttu-id="8f57e-117">Ale informace o obcházení tato omezení, najdete v části "Použití kolekce rozhraní typy a jen pro čtení kolekce" dál v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>  
  
 <span data-ttu-id="8f57e-118">Typy obsažené v kolekcích musí být typy kontraktů dat nebo jinak být serializovatelný.</span><span class="sxs-lookup"><span data-stu-id="8f57e-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="8f57e-119">[Typy podporované systémem serializátor kontraktu dat](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="8f57e-119"> [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="8f57e-120">Co je a co se nepovažuje za platnou kolekci, stejně jako o tom, jak se serializují kolekcí, přečtěte si informace o serializaci kolekce v části "pravidla shromažďování Advanced" v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-120"> what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>  
  
## <a name="interchangeable-collections"></a><span data-ttu-id="8f57e-121">Zaměňovat kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-121">Interchangeable Collections</span></span>  
 <span data-ttu-id="8f57e-122">Všechny kolekce seznamu stejného typu jsou považovány za stejná data kontrakt (Pokud se jsou přizpůsobit pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributu, jak je popsáno dále v tomto tématu).</span><span class="sxs-lookup"><span data-stu-id="8f57e-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="8f57e-123">Proto například následující kontrakty dat jsou ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="8f57e-123">Thus, for example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
 [!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]  
  
 <span data-ttu-id="8f57e-124">Obě kontrakty dat za následek podobná následující kód XML.</span><span class="sxs-lookup"><span data-stu-id="8f57e-124">Both data contracts result in XML similar to the following code.</span></span>  
  
```xml  
<PurchaseOrder>  
    <customerName>...</customerName>  
    <items>  
        <Item>...</Item>  
        <Item>...</Item>  
        <Item>...</Item>  
        ...  
    </items>  
    <comments>  
        <string>...</string>  
        <string>...</string>  
        <string>...</string>  
        ...  
    </comments>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="8f57e-125">Kolekce zaměnitelnost umožňuje vám použít, například, typu kolekce, která je optimalizovaná pro výkon na serveru a typu kolekce, která je navržená tak, aby být vázána na součásti uživatelského rozhraní na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="8f57e-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>  
  
 <span data-ttu-id="8f57e-126">Podobně jako seznam kolekcí, všechny kolekce slovníku, které mají stejný klíč a hodnotu typy jsou považovány za obsahovaly stejná data kontrakt (není-li přizpůsobit pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut).</span><span class="sxs-lookup"><span data-stu-id="8f57e-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>  
  
 <span data-ttu-id="8f57e-127">Pouze data kontrakt typ záleží daleko collection ekvivalenční problémem, není typy .NET.</span><span class="sxs-lookup"><span data-stu-id="8f57e-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="8f57e-128">To znamená kolekce Type1 je považovány za ekvivalentní na kolekci Type2 Pokud Type1 a Type2 ekvivalentní datové kontrakty.</span><span class="sxs-lookup"><span data-stu-id="8f57e-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>  
  
 <span data-ttu-id="8f57e-129">Non obecné kolekce jsou považovány za stejná data jako obecné kolekce typu kontraktu `Object`.</span><span class="sxs-lookup"><span data-stu-id="8f57e-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="8f57e-130">(Například na smlouvách data <xref:System.Collections.ArrayList> a obecná <xref:System.Collections.Generic.List%601> z `Object` jsou stejné.)</span><span class="sxs-lookup"><span data-stu-id="8f57e-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>  
  
## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="8f57e-131">Pomocí rozhraní typy kolekcí a kolekce jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="8f57e-131">Using Collection Interface Types and Read-Only Collections</span></span>  
 <span data-ttu-id="8f57e-132">Typy kolekcí rozhraní (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>obecný <xref:System.Collections.Generic.IDictionary%602>, nebo rozhraní odvozené od těchto rozhraní) jsou také považovány za tak, že má kolekce datové kontrakty, ekvivalentní kontrakty kolekce dat pro typy skutečné kolekcí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="8f57e-133">Proto je možné deklarovat serializovaný jako typ rozhraní kolekce typ a výsledky jsou stejné, jako kdyby byly použity typ shromažďování.</span><span class="sxs-lookup"><span data-stu-id="8f57e-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="8f57e-134">Například následující kontrakty dat jsou ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="8f57e-134">For example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
 [!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]  
  
 <span data-ttu-id="8f57e-135">Během serializace Pokud je deklarovaný typ rozhraní, lze skutečné instance typu použitého žádný typ, který implementuje rozhraní.</span><span class="sxs-lookup"><span data-stu-id="8f57e-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="8f57e-136">Omezení jak jsme vysvětlili výše (s výchozí konstruktor a `Add` metoda) se nevztahují.</span><span class="sxs-lookup"><span data-stu-id="8f57e-136">Restrictions discussed previously (having a default constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="8f57e-137">Například můžete nastavit adresy v Customer2 na instanci Obecné <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> adresy, i když nelze deklarovat přímo data členem zadejte obecného <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="8f57e-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 <span data-ttu-id="8f57e-138">Během deserializace, pokud deklarovaný typ je rozhraní, pro Serializační stroj vybere typ, který implementuje rozhraní deklarované a vytvoření instance typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="8f57e-139">Známé typy mechanismus (popsané v [známé typy kontraktů dat](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) nemá žádný vliv zde; je součástí volba typu [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8f57e-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="customizing-collection-types"></a><span data-ttu-id="8f57e-140">Přizpůsobení typy kolekcí</span><span class="sxs-lookup"><span data-stu-id="8f57e-140">Customizing Collection Types</span></span>  
 <span data-ttu-id="8f57e-141">Typy kolekcí lze přizpůsobit pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut, který se dá použít několika způsoby.</span><span class="sxs-lookup"><span data-stu-id="8f57e-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>  
  
 <span data-ttu-id="8f57e-142">Poznámka: Tento přizpůsobení kolekci typů ohrožení kolekce zaměnitelnost, tak obecně se doporučuje Vyhněte se použití tohoto atributu, kdykoli je to možné.</span><span class="sxs-lookup"><span data-stu-id="8f57e-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="8f57e-143">Tento problém, naleznete v části "pravidla shromažďování Advanced" dál v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-143"> this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="collection-data-contract-naming"></a><span data-ttu-id="8f57e-144">Kontrakt dat kolekce pojmenování</span><span class="sxs-lookup"><span data-stu-id="8f57e-144">Collection Data Contract Naming</span></span>  
 <span data-ttu-id="8f57e-145">Pravidla pro pojmenovávání typy kolekcí jsou podobná těm pro pojmenování regulární datové typy kontrakt, jak je popsáno v [názvy datových kontraktů](../../../../docs/framework/wcf/feature-details/data-contract-names.md), i když existuje několik důležitých rozdílů:</span><span class="sxs-lookup"><span data-stu-id="8f57e-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>  
  
-   <span data-ttu-id="8f57e-146"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Atribut slouží k přizpůsobení názvu, místo <xref:System.Runtime.Serialization.DataContractAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="8f57e-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="8f57e-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Atribut má také `Name` a `Namespace` vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="8f57e-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>  
  
-   <span data-ttu-id="8f57e-148">Když <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut není použit, výchozí název a obor názvů pro typy kolekcí závisí na názvy a obory názvů obsažené v kolekci typů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="8f57e-149">Ovlivněné nejsou podle názvu a obor názvů samotného typu kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="8f57e-150">Příklad najdete v tématu následující typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-150">For an example, see the following types.</span></span>  
  
    ```  
    public CustomerList1 : Collection<string> {}  
    public StringList1 : Collection<string> {}  
    ```  
  
 <span data-ttu-id="8f57e-151">Název kontraktu oba typy dat je "ArrayOfstring" a není "CustomerList1" nebo "StringList1".</span><span class="sxs-lookup"><span data-stu-id="8f57e-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="8f57e-152">To znamená, že serializaci kterékoli z těchto typů na kořenové úrovni vypočítá podobná následující kód XML.</span><span class="sxs-lookup"><span data-stu-id="8f57e-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>  
  
```xml  
<ArrayOfstring>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</ArrayOfstring>  
```  
  
 <span data-ttu-id="8f57e-153">Toto pravidlo pojmenování jste vybrali zajistit, že žádný neupravené typ, který představuje seznam řetězců, má stejné kontrakt dat a reprezentaci XML.</span><span class="sxs-lookup"><span data-stu-id="8f57e-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="8f57e-154">Díky zaměnitelnost kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="8f57e-155">V tomto příkladu se úplně zaměňovat CustomerList1 a StringList1.</span><span class="sxs-lookup"><span data-stu-id="8f57e-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>  
  
 <span data-ttu-id="8f57e-156">Ale pokud <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut se používá, kolekce stane kontraktu uzpůsobenou kolekci dat i v případě, že jsou na atribut nastavené žádné vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="8f57e-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="8f57e-157">Název a obor názvů dat kolekce smlouvy a závisí na typu kolekce sám sebe.</span><span class="sxs-lookup"><span data-stu-id="8f57e-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="8f57e-158">Příklad najdete v tématu následujícího typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-158">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
 [!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]  
  
 <span data-ttu-id="8f57e-159">Když serializovat, výsledná XML je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-159">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList2>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</CustomerList2>  
```  
  
 <span data-ttu-id="8f57e-160">Všimněte si, že není již ekvivalentní k reprezentaci XML neupravené typů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>  
  
-   <span data-ttu-id="8f57e-161">Můžete použít `Name` a `Namespace` vlastnosti k dalšímu přizpůsobení u názvu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="8f57e-162">Viz následující třídy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-162">See the following class.</span></span>  
  
     [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
     [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]  
  
 <span data-ttu-id="8f57e-163">Výsledný XML je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-163">The resulting XML is similar to the following.</span></span>  
  
```xml  
<cust_list>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</cust_list>  
```  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="8f57e-164">později v tomto tématu v části "pravidla shromažďování pokročilé".</span><span class="sxs-lookup"><span data-stu-id="8f57e-164"> the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="8f57e-165">Přizpůsobení opakovaný název elementu v seznamu kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-165">Customizing the Repeating Element Name in List Collections</span></span>  
 <span data-ttu-id="8f57e-166">Seznam kolekcí obsahovat opakující se položky.</span><span class="sxs-lookup"><span data-stu-id="8f57e-166">List collections contain repeating entries.</span></span> <span data-ttu-id="8f57e-167">Každý záznam opakující se za normálních okolností je reprezentována jako element s názvem podle název kontraktu dat typu obsažené v kolekci.</span><span class="sxs-lookup"><span data-stu-id="8f57e-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>  
  
 <span data-ttu-id="8f57e-168">V `CustomerList` příklady, kolekce obsažené řetězce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="8f57e-169">Název kontraktu dat pro primitivní typ řetězec je "řetězec", takže opakovaných element "\<řetězec >".</span><span class="sxs-lookup"><span data-stu-id="8f57e-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>  
  
 <span data-ttu-id="8f57e-170">Však pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> vlastnost na <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut opakující se tento název elementu, který lze přizpůsobit.</span><span class="sxs-lookup"><span data-stu-id="8f57e-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="8f57e-171">Příklad najdete v tématu následujícího typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-171">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
 [!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]  
  
 <span data-ttu-id="8f57e-172">Výsledný XML je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-172">The resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList4>  
    <customer>...</customer>  
    <customer>...</customer>  
    <customer>...</customer>  
    ...  
</CustomerList4>  
```  
  
 <span data-ttu-id="8f57e-173">Obor názvů opakující se prvek je vždy stejný jako obor názvů kontraktu dat kolekce, které lze přizpůsobit pomocí `Namespace` vlastnost, jak je popsáno výše.</span><span class="sxs-lookup"><span data-stu-id="8f57e-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>  
  
### <a name="customizing-dictionary-collections"></a><span data-ttu-id="8f57e-174">Přizpůsobení kolekce slovníku</span><span class="sxs-lookup"><span data-stu-id="8f57e-174">Customizing Dictionary Collections</span></span>  
 <span data-ttu-id="8f57e-175">Kolekce slovníku jsou v podstatě seznam položek, kde každá položka má klíč a hodnotu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="8f57e-176">Stejně jako s regulární seznamy, můžete změnit název elementu, který odpovídá opakovaných element pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="8f57e-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>  
  
 <span data-ttu-id="8f57e-177">Kromě toho můžete změnit názvy elementů, které představují klíč a hodnotu pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> a <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="8f57e-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="8f57e-178">Obory názvů pro tyto prvky jsou stejné jako obor názvů kontraktu dat kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>  
  
 <span data-ttu-id="8f57e-179">Příklad najdete v tématu následujícího typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-179">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
 [!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]  
  
 <span data-ttu-id="8f57e-180">Když serializovat, výsledná XML je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-180">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CountriesOrRegionsWithCapitals>  
    <entry>  
        <countryorregion>USA</countryorregion>  
        <capital>Washington</capital>  
    </entry>  
    <entry>  
        <countryorregion>France</countryorregion>  
        <capital>Paris</capital>  
    </entry>  
    ...  
</CountriesOrRegionsWithCapitals>  
```  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="8f57e-181">kolekce slovníku, najdete v části "pravidla shromažďování Advanced" dál v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-181"> dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
## <a name="collections-and-known-types"></a><span data-ttu-id="8f57e-182">Kolekce a známé typy</span><span class="sxs-lookup"><span data-stu-id="8f57e-182">Collections and Known Types</span></span>  
 <span data-ttu-id="8f57e-183">Není nutné přidat typy kolekcí do známé typy při použití polymorphically místo ostatní kolekce nebo rozhraní pro kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="8f57e-184">Například, pokud je deklarovat členem datového typu <xref:System.Collections.IEnumerable> a použít ho k odeslání instanci <xref:System.Collections.ArrayList>, není potřeba přidat <xref:System.Collections.ArrayList> na známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="8f57e-185">Použijete-li kolekce polymorphically místo typy jiných kolekcí, je nutné přidat do známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="8f57e-186">Například, pokud je deklarovat členem datového typu `Object` a použít ho k odeslání instanci <xref:System.Collections.ArrayList>, přidejte <xref:System.Collections.ArrayList> na známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="8f57e-187">To je určená k serializaci jakékoli ekvivalentní kolekce polymorphically nepovolíte.</span><span class="sxs-lookup"><span data-stu-id="8f57e-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="8f57e-188">Například když přidáte <xref:System.Collections.ArrayList> do seznamu ze známých typů v předchozím příkladu to neumožňuje přiřadit `Array of Object` třídy, i když má ekvivalentní datové kontrakt.</span><span class="sxs-lookup"><span data-stu-id="8f57e-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="8f57e-189">Nijak se to neliší od chování regulárních známé typy v serializace pro typy jiných kolekcí, ale je velmi důležité pochopit v případě kolekcí, protože je velmi běžné pro kolekce jako ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="8f57e-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>  
  
 <span data-ttu-id="8f57e-190">Během serializace může být známé pouze jeden typ v jakékoli dané oboru pro kontraktu dat a ekvivalentní kolekce všechny mají stejné kontrakty dat.</span><span class="sxs-lookup"><span data-stu-id="8f57e-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="8f57e-191">To znamená, že v předchozím příkladu, nemůžete přidat i <xref:System.Collections.ArrayList> a `Array of Object` na známé typy ve stejném oboru.</span><span class="sxs-lookup"><span data-stu-id="8f57e-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="8f57e-192">Znovu jde o ekvivalent známé typy chování pro jiné kolekce typy, ale je velmi důležité porozumět pro kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>  
  
 <span data-ttu-id="8f57e-193">Známé typy může být potřeba taky pro obsah kolekcí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="8f57e-194">Například pokud <xref:System.Collections.ArrayList> ve skutečnosti obsahuje instance `Type1` a `Type2`, oba tyto typy musí být přidaní do známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>  
  
 <span data-ttu-id="8f57e-195">Následující příklad ukazuje správně strukturovaný objekt graf pomocí kolekcí a známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="8f57e-196">V příkladu je poněkud contrived, protože v aplikaci skutečné nejsou obvykle definujete následující členy data jako `Object`a proto nemají žádné známé typu nebo polymorfismus problémy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
 [!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]  
  
 <span data-ttu-id="8f57e-197">U deserializace Pokud deklarovaný typ je typu kolekce je deklarovaný typ instanci bez ohledu na typ, který vám byl zaslán ve skutečnosti.</span><span class="sxs-lookup"><span data-stu-id="8f57e-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="8f57e-198">Pokud deklarovaný typ rozhraní kolekci, vybere deserializátor typu, který chcete vytvořit instanci, bez ohledu na na známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>  
  
 <span data-ttu-id="8f57e-199">Také u deserializace, pokud deklarovaný typ není typu kolekce, ale typ kolekce je odesílány, odpovídající typ kolekce vydán mimo seznamu známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="8f57e-200">Je možné přidat do seznamu ze známých typů pro deserializaci rozhraní typy kolekcí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="8f57e-201">V takovém případě modul deserializace znovu vybere typ má být vytvořena instance.</span><span class="sxs-lookup"><span data-stu-id="8f57e-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>  
  
## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="8f57e-202">Kolekce a NetDataContractSerializer – třída</span><span class="sxs-lookup"><span data-stu-id="8f57e-202">Collections and the NetDataContractSerializer Class</span></span>  
 <span data-ttu-id="8f57e-203">Když <xref:System.Runtime.Serialization.NetDataContractSerializer> třída se používá, typy kolekcí neupravené (bez <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut), není pole ztrácejí zvláštní význam.</span><span class="sxs-lookup"><span data-stu-id="8f57e-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>  
  
 <span data-ttu-id="8f57e-204">Typy kolekcí přizpůsobené bez označené jako <xref:System.SerializableAttribute> atribut může serializovat stále <xref:System.Runtime.Serialization.NetDataContractSerializer> třídy podle <xref:System.SerializableAttribute> atribut nebo <xref:System.Runtime.Serialization.ISerializable> rozhraní pravidla.</span><span class="sxs-lookup"><span data-stu-id="8f57e-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>  
  
 <span data-ttu-id="8f57e-205">Typy vlastní kolekce, rozhraní pro kolekce a pole jsou stále považovány za kolekcí, i v případě <xref:System.Runtime.Serialization.NetDataContractSerializer> třída se používá.</span><span class="sxs-lookup"><span data-stu-id="8f57e-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>  
  
## <a name="collections-and-schema"></a><span data-ttu-id="8f57e-206">Kolekce a schématu</span><span class="sxs-lookup"><span data-stu-id="8f57e-206">Collections and Schema</span></span>  
 <span data-ttu-id="8f57e-207">Všechny kolekce ekvivalentní mají stejnou reprezentaci ve schématu XML definition language (XSD) schématu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="8f57e-208">Z toho důvodu se obvykle nezobrazí stejného typu kolekce v kód klienta vygenerovaný jako ten, na serveru.</span><span class="sxs-lookup"><span data-stu-id="8f57e-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="8f57e-209">Například může server použít kontraktu dat s obecný <xref:System.Collections.Generic.List%601> datového členu celé číslo, ale kód klienta vygenerovaný stejného člena dat se může stát pole celých čísel.</span><span class="sxs-lookup"><span data-stu-id="8f57e-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>  
  
 <span data-ttu-id="8f57e-210">Kolekce slovníku jsou označené [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-poznámky určité schéma, které označují, že jsou slovník; jinak, jsou lišit od jednoduchých seznamů, které obsahují položky se klíč a hodnotu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-210">Dictionary collections are marked with a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="8f57e-211">Přesný popis zastoupení kolekce ve schématu kontraktu dat, najdete v části [Přehled schématu kontraktu dat](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="8f57e-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="8f57e-212">Ve výchozím nastavení nejsou typy generované neupravené kolekcí v importovaných kódu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="8f57e-213">Datové členy kolekce typů seznamu se importují jako pole a datové členy typy kolekcí slovník importují jako obecný slovníku.</span><span class="sxs-lookup"><span data-stu-id="8f57e-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>  
  
 <span data-ttu-id="8f57e-214">Ale pro vlastní kolekce, samostatné typy jsou generovány, označené jako <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut.</span><span class="sxs-lookup"><span data-stu-id="8f57e-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="8f57e-215">(Uzpůsobenou kolekci typu ve schématu je ten, který nepoužívá výchozí obor názvů, název, opakovaný název elementu nebo klíč/hodnota názvy elementu.) Tyto typy jsou prázdné typy, které jsou odvozeny od obecného <xref:System.Collections.Generic.List%601> typů seznamů a obecné slovník pro typy slovníku.</span><span class="sxs-lookup"><span data-stu-id="8f57e-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>  
  
 <span data-ttu-id="8f57e-216">Například může mít následující typy na serveru.</span><span class="sxs-lookup"><span data-stu-id="8f57e-216">For example, you may have the following types on the server.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
 [!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]  
  
 <span data-ttu-id="8f57e-217">Při exportu schéma a importované zpět znovu, kód klienta vygenerovaný je podobný následujícímu (pole jsou uvedené místo vlastnosti pro snadnější čtení).</span><span class="sxs-lookup"><span data-stu-id="8f57e-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
 [!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]  
  
 <span data-ttu-id="8f57e-218">Můžete používat různé typy generovaného kódu než výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="8f57e-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="8f57e-219">Například můžete chtít použít Obecné <xref:System.ComponentModel.BindingList%601> místo regulární pole členům dat se usnadňují navázat je součástí uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="8f57e-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>  
  
 <span data-ttu-id="8f57e-220">Chcete-li zvolit typy kolekcí ke generování, předat seznam typů kolekce, kterou chcete použít do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> vlastnost <xref:System.Runtime.Serialization.ImportOptions> objektu při importu schématu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="8f57e-221">Tyto typy jsou označovány jako *odkazuje typy kolekcí*.</span><span class="sxs-lookup"><span data-stu-id="8f57e-221">These types are called *referenced collection types*.</span></span>  
  
 <span data-ttu-id="8f57e-222">Při obecné typy se odkazuje, se musí být buď plně open obecné nebo plně uzavřený obecné typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f57e-223">Při použití nástroje Svcutil.exe, tento odkaz můžete provést pomocí **/collectionType** přepínač příkazového řádku (krátký tvar: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="8f57e-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="8f57e-224">Mějte na paměti, která je nutné také zadat sestavení pro typy odkazovaná kolekce pomocí **/reference** přepínače (krátký tvar: **/r**).</span><span class="sxs-lookup"><span data-stu-id="8f57e-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="8f57e-225">Pokud je obecný typ, se musí následovat zpětné uvozovky a počet obecné parametry.</span><span class="sxs-lookup"><span data-stu-id="8f57e-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="8f57e-226">Zpětné uvozovky (') je termín nelze zaměňovat s znak jednoduché uvozovky (').</span><span class="sxs-lookup"><span data-stu-id="8f57e-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="8f57e-227">Můžete určit více typy odkazovaná kolekce pomocí **/collectionType** přepínač více než jednou.</span><span class="sxs-lookup"><span data-stu-id="8f57e-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>  
  
 <span data-ttu-id="8f57e-228">Chcete-li například způsobit, že všechny seznamy, které má být importován jako obecný <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="8f57e-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>  
  
```  
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1  
```  
  
 <span data-ttu-id="8f57e-229">Při importu jakoukoli kolekci, je tento seznam typů odkazovaná kolekce zkontrolovat a nejlépe odpovídající kolekce se používá, pokud ho najde, jako datový typ člena (pro neupravené kolekce) nebo jako základní typ k odvozování z (pro vlastní kolekce).</span><span class="sxs-lookup"><span data-stu-id="8f57e-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="8f57e-230">Slovník jsou pouze porovnání slovníky, zatímco seznamy jsou porovnání seznamy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>  
  
 <span data-ttu-id="8f57e-231">Například, pokud přidáte obecná <xref:System.ComponentModel.BindingList%601> a <xref:System.Collections.Hashtable> seznam odkazovaných typů, kód klienta vygenerovaný pro v předchozím příkladu je podobný následujícímu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
 [!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]  
  
 <span data-ttu-id="8f57e-232">Můžete určit typy rozhraní kolekce jako součást vaší typy odkazovaná kolekce, nemůžete ale zadat neplatný kolekci typů (jako jsou ty, které bez `Add` metoda nebo konstruktor public).</span><span class="sxs-lookup"><span data-stu-id="8f57e-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>  
  
 <span data-ttu-id="8f57e-233">Uzavřené obecného se považuje za nejlepší shodu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="8f57e-234">(Non obecné typy jsou považovány za ekvivalentní do uzavřených obecných typů z `Object`).</span><span class="sxs-lookup"><span data-stu-id="8f57e-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="8f57e-235">Například pokud typy obecného <xref:System.Collections.Generic.List%601> z <xref:System.DateTime>obecný <xref:System.ComponentModel.BindingList%601> (otevřete obecné), a <xref:System.Collections.ArrayList> jsou typy odkazovaná kolekce následující se vygeneruje.</span><span class="sxs-lookup"><span data-stu-id="8f57e-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
 [!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]  
  
 <span data-ttu-id="8f57e-236">Seznam kolekcí jsou podporovány pouze v případech v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-236">For list collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="8f57e-237">Odkazovaného typu</span><span class="sxs-lookup"><span data-stu-id="8f57e-237">Referenced type</span></span>|<span data-ttu-id="8f57e-238">Rozhraní implementované odkazovaného typu</span><span class="sxs-lookup"><span data-stu-id="8f57e-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="8f57e-239">Příklad</span><span class="sxs-lookup"><span data-stu-id="8f57e-239">Example</span></span>|<span data-ttu-id="8f57e-240">Typ považován za:</span><span class="sxs-lookup"><span data-stu-id="8f57e-240">Type treated as:</span></span>|  
|---------------------|----------------------------------------------|-------------|----------------------|  
|<span data-ttu-id="8f57e-241">Obecná jiného typu nebo uzavřených obecného (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="8f57e-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="8f57e-242">Non obecné</span><span class="sxs-lookup"><span data-stu-id="8f57e-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="8f57e-243">or</span><span class="sxs-lookup"><span data-stu-id="8f57e-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="8f57e-244">kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="8f57e-244">where T= `int`</span></span>|<span data-ttu-id="8f57e-245">Uzavřený obecné z `Object` (například `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|  
|<span data-ttu-id="8f57e-246">Obecná jiného typu nebo uzavřených obecného (libovolný počet parametrů, které neodpovídají nutně typ kolekce)</span><span class="sxs-lookup"><span data-stu-id="8f57e-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="8f57e-247">Uzavřený obecné</span><span class="sxs-lookup"><span data-stu-id="8f57e-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="8f57e-248">or</span><span class="sxs-lookup"><span data-stu-id="8f57e-248">or</span></span><br /><br /> <span data-ttu-id="8f57e-249">`MyType<T> : IList<string>`kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="8f57e-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="8f57e-250">Uzavřené obecného (například `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-250">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="8f57e-251">Uzavřený obecné s libovolným počtem parametrů</span><span class="sxs-lookup"><span data-stu-id="8f57e-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="8f57e-252">Otevřete obecného pomocí některého z parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="8f57e-253">kde T =`int`, U =`string`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="8f57e-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="8f57e-254">Uzavřené obecného (například `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-254">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="8f57e-255">Otevřete obecného s jeden parametr</span><span class="sxs-lookup"><span data-stu-id="8f57e-255">Open generic with one parameter</span></span>|<span data-ttu-id="8f57e-256">Otevřete obecného pomocí parametru typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="8f57e-257">`MyType<T> : IList<T>`, T je otevřený</span><span class="sxs-lookup"><span data-stu-id="8f57e-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="8f57e-258">Otevřete obecného (například `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-258">Open generic (for example, `IList<T>`)</span></span>|  
  
 <span data-ttu-id="8f57e-259">Pokud typ implementuje více než jedno rozhraní kolekce seznamu, se vztahují následující omezení:</span><span class="sxs-lookup"><span data-stu-id="8f57e-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="8f57e-260">Pokud typ implementuje obecného <xref:System.Collections.Generic.IEnumerable%601> (nebo její odvozené rozhraní) více než jednou pro různé typy typ typu platný odkazovaná kolekce, nepovažuje se ignoruje.</span><span class="sxs-lookup"><span data-stu-id="8f57e-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="8f57e-261">To platí i v případě, že některé implementace jsou neplatné nebo používají otevřete obecné typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="8f57e-262">Například typ, který implementuje obecného <xref:System.Collections.Generic.IEnumerable%601> z `int` a obecná <xref:System.Collections.Generic.IEnumerable%601> t, které by se nikdy nepoužívá jako odkazované kolekce `int` nebo jakýkoli jiný typ, bez ohledu na to, zda má tento typ `Add` přijetí – metoda `int` nebo `Add` metoda přijímá parametr typ T, nebo obojí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>  
  
-   <span data-ttu-id="8f57e-263">Pokud typ implementuje rozhraní obecnou kolekci a také <xref:System.Collections.IList>, typ se nikdy nepoužívá jako typ odkazované kolekce, pokud rozhraní obecnou kolekci je uzavřené obecného typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="8f57e-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="8f57e-264">Pro kolekce slovníku jsou podporovány pouze v případech v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-264">For dictionary collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="8f57e-265">Odkazovaného typu</span><span class="sxs-lookup"><span data-stu-id="8f57e-265">Referenced type</span></span>|<span data-ttu-id="8f57e-266">Rozhraní implementované odkazovaného typu</span><span class="sxs-lookup"><span data-stu-id="8f57e-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="8f57e-267">Příklad</span><span class="sxs-lookup"><span data-stu-id="8f57e-267">Example</span></span>|<span data-ttu-id="8f57e-268">Typ považován za</span><span class="sxs-lookup"><span data-stu-id="8f57e-268">Type treated as</span></span>|  
|---------------------|----------------------------------------------|-------------|---------------------|  
|<span data-ttu-id="8f57e-269">Obecná jiného typu nebo uzavřených obecného (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="8f57e-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="8f57e-270">or</span><span class="sxs-lookup"><span data-stu-id="8f57e-270">or</span></span><br /><br /> <span data-ttu-id="8f57e-271">`MyType<T> : IDictionary`kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="8f57e-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="8f57e-272">Uzavřený obecné`IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="8f57e-272">Closed generic `IDictionary<object,object>`</span></span>|  
|<span data-ttu-id="8f57e-273">Uzavřené obecného (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="8f57e-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="8f57e-274"><xref:System.Collections.Generic.IDictionary%602>, uzavřený</span><span class="sxs-lookup"><span data-stu-id="8f57e-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="8f57e-275">`MyType<T> : IDictionary<string, bool>`kde T =`int`</span><span class="sxs-lookup"><span data-stu-id="8f57e-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="8f57e-276">Uzavřené obecného (například `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|  
|<span data-ttu-id="8f57e-277">Uzavřené obecného (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="8f57e-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="8f57e-278">Obecné <xref:System.Collections.Generic.IDictionary%602>, jeden klíč nebo hodnota je uzavřen, druhý je otevřený a používá jeden z parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="8f57e-279">`MyType<T,U,V> : IDictionary<string,V>`kde T =`int`, U =`float`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="8f57e-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="8f57e-280">or</span><span class="sxs-lookup"><span data-stu-id="8f57e-280">or</span></span><br /><br /> <span data-ttu-id="8f57e-281">`MyType<Z> : IDictionary<Z,bool>`kde Z =`string`</span><span class="sxs-lookup"><span data-stu-id="8f57e-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="8f57e-282">Uzavřené obecného (například `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="8f57e-283">Uzavřené obecného (libovolný počet parametrů)</span><span class="sxs-lookup"><span data-stu-id="8f57e-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="8f57e-284">Obecné <xref:System.Collections.Generic.IDictionary%602>, klíče a hodnoty jsou otevřené a každá používá jeden z parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="8f57e-285">`MyType<T,U,V> : IDictionary<V,U>`kde T =`int`, U =`bool`, V =`string`</span><span class="sxs-lookup"><span data-stu-id="8f57e-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="8f57e-286">Uzavřené obecného (například `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="8f57e-287">Otevřete obecného (dva parametry)</span><span class="sxs-lookup"><span data-stu-id="8f57e-287">Open generic (two parameters)</span></span>|<span data-ttu-id="8f57e-288">Obecné <xref:System.Collections.Generic.IDictionary%602>, otevření, oba parametry obecného typu používá v pořadí, jsou zobrazeny</span><span class="sxs-lookup"><span data-stu-id="8f57e-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="8f57e-289">`MyType<K,V> : IDictionary<K,V>`, Tisíc a V obou otevřete</span><span class="sxs-lookup"><span data-stu-id="8f57e-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="8f57e-290">Otevřete obecného (například `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="8f57e-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|  
  
 <span data-ttu-id="8f57e-291">Pokud typ implementuje obě <xref:System.Collections.IDictionary> a obecná <xref:System.Collections.Generic.IDictionary%602>pouze obecný <xref:System.Collections.Generic.IDictionary%602> se považuje za.</span><span class="sxs-lookup"><span data-stu-id="8f57e-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>  
  
 <span data-ttu-id="8f57e-292">Odkazování na částečné obecné typy není podporována.</span><span class="sxs-lookup"><span data-stu-id="8f57e-292">Referencing partial generic types is not supported.</span></span>  
  
 <span data-ttu-id="8f57e-293">Duplicitní položky nejsou povoleny, například nelze přidat obě obecná <xref:System.Collections.Generic.List%601> z `Integer` a obecné kolekce `Integer` k <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, protože díky tomu je možné určit, který se má použít při seznam celých čísel nenajde ve schématu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="8f57e-294">Duplicity se jenom v případě, že je typu ve schématu, která zveřejňuje problém duplicitní položky.</span><span class="sxs-lookup"><span data-stu-id="8f57e-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="8f57e-295">Například pokud schéma importovaných neobsahuje seznam celých čísel, je povoleno mít obě obecná <xref:System.Collections.Generic.List%601> z `Integer` a obecné kolekce `Integer` v <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, ale ani nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="8f57e-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>  
  
## <a name="advanced-collection-rules"></a><span data-ttu-id="8f57e-296">Pokročilé kolekce pravidel</span><span class="sxs-lookup"><span data-stu-id="8f57e-296">Advanced Collection Rules</span></span>  
  
### <a name="serializing-collections"></a><span data-ttu-id="8f57e-297">Serializace kolekcí</span><span class="sxs-lookup"><span data-stu-id="8f57e-297">Serializing Collections</span></span>  
 <span data-ttu-id="8f57e-298">Následuje seznam kolekci pravidel pro serializaci:</span><span class="sxs-lookup"><span data-stu-id="8f57e-298">The following is a list of collection rules for serialization:</span></span>  
  
-   <span data-ttu-id="8f57e-299">Kombinování typy kolekcí (s kolekcí kolekcí) je povolen.</span><span class="sxs-lookup"><span data-stu-id="8f57e-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="8f57e-300">Vícenásobná pole jsou považovány za kolekce kolekcí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="8f57e-301">Multidimenzionální pole nejsou podporována.</span><span class="sxs-lookup"><span data-stu-id="8f57e-301">Multidimensional arrays are not supported.</span></span>  
  
-   <span data-ttu-id="8f57e-302">Pole bajtů a pole <xref:System.Xml.XmlNode> jsou pole speciální typy, které jsou zpracovány jako primitiva, není kolekcí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="8f57e-303">Serializace pole bajtů výsledky v jednom elementu XML, který obsahuje bloku dat kódováním Base64, místo samostatných element pro každou bajtů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="8f57e-304">jak pole <xref:System.Xml.XmlNode> je zpracováván, najdete v části [typy XML a ADO.NET v kontraktech dat](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8f57e-304"> how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="8f57e-305">Samozřejmě, tyto speciální typy můžete sami účastnit kolekcí: pole pole bajtů za následek více elementů XML, pomocí každý obsahující bloků dat s kódováním Base64.</span><span class="sxs-lookup"><span data-stu-id="8f57e-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>  
  
-   <span data-ttu-id="8f57e-306">Pokud <xref:System.Runtime.Serialization.DataContractAttribute> je použit atribut typu kolekce, typ je považován za regulární datového typu kontraktu, ne jako kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>  
  
-   <span data-ttu-id="8f57e-307">Pokud typ kolekce implementuje <xref:System.Xml.Serialization.IXmlSerializable> platí následující pravidla rozhraní, zadaný typ `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="8f57e-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>  
  
    -   <span data-ttu-id="8f57e-308">Pokud je deklarovaný typ `IList<string>`, je typ serializován jako seznam.</span><span class="sxs-lookup"><span data-stu-id="8f57e-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>  
  
    -   <span data-ttu-id="8f57e-309">Pokud je deklarovaný typ `myType`, je serializován jako `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="8f57e-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>  
  
    -   <span data-ttu-id="8f57e-310">Pokud je deklarovaný typ `IXmlSerializable`, je serializován jako `IXmlSerializable`, ale jenom v případě, že přidáte `myType` do seznamu ze známých typů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>  
  
-   <span data-ttu-id="8f57e-311">Kolekce lze serializovat a deserializovat pomocí metody uvedené v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>  
  
|<span data-ttu-id="8f57e-312">Implementuje – typ kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-312">Collection type implements</span></span>|<span data-ttu-id="8f57e-313">Volání metody pro serializaci</span><span class="sxs-lookup"><span data-stu-id="8f57e-313">Method(s) called on serialization</span></span>|<span data-ttu-id="8f57e-314">Volá metodu nebo metody k deserializaci</span><span class="sxs-lookup"><span data-stu-id="8f57e-314">Method(s) called on deserialization</span></span>|  
|--------------------------------|-----------------------------------------|-------------------------------------------|  
|<span data-ttu-id="8f57e-315">Obecné<xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="8f57e-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="8f57e-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="8f57e-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="8f57e-317">Přidat obecné</span><span class="sxs-lookup"><span data-stu-id="8f57e-317">Generic Add</span></span>|  
|<xref:System.Collections.IDictionary>|<span data-ttu-id="8f57e-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="8f57e-318">`get_Keys`, `get_Values`</span></span>|`Add`|  
|<span data-ttu-id="8f57e-319">Obecné<xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="8f57e-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="8f57e-320">Obecné <xref:System.Collections.Generic.IList%601> indexeru</span><span class="sxs-lookup"><span data-stu-id="8f57e-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="8f57e-321">Přidat obecné</span><span class="sxs-lookup"><span data-stu-id="8f57e-321">Generic Add</span></span>|  
|<span data-ttu-id="8f57e-322">Obecné<xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="8f57e-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="8f57e-323">Enumerátor</span><span class="sxs-lookup"><span data-stu-id="8f57e-323">Enumerator</span></span>|<span data-ttu-id="8f57e-324">Přidat obecné</span><span class="sxs-lookup"><span data-stu-id="8f57e-324">Generic Add</span></span>|  
|<xref:System.Collections.IList>|<span data-ttu-id="8f57e-325"><xref:System.Collections.IList>Indexer</span><span class="sxs-lookup"><span data-stu-id="8f57e-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|  
|<span data-ttu-id="8f57e-326">Obecné<xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="8f57e-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="8f57e-327">Volána metoda nestatické `Add` které přijímá jeden parametr příslušného typu (typ obecný parametr) nebo jednoho z jeho základních typů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="8f57e-328">Tato metoda musí existovat serializátoru považovat za kolekci během serializace a deserializace typu kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
|<span data-ttu-id="8f57e-329"><xref:System.Collections.IEnumerable>(a tedy <xref:System.Collections.ICollection>, která je odvozena z něj)</span><span class="sxs-lookup"><span data-stu-id="8f57e-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="8f57e-330">Volána metoda nestatické `Add` které přijímá jeden parametr typu `Object`.</span><span class="sxs-lookup"><span data-stu-id="8f57e-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="8f57e-331">Tato metoda musí existovat serializátoru považovat za kolekci během serializace a deserializace typu kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
  
 <span data-ttu-id="8f57e-332">V předchozí tabulce jsou uvedeny rozhraní pro kolekce v sestupném pořadí podle priority.</span><span class="sxs-lookup"><span data-stu-id="8f57e-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="8f57e-333">To znamená, například, pokud typ implementuje obě <xref:System.Collections.IList> a obecná <xref:System.Collections.Generic.IEnumerable%601>, kolekce se serializovat a deserializovat podle <xref:System.Collections.IList> pravidla:</span><span class="sxs-lookup"><span data-stu-id="8f57e-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>  
  
-   <span data-ttu-id="8f57e-334">Při deserializaci jsou všechny kolekce deserializovat vytvořením první instance typu voláním výchozí konstruktor, který musí být k dispozici pro serializátor zacházet s typem kolekce jako kolekce během serializace a deserializace.</span><span class="sxs-lookup"><span data-stu-id="8f57e-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>  
  
-   <span data-ttu-id="8f57e-335">Pokud je více než jednou implementovat stejné rozhraní obecnou kolekci (např. Pokud typ implementuje obou obecného <xref:System.Collections.Generic.ICollection%601> z `Integer` a obecná <xref:System.Collections.Generic.ICollection%601> z <xref:System.String>) a nenajde žádné rozhraní s vyšší prioritou, je kolekce nejsou považovány za platnou kolekci.</span><span class="sxs-lookup"><span data-stu-id="8f57e-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>  
  
-   <span data-ttu-id="8f57e-336">Typy kolekcí může mít <xref:System.SerializableAttribute> atribut na ně použity a můžete implementovat <xref:System.Runtime.Serialization.ISerializable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="8f57e-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="8f57e-337">Obě tyto se ignorují.</span><span class="sxs-lookup"><span data-stu-id="8f57e-337">Both of these are ignored.</span></span> <span data-ttu-id="8f57e-338">Ale pokud typ plně nesplňuje požadavky na typ kolekce (například `Add` metoda nebyla nalezena), typ se nepovažuje za typu kolekce proto <xref:System.SerializableAttribute> atribut a <xref:System.Runtime.Serialization.ISerializable> rozhraní se používají k určení jestli může být typ serializovat.</span><span class="sxs-lookup"><span data-stu-id="8f57e-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>  
  
-   <span data-ttu-id="8f57e-339">Použití <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut kolekce a přizpůsobit odebere <xref:System.SerializableAttribute> předcházející nouzový mechanismus.</span><span class="sxs-lookup"><span data-stu-id="8f57e-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="8f57e-340">Místo toho, pokud vlastní kolekce nemá plnění kolekce zadejte požadavky, <xref:System.Runtime.Serialization.InvalidDataContractException> je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="8f57e-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="8f57e-341">Řetězec výjimky často obsahuje informace popisující, proč se daný typ nepovažuje za platnou kolekci (žádné `Add` metoda, neexistoval výchozí konstruktor a tak dále), takže je často užitečné použít <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut pro účely ladění.</span><span class="sxs-lookup"><span data-stu-id="8f57e-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no default constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>  
  
### <a name="collection-naming"></a><span data-ttu-id="8f57e-342">Pojmenování kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-342">Collection Naming</span></span>  
 <span data-ttu-id="8f57e-343">Následuje seznam pravidla pojmenování kolekce:</span><span class="sxs-lookup"><span data-stu-id="8f57e-343">The following is a list of collection naming rules:</span></span>  
  
-   <span data-ttu-id="8f57e-344">Výchozí obor názvů pro všechny smlouvy dat kolekce slovníku i pro kontrakty seznamu kolekce dat, které obsahují primitivní typy, je http://schemas.microsoft.com/2003/10/Serialization/Arrays, není-li přepsat pomocí Namespace.</span><span class="sxs-lookup"><span data-stu-id="8f57e-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is http://schemas.microsoft.com/2003/10/Serialization/Arrays unless overridden using Namespace.</span></span> <span data-ttu-id="8f57e-345">Typy, které jsou mapovány na vestavěné typy XSD, a také `char`, `Timespan`, a `Guid` typy, jsou považovány za primitiv pro tento účel.</span><span class="sxs-lookup"><span data-stu-id="8f57e-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>  
  
-   <span data-ttu-id="8f57e-346">Výchozí obor názvů pro typy kolekcí, které obsahují není primitivní typy, pokud je přepsat, pomocí Namespace, je stejný jako obor názvů kontraktu dat typu obsažené v kolekci.</span><span class="sxs-lookup"><span data-stu-id="8f57e-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>  
  
-   <span data-ttu-id="8f57e-347">Výchozí název pro seznam kolekce datové kontrakty, není-li přepsat pomocí názvu, je řetězec, který kombinaci "ArrayOf" s název kontraktu dat typu obsažené v kolekci.</span><span class="sxs-lookup"><span data-stu-id="8f57e-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="8f57e-348">Například název kontraktu dat obecné seznamu celá je "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="8f57e-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="8f57e-349">Mějte na paměti, že název kontraktu dat `Object` je "anyType", aby jako název kontraktu dat neobecnou seznamů <xref:System.Collections.ArrayList> je "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="8f57e-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>  
  
 <span data-ttu-id="8f57e-350">Výchozí název pro slovník dat kolekce měnící, není-li přepsat pomocí `Name`, je "ArrayOfKeyValueOf" v kombinaci s názvem kontraktu dat typ klíče, za nímž následuje název kontraktu dat hodnota typu řetězec.</span><span class="sxs-lookup"><span data-stu-id="8f57e-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="8f57e-351">Například data "ArrayOfKeyValueOfstringint" je název kontraktu pro obecné slovník řetězec a celé číslo.</span><span class="sxs-lookup"><span data-stu-id="8f57e-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="8f57e-352">Navíc pokud klíč nebo typy hodnot nejsou primitivní typy, připojí se k názvu hash obor názvů oborů názvů kontraktu dat typů klíč a hodnotu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="8f57e-353">obor názvů hodnoty hash, najdete v části [názvy datových kontraktů](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="8f57e-353"> namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
 <span data-ttu-id="8f57e-354">Každý kontrakt dat kolekce slovníku má doprovodné kontraktu dat, která představuje jednu položku ve slovníku.</span><span class="sxs-lookup"><span data-stu-id="8f57e-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="8f57e-355">Jeho název je stejné jako slovník dat kontrakt, s výjimkou předponu "ArrayOf" a její obor názvů je stejné jako pro kontrakt dat slovníku.</span><span class="sxs-lookup"><span data-stu-id="8f57e-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="8f57e-356">Například pro kontrakt dat slovník "ArrayOfKeyValueOfstringint", kontrakt dat "KeyValueofstringint" představuje jednu položku ve slovníku.</span><span class="sxs-lookup"><span data-stu-id="8f57e-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="8f57e-357">Název tohoto kontraktu dat lze přizpůsobit pomocí `ItemName` vlastnost, jak je popsáno v následující části.</span><span class="sxs-lookup"><span data-stu-id="8f57e-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>  
  
 <span data-ttu-id="8f57e-358">Obecná pravidla pojmenování, zadejte, jak je popsáno v [názvy datových kontraktů](../../../../docs/framework/wcf/feature-details/data-contract-names.md), plně použít typy kolekcí; tzn., můžete použít složené závorky v název označující parametry obecného typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="8f57e-359">Čísla do závorek však naleznete obecné parametry a není typy obsažené v kolekci.</span><span class="sxs-lookup"><span data-stu-id="8f57e-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>  
  
## <a name="collection-customization"></a><span data-ttu-id="8f57e-360">Přizpůsobení kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-360">Collection Customization</span></span>  
 <span data-ttu-id="8f57e-361">Následující používání <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut jsou zakázané a vést <xref:System.Runtime.Serialization.InvalidDataContractException> výjimka:</span><span class="sxs-lookup"><span data-stu-id="8f57e-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>  
  
-   <span data-ttu-id="8f57e-362">Použití <xref:System.Runtime.Serialization.DataContractAttribute> atribut na typ, do kterého <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut byl použité, nebo do jednoho z jeho odvozených typů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>  
  
-   <span data-ttu-id="8f57e-363">Použití <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut na typ, který implementuje <xref:System.Xml.Serialization.IXmlSerializable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="8f57e-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="8f57e-364">Použití <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut typu jiné kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>  
  
-   <span data-ttu-id="8f57e-365">Probíhá pokus o nastavení <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> nebo <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> na <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut použitý typ jiný adresář.</span><span class="sxs-lookup"><span data-stu-id="8f57e-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>  
  
### <a name="polymorphism-rules"></a><span data-ttu-id="8f57e-366">Polymorfismus pravidla</span><span class="sxs-lookup"><span data-stu-id="8f57e-366">Polymorphism Rules</span></span>  
 <span data-ttu-id="8f57e-367">Jak už jsme zmínili, přizpůsobení kolekce pomocí <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atribut mohou ovlivňovat zaměnitelnost kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="8f57e-368">Dva typy uzpůsobenou kolekci lze pouze považovat za ekvivalentní, pokud se jejich název, obor názvů, název položky, jakož i názvy klíčů a hodnot (pokud jsou kolekce slovníku) shodují.</span><span class="sxs-lookup"><span data-stu-id="8f57e-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>  
  
 <span data-ttu-id="8f57e-369">Z důvodu úprav je možné nechtěně použít kontrakt dat jednu kolekci jiné, kde je očekávána.</span><span class="sxs-lookup"><span data-stu-id="8f57e-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="8f57e-370">To je nutno.</span><span class="sxs-lookup"><span data-stu-id="8f57e-370">This should be avoided.</span></span> <span data-ttu-id="8f57e-371">Zobrazíte následující typy.</span><span class="sxs-lookup"><span data-stu-id="8f57e-371">See the following types.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
 [!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]  
  
 <span data-ttu-id="8f57e-372">V tomto případě instance `Marks1` lze přiřadit k `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="8f57e-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="8f57e-373">Ale `Marks2` by se neměla používat, protože jeho kontrakt dat není považovány za ekvivalentní k `IList<int>` kontrakt dat.</span><span class="sxs-lookup"><span data-stu-id="8f57e-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="8f57e-374">Název kontraktu dat je "Marks2" a není "ArrayOfint" a je opakovaný název elementu "\<označit >" a zda není "\<int >".</span><span class="sxs-lookup"><span data-stu-id="8f57e-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>  
  
 <span data-ttu-id="8f57e-375">Pravidla v následující tabulce platí pro polymorfní přiřazení kolekcí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>  
  
|<span data-ttu-id="8f57e-376">Deklarovaný typ</span><span class="sxs-lookup"><span data-stu-id="8f57e-376">Declared type</span></span>|<span data-ttu-id="8f57e-377">Přiřazení neupravené kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="8f57e-378">Přiřazení uzpůsobenou kolekci</span><span class="sxs-lookup"><span data-stu-id="8f57e-378">Assigning a customized collection</span></span>|  
|-------------------|--------------------------------------------|---------------------------------------|  
|<span data-ttu-id="8f57e-379">Objekt</span><span class="sxs-lookup"><span data-stu-id="8f57e-379">Object</span></span>|<span data-ttu-id="8f57e-380">Název smlouvy je serializováno.</span><span class="sxs-lookup"><span data-stu-id="8f57e-380">Contract name is serialized.</span></span>|<span data-ttu-id="8f57e-381">Název smlouvy je serializováno.</span><span class="sxs-lookup"><span data-stu-id="8f57e-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="8f57e-382">Slouží k přizpůsobení.</span><span class="sxs-lookup"><span data-stu-id="8f57e-382">Customization is used.</span></span>|  
|<span data-ttu-id="8f57e-383">Rozhraní kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-383">Collection interface</span></span>|<span data-ttu-id="8f57e-384">Název kontraktu není serializovat.</span><span class="sxs-lookup"><span data-stu-id="8f57e-384">Contract name is not serialized.</span></span>|<span data-ttu-id="8f57e-385">Název kontraktu není serializovat.</span><span class="sxs-lookup"><span data-stu-id="8f57e-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="8f57e-386">Přizpůsobení není used.*</span><span class="sxs-lookup"><span data-stu-id="8f57e-386">Customization is not used.*</span></span>|  
|<span data-ttu-id="8f57e-387">Přizpůsobené bez kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-387">Non-customized collection</span></span>|<span data-ttu-id="8f57e-388">Název kontraktu není serializovat.</span><span class="sxs-lookup"><span data-stu-id="8f57e-388">Contract name is not serialized.</span></span>|<span data-ttu-id="8f57e-389">Název smlouvy je serializováno.</span><span class="sxs-lookup"><span data-stu-id="8f57e-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="8f57e-390">Přizpůsobení je used.* *</span><span class="sxs-lookup"><span data-stu-id="8f57e-390">Customization is used.**</span></span>|  
|<span data-ttu-id="8f57e-391">Vlastní kolekce</span><span class="sxs-lookup"><span data-stu-id="8f57e-391">Customized collection</span></span>|<span data-ttu-id="8f57e-392">Název smlouvy je serializováno.</span><span class="sxs-lookup"><span data-stu-id="8f57e-392">Contract name is serialized.</span></span> <span data-ttu-id="8f57e-393">Přizpůsobení není used.* *</span><span class="sxs-lookup"><span data-stu-id="8f57e-393">Customization is not used.**</span></span>|<span data-ttu-id="8f57e-394">Název smlouvy je serializováno.</span><span class="sxs-lookup"><span data-stu-id="8f57e-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="8f57e-395">Přizpůsobení přiřazené typu je used.* *</span><span class="sxs-lookup"><span data-stu-id="8f57e-395">Customization of the assigned type is used.**</span></span>|  
  
 <span data-ttu-id="8f57e-396">* Se <xref:System.Runtime.Serialization.NetDataContractSerializer> třídy, přizpůsobení se používá v tomto případě.</span><span class="sxs-lookup"><span data-stu-id="8f57e-396">*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="8f57e-397"><xref:System.Runtime.Serialization.NetDataContractSerializer> Třídy v tomto případě také serializuje název skutečný typ, takže deserializace funguje podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="8f57e-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>  
  
 <span data-ttu-id="8f57e-398">** Těchto případech vést k neplatné schéma instancí a proto by měly být vyloučeny.</span><span class="sxs-lookup"><span data-stu-id="8f57e-398">**These cases result in schema-invalid instances and thus should be avoided.</span></span>  
  
 <span data-ttu-id="8f57e-399">V případech, kde je serializováno název kontraktu musí být typu přiřazené kolekce v seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="8f57e-400">Jako opak platí to i naopak: v případech, kde se název neserializuje, přidáte do seznamu známé typy typ se nevyžaduje.</span><span class="sxs-lookup"><span data-stu-id="8f57e-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>  
  
 <span data-ttu-id="8f57e-401">Do pole Základní typ lze přiřadit pole odvozeného typu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="8f57e-402">V takovém případě je název kontraktu pro odvozený typ serializovat pro každý opakovaných prvek.</span><span class="sxs-lookup"><span data-stu-id="8f57e-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="8f57e-403">Například, pokud typ `Book` je odvozen od typu `LibraryItem`, můžete přiřadit pole `Book` na pole `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="8f57e-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="8f57e-404">To se nevztahuje na jiné typy kolekcí.</span><span class="sxs-lookup"><span data-stu-id="8f57e-404">This does not apply to other collection types.</span></span> <span data-ttu-id="8f57e-405">Nelze přiřadit například `Generic List of Book` k `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="8f57e-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="8f57e-406">Můžete ale přiřadit `Generic List of LibraryItem` obsahující `Book` instance.</span><span class="sxs-lookup"><span data-stu-id="8f57e-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="8f57e-407">V poli i případě mimo pole `Book` by měla být v seznamu známých typů.</span><span class="sxs-lookup"><span data-stu-id="8f57e-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>  
  
## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="8f57e-408">Kolekce a zachovávání odkaz na objekt</span><span class="sxs-lookup"><span data-stu-id="8f57e-408">Collections and Object Reference Preservation</span></span>  
 <span data-ttu-id="8f57e-409">Při serializátor funkce v režimu, kde uchovává odkazy na objekty, objekt odkaz zachovávání platí také pro kolekce.</span><span class="sxs-lookup"><span data-stu-id="8f57e-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="8f57e-410">Identity – objekt je konkrétně zachovají pro celý kolekce a jednotlivé položky, které jsou obsažené v kolekcích.</span><span class="sxs-lookup"><span data-stu-id="8f57e-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="8f57e-411">Pro slovník je zachovaná objekt identity pro objekty dvojice klíč/hodnota i jednotlivé objekty klíč a hodnotu.</span><span class="sxs-lookup"><span data-stu-id="8f57e-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8f57e-412">Viz také</span><span class="sxs-lookup"><span data-stu-id="8f57e-412">See Also</span></span>  
 <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
