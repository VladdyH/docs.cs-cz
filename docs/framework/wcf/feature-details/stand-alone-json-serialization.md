---
title: Samostatná serializace JSON
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 5a157dfd55e722b3e7be967a26e8d2ff5fd54afe
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33509105"
---
# <a name="stand-alone-json-serialization"></a><span data-ttu-id="8f713-102">Samostatná serializace JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-102">Stand-Alone JSON Serialization</span></span>
<span data-ttu-id="8f713-103">JSON (JavaScript Object Notation) je formát dat, která je určená speciálně pro používat kód JavaScript spuštěný na webových stránkách otvírala v prohlížeči.</span><span class="sxs-lookup"><span data-stu-id="8f713-103">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="8f713-104">Je výchozí formát dat používaný pomocí prvku ASP.NET AJAX služby vytvořené v systému Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="8f713-104">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>  
  
 <span data-ttu-id="8f713-105">Tento formát můžete použít také v případě vytváření služeb AJAX bez integrace s ASP.NET – v takovém případě XML je výchozí nastavení ale JSON je možné vybrat.</span><span class="sxs-lookup"><span data-stu-id="8f713-105">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>  
  
 <span data-ttu-id="8f713-106">Nakonec, pokud nepožadujete podporu JSON, ale nejsou vytvoření služby AJAX <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> je možné přímo serializaci objektů .NET do JSON data a deserializuje taková data zpět do instance typy .NET.</span><span class="sxs-lookup"><span data-stu-id="8f713-106">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="8f713-107">Popis toho, jak to provést, najdete v části [postup: serializaci a deserializaci JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-107">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="8f713-108">Při práci s JSON, stejné typy .NET jsou podporovány, s několika výjimkami, jako jsou podporovány <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="8f713-108">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="8f713-109">Seznam typů podporovány, naleznete v části [typy nepodporuje serializátor kontraktu dat](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-109">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="8f713-110">To zahrnuje nejvíce primitivní typy, většina pole a typy kolekcí, stejně jako komplexní typy, které používají <xref:System.Runtime.Serialization.DataContractAttribute> a <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="8f713-110">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="8f713-111">Mapování typů .NET pro typy JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-111">Mapping .NET types to JSON Types</span></span>  
 <span data-ttu-id="8f713-112">Následující tabulka ukazuje souvislost mezi typy JSON nebo JavaScript při mapovat pomocí procedury serializace a deserializace a rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="8f713-112">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>  
  
|<span data-ttu-id="8f713-113">Typy .NET</span><span class="sxs-lookup"><span data-stu-id="8f713-113">.NET Types</span></span>|<span data-ttu-id="8f713-114">JSON nebo JavaScript</span><span class="sxs-lookup"><span data-stu-id="8f713-114">JSON/JavaScript</span></span>|<span data-ttu-id="8f713-115">Poznámky</span><span class="sxs-lookup"><span data-stu-id="8f713-115">Notes</span></span>|  
|----------------|----------------------|-----------|  
|<span data-ttu-id="8f713-116">Všechny číselné typy, například <xref:System.Int32>, <xref:System.Decimal> nebo <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="8f713-116">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="8f713-117">Číslo</span><span class="sxs-lookup"><span data-stu-id="8f713-117">Number</span></span>|<span data-ttu-id="8f713-118">Zvláštní hodnoty jako například `Double.NaN`, `Double.PositiveInfinity` a `Double.NegativeInfinity` nejsou podporovány a mít za následek neplatný JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-118">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|  
|<xref:System.Enum>|<span data-ttu-id="8f713-119">Číslo</span><span class="sxs-lookup"><span data-stu-id="8f713-119">Number</span></span>|<span data-ttu-id="8f713-120">Později v tomto tématu najdete v části "A výčty JSON".</span><span class="sxs-lookup"><span data-stu-id="8f713-120">See "Enumerations and JSON" later in this topic.</span></span>|  
|<xref:System.Boolean>|<span data-ttu-id="8f713-121">Boolean</span><span class="sxs-lookup"><span data-stu-id="8f713-121">Boolean</span></span>|--|  
|<span data-ttu-id="8f713-122"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="8f713-122"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="8f713-123">String</span><span class="sxs-lookup"><span data-stu-id="8f713-123">String</span></span>|--|  
|<span data-ttu-id="8f713-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="8f713-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="8f713-125">String</span><span class="sxs-lookup"><span data-stu-id="8f713-125">String</span></span>|<span data-ttu-id="8f713-126">Formát tyto typy ve formátu JSON je stejné jako XML (v podstatě časový interval ve formátu ISO 8601 trvání, GUID ve formátu "12345678-ABCD-ABCD-ABCD-1234567890AB" a identifikátor URI v podobě přirozené řetězec, například "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="8f713-126">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="8f713-127">Přesné informace najdete v tématu [Přehled schématu kontraktu dat](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-127">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|  
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="8f713-128">String</span><span class="sxs-lookup"><span data-stu-id="8f713-128">String</span></span>|<span data-ttu-id="8f713-129">Není ve formátu "název: obor názvů" (NIC před první dvojtečkou název).</span><span class="sxs-lookup"><span data-stu-id="8f713-129">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="8f713-130">Název nebo obor názvů se může chybět.</span><span class="sxs-lookup"><span data-stu-id="8f713-130">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="8f713-131">Pokud žádný obor názvů je lze vynechat také dvojtečkou.</span><span class="sxs-lookup"><span data-stu-id="8f713-131">If there is no namespace the colon can be omitted as well.</span></span>|  
|<span data-ttu-id="8f713-132"><xref:System.Array> typu <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="8f713-132"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="8f713-133">Pole čísla</span><span class="sxs-lookup"><span data-stu-id="8f713-133">Array of numbers</span></span>|<span data-ttu-id="8f713-134">Každé číslo představuje hodnotu jeden bajt.</span><span class="sxs-lookup"><span data-stu-id="8f713-134">Each number represents the value of one byte.</span></span>|  
|<xref:System.DateTime>|<span data-ttu-id="8f713-135">Data a času nebo řetězec</span><span class="sxs-lookup"><span data-stu-id="8f713-135">DateTime or String</span></span>|<span data-ttu-id="8f713-136">V tématu kalendářní data nebo časy a JSON později v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-136">See Dates/Times and JSON later in this topic.</span></span>|  
|<xref:System.DateTimeOffset>|<span data-ttu-id="8f713-137">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8f713-137">Complex type</span></span>|<span data-ttu-id="8f713-138">V tématu kalendářní data nebo časy a JSON později v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-138">See Dates/Times and JSON later in this topic.</span></span>|  
|<span data-ttu-id="8f713-139">Typy XML a ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="8f713-139">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="8f713-140"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="8f713-140"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="8f713-141">Pole <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="8f713-141">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="8f713-142"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="8f713-142"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="8f713-143"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="8f713-143"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="8f713-144">String</span><span class="sxs-lookup"><span data-stu-id="8f713-144">String</span></span>|<span data-ttu-id="8f713-145">Najdete v části typy XML a JSON v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-145">See the XML Types and JSON section of this topic.</span></span>|  
|<xref:System.DBNull>|<span data-ttu-id="8f713-146">Prázdný komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8f713-146">Empty complex type</span></span>|--|  
|<span data-ttu-id="8f713-147">Kolekce, slovník a pole</span><span class="sxs-lookup"><span data-stu-id="8f713-147">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="8f713-148">Pole</span><span class="sxs-lookup"><span data-stu-id="8f713-148">Array</span></span>|<span data-ttu-id="8f713-149">Najdete v části kolekcí, slovník a pole v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-149">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|  
|<span data-ttu-id="8f713-150">Komplexní typy (s <xref:System.Runtime.Serialization.DataContractAttribute> nebo <xref:System.SerializableAttribute> použít)</span><span class="sxs-lookup"><span data-stu-id="8f713-150">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="8f713-151">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8f713-151">Complex type</span></span>|<span data-ttu-id="8f713-152">Datové členy se stanou členy JavaScript komplexního typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-152">Data members become members of the JavaScript complex type.</span></span>|  
|<span data-ttu-id="8f713-153">Komplexní typy implementace <xref:System.Runtime.Serialization.ISerializable> rozhraní)</span><span class="sxs-lookup"><span data-stu-id="8f713-153">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="8f713-154">Komplexní typ</span><span class="sxs-lookup"><span data-stu-id="8f713-154">Complex type</span></span>|<span data-ttu-id="8f713-155">Stejné jako ostatní komplexní typy, ale některé <xref:System.Runtime.Serialization.ISerializable> typy nejsou podporovány – viz část ISerializable podporu rozšířené informace o části tohoto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-155">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|  
|<span data-ttu-id="8f713-156">`Null` hodnota pro jakýkoli typ</span><span class="sxs-lookup"><span data-stu-id="8f713-156">`Null` value for any type</span></span>|<span data-ttu-id="8f713-157">Null</span><span class="sxs-lookup"><span data-stu-id="8f713-157">Null</span></span>|<span data-ttu-id="8f713-158">Typy s možnou hodnotou Null jsou podporovány také a mapovat do formátu JSON stejným způsobem jako typy neumožňující hodnotu Null.</span><span class="sxs-lookup"><span data-stu-id="8f713-158">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|  
  
### <a name="enumerations-and-json"></a><span data-ttu-id="8f713-159">Výčty a JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-159">Enumerations and JSON</span></span>  
 <span data-ttu-id="8f713-160">Člen hodnoty výčtu jsou považovány za čísel ve formátu JSON, který se liší od jak jsou považovány v kontraktech dat tam, kde jsou zahrnuty jako názvy členů.</span><span class="sxs-lookup"><span data-stu-id="8f713-160">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="8f713-161">Další informace o zacházení kontraktu dat najdete v tématu [výčtové typy v kontraktech dat](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-161">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>  
  
-   <span data-ttu-id="8f713-162">Pokud máte například `public enum Color {red, green, blue, yellow, pink}`, serializaci `yellow` vytvoří čísla 3 a není řetězec "žlutá".</span><span class="sxs-lookup"><span data-stu-id="8f713-162">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>  
  
-   <span data-ttu-id="8f713-163">Všechny `enum` členové jsou serializable.</span><span class="sxs-lookup"><span data-stu-id="8f713-163">All `enum` members are serializable.</span></span> <span data-ttu-id="8f713-164"><xref:System.Runtime.Serialization.EnumMemberAttribute> a <xref:System.NonSerializedAttribute> atributy jsou ignorovány, pokud se používá.</span><span class="sxs-lookup"><span data-stu-id="8f713-164">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>  
  
-   <span data-ttu-id="8f713-165">Je možné k deserializaci neexistující `enum` hodnota – například hodnota 87 může být deserializovat do předchozí výčtu barva i když není žádný odpovídající název barev, které jsou definované.</span><span class="sxs-lookup"><span data-stu-id="8f713-165">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>  
  
-   <span data-ttu-id="8f713-166">Příznaky `enum` není speciální a chovají stejně jako libovolný jiný `enum`.</span><span class="sxs-lookup"><span data-stu-id="8f713-166">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>  
  
### <a name="datestimes-and-json"></a><span data-ttu-id="8f713-167">Data/Times a JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-167">Dates/Times and JSON</span></span>  
 <span data-ttu-id="8f713-168">Formát JSON nepodporuje přímo, data a časy.</span><span class="sxs-lookup"><span data-stu-id="8f713-168">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="8f713-169">Ale se velmi často používají a prvku ASP.NET AJAX poskytuje speciální podporu pro tyto typy.</span><span class="sxs-lookup"><span data-stu-id="8f713-169">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="8f713-170">Při použití ASP.NET AJAX proxy, <xref:System.DateTime> typu v rozhraní .NET plně odpovídá `DateTime` typ v jazyce JavaScript.</span><span class="sxs-lookup"><span data-stu-id="8f713-170">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>  
  
-   <span data-ttu-id="8f713-171">Pokud nepoužíváte technologii ASP.NET <xref:System.DateTime> typ je ve formátu JSON reprezentován jako řetězec s speciální formátu, který je popsaný v části Upřesnit informace v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-171">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>  
  
-   <span data-ttu-id="8f713-172"><xref:System.DateTimeOffset> představuje ve formátu JSON jako komplexní typ.: {"Datum a čas": dateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="8f713-172"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="8f713-173">`offsetMinutes` Člen je posun místního času z greenwichský střední čas (GMT), nyní také označuje jako koordinovaný světový čas (UTC), přidružená k umístění události, které vás zajímají.</span><span class="sxs-lookup"><span data-stu-id="8f713-173">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="8f713-174">`dateTime` Člen reprezentuje instanci v čase, kdy došlo k události, které vás zajímají (znovu, bude `DateTime` v jazyce JavaScript Pokud prvku ASP.NET AJAX v řetězec a použijte, pokud není).</span><span class="sxs-lookup"><span data-stu-id="8f713-174">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="8f713-175">V serializaci `dateTime` člen je vždy serializována v GMT.</span><span class="sxs-lookup"><span data-stu-id="8f713-175">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="8f713-176">Pokud popisující 3:00 New Yorku času, tedy `dateTime` má čas součást 8:00 AM a `offsetMinutes` jsou 300 (minus 300 minut nebo 5 hodin od GMT).</span><span class="sxs-lookup"><span data-stu-id="8f713-176">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="8f713-177"><xref:System.DateTime> a <xref:System.DateTimeOffset> objekty, když serializovat na JSON, pouze zachovat informace, které přesnost milisekundu.</span><span class="sxs-lookup"><span data-stu-id="8f713-177"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="8f713-178">Dílčí milisekundu hodnoty (micro/nanosekundách) jsou ztraceny během serializace.</span><span class="sxs-lookup"><span data-stu-id="8f713-178">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>  
  
### <a name="xml-types-and-json"></a><span data-ttu-id="8f713-179">Typy XML a JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-179">XML Types and JSON</span></span>  
 <span data-ttu-id="8f713-180">Typy XML stát řetězce formátu JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-180">XML types become JSON strings.</span></span>  
  
-   <span data-ttu-id="8f713-181">Například pokud data člena "d:" z typu XElement obsahuje \<abc / >, JSON je {"d:": "\<abc / >"}.</span><span class="sxs-lookup"><span data-stu-id="8f713-181">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>  
  
-   <span data-ttu-id="8f713-182">Existují některé speciální pravidla, které zadejte, jak zabalit XML - Další informace najdete v části Upřesnit informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-182">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>  
  
-   <span data-ttu-id="8f713-183">Pokud jsou pomocí prvku ASP.NET AJAX a nechcete použít řetězce v jazyce JavaScript, ale místo toho chcete XML DOM, nastavte <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> vlastnost XML na <xref:System.ServiceModel.Web.WebGetAttribute> nebo <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> vlastnost XML na <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="8f713-183">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>  
  
### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="8f713-184">Kolekce, slovník a pole</span><span class="sxs-lookup"><span data-stu-id="8f713-184">Collections, Dictionaries and Arrays</span></span>  
 <span data-ttu-id="8f713-185">Všechny kolekce, slovník a pole jsou ve formátu JSON reprezentovány jako pole.</span><span class="sxs-lookup"><span data-stu-id="8f713-185">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>  
  
-   <span data-ttu-id="8f713-186">Všechny vlastní nastavení, která používá <xref:System.Runtime.Serialization.CollectionDataContractAttribute> je ignorován v reprezentace JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-186">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>  
  
-   <span data-ttu-id="8f713-187">Slovník nejsou způsob, jak pracovat přímo s JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-187">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="8f713-188">Slovník\<řetězec, objekt > nemusí být podporována stejně jako ve WCF podle očekávání v práci s jinými technologiemi JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-188">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="8f713-189">Například pokud "abc" je namapovaná na "xyz" a "def" je namapována na 42 ve slovníku, reprezentace JSON není {"abc": "xyz", "def": 42}, ale [{"Klíč": "abc", "Value": "xyz"}, {"Klíč": "def", "Value": 42}] místo.</span><span class="sxs-lookup"><span data-stu-id="8f713-189">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>  
  
-   <span data-ttu-id="8f713-190">Pokud chcete pracovat přímo s JSON (přístup ke klíči a hodnotami dynamicky, bez předběžné definování kontraktu pevné), máte několik možností:</span><span class="sxs-lookup"><span data-stu-id="8f713-190">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>  
  
    -   <span data-ttu-id="8f713-191">Zvažte použití [slabě typované serializace JSON (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) ukázka.</span><span class="sxs-lookup"><span data-stu-id="8f713-191">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>  
  
    -   <span data-ttu-id="8f713-192">Zvažte použití <xref:System.Runtime.Serialization.ISerializable> rozhraní a deserializace konstruktory - těchto dvou mechanismů vám umožní přístup k páry klíč – hodnota JSON na serializace a deserializace v uvedeném pořadí, ale nefungují ve scénářích s částečnou důvěryhodností.</span><span class="sxs-lookup"><span data-stu-id="8f713-192">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>  
  
    -   <span data-ttu-id="8f713-193">Vezměte v úvahu práci s [mapování mezi JSON a XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) místo použití označuje, že serializátor.</span><span class="sxs-lookup"><span data-stu-id="8f713-193">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>  
  
    -   <span data-ttu-id="8f713-194">*Polymorfismus* v kontextu serializace odkazuje na schopnost odvozený typ, kde je očekávána jeho základní typ serializovat.</span><span class="sxs-lookup"><span data-stu-id="8f713-194">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="8f713-195">Při používání kolekce polymorphically, když například přiřazení kolekce se zvláštní JSON specifická pravidla <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="8f713-195">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="8f713-196">Tento problém je podrobněji popsán v části Upřesnit informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-196">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>  
  
## <a name="additional-details"></a><span data-ttu-id="8f713-197">Další podrobnosti</span><span class="sxs-lookup"><span data-stu-id="8f713-197">Additional Details</span></span>  
  
### <a name="order-of-data-members"></a><span data-ttu-id="8f713-198">Pořadí datových členů</span><span class="sxs-lookup"><span data-stu-id="8f713-198">Order of Data Members</span></span>  
 <span data-ttu-id="8f713-199">Pořadí datových členů není důležité, pokud používáte JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-199">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="8f713-200">Konkrétně, i když <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> nastavena JSON data lze deserializovat stále v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="8f713-200">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>  
  
### <a name="json-types"></a><span data-ttu-id="8f713-201">Typy JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-201">JSON Types</span></span>  
 <span data-ttu-id="8f713-202">Typ formátu JSON nemá tak, aby odpovídaly v předchozí tabulce k deserializaci.</span><span class="sxs-lookup"><span data-stu-id="8f713-202">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="8f713-203">Například `Int` obvykle mapuje JSON číslo, ale může být také úspěšně deserializovaný z JSON řetězce tak dlouho, dokud tento řetězec obsahuje platné číslo.</span><span class="sxs-lookup"><span data-stu-id="8f713-203">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="8f713-204">To znamená, i {"d:": 42} a {"d:": "42"} jsou platné, pokud dojde `Int` data člena s názvem "d:".</span><span class="sxs-lookup"><span data-stu-id="8f713-204">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="8f713-205">Polymorfismus</span><span class="sxs-lookup"><span data-stu-id="8f713-205">Polymorphism</span></span>  
 <span data-ttu-id="8f713-206">Polymorfní serializace se skládá z možnost odvozený typ, kde je očekávána jeho základní typ serializovat.</span><span class="sxs-lookup"><span data-stu-id="8f713-206">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="8f713-207">Toto je podporováno pro serializaci JSON technologie WCF porovnatelný z hlediska způsobem, jakým serializace XML je podporována.</span><span class="sxs-lookup"><span data-stu-id="8f713-207">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="8f713-208">Například může serializovat `MyDerivedType` kde `MyBaseType` je očekávána nebo serializovat `Int` kde `Object` se očekává.</span><span class="sxs-lookup"><span data-stu-id="8f713-208">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>  
  
 <span data-ttu-id="8f713-209">Při deserializaci odvozený typ, pokud základní typ je očekávané, pokud jsou deserializaci komplexního typu, může dojít ke ztrátě informací o typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-209">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="8f713-210">Například pokud <xref:System.Uri> kde serializován <xref:System.Object> je očekávané, výsledkem je to řetězec formátu JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-210">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="8f713-211">Pokud se tento řetězec bude poté deserializován zpět do <xref:System.Object>, .NET <xref:System.String> je vrácen.</span><span class="sxs-lookup"><span data-stu-id="8f713-211">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="8f713-212">Deserializátor nebude vědět, že řetězec byla původně typu <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="8f713-212">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="8f713-213">Obecně platí Pokud byla očekávána <xref:System.Object>, všechny řetězce JSON jsou deserializovat jako řetězce .NET a všechna pole JSON používaný k serializaci kolekcí .NET, slovníky, a pole jsou deserializovat jako .NET <xref:System.Array> typu <xref:System.Object>bez ohledu na to, co původní skutečným typem je.</span><span class="sxs-lookup"><span data-stu-id="8f713-213">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="8f713-214">Logická hodnota JSON mapuje .NET <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="8f713-214">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="8f713-215">Ale pokud byla očekávána <xref:System.Object>, JSON čísla se deserializovat jako buď .NET <xref:System.Int32>, <xref:System.Decimal> nebo <xref:System.Double>, kde je nejvhodnější typ automaticky vybráno.</span><span class="sxs-lookup"><span data-stu-id="8f713-215">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>  
  
 <span data-ttu-id="8f713-216">Při deserializaci do typu rozhraní <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializuje, jako kdyby deklarovaný typ objektu.</span><span class="sxs-lookup"><span data-stu-id="8f713-216">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>  
  
 <span data-ttu-id="8f713-217">Při práci s vlastními základní a odvozené typy, pomocí <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> nebo podobného mechanismu se obvykle vyžaduje.</span><span class="sxs-lookup"><span data-stu-id="8f713-217">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="8f713-218">Například, pokud máte operace, která má `Animal` vracet hodnotu a je ve skutečnosti vrátí instanci `Cat` (odvozený od `Animal`), byste měli použít buď <xref:System.Runtime.Serialization.KnownTypeAttribute>do `Animal` typu nebo <xref:System.ServiceModel.ServiceKnownTypeAttribute> na operaci a zadejte `Cat` typu v těchto atributů.</span><span class="sxs-lookup"><span data-stu-id="8f713-218">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="8f713-219">Další informace najdete v tématu [známé typy kontraktů dat](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-219">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="8f713-220">Podrobnosti o tom, jak polymorfní serializace funguje a diskuzi o některá omezení, které je nutné dodržovat při používání najdete v části Upřesnit informace dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-220">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>  
  
### <a name="versioning"></a><span data-ttu-id="8f713-221">Správa verzí</span><span class="sxs-lookup"><span data-stu-id="8f713-221">Versioning</span></span>  
 <span data-ttu-id="8f713-222">Správa verzí funkce, včetně kontraktu dat <xref:System.Runtime.Serialization.IExtensibleDataObject> rozhraní, jsou plně podporovány ve formátu JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-222">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="8f713-223">Ve většině případů je navíc možné deserializovat typ v jednoho formátu (například XML) a pak se serializace do jiného formátu (například JSON) a současně zachovat data v <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="8f713-223">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="8f713-224">Další informace najdete v tématu [kontrakty dat dopřednou](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-224">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="8f713-225">Mějte na paměti, že JSON neuspořádaného, budou ztraceny všechny informace o objednávce.</span><span class="sxs-lookup"><span data-stu-id="8f713-225">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="8f713-226">Kromě toho JSON nepodporuje více páry klíč/hodnota se stejným názvem klíče.</span><span class="sxs-lookup"><span data-stu-id="8f713-226">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="8f713-227">Nakonec všechny operace v <xref:System.Runtime.Serialization.IExtensibleDataObject> jsou ze své podstaty polymorfní -, která je jejich odvozený typ přiřazené k <xref:System.Object>, základní typ pro všechny typy.</span><span class="sxs-lookup"><span data-stu-id="8f713-227">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>  
  
## <a name="json-in-urls"></a><span data-ttu-id="8f713-228">JSON v adresách URL</span><span class="sxs-lookup"><span data-stu-id="8f713-228">JSON in URLs</span></span>  
 <span data-ttu-id="8f713-229">Při použití ASP.NET AJAX koncových bodů s příkazem GET protokolu HTTP (pomocí <xref:System.ServiceModel.Web.WebGetAttribute> atribut), příchozí parametry jsou v adrese URL žádosti místo textu zprávy.</span><span class="sxs-lookup"><span data-stu-id="8f713-229">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="8f713-230">JSON je podporována i v adrese URL žádosti, takže pokud máte operace, která přebírá `Int` nazvané "number" a `Person` komplexní typ s názvem "p", adresa URL může být podobná následující adresu URL.</span><span class="sxs-lookup"><span data-stu-id="8f713-230">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 <span data-ttu-id="8f713-231">Pokud používáte služby ovládacího prvku ASP.NET AJAX skript správce a proxy pro volání služby, tato adresa URL je automaticky generován proxy server a není vidět.</span><span class="sxs-lookup"><span data-stu-id="8f713-231">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="8f713-232">JSON nelze použít v adresách URL na koncové body prvku ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="8f713-232">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>  
  
## <a name="advanced-information"></a><span data-ttu-id="8f713-233">Informace pro pokročilé uživatele</span><span class="sxs-lookup"><span data-stu-id="8f713-233">Advanced information</span></span>  
  
### <a name="iserializable-support"></a><span data-ttu-id="8f713-234">Podpora iSerializable</span><span class="sxs-lookup"><span data-stu-id="8f713-234">ISerializable Support</span></span>  
  
#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="8f713-235">Podporované a nepodporované typy ISerializable</span><span class="sxs-lookup"><span data-stu-id="8f713-235">Supported and Unsupported ISerializable Types</span></span>  
 <span data-ttu-id="8f713-236">Obecně platí, které implementují typy <xref:System.Runtime.Serialization.ISerializable> rozhraní jsou plně podporované při serializaci nebo deserializaci JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-236">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="8f713-237">Ale některé z těchto typů (včetně některé typy rozhraní .NET Framework) jsou implementované tak, že aspekty serializace JSON konkrétní způsobit není správně deserializovat:</span><span class="sxs-lookup"><span data-stu-id="8f713-237">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>  
  
-   <span data-ttu-id="8f713-238">S <xref:System.Runtime.Serialization.ISerializable>, typ jednotlivých datových členů je nikdy předem známo.</span><span class="sxs-lookup"><span data-stu-id="8f713-238">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="8f713-239">To vede k polymorfní situace podobná deserializaci typy do objektu.</span><span class="sxs-lookup"><span data-stu-id="8f713-239">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="8f713-240">Jak je uvedeno nahoře, může to vést ke ztrátě informací o typu ve formátu JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-240">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="8f713-241">Například typ, který serializuje `enum` v jeho <xref:System.Runtime.Serialization.ISerializable> implementace a pokusí se deserializovat zpět přímo do `enum` (bez správné přetypování) se nezdaří, protože `enum` serializován pomocí čísel ve formátu JSON a JSON deserializuje čísla do vestavěné typy rozhraní .NET číselné (Int32, Decimal nebo dvojitou).</span><span class="sxs-lookup"><span data-stu-id="8f713-241">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="8f713-242">Proto fakt, že používá číslo jako `enum` dojde ke ztrátě hodnoty.</span><span class="sxs-lookup"><span data-stu-id="8f713-242">So the fact that the number used to be an `enum` value is lost.</span></span>  
  
-   <span data-ttu-id="8f713-243"><xref:System.Runtime.Serialization.ISerializable> Typ, který závisí na konkrétní pořadí deserializace v jeho konstruktor deserializace může selhat také k deserializaci některá data JSON, protože většina serializátorů JSON nezaručují dodržovat konkrétní pořadí.</span><span class="sxs-lookup"><span data-stu-id="8f713-243">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>  
  
#### <a name="factory-types"></a><span data-ttu-id="8f713-244">Objekt pro vytváření typů</span><span class="sxs-lookup"><span data-stu-id="8f713-244">Factory Types</span></span>  
 <span data-ttu-id="8f713-245">Když <xref:System.Runtime.Serialization.IObjectReference> rozhraní se podporuje ve formátu JSON v obecné, všechny typy, které vyžadují funkci "typ objektu pro vytváření" (vrácení jiného typu z instance <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> než typ, který implementuje rozhraní) nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="8f713-245">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>  
  
### <a name="datetime-wire-format"></a><span data-ttu-id="8f713-246">Data a času přenosový formát</span><span class="sxs-lookup"><span data-stu-id="8f713-246">DateTime Wire Format</span></span>  
 <span data-ttu-id="8f713-247"><xref:System.DateTime> hodnoty se zobrazí jako řetězce JSON ve formě "/ Date(700000+0500) /", kde první číslo (700000 v uvedeném příkladu) je počet milisekund, po v GMT časovém pásmu, regulární (bez-letního) čas od půlnoci 1. ledna 1970.</span><span class="sxs-lookup"><span data-stu-id="8f713-247"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="8f713-248">Číslo může být záporné představují starší časy.</span><span class="sxs-lookup"><span data-stu-id="8f713-248">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="8f713-249">Část, která se skládá z "+0500" v příkladu je volitelný a označuje, že doba je z <xref:System.DateTimeKind.Local> druh – to znamená, by měla být převedena na místní časové pásmo pro deserializaci.</span><span class="sxs-lookup"><span data-stu-id="8f713-249">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="8f713-250">Pokud chybí, je čas deserializovat jako <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="8f713-250">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="8f713-251">Skutečný počet ("0500" v tomto příkladu) a znaménka (+ nebo -) se ignorují.</span><span class="sxs-lookup"><span data-stu-id="8f713-251">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>  
  
 <span data-ttu-id="8f713-252">Při serializaci <xref:System.DateTime>, <xref:System.DateTimeKind.Local> a <xref:System.DateTimeKind.Unspecified> časy jsou zapsány s posunem, a <xref:System.DateTimeKind.Utc> je zapsán bez.</span><span class="sxs-lookup"><span data-stu-id="8f713-252">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>  
  
 <span data-ttu-id="8f713-253">Kód jazyka JavaScript klienta ASP.NET AJAX automaticky převede takové řetězce do jazyka JavaScript `DateTime` instance.</span><span class="sxs-lookup"><span data-stu-id="8f713-253">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="8f713-254">Pokud existují další řetězce, které mají podobné formuláře, které nejsou typu <xref:System.DateTime> v rozhraní .NET, jsou také převést.</span><span class="sxs-lookup"><span data-stu-id="8f713-254">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>  
  
 <span data-ttu-id="8f713-255">Převod pouze probíhá pokud "/" znaky jsou uvozeny uvozovacím znakem (tedy JSON vypadá jako "\\/Date(700000+0500)\\/") a pro tento důvod WCF JSON kodér (povolené ve <xref:System.ServiceModel.WebHttpBinding>) vždy řídicí sekvence znaků "/".</span><span class="sxs-lookup"><span data-stu-id="8f713-255">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>  
  
### <a name="xml-in-json-strings"></a><span data-ttu-id="8f713-256">XML v řetězcích JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-256">XML in JSON Strings</span></span>  
  
#### <a name="xmlelement"></a><span data-ttu-id="8f713-257">XmlElement.</span><span class="sxs-lookup"><span data-stu-id="8f713-257">XmlElement</span></span>  
 <span data-ttu-id="8f713-258"><xref:System.Xml.XmlElement> je serializováno, jako je tomu v žádné zabalení.</span><span class="sxs-lookup"><span data-stu-id="8f713-258"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="8f713-259">Například – datový člen "x" typu <xref:System.Xml.XmlElement> obsahující \<abc / > je reprezentovaný následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="8f713-259">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is as represented as follows.</span></span>  
  
```json  
{"x":"<abc/>"}  
```  
  
#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="8f713-260">XmlNode – pole</span><span class="sxs-lookup"><span data-stu-id="8f713-260">Arrays of XmlNode</span></span>  
 <span data-ttu-id="8f713-261"><xref:System.Array> objekty typu <xref:System.Xml.XmlNode> je uzavřen do elementu s názvem ArrayOfXmlNode v oboru názvů kontraktu standardní data pro typ.</span><span class="sxs-lookup"><span data-stu-id="8f713-261"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="8f713-262">Pokud "x" je pole, které obsahuje atribut uzel "N" v oboru názvů "ns", který obsahuje "value" a do uzlu prázdný element "M", reprezentace je následující.</span><span class="sxs-lookup"><span data-stu-id="8f713-262">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 <span data-ttu-id="8f713-263">Atributy v prázdný oboru názvů na začátku XmlNode pole (před další prvky) nejsou podporovány.</span><span class="sxs-lookup"><span data-stu-id="8f713-263">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>  
  
#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="8f713-264">Typy IXmlSerializable včetně XElement a datové sady</span><span class="sxs-lookup"><span data-stu-id="8f713-264">IXmlSerializable Types including XElement and DataSet</span></span>  
 <span data-ttu-id="8f713-265"><xref:System.Runtime.Serialization.ISerializable> typy rozdělte "typy obsahu", "Datovou sadu typů" a "typů element".</span><span class="sxs-lookup"><span data-stu-id="8f713-265"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="8f713-266">Definice z těchto typů naleznete v tématu [typy XML a ADO.NET v kontraktech dat](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-266">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>  
  
 <span data-ttu-id="8f713-267">"Obsah" a "Datovou sadu" typy jsou serializovat podobná <xref:System.Array> objekty <xref:System.Xml.XmlNode> popsané v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="8f713-267">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="8f713-268">Jsou zabaleny v elementu, jehož název a obor názvů odpovídá názvu kontraktu dat a obor názvů typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-268">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>  
  
 <span data-ttu-id="8f713-269">"Elementu" typy, jako <xref:System.Xml.Linq.XElement> jsou serializovat jako je podobná <xref:System.Xml.XmlElement> dřív popsané v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="8f713-269">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="8f713-270">Polymorfismus</span><span class="sxs-lookup"><span data-stu-id="8f713-270">Polymorphism</span></span>  
  
#### <a name="preserving-type-information"></a><span data-ttu-id="8f713-271">Zachování informací o typu</span><span class="sxs-lookup"><span data-stu-id="8f713-271">Preserving Type Information</span></span>  
 <span data-ttu-id="8f713-272">Jak jsme uvedli dříve, polymorfismus se podporuje ve formátu JSON s omezeními.</span><span class="sxs-lookup"><span data-stu-id="8f713-272">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="8f713-273">JavaScript je slabě typované jazyk a typ identita je obvykle není problém.</span><span class="sxs-lookup"><span data-stu-id="8f713-273">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="8f713-274">Ale při použití formátu JSON pro komunikaci mezi systémem silného typu (.NET) a systém slabě typované (JavaScript), je užitečná k zachování identity typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-274">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="8f713-275">Typy s daty smlouvy například názvy, které "Hranaté" a "V kruhu" jsou odvozeny od typu s názvem kontraktu dat. "Tvar".</span><span class="sxs-lookup"><span data-stu-id="8f713-275">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="8f713-276">Pokud "Kruh" se odesílá z rozhraní .NET pro jazyk JavaScript a později je vrácen do .NET metodu, která očekává "Tvar", je vhodné pro rozhraní .NET straně vědět, že u daného objektu byl původně "Kruh" - jinak žádné informace, které jsou specifické pro odvozený typ (např. člen data "radius" na "Kruh") mohou být ztracena.</span><span class="sxs-lookup"><span data-stu-id="8f713-276">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>  
  
 <span data-ttu-id="8f713-277">K zachování identity typu při serializaci složitých typů JSON nápovědu"typ" lze přidat, a deserializátor rozpozná pomocný parametr a funguje správně.</span><span class="sxs-lookup"><span data-stu-id="8f713-277">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="8f713-278">"Pomocný parametr typu" je dvojice klíč/hodnota JSON s názvem klíče "__type" (dvě podtržítka a potom slovo "typ").</span><span class="sxs-lookup"><span data-stu-id="8f713-278">The "type hint" is a JSON key/value pair with the key name of "__type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="8f713-279">Hodnota je řetězec formátu JSON ve tvaru "DataContractName:DataContractNamespace" (NIC až první dvojtečkou je název).</span><span class="sxs-lookup"><span data-stu-id="8f713-279">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="8f713-280">Pomocí předchozího příkladu, "Kruh" může serializovat následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="8f713-280">Using the earlier example, "Circle" can be serialized as follows.</span></span>  
  
```json  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="8f713-281">Pomocný parametr typu je velmi podobné `xsi:type` atribut definované ve standardu Instance schématu XML a použít při serializaci nebo deserializaci XML.</span><span class="sxs-lookup"><span data-stu-id="8f713-281">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>  
  
 <span data-ttu-id="8f713-282">Datové členy názvem "__type" jsou zakázáno z důvodu potenciální konfliktu s pomocným parametrem typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-282">Data members called "__type" are forbidden due to potential conflict with the type hint.</span></span>  
  
#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="8f713-283">Zmenšení velikosti této pomocné parametry typu</span><span class="sxs-lookup"><span data-stu-id="8f713-283">Reducing the Size of Type Hints</span></span>  
 <span data-ttu-id="8f713-284">Chcete-li snížit velikost JSON zprávy, Předpona oboru názvů kontraktu dat výchozí (http://schemas.datacontract.org/2004/07/) se nahradí znak "#".</span><span class="sxs-lookup"><span data-stu-id="8f713-284">To reduce the size of JSON messages, the default data contract namespace prefix (http://schemas.datacontract.org/2004/07/) is replaced with the "#" character.</span></span> <span data-ttu-id="8f713-285">(Chcete-li tento nahrazení reverzibilního, se používá pravidlo útěku: Pokud obor názvů začíná "#" nebo "\\" znaky, jsou připojeny navíc "\\" znak).</span><span class="sxs-lookup"><span data-stu-id="8f713-285">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="8f713-286">Proto pokud "Kruh" je typu v oboru názvů .NET "MyApp.Shapes", výchozí obor názvů kontraktu dat je http://schemas.datacontract.org/2004/07/MyApp.</span><span class="sxs-lookup"><span data-stu-id="8f713-286">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is http://schemas.datacontract.org/2004/07/MyApp.</span></span> <span data-ttu-id="8f713-287">Tvarů a reprezentace JSON je následující.</span><span class="sxs-lookup"><span data-stu-id="8f713-287">Shapes and the JSON representation is as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="8f713-288">Zkrácený (#MyApp.Shapes) a úplná (http://schemas.datacontract.org/2004/07/MyApp.Shapes) jména odhalíte k deserializaci.</span><span class="sxs-lookup"><span data-stu-id="8f713-288">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>  
  
#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="8f713-289">Typ pozice pomocný parametr v objekty JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-289">Type Hint Position in JSON Objects</span></span>  
 <span data-ttu-id="8f713-290">Všimněte si, že pomocný parametr typu musí být nejdříve uveden v reprezentace JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-290">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="8f713-291">Toto je pouze případě, je důležité při zpracování JSON pořadí dvojic klíč/hodnota.</span><span class="sxs-lookup"><span data-stu-id="8f713-291">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="8f713-292">Například následující není platný způsob, jak určit pomocný parametr typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-292">For example, the following is not a valid way to specify the type hint.</span></span>  
  
```json  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 <span data-ttu-id="8f713-293">Jak <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> používané WCF a ASP.NET AJAX stránky klient vždy emitování pomocný parametr typu první.</span><span class="sxs-lookup"><span data-stu-id="8f713-293">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>  
  
#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="8f713-294">Pomocné parametry typu platí pouze pro komplexní typy</span><span class="sxs-lookup"><span data-stu-id="8f713-294">Type Hints Apply Only to Complex Types</span></span>  
 <span data-ttu-id="8f713-295">Neexistuje žádný způsob, jak emitování typ nápovědu pro jednoduché typy.</span><span class="sxs-lookup"><span data-stu-id="8f713-295">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="8f713-296">Například, pokud má operace <xref:System.Object> návratový typ, ale vrátí kruh, může být reprezentace JSON, jako je uvedené výše a uchování informací o typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-296">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="8f713-297">Ale pokud identifikátor Uri je vrácena, reprezentace JSON je řetězec a skutečnost, že je řetězec představující identifikátoru Uri ztraceny.</span><span class="sxs-lookup"><span data-stu-id="8f713-297">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="8f713-298">To platí pouze pro primitivní typy, ale také do kolekcí a pole.</span><span class="sxs-lookup"><span data-stu-id="8f713-298">This applies not only to primitive types but also to collections and arrays.</span></span>  
  
#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="8f713-299">Když jsou pomocné parametry typu vygenerované</span><span class="sxs-lookup"><span data-stu-id="8f713-299">When Are Type Hints Emitted</span></span>  
 <span data-ttu-id="8f713-300">Pomocné parametry typu může výrazně zvýšit velikost zprávy (jeden ze způsobů, jak zmírnit jde použít kratší obory názvů kontraktu dat. Pokud je to možné).</span><span class="sxs-lookup"><span data-stu-id="8f713-300">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="8f713-301">Proto platí následující pravidla, zda jsou vygenerované pomocné parametry typu:</span><span class="sxs-lookup"><span data-stu-id="8f713-301">Therefore, the following rules govern whether type hints are emitted:</span></span>  
  
-   <span data-ttu-id="8f713-302">Když pomocí prvku ASP.NET AJAX, pomocné parametry typu jsou vždy vygenerované kdykoli je to možné, i v případě, že neexistuje žádná základní nebo odvozené přiřazení – například i v případě, že kroužek je přiřazena k kruh.</span><span class="sxs-lookup"><span data-stu-id="8f713-302">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="8f713-303">(To je potřeba pro plné zpřístupnění proces volání z prostředí slabě typované JSON do prostředí .NET silného typu bez překvapivé ztráty informací.)</span><span class="sxs-lookup"><span data-stu-id="8f713-303">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>  
  
-   <span data-ttu-id="8f713-304">Při použití služby AJAX s bez integrace ASP.NET, pomocné parametry typu jenom vygenerované při přiřazení základní nebo odvozené – který se vygenerované při kroužek je přiřazena k tvar nebo <xref:System.Object> ale ne v případě přiřazení ke kruh.</span><span class="sxs-lookup"><span data-stu-id="8f713-304">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="8f713-305">To poskytuje minimální informace požadované pro správně implementace klienta JavaScript, tedy zvýšení výkonu, ale neposkytuje ochranu proti ztrátě informací typu v nesprávně určené klienty.</span><span class="sxs-lookup"><span data-stu-id="8f713-305">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="8f713-306">Pokud chcete, aby se zabránilo s řešením tohoto problému v klientovi, vyhněte na serveru zcela základní nebo odvozené přiřazení.</span><span class="sxs-lookup"><span data-stu-id="8f713-306">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>  
  
-   <span data-ttu-id="8f713-307">Při použití <xref:System.Runtime.Serialization.DataContractSerializer> typu, `alwaysEmitTypeInformation` parametr konstruktoru umožňuje výběr mezi předchozí dva režimy s výchozím nastavení se "`false`" (pouze emitování pomocné parametry typu případě potřeby).</span><span class="sxs-lookup"><span data-stu-id="8f713-307">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>  
  
#### <a name="duplicate-data-member-names"></a><span data-ttu-id="8f713-308">Duplicitní názvy datových členů</span><span class="sxs-lookup"><span data-stu-id="8f713-308">Duplicate Data Member Names</span></span>  
 <span data-ttu-id="8f713-309">Odvozený typ informace se nachází ve stejném objektu JSON spolu s informacemi základní typ a může dojít v libovolném pořadí.</span><span class="sxs-lookup"><span data-stu-id="8f713-309">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="8f713-310">Například `Shape` může být reprezentován následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="8f713-310">For example, `Shape` may be represented as follows.</span></span>  
  
```json  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 <span data-ttu-id="8f713-311">Zatímco kruh může být reprezentován následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="8f713-311">Whereas Circle may be represented as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 <span data-ttu-id="8f713-312">Pokud základní `Shape` typ také obsažená data člena s názvem "`radius`", to vede k kolize na obou serializace (protože objekty JSON nemůže mít opakující se názvy klíčů) a deserializace (protože je jasné, jestli se "radius" odkazuje na `Shape.radius` nebo `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="8f713-312">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="8f713-313">Proto při koncepci "vlastnost skrytí" (datové členy se stejným názvem na základě a odvozených třídách) se obecně nedoporučuje v třídách kontraktu dat, je ve skutečnosti zakázáno v případě JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-313">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>  
  
#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="8f713-314">Polymorfismus a IXmlSerializable typy</span><span class="sxs-lookup"><span data-stu-id="8f713-314">Polymorphism and IXmlSerializable Types</span></span>  
 <span data-ttu-id="8f713-315"><xref:System.Xml.Serialization.IXmlSerializable> typy polymorphically přiřazeni k sobě navzájem obvyklým tak dlouho, dokud známé typy požadavků, podle pravidel kontrakt obvykle data.</span><span class="sxs-lookup"><span data-stu-id="8f713-315"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="8f713-316">Ale serializaci <xref:System.Xml.Serialization.IXmlSerializable> zadejte místě <xref:System.Object> vede ke ztrátě informací o typu jako výsledek je řetězec formátu JSON.</span><span class="sxs-lookup"><span data-stu-id="8f713-316">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>  
  
#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="8f713-317">Polymorfismus a určitých typech rozhraní</span><span class="sxs-lookup"><span data-stu-id="8f713-317">Polymorphism and Certain Interface Types</span></span>  
 <span data-ttu-id="8f713-318">Je zakázáno k serializaci kolekce typ nebo typ, který implementuje <xref:System.Xml.Serialization.IXmlSerializable> tam, kde typ není kolekce, který není <xref:System.Xml.Serialization.IXmlSerializable> (s výjimkou <xref:System.Object>) se očekává.</span><span class="sxs-lookup"><span data-stu-id="8f713-318">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="8f713-319">Například vlastní rozhraní nazývá `IMyInterface` a typ `MyType` , jak implementovat <xref:System.Collections.Generic.IEnumerable%601> typu `int` a `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="8f713-319">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="8f713-320">Je zakázáno vrácení `MyType` z operace s návratovým typem `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="8f713-320">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="8f713-321">Důvodem je, že `MyType` musí být serializované jako pole JSON a vyžaduje typ nápovědu a jak je uvedeno před nesmí obsahovat nápovědu typ s poli jenom s komplexními typy.</span><span class="sxs-lookup"><span data-stu-id="8f713-321">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>  
  
#### <a name="known-types-and-configuration"></a><span data-ttu-id="8f713-322">Známé typy a konfigurace</span><span class="sxs-lookup"><span data-stu-id="8f713-322">Known Types and Configuration</span></span>  
 <span data-ttu-id="8f713-323">Všechny mechanismů známý typ používané <xref:System.Runtime.Serialization.DataContractSerializer> jsou podporovány také stejným způsobem, pomocí <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="8f713-323">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="8f713-324">Obě serializátorů číst stejného elementu konfigurace [ \<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) v [ \<system.runtime.serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), ke zjištění známé typy přidán prostřednictvím konfiguračního souboru.</span><span class="sxs-lookup"><span data-stu-id="8f713-324">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>  
  
#### <a name="collections-assigned-to-object"></a><span data-ttu-id="8f713-325">Kolekcích přiřazených k objektu</span><span class="sxs-lookup"><span data-stu-id="8f713-325">Collections Assigned to Object</span></span>  
 <span data-ttu-id="8f713-326">Kolekce, které jsou přiřazeny k objektu se serializují jako v případě, že jsou kolekce, které implementují <xref:System.Collections.Generic.IEnumerable%601>: pole JSON s každou položku, která obsahuje pokyn typu, pokud je komplexního typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-326">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="8f713-327">Například <xref:System.Collections.Generic.List%601> typu `Shape` přiřazené <xref:System.Object> vypadá podobně jako následující.</span><span class="sxs-lookup"><span data-stu-id="8f713-327">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>  
  
```json  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 <span data-ttu-id="8f713-328">Při deserializaci zpět do <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="8f713-328">When deserialized back into <xref:System.Object>:</span></span>  
  
-   <span data-ttu-id="8f713-329">`Shape` musí být v seznamu známé typy.</span><span class="sxs-lookup"><span data-stu-id="8f713-329">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="8f713-330">S <xref:System.Collections.Generic.List%601> typu `Shape` v známé typy nemá žádný vliv.</span><span class="sxs-lookup"><span data-stu-id="8f713-330">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="8f713-331">Všimněte si, že není třeba přidávat `Shape` na známé typy na serializaci v tomto případě - udělá se to automaticky.</span><span class="sxs-lookup"><span data-stu-id="8f713-331">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>  
  
-   <span data-ttu-id="8f713-332">Kolekce se deserializovat jako <xref:System.Array> typu <xref:System.Object> obsahující `Shape` instance.</span><span class="sxs-lookup"><span data-stu-id="8f713-332">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>  
  
#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="8f713-333">Odvozené kolekcích přiřazených do základní kolekcí</span><span class="sxs-lookup"><span data-stu-id="8f713-333">Derived Collections Assigned to Base Collections</span></span>  
 <span data-ttu-id="8f713-334">Při odvozené kolekce je přiřazena k základní kolekce, kolekce obvykle serializovat, jako kdyby byl kolekce základního typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-334">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="8f713-335">Pokud typ položky odvozené kolekce nelze nastavit na typ položky základní kolekce, je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="8f713-335">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>  
  
#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="8f713-336">Pomocné parametry typu a slovník</span><span class="sxs-lookup"><span data-stu-id="8f713-336">Type Hints and Dictionaries</span></span>  
 <span data-ttu-id="8f713-337">Když je slovník přiřazení <xref:System.Object>, každou položku klíče a hodnoty ve slovníku považuje, jako kdyby byl přiřazen <xref:System.Object> a získá pomocný parametr typu.</span><span class="sxs-lookup"><span data-stu-id="8f713-337">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>  
  
 <span data-ttu-id="8f713-338">Při serializaci typy slovník, je objekt JSON, který obsahuje členy "Klíč" a "Value" nemá vliv `alwaysEmitTypeInformation` nastavení a pokud to vyžadují výše uvedená pravidla kolekce obsahuje pouze typ nápovědu.</span><span class="sxs-lookup"><span data-stu-id="8f713-338">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>  
  
### <a name="valid-json-key-names"></a><span data-ttu-id="8f713-339">Názvy klíčů platný kód JSON</span><span class="sxs-lookup"><span data-stu-id="8f713-339">Valid JSON Key Names</span></span>  
 <span data-ttu-id="8f713-340">Serializátor XML kóduje názvy klíčů, které nejsou platné názvy XML.</span><span class="sxs-lookup"><span data-stu-id="8f713-340">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="8f713-341">Například datový člen s názvem "123" by mít kódovaného název jako "_x0031\__x0032\__x0033\_" protože "123" je neplatný název elementu XML (začíná číslice).</span><span class="sxs-lookup"><span data-stu-id="8f713-341">For example, a data member with the name of "123" would have an encoded name such as "_x0031\__x0032\__x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="8f713-342">Podobné situace může nastat u některé mezinárodní znakové sady v názvech XML není platná.</span><span class="sxs-lookup"><span data-stu-id="8f713-342">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="8f713-343">Další informace o této účinku XML na zpracování JSON, najdete v části [mapování mezi JSON a XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="8f713-343">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8f713-344">Viz také</span><span class="sxs-lookup"><span data-stu-id="8f713-344">See Also</span></span>  
 [<span data-ttu-id="8f713-345">Podpora JSON a dalších formátů přenosu dat</span><span class="sxs-lookup"><span data-stu-id="8f713-345">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
