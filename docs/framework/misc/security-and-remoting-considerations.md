---
title: "Důležité informace o zabezpečení a vzdálené komunikaci"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
caps.latest.revision: "10"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 38b4f61b334a41cedf812a900265af95f1f52e61
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/22/2017
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="c9162-102">Důležité informace o zabezpečení a vzdálené komunikaci</span><span class="sxs-lookup"><span data-stu-id="c9162-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="c9162-103">Vzdálená komunikace umožňuje nastavit průhledné volání mezi doménami aplikace, procesy nebo počítače.</span><span class="sxs-lookup"><span data-stu-id="c9162-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="c9162-104">Procházení zásobníku zabezpečení přístupu kódu však nemůže překročit hranice procesu nebo počítače (použít mezi doménami aplikací stejného procesu).</span><span class="sxs-lookup"><span data-stu-id="c9162-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="c9162-105">Všechny třídy, která je vzdáleně nastavitelné (odvozený od <xref:System.MarshalByRefObject> třída) musí převzít odpovědnost za účelem zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="c9162-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="c9162-106">Buď kód by měl použít pouze v uzavřené prostředích, kde může být implicitně důvěryhodné volající kód nebo Vzdálená volání by měly být navrženy tak, aby se není předmětem chráněný kód mimo položku, která lze zneužít.</span><span class="sxs-lookup"><span data-stu-id="c9162-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="c9162-107">Obecně platí, které byste nikdy neměli zveřejňovat metody, vlastnosti a události, které jsou chráněné pomocí deklarativní [LinkDemand](../../../docs/framework/misc/link-demands.md) a <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> kontroly zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="c9162-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](../../../docs/framework/misc/link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="c9162-108">S vzdálenou komunikaci nejsou tyto kontroly vynutí.</span><span class="sxs-lookup"><span data-stu-id="c9162-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="c9162-109">Další kontroly zabezpečení, jako například <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md)a tak dále fungovat mezi doménami aplikací v rámci procesu, ale nefungují ve scénářích napříč procesem nebo počítači.</span><span class="sxs-lookup"><span data-stu-id="c9162-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="c9162-110">Chráněných objektů</span><span class="sxs-lookup"><span data-stu-id="c9162-110">Protected objects</span></span>  
 <span data-ttu-id="c9162-111">Některé objekty uložení stavu zabezpečení v sami.</span><span class="sxs-lookup"><span data-stu-id="c9162-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="c9162-112">Tyto objekty by neměl být předána do nedůvěryhodné kód, který by pak získal autorizaci zabezpečení mimo vlastní oprávnění.</span><span class="sxs-lookup"><span data-stu-id="c9162-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="c9162-113">Příkladem je vytvoření <xref:System.IO.FileStream> objektu.</span><span class="sxs-lookup"><span data-stu-id="c9162-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="c9162-114"><xref:System.Security.Permissions.FileIOPermission> Je požadováno v době vytvoření a pokud se aktivace podaří, je vrácen objekt souboru.</span><span class="sxs-lookup"><span data-stu-id="c9162-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="c9162-115">Ale pokud odkaz na tento objekt je předán do kódu bez oprávnění k souboru, objekt bude moct číst a zapisovat do tohoto konkrétního souboru.</span><span class="sxs-lookup"><span data-stu-id="c9162-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="c9162-116">Nejjednodušší obrana pro takový objekt je požadovat stejný **FileIOPermission** jakéhokoli kódu, který se snaží získat odkaz na objekt prostřednictvím veřejného elementu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c9162-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="c9162-117">Překročení problémy v doméně aplikace</span><span class="sxs-lookup"><span data-stu-id="c9162-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="c9162-118">Když Pokud chcete izolovat kódu ve spravovaných prostředích hostingu, je běžné generovat více podřízených domén aplikace s explicitní zásad snížení úrovně oprávnění pro různé sestavení.</span><span class="sxs-lookup"><span data-stu-id="c9162-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="c9162-119">Zásady pro tyto sestavení zůstává však beze změny ve výchozí doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9162-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="c9162-120">Pokud jeden z podřízených domén aplikace může vynutit výchozí doménu aplikace pro načtení sestavení, dojde ke ztrátě účinku izolace kódu a typy vynucené načíst sestavení budou moci spustit kód na vyšší úrovni důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="c9162-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="c9162-121">Domény aplikace můžete vynutit jinou doménu aplikace pro načtení sestavení a spuštění kódu v něm obsažený voláním proxy server na objekt hostované v jiné doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9162-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="c9162-122">Pokud chcete získat proxy aplikace. mezi doménami, musíte distribuovat hostování objektu domény aplikace jedna prostřednictvím volání metoda hodnotu parametru nebo return.</span><span class="sxs-lookup"><span data-stu-id="c9162-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="c9162-123">Nebo, pokud doména aplikace byl právě vytvořen, Tvůrce má proxy server a <xref:System.AppDomain> objekt ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="c9162-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="c9162-124">Aby se zabránilo narušení izolace kódu, proto by nemělo domény aplikace s vyšší úrovní důvěryhodnosti distribuovat odkazy na objekty zařazené pomocí odkazu (instance třídy odvozené od <xref:System.MarshalByRefObject>) ve své doméně do domén aplikace s nižší úrovně důvěryhodnosti.</span><span class="sxs-lookup"><span data-stu-id="c9162-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="c9162-125">Výchozí doméně aplikace obvykle vytvoří podřízené domény aplikace s objekt ovládacího prvku v každé z nich.</span><span class="sxs-lookup"><span data-stu-id="c9162-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="c9162-126">Objekt ovládacího prvku spravuje novou doménu aplikace a někdy trvá objednávky z výchozí doménu aplikace, ale nemůže kontaktovat domény přímo.</span><span class="sxs-lookup"><span data-stu-id="c9162-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="c9162-127">V některých případech výchozí doméně aplikace volá jeho proxy objekt ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="c9162-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="c9162-128">Však může být případy, ve které je nezbytné pro objekt ovládacího prvku volat zpět na výchozí doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9162-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="c9162-129">V těchto případech výchozí doméně aplikace předá objekt zpětného volání zařazování odkazem do konstruktoru objektu objekt ovládacího prvku.</span><span class="sxs-lookup"><span data-stu-id="c9162-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="c9162-130">Je zodpovědností objekt ovládacího prvku, který chcete chránit tento proxy server.</span><span class="sxs-lookup"><span data-stu-id="c9162-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="c9162-131">Pokud objekt ovládacího prvku umístit proxy server na veřejné statické pole veřejné třídy nebo jinak veřejně odhalí proxy server, to by otevře nebezpečná mechanismus pro jiný kód pro zpětné volání do výchozí doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9162-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="c9162-132">Z tohoto důvodu jsou vždy objekty řízení implicitně důvěryhodné zachovat privátní proxy serveru.</span><span class="sxs-lookup"><span data-stu-id="c9162-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c9162-133">Viz také</span><span class="sxs-lookup"><span data-stu-id="c9162-133">See Also</span></span>  
 [<span data-ttu-id="c9162-134">Pokyny pro zabezpečené kódování</span><span class="sxs-lookup"><span data-stu-id="c9162-134">Secure Coding Guidelines</span></span>](../../../docs/standard/security/secure-coding-guidelines.md)
