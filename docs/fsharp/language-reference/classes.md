---
title: "Třídy (F#)"
description: "Zjistěte, jak F # třídy jsou typy, které představují objekty, které mohou mít vlastnosti, metod a události."
keywords: "Visual f #, f #, funkční programování"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: d58679d5-7753-4b3b-a12f-6e9f00ed5ba3
ms.openlocfilehash: 2a73baba1f7c1b0d3bd09d22c9d6d9f0524daef3
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/18/2017
---
# <a name="classes"></a><span data-ttu-id="417e6-104">Třídy</span><span class="sxs-lookup"><span data-stu-id="417e6-104">Classes</span></span>

<span data-ttu-id="417e6-105">*Třídy* jsou typy, které představují objekty, které mohou mít vlastnosti, metod a události.</span><span class="sxs-lookup"><span data-stu-id="417e6-105">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>


## <a name="syntax"></a><span data-ttu-id="417e6-106">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="417e6-106">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="417e6-107">Poznámky</span><span class="sxs-lookup"><span data-stu-id="417e6-107">Remarks</span></span>
<span data-ttu-id="417e6-108">Třídy představují základní popis typy objektů .NET; Třída je koncept primární typ, který podporuje objektově orientované programování v F #.</span><span class="sxs-lookup"><span data-stu-id="417e6-108">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="417e6-109">V předchozím syntaxi `type-name` je libovolný platný identifikátor.</span><span class="sxs-lookup"><span data-stu-id="417e6-109">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="417e6-110">`type-params` Popisuje parametry volitelné obecného typu.</span><span class="sxs-lookup"><span data-stu-id="417e6-110">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="417e6-111">Obsahuje názvy parametrů typu a omezení uzavřené v lomených závorkách (`<` a `>`).</span><span class="sxs-lookup"><span data-stu-id="417e6-111">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="417e6-112">Další informace najdete v tématu [obecné typy](generics/index.md) a [omezení](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="417e6-112">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="417e6-113">`parameter-list` Popisuje parametry konstruktor.</span><span class="sxs-lookup"><span data-stu-id="417e6-113">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="417e6-114">První – modifikátor přístupu se vztahují na typ; druhá se vztahují na primární konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="417e6-114">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="417e6-115">V obou případech se výchozí hodnota je `public`.</span><span class="sxs-lookup"><span data-stu-id="417e6-115">In both cases, the default is `public`.</span></span>

<span data-ttu-id="417e6-116">Zadejte základní třídu pro třídy pomocí `inherit` – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="417e6-116">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="417e6-117">Je třeba zadat argumenty, v závorkách, pro konstruktor základní třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-117">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="417e6-118">Deklarace pole nebo hodnoty, které jsou místní vzhledem k třídě pomocí funkce `let` vazby a musí postupovat podle obecná pravidla pro `let` vazby.</span><span class="sxs-lookup"><span data-stu-id="417e6-118">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="417e6-119">`do-bindings` Část obsahuje být spuštěn při vytváření objektů.</span><span class="sxs-lookup"><span data-stu-id="417e6-119">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="417e6-120">`member-list` Se skládá z další konstruktory, instanci a statickou metodu deklarace, rozhraní deklarace, abstraktní vazby a deklarace vlastnosti a události.</span><span class="sxs-lookup"><span data-stu-id="417e6-120">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="417e6-121">Tyto možnosti jsou popsány v [členy](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="417e6-121">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="417e6-122">`identifier` Používané s nepovinným `as` – klíčové slovo poskytuje název pro proměnnou instance nebo vlastní identifikátor, který můžete použít v definici typu, který bude odkazovat na instanci typu.</span><span class="sxs-lookup"><span data-stu-id="417e6-122">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="417e6-123">Další informace najdete v části identifikátory samoobslužné později v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="417e6-123">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="417e6-124">Klíčová slova `class` a `end` , označte začátku a konce definice jsou volitelné.</span><span class="sxs-lookup"><span data-stu-id="417e6-124">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="417e6-125">Vzájemně rekurzivní typy, které jsou typy, které odkazují na sobě navzájem, připojeni společně s `and` stejně jako vzájemně rekurzivní funkce jsou – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="417e6-125">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="417e6-126">Příklad najdete v části vzájemně rekurzivní typy.</span><span class="sxs-lookup"><span data-stu-id="417e6-126">For an example, see the section Mutually Recursive Types.</span></span>


## <a name="constructors"></a><span data-ttu-id="417e6-127">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="417e6-127">Constructors</span></span>
<span data-ttu-id="417e6-128">Konstruktor je kód, který vytvoří instanci typu třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-128">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="417e6-129">Konstruktory pro třídy fungují v jazyce F # trochu jinak než v jinými jazyky rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="417e6-129">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="417e6-130">F # třídy, je vždy primární konstruktor jejichž argumenty jsou popsané v `parameter-list` , následuje název typu a jehož subjekt se skládá z `let` (a `let rec`) vazby na začátku deklaraci třídy a `do`vazby, které následují.</span><span class="sxs-lookup"><span data-stu-id="417e6-130">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="417e6-131">Argumenty primární konstruktoru jsou v oboru v rámci deklaraci třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-131">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="417e6-132">Můžete přidat další konstruktory pomocí `new` – klíčové slovo přidání člena, následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="417e6-132">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="417e6-133">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="417e6-133">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="417e6-134">Text nového konstruktor musí volat primární konstruktor, který je zadán v horní části deklaraci třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-134">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="417e6-135">Následující příklad ilustruje tento koncept.</span><span class="sxs-lookup"><span data-stu-id="417e6-135">The following example illustrates this concept.</span></span> <span data-ttu-id="417e6-136">V následujícím kódu `MyClass` má dva konstruktory, primární konstruktor, který přebírá dva argumenty a jiný konstruktor, který nezadávaly žádné argumenty.</span><span class="sxs-lookup"><span data-stu-id="417e6-136">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a><span data-ttu-id="417e6-137">umožňují a do – vazby</span><span class="sxs-lookup"><span data-stu-id="417e6-137">let and do Bindings</span></span>

<span data-ttu-id="417e6-138">`let` a `do` vazby v definici třídy tvoří text konstruktoru třídy primární, a proto spustit vždy, když se vytvoří instance třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-138">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="417e6-139">Pokud `let` vazba je funkce, a potom se zkompiluje do člena.</span><span class="sxs-lookup"><span data-stu-id="417e6-139">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="417e6-140">Pokud `let` vazba je hodnota, která se nepoužívá v libovolném funkce nebo člen a pak se zkompiluje do proměnné, která je místní pro konstruktor.</span><span class="sxs-lookup"><span data-stu-id="417e6-140">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="417e6-141">Jinak je zkompilovat do pole třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-141">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="417e6-142">`do` Výrazy, které následují kompilovány do primární konstruktor a spouštění kódu inicializace pro všechny instance.</span><span class="sxs-lookup"><span data-stu-id="417e6-142">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="417e6-143">Vzhledem k tomu, že žádné další konstruktory vždy volat primární konstruktor, `let` vazby a `do` vazby vždy provést bez ohledu na to, které volání konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="417e6-143">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="417e6-144">Pole, které jsou vytvořené pomocí `let` vazby je přístupná prostřednictvím metody a vlastnosti třídy; však budou nelze získat přístup z statických metod, i pokud statických metod proměnnou instance jako parametr.</span><span class="sxs-lookup"><span data-stu-id="417e6-144">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="417e6-145">Nemůže být přistupovali pomocí vlastní identifikátor, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="417e6-145">They cannot be accessed by using the self identifier, if one exists.</span></span>


## <a name="self-identifiers"></a><span data-ttu-id="417e6-146">Self – identifikátory</span><span class="sxs-lookup"><span data-stu-id="417e6-146">Self Identifiers</span></span>

<span data-ttu-id="417e6-147">A *vlastní identifikátor* je název, který představuje aktuální instanci.</span><span class="sxs-lookup"><span data-stu-id="417e6-147">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="417e6-148">Self – identifikátory vypadat `this` – klíčové slovo v C# nebo C++ nebo `Me` v jazyce Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="417e6-148">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="417e6-149">Můžete definovat vlastní identifikátor dvěma různými způsoby v závislosti na tom, zda má být v oboru pro definici celou třídy nebo pouze pro jednotlivé metody vlastní identifikátor.</span><span class="sxs-lookup"><span data-stu-id="417e6-149">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="417e6-150">Chcete-li definovat vlastní identifikátor pro celou třídu, použijte `as` – klíčové slovo po zavření závorkách parametr konstruktoru seznamu a zadejte název identifikátoru.</span><span class="sxs-lookup"><span data-stu-id="417e6-150">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="417e6-151">K definování vlastní identifikátor pro právě jednu metodu, zadejte vlastní identifikátor v deklaraci člen, těsně před název metody a tečka (.) jako oddělovač.</span><span class="sxs-lookup"><span data-stu-id="417e6-151">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="417e6-152">Následující příklad kódu ukazuje dva způsoby vytvoření vlastní identifikátor.</span><span class="sxs-lookup"><span data-stu-id="417e6-152">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="417e6-153">V prvním řádku `as` – klíčové slovo se používá k definování vlastní identifikátor.</span><span class="sxs-lookup"><span data-stu-id="417e6-153">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="417e6-154">V páté řádku identifikátor `this` se používá k definování vlastní identifikátor, jejíž obor je omezen na metodu `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="417e6-154">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="417e6-155">Na rozdíl od v jiných jazyků .NET, můžete pojmenovat vlastní identifikátor ale chcete; nejsou omezena na názvy, jako `self`, `Me`, nebo `this`.</span><span class="sxs-lookup"><span data-stu-id="417e6-155">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="417e6-156">Vlastní identifikátor, který je deklarovaný s `as` – klíčové slovo není inicializován až po `let` provedení vazby.</span><span class="sxs-lookup"><span data-stu-id="417e6-156">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="417e6-157">Proto jej nelze použít v `let` vazby.</span><span class="sxs-lookup"><span data-stu-id="417e6-157">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="417e6-158">Můžete použít vlastní identifikátor v `do` části vazby.</span><span class="sxs-lookup"><span data-stu-id="417e6-158">You can use the self identifier in the `do` bindings section.</span></span>


## <a name="generic-type-parameters"></a><span data-ttu-id="417e6-159">Parametry obecného typu</span><span class="sxs-lookup"><span data-stu-id="417e6-159">Generic Type Parameters</span></span>

<span data-ttu-id="417e6-160">Parametry obecného typu jsou určené v lomené závorky (`<` a `>`), ve formě jednoduché uvozovky, za nímž následuje identifikátor elementu.</span><span class="sxs-lookup"><span data-stu-id="417e6-160">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="417e6-161">Několik parametrů obecného typu jsou oddělené čárkami.</span><span class="sxs-lookup"><span data-stu-id="417e6-161">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="417e6-162">Parametr obecného typu je v oboru v celém prohlášení.</span><span class="sxs-lookup"><span data-stu-id="417e6-162">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="417e6-163">Následující příklad kódu ukazuje, jak zadat parametry obecného typu.</span><span class="sxs-lookup"><span data-stu-id="417e6-163">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="417e6-164">Argumenty typu jsou odvodit při použití typu.</span><span class="sxs-lookup"><span data-stu-id="417e6-164">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="417e6-165">V následujícím kódu je odvozeném typu pořadí řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="417e6-165">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a><span data-ttu-id="417e6-166">Určení dědičnosti</span><span class="sxs-lookup"><span data-stu-id="417e6-166">Specifying Inheritance</span></span>

<span data-ttu-id="417e6-167">`inherit` Klauzule identifikuje přímé základní třídy, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="417e6-167">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="417e6-168">V F # je povolen pouze jeden přímé základní třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-168">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="417e6-169">Rozhraní, která implementuje třídu nejsou považovány za základní třídy.</span><span class="sxs-lookup"><span data-stu-id="417e6-169">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="417e6-170">Rozhraní, které jsou popsané v [rozhraní](Interfaces.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="417e6-170">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="417e6-171">Metody a vlastnosti základní třídy můžete přistupovat z odvozené třídy pomocí klíčové slovo jazyka `base` jako identifikátor, za nímž následuje tečka (.) a název člena.</span><span class="sxs-lookup"><span data-stu-id="417e6-171">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="417e6-172">Další informace najdete v tématu [dědičnosti](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="417e6-172">For more information, see [Inheritance](inheritance.md).</span></span>


## <a name="members-section"></a><span data-ttu-id="417e6-173">Oddíl členové</span><span class="sxs-lookup"><span data-stu-id="417e6-173">Members Section</span></span>
<span data-ttu-id="417e6-174">V této části můžete definovat statické nebo instanci metody, vlastnosti, implementace rozhraní, abstraktní členy, událostí prohlášení a další konstruktory.</span><span class="sxs-lookup"><span data-stu-id="417e6-174">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="417e6-175">Umožňují a provést vazby nemůže vyskytovat v této části.</span><span class="sxs-lookup"><span data-stu-id="417e6-175">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="417e6-176">Vzhledem k tomu, že členové mohou být přidány do různých typů F # kromě třídy, jsou popsané v samostatném tématu, [členy](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="417e6-176">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>


## <a name="mutually-recursive-types"></a><span data-ttu-id="417e6-177">Vzájemně rekurzivní typy</span><span class="sxs-lookup"><span data-stu-id="417e6-177">Mutually Recursive Types</span></span>
<span data-ttu-id="417e6-178">Když definujete typy, které vzájemně odkazovat cyklické způsobem, můžete řetězec společně definic typů pomocí `and` – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="417e6-178">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="417e6-179">`and` Nahrazuje – klíčové slovo `type` – klíčové slovo na všech kromě první definice, následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="417e6-179">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="417e6-180">Výstup je seznam všech souborů v aktuálním adresáři.</span><span class="sxs-lookup"><span data-stu-id="417e6-180">The output is a list of all the files in the current directory.</span></span>


## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="417e6-181">Kdy použít třídy, sjednocení, záznamy a struktury</span><span class="sxs-lookup"><span data-stu-id="417e6-181">When to Use Classes, Unions, Records, and Structures</span></span>
<span data-ttu-id="417e6-182">Zadána řadu typů na výběr, je potřeba mít dobrou znalost jazyka co každý typ je určen pro vyberte odpovídající typ pro konkrétní situaci.</span><span class="sxs-lookup"><span data-stu-id="417e6-182">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="417e6-183">Třídy jsou navrženy pro použití v objektově orientované programování kontexty.</span><span class="sxs-lookup"><span data-stu-id="417e6-183">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="417e6-184">Objektově orientované programování je dominantní zlepší používat v aplikacích, které jsou napsané pro rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="417e6-184">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="417e6-185">Pokud má váš kód F # úzce spolupracovat rozhraní .NET Framework nebo jiné knihovny objektově orientované a obzvláště pokud máte rozšíření z objektově orientované typ systému, jako je například knihovna uživatelského rozhraní, třídy jsou pravděpodobně vhodné.</span><span class="sxs-lookup"><span data-stu-id="417e6-185">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="417e6-186">Pokud nejsou úzce spolupráce s objektově orientované kód, nebo pokud píšete kód, který je samostatný a proto chráněný před časté interakci s objektově orientované kódu, byste měli zvážit použití záznamů a rozlišované sjednocení.</span><span class="sxs-lookup"><span data-stu-id="417e6-186">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="417e6-187">Jedinou dobře myšlenku – out rozlišovaná sjednocení, společně s odpovídající vzor odpovídající kód, můžete často použít jako jednodušší alternativní hierarchii objektu.</span><span class="sxs-lookup"><span data-stu-id="417e6-187">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="417e6-188">Další informace o rozlišovaná sjednocení najdete v tématu [Rozlišované sjednocení](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="417e6-188">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="417e6-189">Výhodou je jednodušší než třídy jsou záznamy, ale záznamy nejsou vhodné, pokud jsou požadavky typ překročit, co můžete udělat s jejich jednoduchost.</span><span class="sxs-lookup"><span data-stu-id="417e6-189">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="417e6-190">Záznamy jsou v podstatě jednoduché agregace hodnot, bez samostatné konstruktory, které můžete provést vlastní akci, bez skrytá pole a bez implementace dědičnosti nebo rozhraní.</span><span class="sxs-lookup"><span data-stu-id="417e6-190">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="417e6-191">Členy například vlastnosti a metody, je možné přidat záznamy, aby jejich chování složitější, pole uložené v záznamu jsou stále jednoduché agregace hodnot.</span><span class="sxs-lookup"><span data-stu-id="417e6-191">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="417e6-192">Další informace o záznamech najdete v tématu [záznamy](records.md).</span><span class="sxs-lookup"><span data-stu-id="417e6-192">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="417e6-193">Struktury jsou užitečné i pro malý agregace dat, ale se liší od třídy a záznamy, protože se typy hodnotu .NET.</span><span class="sxs-lookup"><span data-stu-id="417e6-193">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="417e6-194">Třídy a záznamy jsou referenční typy .NET.</span><span class="sxs-lookup"><span data-stu-id="417e6-194">Classes and records are .NET reference types.</span></span> <span data-ttu-id="417e6-195">Sémantika typy hodnot a typy odkazu se liší, že jsou typy hodnot předaná hodnota.</span><span class="sxs-lookup"><span data-stu-id="417e6-195">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="417e6-196">To znamená, že se kopírují bit pro bit, pokud jsou předána jako parametr nebo vrácená z funkce.</span><span class="sxs-lookup"><span data-stu-id="417e6-196">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="417e6-197">Jsou také uloženy v zásobníku nebo, pokud se používají jako pole, vložený v nadřazeném objektu místo, které jsou uložené v vlastní samostatné umístění v haldě.</span><span class="sxs-lookup"><span data-stu-id="417e6-197">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="417e6-198">Proto jsou vhodné pro často používaná data struktury, když nároky na přístup k haldě k potížím.</span><span class="sxs-lookup"><span data-stu-id="417e6-198">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="417e6-199">Další informace o struktury najdete v tématu [struktury](structures.md).</span><span class="sxs-lookup"><span data-stu-id="417e6-199">For more information about structures, see [Structures](structures.md).</span></span>


## <a name="see-also"></a><span data-ttu-id="417e6-200">Viz také</span><span class="sxs-lookup"><span data-stu-id="417e6-200">See Also</span></span>
[<span data-ttu-id="417e6-201">Referenční dokumentace jazyka F #</span><span class="sxs-lookup"><span data-stu-id="417e6-201">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="417e6-202">Členy</span><span class="sxs-lookup"><span data-stu-id="417e6-202">Members</span></span>](members/index.md)

[<span data-ttu-id="417e6-203">Dědičnost</span><span class="sxs-lookup"><span data-stu-id="417e6-203">Inheritance</span></span>](inheritance.md)

[<span data-ttu-id="417e6-204">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="417e6-204">Interfaces</span></span>](interfaces.md)

