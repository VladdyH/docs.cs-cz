---
title: Pravidla formátování kódu (F#)
description: 'Další kód odsazení formátování pokyny pro programovací jazyk pro čitelnost, estetiku, standardizace a kompilace F #.'
ms.date: 05/16/2016
ms.openlocfilehash: 5bb1f9958a21beb795f9174e44f24c7194453fc3
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33564827"
---
# <a name="code-formatting-guidelines"></a><span data-ttu-id="aefbb-103">Pravidla formátování kódu</span><span class="sxs-lookup"><span data-stu-id="aefbb-103">Code Formatting Guidelines</span></span>

<span data-ttu-id="aefbb-104">Toto téma shrnuje kód odsazení pokyny pro F #.</span><span class="sxs-lookup"><span data-stu-id="aefbb-104">This topic summarizes code indentation guidelines for F#.</span></span> <span data-ttu-id="aefbb-105">Jazyk F # je citlivá na konce řádků a odsazení, a proto není právě čitelnost problém, estetické problém nebo problém kódování standardizace k formátování kódu správně.</span><span class="sxs-lookup"><span data-stu-id="aefbb-105">Because the F# language is sensitive to line breaks and indentation, it is not just a readability issue, aesthetic issue, or coding standardization issue to format your code correctly.</span></span> <span data-ttu-id="aefbb-106">Je třeba naformátovat kódu správně pro něj pro správnou kompilaci.</span><span class="sxs-lookup"><span data-stu-id="aefbb-106">You must format your code correctly for it to compile correctly.</span></span>


## <a name="general-rules-for-indentation"></a><span data-ttu-id="aefbb-107">Obecná pravidla pro odsazení</span><span class="sxs-lookup"><span data-stu-id="aefbb-107">General Rules for Indentation</span></span>
<span data-ttu-id="aefbb-108">Pokud je požadována odsazení, je nutné použít mezery, tabulátory není.</span><span class="sxs-lookup"><span data-stu-id="aefbb-108">When indentation is required, you must use spaces, not tabs.</span></span> <span data-ttu-id="aefbb-109">Je vyžadován alespoň jeden prostor.</span><span class="sxs-lookup"><span data-stu-id="aefbb-109">At least one space is required.</span></span> <span data-ttu-id="aefbb-110">Vaše organizace můžete vytvořit kódování standardy k určení počtu prostory pro odsazení; tři nebo čtyři prostory odsazení na každé úrovni, kde dochází k odsazení je typické.</span><span class="sxs-lookup"><span data-stu-id="aefbb-110">Your organization can create coding standards to specify the number of spaces to use for indentation; three or four spaces of indentation at each level where indentation occurs is typical.</span></span> <span data-ttu-id="aefbb-111">Můžete nakonfigurovat tak, aby odpovídaly vaší organizace odsazení standardy změnou možnosti v aplikaci Visual Studio `Options` dialogové okno, která je k dispozici z `Tools` nabídky.</span><span class="sxs-lookup"><span data-stu-id="aefbb-111">You can configure Visual Studio to match your organization's indentation standards by changing the options in the `Options` dialog box, which is available from the `Tools` menu.</span></span> <span data-ttu-id="aefbb-112">V `Text Editor` uzlu, rozbalte položku `F#` a pak klikněte na tlačítko `Tabs`.</span><span class="sxs-lookup"><span data-stu-id="aefbb-112">In the `Text Editor` node, expand `F#` and then click `Tabs`.</span></span> <span data-ttu-id="aefbb-113">Popis dostupných možností najdete v tématu [možnosti, textový Editor, všechny jazyky, karty](https://msdn.microsoft.com/library/7sffa753.aspx).</span><span class="sxs-lookup"><span data-stu-id="aefbb-113">For a description of the available options, see [Options, Text Editor, All Languages, Tabs](https://msdn.microsoft.com/library/7sffa753.aspx).</span></span>

<span data-ttu-id="aefbb-114">Obecně platí když kompilátor analyzuje kódu, udržuje interní zásobníku, který označuje aktuální úroveň vnoření.</span><span class="sxs-lookup"><span data-stu-id="aefbb-114">In general, when the compiler parses your code, it maintains an internal stack that indicates the current level of nesting.</span></span> <span data-ttu-id="aefbb-115">Při představují odsazení kódu novou úroveň vnoření je vytvořen nebo nabídnutých do této interní zásobníku.</span><span class="sxs-lookup"><span data-stu-id="aefbb-115">When code is indented, a new level of nesting is created, or pushed onto this internal stack.</span></span> <span data-ttu-id="aefbb-116">Při ukončení konstrukt, úroveň je odebrány.</span><span class="sxs-lookup"><span data-stu-id="aefbb-116">When a construct ends, the level is popped.</span></span> <span data-ttu-id="aefbb-117">Odsazení je jedním ze způsobů signál konec úrovní a pop interní zásobníku, ale některé tokeny také způsobit na úroveň být odebrány, jako `end` – klíčové slovo, nebo pravé složené závorce nebo závorky.</span><span class="sxs-lookup"><span data-stu-id="aefbb-117">Indentation is one way to signal the end of a level and pop the internal stack, but certain tokens also cause the level to be popped, such as the `end` keyword, or a closing brace or parenthesis.</span></span>

<span data-ttu-id="aefbb-118">Kód na Víceřádkový konstrukce, jako je například typ definice, definice funkce `try...with` konstrukce a opakování ve smyčce konstrukce, musí být odsazeny relativně k otevírání řádku konstruktu.</span><span class="sxs-lookup"><span data-stu-id="aefbb-118">Code in a multiline construct, such as a type definition, function definition, `try...with` construct, and looping constructs, must be indented relative to the opening line of the construct.</span></span> <span data-ttu-id="aefbb-119">První řádek zobrazují odsazené určuje pozici sloupce pro následné kódu ve stejné konstrukce.</span><span class="sxs-lookup"><span data-stu-id="aefbb-119">The first indented line establishes a column position for subsequent code in the same construct.</span></span> <span data-ttu-id="aefbb-120">Je volána úrovně odsazení *kontextu*.</span><span class="sxs-lookup"><span data-stu-id="aefbb-120">The indentation level is called a *context*.</span></span> <span data-ttu-id="aefbb-121">Pozice sloupec Nastaví minimální sloupci, označuje jako *offside řádku*, pro následující řádky kódu, které jsou ve stejné oblasti.</span><span class="sxs-lookup"><span data-stu-id="aefbb-121">The column position sets a minimum column, referred to as an *offside line*, for subsequent lines of code that are in the same context.</span></span> <span data-ttu-id="aefbb-122">Když je zjistil řádek kódu se zobrazují odsazené méně než této pozice zavedených sloupec, kompilátor předpokládá, že kontext skončila a že je nyní implementován na další úrovni, v rámci předchozí.</span><span class="sxs-lookup"><span data-stu-id="aefbb-122">When a line of code is encountered that is indented less than this established column position, the compiler assumes that the context has ended and that you are now coding at the next level up, in the previous context.</span></span> <span data-ttu-id="aefbb-123">Termín *offside* se používá k popisu stavu, ve kterém řádek kódu aktivuje konec konstrukt, protože není dostatečně odsazeny.</span><span class="sxs-lookup"><span data-stu-id="aefbb-123">The term *offside* is used to describe the condition in which a line of code triggers the end of a construct because it is not indented far enough.</span></span> <span data-ttu-id="aefbb-124">Jinými slovy kód nalevo od offside řádku je offside.</span><span class="sxs-lookup"><span data-stu-id="aefbb-124">In other words, code to the left of an offside line is offside.</span></span> <span data-ttu-id="aefbb-125">V kódu správně zobrazují odsazené využít výhod offside pravidlo Chcete-li zobrazit konec konstrukce.</span><span class="sxs-lookup"><span data-stu-id="aefbb-125">In correctly indented code, you take advantage of the offside rule in order to delineate the end of constructs.</span></span> <span data-ttu-id="aefbb-126">Pokud používáte odsazení nesprávně, podmínku offside může způsobit kompilátoru vydat varování nebo může vést k nesprávné interpretaci vašeho kódu.</span><span class="sxs-lookup"><span data-stu-id="aefbb-126">If you use indentation improperly, an offside condition can cause the compiler to issue a warning or can lead to the incorrect interpretation of your code.</span></span>

<span data-ttu-id="aefbb-127">Offside řádků je stanoven následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="aefbb-127">Offside lines are determined as follows.</span></span>


- <span data-ttu-id="aefbb-128">`=` Token přidružený `let` zavádí řádku s offside ve sloupci prvního tokenu po `=` přihlášení.</span><span class="sxs-lookup"><span data-stu-id="aefbb-128">An `=` token associated with a `let` introduces an offside line at the column of the first token after the `=` sign.</span></span>


- <span data-ttu-id="aefbb-129">V `if...then...else` výrazu, sloupec pozice prvního tokenu po `then` – klíčové slovo nebo `else` – klíčové slovo zavádí offside řádku.</span><span class="sxs-lookup"><span data-stu-id="aefbb-129">In an `if...then...else` expression, the column position of the first token after the `then` keyword or the `else` keyword introduces an offside line.</span></span>


- <span data-ttu-id="aefbb-130">V `try...with` výrazu, první token po `try` zavádí offside řádku.</span><span class="sxs-lookup"><span data-stu-id="aefbb-130">In a `try...with` expression, the first token after `try` introduces an offside line.</span></span>


- <span data-ttu-id="aefbb-131">V `match` výrazu, první token po `with` a první token po každém z nich `->` zavést offside řádky.</span><span class="sxs-lookup"><span data-stu-id="aefbb-131">In a `match` expression, the first token after `with` and the first token after each `->` introduce offside lines.</span></span>


- <span data-ttu-id="aefbb-132">První token po `with` v typu rozšíření zavádí offside řádku.</span><span class="sxs-lookup"><span data-stu-id="aefbb-132">The first token after `with` in a type extension introduces an offside line.</span></span>


- <span data-ttu-id="aefbb-133">První token po provedení závorka nebo závorky, nebo až když `begin` – klíčové slovo, představuje offside řádku.</span><span class="sxs-lookup"><span data-stu-id="aefbb-133">The first token after an opening brace or parenthesis, or after the `begin` keyword, introduces an offside line.</span></span>


- <span data-ttu-id="aefbb-134">První znak v klíčová slova `let`, `if`, a `module` zavést offside řádky.</span><span class="sxs-lookup"><span data-stu-id="aefbb-134">The first character in the keywords `let`, `if`, and `module` introduce offside lines.</span></span>


<span data-ttu-id="aefbb-135">Následující příklady kódu ilustrují pravidel odsazení.</span><span class="sxs-lookup"><span data-stu-id="aefbb-135">The following code examples illustrate the indentation rules.</span></span> <span data-ttu-id="aefbb-136">Zde tiskové příkazy spoléhají na odsazení a přiřadit je k odpovídající kontext.</span><span class="sxs-lookup"><span data-stu-id="aefbb-136">Here, the print statements rely on indentation to associate them with the appropriate context.</span></span> <span data-ttu-id="aefbb-137">Pokaždé, když odsazení posune, kontext je odebrány a vrátí do předchozí kontextu.</span><span class="sxs-lookup"><span data-stu-id="aefbb-137">Every time the indentation shifts, the context is popped and returns to the previous context.</span></span> <span data-ttu-id="aefbb-138">Proto je vytištěno mezeru na konci každé iteraci; "Hotovo!"</span><span class="sxs-lookup"><span data-stu-id="aefbb-138">Therefore, a space is printed at the end of each iteration; "Done!"</span></span> <span data-ttu-id="aefbb-139">je pouze vytištěno jednou, protože offside odsazení určuje, že není součástí smyčky.</span><span class="sxs-lookup"><span data-stu-id="aefbb-139">is only printed one time because the offside indentation establishes that it is not part of the loop.</span></span> <span data-ttu-id="aefbb-140">Tisk řetězce "Nejvyšší úrovně kontextu" není součástí funkce.</span><span class="sxs-lookup"><span data-stu-id="aefbb-140">The printing of the string "Top-level context" is not part of the function.</span></span> <span data-ttu-id="aefbb-141">Proto vytištění nejdřív během inicializace statické, než je tato funkce volána.</span><span class="sxs-lookup"><span data-stu-id="aefbb-141">Therefore, it is printed first, during the static initialization, before the function is called.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet1.fs)]

<span data-ttu-id="aefbb-142">Výstup je následující.</span><span class="sxs-lookup"><span data-stu-id="aefbb-142">The output is as follows.</span></span>

```
Top-level context

(Negative number) Zero 1 2 3 Done!
```

<span data-ttu-id="aefbb-143">Pokud zrušíte dlouhé řádky, musí být pokračování řádku odsazeny farther than nadřazených konstrukce.</span><span class="sxs-lookup"><span data-stu-id="aefbb-143">When you break long lines, the continuation of the line must be indented farther than the enclosing construct.</span></span> <span data-ttu-id="aefbb-144">Argumenty funkce musí být například odsazeny farther than první znak názvu funkce, jak je znázorněno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="aefbb-144">For example, function arguments must be indented farther than the first character of the function name, as shown in the following code.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet2.fs)]

<span data-ttu-id="aefbb-145">Existují výjimky pro tato pravidla, jak je popsáno v následující části.</span><span class="sxs-lookup"><span data-stu-id="aefbb-145">There are exceptions to these rules, as described in the next section.</span></span>


## <a name="indentation-in-modules"></a><span data-ttu-id="aefbb-146">Odsazení v modulech</span><span class="sxs-lookup"><span data-stu-id="aefbb-146">Indentation in Modules</span></span>
<span data-ttu-id="aefbb-147">Kód v místním modulu musí odsazeny relativně k modulu, ale kód v nejvyšší úrovně modulu nemusí být zobrazují odsazené.</span><span class="sxs-lookup"><span data-stu-id="aefbb-147">Code in a local module must be indented relative to the module, but code in a top-level module does not have to be indented.</span></span> <span data-ttu-id="aefbb-148">Namespace prvky nemají odsazení.</span><span class="sxs-lookup"><span data-stu-id="aefbb-148">Namespace elements do not have to be indented.</span></span>

<span data-ttu-id="aefbb-149">Následující příklady kódu znázornění.</span><span class="sxs-lookup"><span data-stu-id="aefbb-149">The following code examples illustrate this.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet3.fs)]
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet4.fs)]

<span data-ttu-id="aefbb-150">Další informace najdete v tématu [moduly](modules.md).</span><span class="sxs-lookup"><span data-stu-id="aefbb-150">For more information, see [Modules](modules.md).</span></span>


## <a name="exceptions-to-the-basic-indentation-rules"></a><span data-ttu-id="aefbb-151">Výjimky z pravidel základní odsazení</span><span class="sxs-lookup"><span data-stu-id="aefbb-151">Exceptions to the Basic Indentation Rules</span></span>
<span data-ttu-id="aefbb-152">Obecně platí, jak je popsáno v předchozí části, je, že musí být kód v Víceřádkový konstrukce odsazeny relativně k odsazení prvního řádku konstruktu a že konec konstruktu je dáno při první řádek offside.</span><span class="sxs-lookup"><span data-stu-id="aefbb-152">The general rule, as described in the previous section, is that code in multiline constructs must be indented relative to the indentation of the first line of the construct, and that the end of the construct is determined by when the first offside line occurs.</span></span> <span data-ttu-id="aefbb-153">Výjimku z pravidla o při kontexty koncový je, že některé konstrukce, jako například `try...with` výrazu `if...then...else` výraz a použití `and` syntaxe deklarace vzájemně rekurzivní funkce nebo typy, mají více částí.</span><span class="sxs-lookup"><span data-stu-id="aefbb-153">An exception to the rule about when contexts end is that some constructs, such as the `try...with` expression, the `if...then...else` expression, and the use of `and` syntax for declaring mutually recursive functions or types, have multiple parts.</span></span> <span data-ttu-id="aefbb-154">Odsazovat novější částí, jako například `then` a `else` v `if...then...else` výraz na stejné úrovni jako token, který spustí výraz, ale místo označující element end do kontextu, představuje v další části stejného kontextu.</span><span class="sxs-lookup"><span data-stu-id="aefbb-154">You indent the later parts, such as `then` and `else` in an `if...then...else` expression, at the same level as the token that starts the expression, but instead of indicating an end to the context, it represents the next part of the same context.</span></span> <span data-ttu-id="aefbb-155">Proto `if...then...else` výraz může být napsán jako v následujícím příkladu kódu.</span><span class="sxs-lookup"><span data-stu-id="aefbb-155">Therefore, an `if...then...else` expression can be written as in the following code example.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet5.fs)]

<span data-ttu-id="aefbb-156">Výjimka, která má offside pravidla se vztahují pouze na `then` a `else` klíčová slova.</span><span class="sxs-lookup"><span data-stu-id="aefbb-156">The exception to the offside rule applies only to the `then` and `else` keywords.</span></span> <span data-ttu-id="aefbb-157">Proto i když se nejedná o chybu pro odsazení `then` a `else` navíc nedaří odsazovat řádky kódu v `then` bloku vyvolá upozornění.</span><span class="sxs-lookup"><span data-stu-id="aefbb-157">Therefore, although it is not an error to indent the `then` and `else` further, failing to indent the lines of code in a `then` block produces a warning.</span></span> <span data-ttu-id="aefbb-158">To je znázorněno v následujícím kódu.</span><span class="sxs-lookup"><span data-stu-id="aefbb-158">This is illustrated in the following lines of code.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet6.fs)]
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet7.fs)]

<span data-ttu-id="aefbb-159">Pro kód ve `else` bloku další zvláštní pravidlo vztahuje.</span><span class="sxs-lookup"><span data-stu-id="aefbb-159">For code in an `else` block, an additional special rule applies.</span></span> <span data-ttu-id="aefbb-160">Upozornění v předchozím příkladu se zobrazí pouze na kód v `then` bloku, nikoli na kód `else` bloku.</span><span class="sxs-lookup"><span data-stu-id="aefbb-160">The warning in the previous example occurs only on the code in the `then` block, not on the code in the `else` block.</span></span> <span data-ttu-id="aefbb-161">To umožňuje psát kód, který zjišťuje různé podmínky na začátku funkce bez vynucení zbytek kódu pro funkce, které je možné `else` bloku odsazení.</span><span class="sxs-lookup"><span data-stu-id="aefbb-161">This allows you to write code that checks for various conditions at the beginning of a function without forcing the rest of the code for the function, which might be in an `else` block, to be indented.</span></span> <span data-ttu-id="aefbb-162">Proto můžete napsat následující bez vytváření upozornění.</span><span class="sxs-lookup"><span data-stu-id="aefbb-162">Thus, you can write the following without producing a warning.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet8.fs)]

<span data-ttu-id="aefbb-163">Další výjimku pro pravidlo, které při řádek není odsazeny, pokud jde o předchozí řádek je zaváděcí operátorů, například ukončit kontexty `+` a `|>`.</span><span class="sxs-lookup"><span data-stu-id="aefbb-163">Another exception to the rule that contexts end when a line is not indented as far as a previous line is for infix operators, such as `+` and `|>`.</span></span> <span data-ttu-id="aefbb-164">Řádky, které začínají zaváděcí operátory jsou povolené zahájíte `(1 + oplength)` sloupce před normální pozice bez aktivace element end do kontextu, kde `oplength` je počet znaků, které tvoří operátor.</span><span class="sxs-lookup"><span data-stu-id="aefbb-164">Lines that start with infix operators are permitted to begin `(1 + oplength)` columns before the normal position without triggering an end to the context, where `oplength` is the number of characters that make up the operator.</span></span> <span data-ttu-id="aefbb-165">To způsobí, že první token po výskytu operátoru vyrovnání v předchozím řádku.</span><span class="sxs-lookup"><span data-stu-id="aefbb-165">This causes the first token after the operator to align with the previous line.</span></span>

<span data-ttu-id="aefbb-166">Například v následujícím kódu `+` symbol smí být zobrazují odsazené dva sloupce a menší než předchozí řádek.</span><span class="sxs-lookup"><span data-stu-id="aefbb-166">For example, in the following code, the `+` symbol is permitted to be indented two columns less than the previous line.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet9.fs)]

<span data-ttu-id="aefbb-167">Přestože odsazení obvykle zvyšuje úroveň vnoření začne být vyšší, existuje několik konstrukce kompilátor ve kterých umožňuje obnovit odsazení nižší pozici sloupce.</span><span class="sxs-lookup"><span data-stu-id="aefbb-167">Although indentation usually increases as the level of nesting becomes higher, there are several constructs in which the compiler allows you to reset the indentation to a lower column position.</span></span>

<span data-ttu-id="aefbb-168">Konstrukce, které umožňují obnovení pozici sloupce jsou následující:</span><span class="sxs-lookup"><span data-stu-id="aefbb-168">The constructs that permit a reset of column position are as follows:</span></span>


- <span data-ttu-id="aefbb-169">Těla anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="aefbb-169">Bodies of anonymous functions.</span></span> <span data-ttu-id="aefbb-170">V následujícím kódu tiskové výraz začíná na pozici sloupce, který je dále vlevo než `fun` – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="aefbb-170">In the following code, the print expression starts at a column position that is farther to the left than the `fun` keyword.</span></span> <span data-ttu-id="aefbb-171">Ale nesmí řádku spustit ve sloupci nalevo od začátku předchozí úrovně odsazení (který je nalevo od `L` v `List`).</span><span class="sxs-lookup"><span data-stu-id="aefbb-171">However, the line must not start at a column to the left of the start of the previous indentation level (that is, to the left of the `L` in `List`).</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet10.fs)]

- <span data-ttu-id="aefbb-172">Konstrukce uzavřený v závorkách nebo pomocí `begin` a `end` v `then` nebo `else` blokovat z `if...then...else` zadán výraz, odsazení je méně než pozici sloupce `if` – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="aefbb-172">Constructs enclosed by parentheses or by `begin` and `end` in a `then` or `else` block of an `if...then...else` expression, provided the indentation is no less than the column position of the `if` keyword.</span></span> <span data-ttu-id="aefbb-173">Tato výjimka umožňuje kódování styl, ve kterém levá závorka nebo `begin` se používá na konci řádku po `then` nebo `else`.</span><span class="sxs-lookup"><span data-stu-id="aefbb-173">This exception allows for a coding style in which an opening parenthesis or `begin` is used at the end of a line after `then` or `else`.</span></span>


- <span data-ttu-id="aefbb-174">Těla modulů, třídy, rozhraní a struktury oddělená `begin...end`, `{...}`, `class...end`, nebo `interface...end`.</span><span class="sxs-lookup"><span data-stu-id="aefbb-174">Bodies of modules, classes, interfaces, and structures delimited by `begin...end`, `{...}`, `class...end`, or `interface...end`.</span></span> <span data-ttu-id="aefbb-175">To umožňuje styl, ve kterém může být otevírání – klíčové slovo typu v definici na stejném řádku jako název typu bez vynucení celý text jako zobrazují odsazené farther than – klíčové slovo otevírání.</span><span class="sxs-lookup"><span data-stu-id="aefbb-175">This allows for a style in which the opening keyword of a type definition can be on the same line as the type name without forcing the whole body to be indented farther than the opening keyword.</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet13.fs)]


## <a name="see-also"></a><span data-ttu-id="aefbb-176">Viz také</span><span class="sxs-lookup"><span data-stu-id="aefbb-176">See Also</span></span>
[<span data-ttu-id="aefbb-177">Referenční dokumentace jazyka F#</span><span class="sxs-lookup"><span data-stu-id="aefbb-177">F# Language Reference</span></span>](index.md)
