---
title: "Rozlišovací Delegáti a události"
description: "Informace o rozdílu mezi Delegáti a události a při použití každé z těchto funkcí .NET Core."
keywords: "Rozhraní .NET, .NET core"
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 3026a0d853cb17dcf05d3b98d814044d743e48dc
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/18/2017
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="55cc9-104">Rozlišovací Delegáti a události</span><span class="sxs-lookup"><span data-stu-id="55cc9-104">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="55cc9-105">Předchozí</span><span class="sxs-lookup"><span data-stu-id="55cc9-105">Previous</span></span>](modern-events.md)

<span data-ttu-id="55cc9-106">Vývojáři, kteří jsou často nové pro platformu .NET Core potýkat s tím zajistily při rozhodování mezi návrh na základě `delegates` a návrh na základě `events`.</span><span class="sxs-lookup"><span data-stu-id="55cc9-106">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="55cc9-107">To je obtížné koncept, protože jsou velmi podobné funkce dvě jazyka.</span><span class="sxs-lookup"><span data-stu-id="55cc9-107">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="55cc9-108">Události jsou i vytvořená s využitím jazyková podpora pro delegáti.</span><span class="sxs-lookup"><span data-stu-id="55cc9-108">Events are even built using the language support for delegates.</span></span> 

<span data-ttu-id="55cc9-109">Obě nabízejí scénáři pozdní vazby: umožňují scénáře, kde součást komunikuje pomocí volání metody, které je známé pouze za běhu.</span><span class="sxs-lookup"><span data-stu-id="55cc9-109">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="55cc9-110">Obě podporovat odběratele jednotlivé a vícenásobné metody.</span><span class="sxs-lookup"><span data-stu-id="55cc9-110">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="55cc9-111">Můžete zjistit, tato podpora označují jako singlecast a vícesměrového vysílání.</span><span class="sxs-lookup"><span data-stu-id="55cc9-111">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="55cc9-112">Obě podporují podobné syntaxe pro přidávání a odebírání obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="55cc9-112">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="55cc9-113">Nakonec vyvolání události a volání metody delegáta pomocí přesně stejnou syntaxi volání metody.</span><span class="sxs-lookup"><span data-stu-id="55cc9-113">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="55cc9-114">Dokonce i podporují stejné `Invoke()` syntaxe využívající metody pro použití s `?.` operátor.</span><span class="sxs-lookup"><span data-stu-id="55cc9-114">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="55cc9-115">Pomocí těchto podobnosti je snadné potíží s určením, kdy se má použít, který.</span><span class="sxs-lookup"><span data-stu-id="55cc9-115">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="55cc9-116">Naslouchá událostem je volitelné</span><span class="sxs-lookup"><span data-stu-id="55cc9-116">Listening to Events is Optional</span></span>

<span data-ttu-id="55cc9-117">Většina důležitý aspekt při určení, kterou funkci používat jazyk je zda musí být připojené odběratele.</span><span class="sxs-lookup"><span data-stu-id="55cc9-117">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="55cc9-118">Pokud váš kód musí volat kód poskytl odběratele, měli byste použít návrh podle delegáti.</span><span class="sxs-lookup"><span data-stu-id="55cc9-118">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="55cc9-119">Pokud váš kód dokončení všech práce bez volání všechny odběratele, měli byste použít návrh na základě událostí.</span><span class="sxs-lookup"><span data-stu-id="55cc9-119">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span> 

<span data-ttu-id="55cc9-120">Je třeba brát příklady vytvořené během této části.</span><span class="sxs-lookup"><span data-stu-id="55cc9-120">Consider the examples built during this section.</span></span> <span data-ttu-id="55cc9-121">Kód, který jste vytvořili pomocí `List.Sort()` musí mít funkci porovnávače aby bylo možné správně řazení elementů.</span><span class="sxs-lookup"><span data-stu-id="55cc9-121">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="55cc9-122">Je nutné zadat dotazů LINQ s delegáti Chcete-li určit, které prvky vrátit.</span><span class="sxs-lookup"><span data-stu-id="55cc9-122">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="55cc9-123">Jak použít návrh vytvořené s nástroji delegáti.</span><span class="sxs-lookup"><span data-stu-id="55cc9-123">Both used a design built with delegates.</span></span>

<span data-ttu-id="55cc9-124">Vezměte v úvahu `Progress` událostí.</span><span class="sxs-lookup"><span data-stu-id="55cc9-124">Consider the `Progress` event.</span></span> <span data-ttu-id="55cc9-125">Ho hlásí průběh úlohy.</span><span class="sxs-lookup"><span data-stu-id="55cc9-125">It reports progress on a task.</span></span>
<span data-ttu-id="55cc9-126">Úloha i nadále pokračovat, zda jsou všechny moduly pro naslouchání.</span><span class="sxs-lookup"><span data-stu-id="55cc9-126">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="55cc9-127">`FileSearcher` Je další příklad.</span><span class="sxs-lookup"><span data-stu-id="55cc9-127">The `FileSearcher` is another example.</span></span> <span data-ttu-id="55cc9-128">By stále Hledat a najít všechny soubory, které byly žádá o, i když žádné události odběratele připojen.</span><span class="sxs-lookup"><span data-stu-id="55cc9-128">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="55cc9-129">Ovládací prvky UX i nadále fungovat správně, i když neexistují žádné odběratele naslouchání událostem.</span><span class="sxs-lookup"><span data-stu-id="55cc9-129">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="55cc9-130">Obě používají návrhy na základě událostí.</span><span class="sxs-lookup"><span data-stu-id="55cc9-130">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="55cc9-131">Návratové hodnoty vyžadují delegáti</span><span class="sxs-lookup"><span data-stu-id="55cc9-131">Return Values Require Delegates</span></span>

<span data-ttu-id="55cc9-132">Je potřeba zamyslet se metoda prototyp, které je vhodnější pro metodu delegáta.</span><span class="sxs-lookup"><span data-stu-id="55cc9-132">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="55cc9-133">Protože jste se seznámili, delegáty použít pro všechny události mít typ vrácené hodnoty void.</span><span class="sxs-lookup"><span data-stu-id="55cc9-133">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="55cc9-134">Také jste viděli, že jsou idioms pro vytváření obslužných rutin událostí, které předávají informace zpět do zdroje událostí prostřednictvím Úprava vlastností objektu argumentu události.</span><span class="sxs-lookup"><span data-stu-id="55cc9-134">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="55cc9-135">I když tyto idioms fungují, nejsou jako přirozené jako vrací hodnotu z metody.</span><span class="sxs-lookup"><span data-stu-id="55cc9-135">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="55cc9-136">Všimněte si, že tyto dvě heuristiky může často i být k dispozici: Pokud metodu delegáta vrátí hodnotu, ovlivní pravděpodobně algoritmus nějakým způsobem.</span><span class="sxs-lookup"><span data-stu-id="55cc9-136">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="55cc9-137">Naslouchacích procesů událostí mají často delší životnosti</span><span class="sxs-lookup"><span data-stu-id="55cc9-137">Event Listeners Often Have Longer Lifetimes</span></span> 

<span data-ttu-id="55cc9-138">Toto je mírně nižší zarovnání do bloku.</span><span class="sxs-lookup"><span data-stu-id="55cc9-138">This is a slightly weaker justification.</span></span> <span data-ttu-id="55cc9-139">Však můžete zjistit, že založený na událostech návrzích přirozenější při zdroj události bude vyvolání události po dlouhou dobu.</span><span class="sxs-lookup"><span data-stu-id="55cc9-139">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="55cc9-140">Zobrazí se to příklady pro ovládací prvky UX na mnoha systémy.</span><span class="sxs-lookup"><span data-stu-id="55cc9-140">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="55cc9-141">Jakmile se přihlásíte k odběru události, zdroj události může vyvolat události po celou dobu programu.</span><span class="sxs-lookup"><span data-stu-id="55cc9-141">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="55cc9-142">(Můžete odhlášení odběru událostí, pokud je už nepotřebujete.)</span><span class="sxs-lookup"><span data-stu-id="55cc9-142">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="55cc9-143">Oproti který řada na základě delegáta návrhů, kde delegáta se používá jako argument pro metodu, a delegát není po návratu této metody.</span><span class="sxs-lookup"><span data-stu-id="55cc9-143">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="55cc9-144">Pečlivě vyhodnotit</span><span class="sxs-lookup"><span data-stu-id="55cc9-144">Evaluate Carefully</span></span>

<span data-ttu-id="55cc9-145">Výše uvedené požadavky nejsou pravidla pevný a rychlé.</span><span class="sxs-lookup"><span data-stu-id="55cc9-145">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="55cc9-146">Místo toho představují pokyny, které vám pomohou rozhodnout, které možnosti je vhodné pro vaše konkrétní použití.</span><span class="sxs-lookup"><span data-stu-id="55cc9-146">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="55cc9-147">Protože jsou podobné, můžete dokonce i prototypu obou a zvažte, který bude pracovat s více fyzických.</span><span class="sxs-lookup"><span data-stu-id="55cc9-147">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="55cc9-148">Obě dobře zpracovávat scénáře pozdní vazbu.</span><span class="sxs-lookup"><span data-stu-id="55cc9-148">They both handle late binding scenarios well.</span></span> <span data-ttu-id="55cc9-149">Použijte ten, který komunikuje návrhu nejvhodnější.</span><span class="sxs-lookup"><span data-stu-id="55cc9-149">Use the one that communicates your design the best.</span></span>
