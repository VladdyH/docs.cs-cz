---
title: "Metody – Průvodce C#"
description: "Přehled metod, metoda parametry a návratové hodnoty – metoda"
keywords: .NET, .NET Core, C#
author: rpetrusha
ms.author: ronpet
ms.date: 10/26/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: 48127d5168ace7733f29f78dc3f72d9c0d051e4e
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/15/2018
---
# <a name="methods"></a><span data-ttu-id="3a3b8-104">Metody</span><span class="sxs-lookup"><span data-stu-id="3a3b8-104">Methods</span></span> #

<span data-ttu-id="3a3b8-105">Metoda je blok kódu, který obsahuje řadu příkazů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-105">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="3a3b8-106">Program způsobí, že příkazy provádět volání metody a zadání argumentů požadovaná metoda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-106">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="3a3b8-107">V jazyce C# každé spuštění instrukce se provádí v kontextu metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-107">In C#, every executed instruction is performed in the context of a method.</span></span> <span data-ttu-id="3a3b8-108">`Main` Metoda je vstupní bod pro každou aplikaci C# a je volána metodou common language runtime (CLR) při spuštění programu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-108">The `Main` method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</span></span>

> [!NOTE]
> <span data-ttu-id="3a3b8-109">Toto téma popisuje pojmenované metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-109">This topic discusses named methods.</span></span> <span data-ttu-id="3a3b8-110">Informace o anonymní funkce najdete v tématu [anonymní funkce](programming-guide/statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="3a3b8-110">For information about anonymous functions, see [Anonymous Functions](programming-guide/statements-expressions-operators/anonymous-functions.md).</span></span>

<span data-ttu-id="3a3b8-111">Toto téma obsahuje následující oddíly:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-111">This topic contains the following sections:</span></span>

- [<span data-ttu-id="3a3b8-112">Podpisy – metoda</span><span class="sxs-lookup"><span data-stu-id="3a3b8-112">Method signatures</span></span>](#signatures)
- [<span data-ttu-id="3a3b8-113">Volání metody</span><span class="sxs-lookup"><span data-stu-id="3a3b8-113">Method invocation</span></span>](#invocation)
- [<span data-ttu-id="3a3b8-114">Zděděné a přepsané metody</span><span class="sxs-lookup"><span data-stu-id="3a3b8-114">Inherited and overridden methods</span></span>](#inherited)
- [<span data-ttu-id="3a3b8-115">Předávání parametrů</span><span class="sxs-lookup"><span data-stu-id="3a3b8-115">Passing parameters</span></span>](#passing)
  - [<span data-ttu-id="3a3b8-116">Předávání parametrů podle hodnoty</span><span class="sxs-lookup"><span data-stu-id="3a3b8-116">Passing parameters by value</span></span>](#byval)
  - [<span data-ttu-id="3a3b8-117">Předávání parametrů odkazem</span><span class="sxs-lookup"><span data-stu-id="3a3b8-117">Passing parameters by reference</span></span>](#byref)
  - [<span data-ttu-id="3a3b8-118">Pole parametrů</span><span class="sxs-lookup"><span data-stu-id="3a3b8-118">Parameter arrays</span></span>](#paramarray)
- [<span data-ttu-id="3a3b8-119">Volitelné parametry a argumenty</span><span class="sxs-lookup"><span data-stu-id="3a3b8-119">Optional parameters and arguments</span></span>](#optional)
- [<span data-ttu-id="3a3b8-120">Návratové hodnoty</span><span class="sxs-lookup"><span data-stu-id="3a3b8-120">Return values</span></span>](#return)
- [<span data-ttu-id="3a3b8-121">Metody rozšíření</span><span class="sxs-lookup"><span data-stu-id="3a3b8-121">Extension methods</span></span>](#extension)
- [<span data-ttu-id="3a3b8-122">Asynchronní metody</span><span class="sxs-lookup"><span data-stu-id="3a3b8-122">Async Methods</span></span>](#async)
- [<span data-ttu-id="3a3b8-123">Členové tvoření výrazy</span><span class="sxs-lookup"><span data-stu-id="3a3b8-123">Expression-bodied members</span></span>](#expr)
- [<span data-ttu-id="3a3b8-124">Iterátory</span><span class="sxs-lookup"><span data-stu-id="3a3b8-124">Iterators</span></span>](#iterators)

<a name="signatures"></a>
## <a name="method-signatures"></a><span data-ttu-id="3a3b8-125">Podpisy – metoda</span><span class="sxs-lookup"><span data-stu-id="3a3b8-125">Method signatures</span></span> ##

<span data-ttu-id="3a3b8-126">Metody, které jsou deklarované v `class` nebo `struct` zadáním:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-126">Methods are declared in a `class` or `struct` by specifying:</span></span>

- <span data-ttu-id="3a3b8-127">Volitelný přístup úrovně, jako například `public` nebo `private`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-127">An optional access level, such as `public` or `private`.</span></span> <span data-ttu-id="3a3b8-128">Výchozí hodnota je `private`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-128">The default is `private`.</span></span>
- <span data-ttu-id="3a3b8-129">Volitelné modifikátory jako `abstract` nebo `sealed`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-129">Optional modifiers such as `abstract` or `sealed`.</span></span>
- <span data-ttu-id="3a3b8-130">Návratovou hodnotu, nebo `void` Pokud metoda má none.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-130">The return value, or `void` if the method has none.</span></span>
- <span data-ttu-id="3a3b8-131">Název metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-131">The method name.</span></span>
- <span data-ttu-id="3a3b8-132">Všechny parametry metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-132">Any method parameters.</span></span> <span data-ttu-id="3a3b8-133">Parametry metody jsou uzavřené v závorkách a jsou odděleny čárkami.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-133">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="3a3b8-134">Závorky, jinak znamenat, že metoda nevyžaduje žádné parametry.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-134">Empty parentheses indicate that the method requires no parameters.</span></span>

<span data-ttu-id="3a3b8-135">Tyto části společně tvoří podpis metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-135">These parts together form the method signature.</span></span>

> [!NOTE]
> <span data-ttu-id="3a3b8-136">Návratový typ metody není součástí podpis metody pro účely přetěžování metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-136">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="3a3b8-137">Je však součástí podpis metody při určování kompatibilitu mezi delegáta a metodu, která odkazuje na.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-137">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="3a3b8-138">Následující příklad definuje třídu s názvem `Motorcycle` obsahující pět metody:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-138">The following example defines a class named `Motorcycle` that contains five methods:</span></span>

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

<span data-ttu-id="3a3b8-139">Všimněte si, že `Motorcycle` třída zahrnuje přetížené metody, `Drive`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-139">Note that the `Motorcycle` class includes an overloaded method, `Drive`.</span></span> <span data-ttu-id="3a3b8-140">Dvě metody se stejným názvem, ale musí být rozlišené pomocí jejich typy parametrů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-140">Two methods have the same name, but must be differentiated by their parameter types.</span></span>

<a name="invocation"></a>
## <a name="method-invocation"></a><span data-ttu-id="3a3b8-141">Volání metody</span><span class="sxs-lookup"><span data-stu-id="3a3b8-141">Method invocation</span></span> ##

<span data-ttu-id="3a3b8-142">Metody může být buď *instance* nebo *statické*.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-142">Methods can be either *instance* or *static*.</span></span> <span data-ttu-id="3a3b8-143">Vyvolání metody instance vyžaduje, abyste vytvoří instanci objektu a volat metodu u tohoto objektu. Metoda instance funguje na tuto instanci a jeho data.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-143">Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</span></span> <span data-ttu-id="3a3b8-144">Vyvolání statickou metodu pod položkou Název typu, do které patří metodu; statické metody pracovat se nevztahují na instance data.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-144">You invoke a static method by referencing the name of the type to which the method belongs; static methods operate do not operate on instance data.</span></span> <span data-ttu-id="3a3b8-145">Probíhá pokus o volání statickou metodu pomocí instance objektu generuje chybu kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-145">Attempting to call a static method through an object instance generates a compiler error.</span></span>

<span data-ttu-id="3a3b8-146">Volání metody je jako přístup k poli.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-146">Calling a method is like accessing a field.</span></span> <span data-ttu-id="3a3b8-147">Po názvu objektu (pokud jsou volání metody instance) nebo název typu (při volání `static` metoda), přidejte období, název metody, a kulaté závorky.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-147">After the object name (if you are calling an instance method) or the type name (if you are calling a `static` method), add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="3a3b8-148">Argumenty jsou uvedeny v závorkách a jsou odděleny čárkami.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-148">Arguments are listed within the parentheses, and are separated by commas.</span></span>

<span data-ttu-id="3a3b8-149">Definice metoda určuje názvy a typy parametrů, které jsou požadovány.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-149">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="3a3b8-150">Když volající vyvolá metodu, poskytuje konkrétní hodnoty, nazývaných argumenty pro jednotlivé parametry.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-150">When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</span></span> <span data-ttu-id="3a3b8-151">Argumenty, které musí být kompatibilní s typem parametru, ale název argument, pokud používá v volání kódu, nemusí být stejný jako parametr s názvem definované v metodě.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-151">The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="3a3b8-152">V následujícím příkladu `Square` metoda obsahuje jeden parametr typu `int` s názvem *i*.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-152">In the following example, the `Square` method includes a single parameter of type `int` named *i*.</span></span> <span data-ttu-id="3a3b8-153">První metodu volat průchodů `Square` metoda a proměnná typu `int` s názvem *num*; druhý, číselnou konstantu; a třetí, výrazu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-153">The first method call passes the `Square` method a variable of type `int` named *num*; the second, a numeric constant; and the third, an expression.</span></span>

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

<span data-ttu-id="3a3b8-154">Nejběžnější volání metody státní poziční argumenty; poskytne argumenty ve stejném pořadí jako parametry metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-154">The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</span></span> <span data-ttu-id="3a3b8-155">Metody `Motorcycle` třída proto nelze volat jako v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-155">The methods of the `Motorcycle` class can therefore be called as in the following example.</span></span> <span data-ttu-id="3a3b8-156">Volání `Drive` metoda, například obsahuje dva argumenty, které odpovídají dva parametry v syntaxi metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-156">The call to the `Drive` method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</span></span> <span data-ttu-id="3a3b8-157">První se změní na hodnotu `miles` parametr, druhá hodnota `speed` parametr.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-157">The first becomes the value of the `miles` parameter, the second the value of the `speed` parameter.</span></span>

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

<span data-ttu-id="3a3b8-158">Můžete také použít *s názvem argumenty* místo poziční argumenty při vyvolání metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-158">You can also used *named arguments* instead of positional arguments when invoking a method.</span></span> <span data-ttu-id="3a3b8-159">Při použití s názvem argumenty, je třeba zadat název parametru následovaným dvojtečkou (":") a argumentem.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-159">When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</span></span> <span data-ttu-id="3a3b8-160">Argumenty pro metodu může vyskytovat v libovolném pořadí, tak dlouho, dokud nejsou všechny požadované argumenty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-160">Arguments to the method can appear in any order, as long as all required arguments are present.</span></span> <span data-ttu-id="3a3b8-161">Následující příklad používá pojmenované argumenty pro vyvolání `TestMotorcycle.Drive` metoda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-161">The following example uses named arguments to invoke the `TestMotorcycle.Drive` method.</span></span> <span data-ttu-id="3a3b8-162">V tomto příkladu jsou pojmenované argumenty z seznam parametrů metody předán v opačném pořadí.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-162">In this example, the named arguments are passed in the opposite order from the method's parameter list.</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

<span data-ttu-id="3a3b8-163">Můžete vyvolat metodu pomocí obou argumentů umístění a pojmenované argumenty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-163">You can invoke a method using both positional arguments and named arguments.</span></span> <span data-ttu-id="3a3b8-164">Poziční argument však nelze sledovat pojmenovaný argument.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-164">However, a positional argument cannot follow a named argument.</span></span> <span data-ttu-id="3a3b8-165">Následující příklad popisuje vyvolání `TestMotorcycle.Drive` metoda z předchozího příkladu pomocí poziční jeden argument a jednu s názvem argument.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-165">The following example invokes the `TestMotorcycle.Drive` method from the previous example using one positional argument and one named argument.</span></span>

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

 <a name="inherited"></a>
 ##<a name="inherited-and-overridden-methods"></a><span data-ttu-id="3a3b8-166">Zděděné a přepsané metody</span><span class="sxs-lookup"><span data-stu-id="3a3b8-166">Inherited and overridden methods</span></span> ##

<span data-ttu-id="3a3b8-167">Kromě členů, které jsou explicitně definované v typu zdědí typu členy definované v jeho základních tříd.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-167">In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</span></span> <span data-ttu-id="3a3b8-168">Vzhledem k tomu, že všechny typy v systému spravovaný typ dědí přímo nebo nepřímo <xref:System.Object> třída, všechny typy dědit jejích členů, například <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, a <xref:System.Object.ToString>.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-168">Since all types in the managed type system inherit directly or indirectly from the <xref:System.Object> class, all types inherit its members, such as <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, and <xref:System.Object.ToString>.</span></span> <span data-ttu-id="3a3b8-169">V následujícím příkladu definuje `Person` třídy, vytvoří dvě instance `Person` objekty a volá `Person.Equals` metoda k určení, zda jsou oba objekty stejné.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-169">The following example defines a `Person` class, instantiates two `Person` objects, and calls the `Person.Equals` method to determine whether the two objects are equal.</span></span> <span data-ttu-id="3a3b8-170">`Equals` Metoda, však není definován v `Person` třídy; je zděděn z <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-170">The `Equals` method, however, is not defined in the `Person` class; it is inherited from <xref:System.Object>.</span></span>

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

<span data-ttu-id="3a3b8-171">Typy můžete přepsat zděděné členy pomocí `override` – klíčové slovo a poskytuje implementaci pro metodu přepsané.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-171">Types can override inherited members by using the `override` keyword and providing an implementation for the overridden method.</span></span> <span data-ttu-id="3a3b8-172">Podpis metody musí být stejný jako přepsané metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-172">The method signature must be the same as that of the overridden method.</span></span> <span data-ttu-id="3a3b8-173">Následující příklad je stejný, jako je předchozí s tím rozdílem, že přepíše <xref:System.Object.Equals(System.Object)> metoda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-173">The following example is like the previous one, except that it overrides the <xref:System.Object.Equals(System.Object)> method.</span></span> <span data-ttu-id="3a3b8-174">(Potlačí také <xref:System.Object.GetHashCode> metoda, protože tyto dvě metody jsou určeny k poskytování konzistentních výsledků.)</span><span class="sxs-lookup"><span data-stu-id="3a3b8-174">(It also overrides the <xref:System.Object.GetHashCode> method, since the two methods are intended to provide consistent results.)</span></span>

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>
## <a name="passing-parameters"></a><span data-ttu-id="3a3b8-175">Předávání parametrů</span><span class="sxs-lookup"><span data-stu-id="3a3b8-175">Passing parameters</span></span> ##

<span data-ttu-id="3a3b8-176">Typy v jazyku C# jsou buď *typů hodnot* nebo *odkazové typy*.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-176">Types in C# are either *value types* or *reference types*.</span></span> <span data-ttu-id="3a3b8-177">Seznam typů předdefinovaných hodnot najdete v tématu [typy a proměnné](./tour-of-csharp/types-and-variables.md).</span><span class="sxs-lookup"><span data-stu-id="3a3b8-177">For a list of built-in value types, see [Types and variables](./tour-of-csharp/types-and-variables.md).</span></span> <span data-ttu-id="3a3b8-178">Ve výchozím nastavení typy hodnot a odkazové typy jsou předaný metodě hodnotou.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-178">By default, both value types and reference types are passed to a method by value.</span></span>

<a name="byval"></a>
### <a name="passing-parameters-by-value"></a><span data-ttu-id="3a3b8-179">Předávání parametrů podle hodnoty</span><span class="sxs-lookup"><span data-stu-id="3a3b8-179">Passing parameters by value</span></span> ###

<span data-ttu-id="3a3b8-180">Když metoda předána typ hodnoty podle hodnoty, je kopii objektu místo samotného objektu předaný metodě.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-180">When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</span></span> <span data-ttu-id="3a3b8-181">Změny objektu volané metody tedy mít žádný vliv na původní objekt při řízení vrátí volajícímu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-181">Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="3a3b8-182">Následující příklad předá typ hodnoty metodu podle hodnoty a zavolat metodu pokusí změnit hodnotu typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-182">The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</span></span> <span data-ttu-id="3a3b8-183">Definuje proměnné typu `int`, což je typ hodnoty, inicializuje jeho hodnotu na 20 a předává je pro metodu s názvem `ModifyValue` , se změní hodnota proměnné na 30.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-183">It defines a variable of type `int`, which is a value type, initializes its value to 20, and passes it to a method named `ModifyValue` that changes the variable's value to 30.</span></span> <span data-ttu-id="3a3b8-184">Když metoda vrátí, ale hodnota proměnné zůstane beze změny.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-184">When the method returns, however, the variable's value remains unchanged.</span></span>

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

<span data-ttu-id="3a3b8-185">Když metoda předána objekt typu odkaz podle hodnoty, je předaná hodnota odkaz na objekt.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-185">When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</span></span> <span data-ttu-id="3a3b8-186">To znamená metoda obdrží není samotného objektu, ale argument, který určuje umístění objektu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-186">That is, the method receives not the object itself, but an argument that indicates the location of the object.</span></span> <span data-ttu-id="3a3b8-187">Pokud změníte členem objektu pomocí tohoto odkazu, změny se v objektu, když se vrátí ovládací prvek volání metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-187">If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</span></span> <span data-ttu-id="3a3b8-188">Však nahradit objekt předaný metodě nemá žádný vliv na původní objekt při řízení vrátí volajícímu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-188">However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="3a3b8-189">Následující příklad definuje třídu (která je typu odkazu) s názvem `SampleRefType`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-189">The following example defines a class (which is a reference type) named `SampleRefType`.</span></span> <span data-ttu-id="3a3b8-190">Vytvoření instance `SampleRefType` objektu, přiřadí 44 k jeho `value` pole a předá objekt, který má `ModifyObject` metoda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-190">It instantiates a `SampleRefType` object, assigns 44 to its `value` field, and passes the object to the `ModifyObject` method.</span></span> <span data-ttu-id="3a3b8-191">Tento příklad nemá v podstatě má stejnou funkci jako předchozí příklad – předá argumentu podle hodnoty metodu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-191">This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</span></span> <span data-ttu-id="3a3b8-192">Ale protože odkaz na typ se používá, výsledek se liší.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-192">But because a reference type is used, the result is different.</span></span> <span data-ttu-id="3a3b8-193">Změna, která se provádí v `ModifyObject` k `obj.value` poli také změní `value` pole argumentu, `rt`v `Main` metodu 33, jako výstup ukazuje příklad.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-193">The modification that is made in `ModifyObject` to the `obj.value` field also changes the `value` field of the argument, `rt`, in the `Main` method to 33, as the output from the example shows.</span></span>

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>
### <a name="passing-parameters-by-reference"></a><span data-ttu-id="3a3b8-194">Předávání parametrů odkazem</span><span class="sxs-lookup"><span data-stu-id="3a3b8-194">Passing parameters by reference</span></span> ###

<span data-ttu-id="3a3b8-195">Předání parametru odkazu, pokud chcete změnit hodnotu argumentu v metodě a chcete refect tato změna při volání metody vrátí ovládací prvek.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-195">You pass a parameter by reference when you want to change the value of an argument in a method and want to refect that change when control returns to the calling method.</span></span> <span data-ttu-id="3a3b8-196">Chcete-li předat parametr odkazu, použijte [ `ref` ](language-reference/keywords/ref.md) nebo [ `out` ](language-reference/keywords/out-parameter-modifier.md) – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-196">To pass a parameter by reference, you use the [`ref`](language-reference/keywords/ref.md) or [`out`](language-reference/keywords/out-parameter-modifier.md) keyword.</span></span> <span data-ttu-id="3a3b8-197">Můžete také předat hodnotu odkazem vyhnout kopírování, ale stále zabránit úpravy pomocí [ `in` ](language-reference/keywords/in-parameter-modifier.md) – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-197">You can also pass a value by reference to avoid copying but still prevent modifications using the [`in`](language-reference/keywords/in-parameter-modifier.md) keyword.</span></span>

<span data-ttu-id="3a3b8-198">Následující příklad je stejný jako předchozí, s výjimkou toho, je předaná hodnota odkaz na `ModifyValue` metoda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-198">The following example is identical to the previous one, except the value is passed by reference to the `ModifyValue` method.</span></span> <span data-ttu-id="3a3b8-199">Pokud je hodnota parametru pozměněn v `ModifyValue` metoda změnu hodnoty se projeví po návratu řízení volajícímu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-199">When the value of the parameter is modified in the `ModifyValue` method, the change in value is reflected when control returns to the caller.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

<span data-ttu-id="3a3b8-200">Běžný vzor, který používá parametry ref zahrnuje odkládací hodnoty proměnných.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-200">A common pattern that uses by ref parameters involves swapping the values of variables.</span></span> <span data-ttu-id="3a3b8-201">Dvě proměnné, které předáte metodě odkazem a metoda prohození jejich obsah.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-201">You pass two variables to a method by reference, and the method swaps their contents.</span></span> <span data-ttu-id="3a3b8-202">Následující příklad prohození celočíselné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-202">The following example swaps integer values.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

<span data-ttu-id="3a3b8-203">Předávání parametrů typu odkazu můžete změnit hodnotu odkaz sám sebe, nikoli hodnotu jeho jednotlivé elementy nebo pole.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-203">Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</span></span>

<a name="paramarray"></a>
### <a name="parameter-arrays"></a><span data-ttu-id="3a3b8-204">Pole parametrů</span><span class="sxs-lookup"><span data-stu-id="3a3b8-204">Parameter arrays</span></span> ###

<span data-ttu-id="3a3b8-205">V některých případech je požadavek je zadat přesně počet argumentů pro metodu omezující.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-205">Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</span></span> <span data-ttu-id="3a3b8-206">Pomocí `params` – klíčové slovo označíte, že je parametr pole parametrů, povolte metodu k volání s proměnlivým počtem argumentů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-206">By using the `params` keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</span></span> <span data-ttu-id="3a3b8-207">Parametr označené `params` – klíčové slovo musí být typu pole a musí být poslední parametr v seznamu parametrů metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-207">The parameter tagged with the `params` keyword must must be an array type, and it must be the last parameter in the method's parameter list.</span></span>

<span data-ttu-id="3a3b8-208">Volající pak můžete vyvolat metodu jedním ze tří způsobů:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-208">A caller can then invoke the method in either of three ways:</span></span>

- <span data-ttu-id="3a3b8-209">Předáním pole příslušného typu, který obsahuje požadovaný počet elementů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-209">By passing an array of the appropriate type that contains the desired number of elements.</span></span>
- <span data-ttu-id="3a3b8-210">Pomocí metody předání čárkami oddělený seznam jednotlivých argumentů příslušného typu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-210">By passing a comma-separated list of individual arguments of the appropriate type to the method.</span></span>
- <span data-ttu-id="3a3b8-211">Poskytnutím není argumentu pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-211">By not providing an argument to the parameter array.</span></span>

<span data-ttu-id="3a3b8-212">V následujícím příkladu definuje metodu s názvem `DoStringOperation` který provede operaci řetězec určeného její první parametr `StringOperation` – člen výčtu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-212">The following example defines a method named `DoStringOperation` that performs the string operation specified by its first parameter, a `StringOperation` enumeration member.</span></span> <span data-ttu-id="3a3b8-213">Pole parametrů jsou definovány řetězce, na kterých je k provedení operace.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-213">The strings upon which it is to perform the operation are defined by a parameter array.</span></span> <span data-ttu-id="3a3b8-214">`Main` Metoda znázorňuje všechny tři způsoby vyvolání metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-214">The `Main` method illustrates all three ways of invoking the method.</span></span> <span data-ttu-id="3a3b8-215">Všimněte si, že metoda označené `params` – klíčové slovo musí být schopen zpracovávat tento případ, ve kterém je žádný argument zadaný pro parametr pole, tak, aby jeho hodnota může být `null`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-215">Note that the method tagged with the `params` keyword must be prepared to handle the case in which no argument is supplied for the parameter array, so that its value is `null`.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref108.cs#108)]

<a name="optional"></a>
## <a name="optional-parameters-and-arguments"></a><span data-ttu-id="3a3b8-216">Volitelné parametry a argumenty</span><span class="sxs-lookup"><span data-stu-id="3a3b8-216">Optional parameters and arguments</span></span> ##

<span data-ttu-id="3a3b8-217">Definice metody můžete určit, že jeho parametry jsou povinné a že jsou volitelné.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-217">A method definition can specify that its parameters are required or that they are optional.</span></span> <span data-ttu-id="3a3b8-218">Ve výchozím nastavení jsou vyžadovány parametry.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-218">By default, parameters are required.</span></span> <span data-ttu-id="3a3b8-219">Volitelné parametry jsou určené v definici metoda včetně výchozí hodnoty parametru.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-219">Optional parameters are specified by including the parameter's default value in the method definition.</span></span> <span data-ttu-id="3a3b8-220">Při volání metody pro volitelný parametr nebude zadán žádný argument, bude místo něj použita výchozí hodnota.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-220">When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</span></span>

<span data-ttu-id="3a3b8-221">Výchozí hodnoty parametru musí být přiřadit pomocí jedné z následujících druhy výrazů:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-221">The parameter's default value must be assigned by one of the following kinds of expressions:</span></span>

- <span data-ttu-id="3a3b8-222">Toto je konstanta, například řetězcového literálu nebo číslo.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-222">A constant, such as a literal string or number.</span></span>
- <span data-ttu-id="3a3b8-223">Výraz, který formulář `new ValType`, kde `ValType` je typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-223">An expression of the form `new ValType`, where `ValType` is a value type.</span></span> <span data-ttu-id="3a3b8-224">Všimněte si, že tím se spustí tento typ hodnoty implicitní výchozí konstruktor, který není skutečné člen daného typu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-224">Note that this invokes the value type's implicit default constructor, which is not an actual member of the type.</span></span>
- <span data-ttu-id="3a3b8-225">Výraz, který formulář `default(ValType)`, kde `ValType` je typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-225">An expression of the form `default(ValType)`, where `ValType` is a value type.</span></span>

<span data-ttu-id="3a3b8-226">Obsahuje-li metodu povinných a volitelných parametrů, volitelné parametry jsou definovány na konci seznamu parametrů po všechny požadované parametry.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-226">If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</span></span>

<span data-ttu-id="3a3b8-227">V následujícím příkladu definuje metodu, `ExampleMethod`, který má jeden požadované a volitelné dva parametry.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-227">The following example defines a method, `ExampleMethod`, that has one required and two optional parameters.</span></span>

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

<span data-ttu-id="3a3b8-228">Pokud je metoda s více volitelné argumenty je vyvolána pomocí poziční argumenty, volající musíte zadat argument pro všechny volitelné parametry z první z nich pro naposledy, pro který je zadán argument.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-228">If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</span></span> <span data-ttu-id="3a3b8-229">U `ExampleMethod` metoda, například, pokud má volající poskytuje argument pro `description` parametru, je třeba zadat také jeden pro `optionalInt` parametr.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-229">In the case of the  `ExampleMethod` method, for example, if the caller supplies an argument for the `description` parameter, it must also supply one for the `optionalInt` parameter.</span></span> <span data-ttu-id="3a3b8-230">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` je neplatná metoda volání; `opt.ExampleMethod(2, , "Addition of 2 and 0);` generuje "Argument chybějící" Chyba kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-230">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` is a valid method call; `opt.ExampleMethod(2, , "Addition of 2 and 0);` generates an "Argument missing" compiler error.</span></span>

<span data-ttu-id="3a3b8-231">Pokud je volána metoda pomocí pojmenované argumenty nebo jejich kombinaci poziční a pojmenované argumenty, volající vynechat všechny argumenty, které následují poslední poziční argument při volání metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-231">If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</span></span>

<span data-ttu-id="3a3b8-232">Následující příklad volání `ExampleMethod` metoda třikrát.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-232">The following example calls the `ExampleMethod` method three times.</span></span>  <span data-ttu-id="3a3b8-233">Volání první dvě metody používají poziční argumenty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-233">The first two method calls use positional arguments.</span></span> <span data-ttu-id="3a3b8-234">První vynechá obou volitelné argumenty, zatímco druhý vynechá poslední argument.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-234">The first omits both optional arguments, while the second omits the last argument.</span></span> <span data-ttu-id="3a3b8-235">Třetí volání metody, které poskytuje poziční argument pro požadovaný parametr, ale používá pojmenovaný argument zadat hodnotu, která `description` parametr při vynechání `optionalInt` argument.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-235">The third method call supplies a positional argument for the required parameter, but uses a named argument to supply a value to the `description` parameter while omitting the `optionalInt` argument.</span></span>

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

<span data-ttu-id="3a3b8-236">Použití volitelné parametry ovlivňuje *řešení přetížení*, nebo způsobem, ve kterém kompilátor jazyka C# určuje, které konkrétní přetížení by měla být volána metoda volání, následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-236">The use of optional parameters affects *overload resolution*, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</span></span>

- <span data-ttu-id="3a3b8-237">Metoda, indexer nebo konstruktor je kandidátem na spuštění, pokud všechny její parametry je volitelný nebo odpovídá podle názvu nebo podle pozici, na jeden argument příkazu volání a který argument lze převést na typ parametru.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-237">A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</span></span>
- <span data-ttu-id="3a3b8-238">Pokud je nalezen více než jeden candidate, přetížení řešení pro upřednostňované převody pravidla argumenty, které jsou explicitně určena.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-238">If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</span></span> <span data-ttu-id="3a3b8-239">Vynechání argumenty pro volitelné parametry jsou ignorovány.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-239">Omitted arguments for optional parameters are ignored.</span></span>
- <span data-ttu-id="3a3b8-240">Pokud dva kandidáty jsou považovány za být stejně dobrý, předvoleb přejde na candidate, který nemá volitelné parametry, pro které byly vynechány argumenty ve volání.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-240">If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</span></span> <span data-ttu-id="3a3b8-241">Toto je důsledkem Obecné předvolby rozlišení přetížení pro kandidáty, které mají méně parametry.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-241">This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</span></span>

 <a name="return"></a>
 ## <a name="return-values"></a><span data-ttu-id="3a3b8-242">Vrácené hodnoty</span><span class="sxs-lookup"><span data-stu-id="3a3b8-242">Return values</span></span> ##

<span data-ttu-id="3a3b8-243">Metody můžete vrátit hodnotu volajícímu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-243">Methods can return a value to the caller.</span></span> <span data-ttu-id="3a3b8-244">Návratový typ (typ uvedené před název metody) není-li `void`, metoda může vrátit hodnotu pomocí `return` – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-244">If the return type (the type listed before the method name) is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="3a3b8-245">Příkaz s `return` – klíčové slovo, za nímž následuje proměnná, konstanta nebo výraz, který odpovídá návratový typ, vrátí tuto hodnotu Metoda volajícího.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-245">A statement with the `return` keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</span></span> <span data-ttu-id="3a3b8-246">Metody s není void vrací typ jsou nutné k použití `return` – klíčové slovo bude vrácena hodnota.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-246">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="3a3b8-247">`return` – Klíčové slovo také zastaví provádění metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-247">The `return` keyword also stops the execution of the method.</span></span>

<span data-ttu-id="3a3b8-248">Pokud je návratový typ `void`, `return` je stále užitečné zastavit provádění metody příkaz bez hodnoty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-248">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="3a3b8-249">Bez `return` – klíčové slovo, metoda skončí při ukončení bloku kódu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-249">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span>

<span data-ttu-id="3a3b8-250">Například použít tyto dvě metody `return` – klíčové slovo vrátit celá čísla:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-250">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

<span data-ttu-id="3a3b8-251">Pokud chcete použít hodnotu, vrátí metoda, můžete použít metodu volání volání metody samotné kdekoli hodnota stejného typu by být dostatečná.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-251">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="3a3b8-252">Můžete také přiřadit návratovou hodnotu proměnné.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-252">You can also assign the return value to a variable.</span></span> <span data-ttu-id="3a3b8-253">Například následující příklady kódu dvě dosažení stejné cíle:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-253">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

<span data-ttu-id="3a3b8-254">Použití místní proměnné, v takovém případě `result`, ukládat hodnota je volitelná.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-254">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="3a3b8-255">Dobře čitelnost kódu, nebo může být nutné, pokud je třeba uložit původní hodnota argumentu pro celý rozsah metodu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-255">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="3a3b8-256">V některých případech budete chtít metodu vrátit více než jednu hodnotu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-256">Sometimes, you want your method to return more than a single value.</span></span> <span data-ttu-id="3a3b8-257">Od verze 7.0 C#, můžete k tomu snadno pomocí *řazené kolekce členů typy* a *řazené kolekce členů literály*.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-257">Starting with C# 7.0, you can do this easily by using *tuple types* and *tuple literals*.</span></span> <span data-ttu-id="3a3b8-258">Typ řazené kolekce členů definuje datové typy elementů řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-258">The tuple type defines the data types of the tuple's elements.</span></span> <span data-ttu-id="3a3b8-259">Literály řazené kolekce členů zadejte skutečné hodnoty vrácené řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-259">Tuple literals provide the actual values of the returned tuple.</span></span> <span data-ttu-id="3a3b8-260">V následujícím příkladu `(string, string, string, int)` definuje typ řazené kolekce členů, která je vrácena `GetPersonalInfo` metoda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-260">In the following example, `(string, string, string, int)` defines the tuple type that is returned by the `GetPersonalInfo` method.</span></span> <span data-ttu-id="3a3b8-261">Výraz `(per.FirstName, per.MiddleName, per.LastName, per.Age)` je literál; název první a poslední společně s stáří, vrátí metoda z řazenou kolekci členů `PersonInfo` objektu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-261">The expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` is the tuple literal; the method returns the first, middle, and last name, along with the age, of a `PersonInfo` object.</span></span>

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    if (per != null)
       return (per.FirstName, per.MiddleName, per.LastName, per.Age);
    else
       return null;
}
```

<span data-ttu-id="3a3b8-262">Volající pak spotřebovat vrácený řazené kolekce členů s kódem takto:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-262">The caller can then consume the returned tuple with code like the following:</span></span>

```csharp
var person = GetPersonalInfo("111111111")
if (person != null)
   Console.WriteLine("{person.Item1} {person.Item3}: age = {person.Item4}");
```

<span data-ttu-id="3a3b8-263">Názvy můžete také přiřazený k elementům řazené kolekce členů v definici typu řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-263">Names can also be assigned to the tuple elements in the tuple type definition.</span></span> <span data-ttu-id="3a3b8-264">Následující příklad ukazuje alternativní verze `GetPersonalInfo` metoda, která používá s názvem prvky:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-264">The following example shows an alternate version of the `GetPersonalInfo` method that uses named elements:</span></span>

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    if (per != null)
       return (per.FirstName, per.MiddleName, per.LastName, per.Age);
    else
       return null;
}
```

<span data-ttu-id="3a3b8-265">Předchozí volání `GetPersonInfo` metoda pak lze upravit takto:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-265">The previous call to the `GetPersonInfo` method can then be modified as follows:</span></span>

```csharp
var person = GetPersonalInfo("111111111");
if (person != null)
   Console.WriteLine("{person.FName} {person.LName}: age = {person.Age}");
```

<span data-ttu-id="3a3b8-266">Pokud metoda pole je předat jako argument a upraví hodnoty jednotlivých prvků, není nutné pro metodu vrátit pole, i když můžete tak učinit pro dobrý styl nebo funkční toku hodnot.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-266">If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</span></span>  <span data-ttu-id="3a3b8-267">Je to proto C# předá všechny odkazové typy podle hodnoty a odkaz na pole hodnotu má ukazatel na pole.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-267">This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="3a3b8-268">V následujícím příkladu se změní na obsah `values` pole, které jsou vytvářeny v `DoubleValues` metoda jsou lze zobrazit pomocí kód, který obsahuje odkaz na pole.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-268">In the following example, changes to the contents of the `values` array that are made in the `DoubleValues` method are observable by any code that has a reference to the array.</span></span>

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

 <a name="exten"></a>
 ## <a name="extension-methods"></a><span data-ttu-id="3a3b8-269">Metody rozšíření</span><span class="sxs-lookup"><span data-stu-id="3a3b8-269">Extension methods</span></span> ##

<span data-ttu-id="3a3b8-270">Normálně existují dva způsoby, jak přidat metodu do stávající typ:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-270">Ordinarily, there are two ways to add a method to an existing type:</span></span>

- <span data-ttu-id="3a3b8-271">Zdrojový kód pro tento typ změňte.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-271">Modify the source code for that type.</span></span> <span data-ttu-id="3a3b8-272">Nelze to uděláte, samozřejmě, pokud nejste vlastníkem tohoto typu zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-272">You cannot do this, of course, if you do not own the type's source code.</span></span> <span data-ttu-id="3a3b8-273">A to se stane narušující změně, pokud přidáte také všechna pole privátní dat podporuje metodu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-273">And this becomes a breaking change if you also add any private data fields to support the method.</span></span>
- <span data-ttu-id="3a3b8-274">Definujte nové metody v odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-274">Define the new method in a derived class.</span></span> <span data-ttu-id="3a3b8-275">Metodu nelze přidat tímto způsobem použití dědičnosti pro jiné typy, jako je například struktury a výčty.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-275">A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</span></span> <span data-ttu-id="3a3b8-276">Ani jej lze "Přidat" metodu zapečetěné třídy.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-276">Nor can it be used to "add" a method to a sealed class.</span></span>

<span data-ttu-id="3a3b8-277">Rozšiřující metody umožňují "Přidat" metodu existující typ bez úpravy vlastní typ nebo implementace nová metoda v zděděné typu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-277">Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</span></span> <span data-ttu-id="3a3b8-278">Metody rozšíření také nemá být umístěné ve stejném sestavení jako typ, který rozšiřuje ji.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-278">The extension method also does not have to reside in the same assembly as the type it extends.</span></span> <span data-ttu-id="3a3b8-279">Metody rozšíření volání, jako by šlo definované člena typu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-279">You call an extension method as if it were a defined member of a type.</span></span>

<span data-ttu-id="3a3b8-280">Další informace najdete v tématu [rozšiřující metody](programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="3a3b8-280">For more information, see [Extension Methods](programming-guide/classes-and-structs/extension-methods.md).</span></span>

<a name="async"></a>
## <a name="async-methods"></a><span data-ttu-id="3a3b8-281">Asynchronní metody</span><span class="sxs-lookup"><span data-stu-id="3a3b8-281">Async Methods</span></span> ##

<span data-ttu-id="3a3b8-282">Pomocí funkce asynchronní můžete vyvolat asynchronních metod bez použití explicitní zpětná volání nebo Ruční rozdělení kódu mezi více metod nebo výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-282">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="3a3b8-283">Pokud označíte metodu s [asynchronní](language-reference/keywords/async.md) modifikátor, můžete použít [await](language-reference/keywords/await.md) operátor v metodě.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-283">If you mark a method with the [async](language-reference/keywords/async.md) modifier, you can use the [await](language-reference/keywords/await.md) operator in the method.</span></span> <span data-ttu-id="3a3b8-284">Při řízení dosáhnou `await` výrazu v asynchronní metody řízení vrátí volající Pokud awaited úloha není dokončena a pokroku v metodě s `await` – klíčové slovo je pozastaveno, dokud se nedokončí awaited úloh.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-284">When control reaches an `await` expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the `await` keyword is suspended until the awaited task completes.</span></span> <span data-ttu-id="3a3b8-285">Po dokončení úlohy provádění může pokračovat v metodě.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-285">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="3a3b8-286">Asynchronní metody vrátí volající, pokud zjistí první awaited objekt, který ještě není dokončena nebo získá na konec asynchronní metody, cokoliv nastane dříve.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-286">An async method returns to the caller when either it encounters the first awaited object that’s not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="3a3b8-287">Asynchronní metody může mít návratový typ <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, nebo `void`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-287">An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or `void`.</span></span> <span data-ttu-id="3a3b8-288">`void` Vrátí typ se používá hlavně k definování obslužné rutiny událostí, kde `void` návratový typ je požadovaná.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-288">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="3a3b8-289">Asynchronní metody, která vrací `void` nemůže být očekáváno, a volající metody vrácení void nelze catch výjimky, které vyvolá metoda.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-289">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="3a3b8-290">C# 7, po vydání, bude usnadňují toto omezení umožňující použití asynchronní metody [vrátit jakýkoli typ úlohy jako](https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md).</span><span class="sxs-lookup"><span data-stu-id="3a3b8-290">C# 7, when it is released, will ease this restriction to allow an async method [to return any task-like type](https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md).</span></span>

<span data-ttu-id="3a3b8-291">V následujícím příkladu `DelayAsync` je asynchronní metody, který má návratový příkaz, který vrátí celé číslo.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-291">In the following example, `DelayAsync` is an async method that has a return statement that returns an integer.</span></span> <span data-ttu-id="3a3b8-292">Protože je asynchronní metody, jeho metoda deklarace musí mít návratový typ `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-292">Because it is an async method, its method declaration must have a return type of `Task<int>`.</span></span> <span data-ttu-id="3a3b8-293">Vzhledem k tomu, že je návratový typ `Task<int>`, vyhodnocení `await` výrazu v `DoSomethingAsync` vytváří celé jako následující `int result = await delayTask` ukazuje příkaz.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-293">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer, as the following `int result = await delayTask` statement demonstrates.</span></span>

[!code-csharp[csSnippets.Methods#102](../../samples/snippets/csharp/concepts/methods/async1.cs#102)]

<span data-ttu-id="3a3b8-294">Asynchronní metody nelze deklarovat všechny [v](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), nebo [out](language-reference/keywords/out-parameter-modifier.md) parametry, ale můžete volat metody, které mají tyto parametry.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-294">An async method can't declare any [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), or [out](language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

 <span data-ttu-id="3a3b8-295">Další informace o asynchronní metody najdete v tématu [asynchronní programování s Async a Await](async.md), [řízení toku v asynchronních programech](programming-guide/concepts/async/control-flow-in-async-programs.md), a [asynchronní vrátit typy](programming-guide/concepts/async/async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="3a3b8-295">For more information about async methods, see [Asynchronous Programming with Async and Await](async.md), [Control Flow in Async Programs](programming-guide/concepts/async/control-flow-in-async-programs.md), and [Async Return Types](programming-guide/concepts/async/async-return-types.md).</span></span>

<a name="expr"></a>
## <a name="expression-bodied-members"></a><span data-ttu-id="3a3b8-296">Výraz vozidlo členy</span><span class="sxs-lookup"><span data-stu-id="3a3b8-296">Expression-bodied members</span></span> ##

<span data-ttu-id="3a3b8-297">Je běžné metoda definicemi, jednoduše okamžitě vrátí s výsledkem výrazu nebo které mají jediný příkaz jako text metody.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-297">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span>  <span data-ttu-id="3a3b8-298">Je syntaxe zástupce pro definování těchto metod, pomocí `=>`:</span><span class="sxs-lookup"><span data-stu-id="3a3b8-298">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="3a3b8-299">Pokud metoda vrátí `void` nebo asynchronní metody, obsah metody musí být výraz – příkaz (stejné jako u lambdas).</span><span class="sxs-lookup"><span data-stu-id="3a3b8-299">If the method returns `void` or is an async method, the body of the method must be a statement expression (same as with lambdas).</span></span>  <span data-ttu-id="3a3b8-300">Pro vlastnostmi a indexery, musí být jen pro čtení a nepoužívejte `get` – klíčové slovo přistupujícího objektu.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-300">For properties and indexers, they must be read-only, and you do not use the `get` accessor keyword.</span></span>

<a name="iterators"></a>
## <a name="iterators"></a><span data-ttu-id="3a3b8-301">Iterátory</span><span class="sxs-lookup"><span data-stu-id="3a3b8-301">Iterators</span></span> ##

<span data-ttu-id="3a3b8-302">Iterátor provede vlastní iterace nad kolekcí, jako je například seznam nebo pole.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-302">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="3a3b8-303">Iterátor používá [yield vrátit](language-reference/keywords/yield.md) příkaz vrátit každý element, jeden v čase.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-303">An iterator uses the [yield return](language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="3a3b8-304">Když `yield return` příkaz je dosaženo, aktuální umístění je uloží, takže volající může požádat o další prvek v pořadí.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-304">When a `yield return` statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</span></span>

<span data-ttu-id="3a3b8-305">Návratový typ iterovat může být <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, nebo <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="3a3b8-305">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="3a3b8-306">Další informace najdete v tématu [iterátory](programming-guide/concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="3a3b8-306">For more information, see [Iterators](programming-guide/concepts/iterators.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="3a3b8-307">Viz také</span><span class="sxs-lookup"><span data-stu-id="3a3b8-307">See also</span></span> ##

<span data-ttu-id="3a3b8-308">[Modifikátory přístupu](language-reference/keywords/access-modifiers.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-308">[Access Modifiers](language-reference/keywords/access-modifiers.md) </span></span>  
<span data-ttu-id="3a3b8-309">[Statické třídy a jejich členové](programming-guide/classes-and-structs/static-classes-and-static-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-309">[Static Classes and Static Class Members](programming-guide/classes-and-structs/static-classes-and-static-class-members.md) </span></span>  
<span data-ttu-id="3a3b8-310">[dědičnost](programming-guide/classes-and-structs/inheritance.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-310">[Inheritance](programming-guide/classes-and-structs/inheritance.md) </span></span>  
<span data-ttu-id="3a3b8-311">[Abstraktní a uzavřené třídy a jejich členové](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-311">[Abstract and Sealed Classes and Class Members](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span></span>  
<span data-ttu-id="3a3b8-312">[params](language-reference/keywords/params.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-312">[params](language-reference/keywords/params.md) </span></span>  
<span data-ttu-id="3a3b8-313">[na více systémů](language-reference/keywords/out-parameter-modifier.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-313">[out](language-reference/keywords/out-parameter-modifier.md) </span></span>  
<span data-ttu-id="3a3b8-314">[ref](language-reference/keywords/ref.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-314">[ref](language-reference/keywords/ref.md) </span></span>  
<span data-ttu-id="3a3b8-315">[V](language-reference/keywords/in-parameter-modifier.md) </span><span class="sxs-lookup"><span data-stu-id="3a3b8-315">[in](language-reference/keywords/in-parameter-modifier.md) </span></span>  
[<span data-ttu-id="3a3b8-316">Předávání parametrů</span><span class="sxs-lookup"><span data-stu-id="3a3b8-316">Passing Parameters</span></span>](programming-guide/classes-and-structs/passing-parameters.md)
