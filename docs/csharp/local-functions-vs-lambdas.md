---
title: "Lokální funkce oproti výrazy lambda"
description: "Zjistěte, proč lokální funkce může být vhodnější než výrazy lambda."
keywords: "C#, .NET, .NET Core, nejnovější funkce, co je nového, místní funkce výrazy lambda"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="b4245-104">Lokální funkce ve srovnání s výrazy lambda</span><span class="sxs-lookup"><span data-stu-id="b4245-104">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="b4245-105">Na první pohled [lokální funkce](programming-guide/classes-and-structs/local-functions.md) a [výrazy lambda](lambda-expressions.md) jsou velmi podobné.</span><span class="sxs-lookup"><span data-stu-id="b4245-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="b4245-106">V mnoha případech je výběr mezi použitím lambda – výrazy a lokální funkce řádu style a osobní preference.</span><span class="sxs-lookup"><span data-stu-id="b4245-106">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="b4245-107">Existují však skutečné rozdíly ve kterém můžete použít jeden z nich, které byste měli vědět.</span><span class="sxs-lookup"><span data-stu-id="b4245-107">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="b4245-108">Podívejme se na rozdíly mezi místní funkce a implementace výrazu lambda faktoriálu algoritmu.</span><span class="sxs-lookup"><span data-stu-id="b4245-108">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="b4245-109">První verzi pomocí místní funkce:</span><span class="sxs-lookup"><span data-stu-id="b4245-109">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="b4245-110">Kontrastu této implementace s verzí, která používá výrazy lambda:</span><span class="sxs-lookup"><span data-stu-id="b4245-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="b4245-111">Místní funkce mají názvy.</span><span class="sxs-lookup"><span data-stu-id="b4245-111">The local functions have names.</span></span> <span data-ttu-id="b4245-112">Anonymní metody, které jsou přiřazeny k proměnné, které jsou jsou výrazy lambda `Func` nebo `Action` typy.</span><span class="sxs-lookup"><span data-stu-id="b4245-112">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="b4245-113">Po deklarování místní funkce typy argumentů a návratový typ jsou součástí deklarace funkce.</span><span class="sxs-lookup"><span data-stu-id="b4245-113">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="b4245-114">Namísto část textu argument lambda výrazu, typy argumentů a návratový typ jsou součástí deklarace proměnné typu výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="b4245-114">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="b4245-115">Tyto dvě rozdíly může vést k jasnější kódu.</span><span class="sxs-lookup"><span data-stu-id="b4245-115">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="b4245-116">Místní funkce mají různá pravidla pro jednoznačné přiřazení než výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="b4245-116">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="b4245-117">Deklarace místní funkce lze odkazovat z libovolného místa kódu, kde se nachází v oboru.</span><span class="sxs-lookup"><span data-stu-id="b4245-117">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="b4245-118">Výraz lambda musí být přiřazený k proměnné delegáta předtím, než může být přístup (nebo zavolaném prostřednictvím delgate odkazující na výrazu lambda.) Všimněte si, že verze pomocí výrazu lambda musí deklarovat a inicializace výrazu lambda `nthFactorial` před definováním ho.</span><span class="sxs-lookup"><span data-stu-id="b4245-118">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="b4245-119">Proti tomu má za následek chybu v době kompilace pro odkazování na `nthFactorial` před jeho přiřazení.</span><span class="sxs-lookup"><span data-stu-id="b4245-119">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="b4245-120">Tyto rozdíly znamená, že rekurzivní algoritmů je snazší vytvářet pomocí místní funkcí.</span><span class="sxs-lookup"><span data-stu-id="b4245-120">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="b4245-121">Můžete deklarovat a definovat místní funkci, která volá sám sebe.</span><span class="sxs-lookup"><span data-stu-id="b4245-121">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="b4245-122">Lambda – výrazy musí být deklarován a přiřazené výchozí hodnotu, než můžou být znovu přiřazen k obsahu, která odkazuje na stejný výraz lambda.</span><span class="sxs-lookup"><span data-stu-id="b4245-122">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="b4245-123">Pravidla jednoznačné přiřazení ovlivní také jakékoli proměnné, které jsou zachyceny místní funkce nebo lamdba epression.</span><span class="sxs-lookup"><span data-stu-id="b4245-123">Definite assignment rules also affect any variables that are captured by the local function or lamdba epression.</span></span> <span data-ttu-id="b4245-124">Místní funkce a pravidel výrazu lambda požadovat, aby všechny zaznamenané proměnné výborný přiřazené v bodě při převodu místní funkce nebo lambda výraz delegáta.</span><span class="sxs-lookup"><span data-stu-id="b4245-124">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="b4245-125">Rozdíl je, že výrazy lambda se převedou na delegáti, když jsou deklarovány.</span><span class="sxs-lookup"><span data-stu-id="b4245-125">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="b4245-126">Lokální funkce se převedou na delegáty jenom v případě, že se používá jako delegáta.</span><span class="sxs-lookup"><span data-stu-id="b4245-126">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="b4245-127">Pokud deklarovat místní funkce a odkazovat pouze na ho voláním jako metodu, nebudou převedeny na delegáta.</span><span class="sxs-lookup"><span data-stu-id="b4245-127">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="b4245-128">Toto pravidlo umožňuje deklarovat místní funkce v libovolném vhodného umístění v jeho nadřazeného oboru.</span><span class="sxs-lookup"><span data-stu-id="b4245-128">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="b4245-129">Je běžné deklarovat místní funkce na konci nadřazenou metodu po všech příkazech return.</span><span class="sxs-lookup"><span data-stu-id="b4245-129">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="b4245-130">Kompilátor třetí, můžete provést statické analýzy, která umožňuje místní funkce výborný přiřadit zaznamenané proměnné ve vymezeném oboru.</span><span class="sxs-lookup"><span data-stu-id="b4245-130">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="b4245-131">Vezměte v úvahu v tomto příkladu:</span><span class="sxs-lookup"><span data-stu-id="b4245-131">Consider this example:</span></span>

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

<span data-ttu-id="b4245-132">Kompilátor můžete určit, který `Local` výborný přiřadí `y` při volání.</span><span class="sxs-lookup"><span data-stu-id="b4245-132">The compiler can determine that `Local` definitely assigns `y` when called.</span></span> <span data-ttu-id="b4245-133">Protože `Local` je volána před provedením `return` příkaz `y` definitiely přiřazen za `return` příkaz.</span><span class="sxs-lookup"><span data-stu-id="b4245-133">Because `Local` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="b4245-134">Analýzy, která umožňuje, že analysis umožňuje čtvrtý rozdíl.</span><span class="sxs-lookup"><span data-stu-id="b4245-134">The analysis that enables that analysis enables the fourth difference.</span></span>
<span data-ttu-id="b4245-135">V závislosti na jejich použití se můžete vyhnout lokální funkce přidělení haldy, které jsou vždy potřebné pro výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="b4245-135">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="b4245-136">Pokud je místní funkce nikdy převedeno na delegáta a žádné proměnné zachycenou místní funkce zachycenou další lambdas nebo místní funkce, které se převedou na delegáty, kompilátor se můžete vyhnout přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="b4245-136">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="b4245-137">Tento příklad asynchronní vezměte v úvahu:</span><span class="sxs-lookup"><span data-stu-id="b4245-137">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="b4245-138">Obsahuje uzavření pro tento výraz lambda `address`, `index` a `name` proměnné.</span><span class="sxs-lookup"><span data-stu-id="b4245-138">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="b4245-139">V případě místní funkce, může být objektu, který implementuje uzavření `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="b4245-139">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="b4245-140">Struktura typu by byly předány podle odkaz na tuto funkci místní.</span><span class="sxs-lookup"><span data-stu-id="b4245-140">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="b4245-141">Tento rozdíl v implementaci by uložit na přidělení.</span><span class="sxs-lookup"><span data-stu-id="b4245-141">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="b4245-142">Instance, které jsou nezbytné pro výrazy lambda znamená přidělení paměť navíc, které můžou být faktor v cestách kód kritický pro čas.</span><span class="sxs-lookup"><span data-stu-id="b4245-142">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="b4245-143">Lokální funkce nevznikají Tato dodatečná režie.</span><span class="sxs-lookup"><span data-stu-id="b4245-143">Local functions do not incur this overhead.</span></span> <span data-ttu-id="b4245-144">V předchozím příkladu musí lokální funkce verze 2 přidělení méně než verze výrazu lambda.</span><span class="sxs-lookup"><span data-stu-id="b4245-144">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="b4245-145">Místní funkce ekvivalent tato metoda také používá třídu pro uzavření.</span><span class="sxs-lookup"><span data-stu-id="b4245-145">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="b4245-146">Jestli uzavření pro místní funkce je implementovaná jako `class` nebo `struct` je podrobností implementace.</span><span class="sxs-lookup"><span data-stu-id="b4245-146">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="b4245-147">Může použít místní funkce `struct` zatímco lambda bude vždy používat `class`.</span><span class="sxs-lookup"><span data-stu-id="b4245-147">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="b4245-148">Jednou z výhod konečné není ukázáno v této ukázce je, že lokální funkce může být prováděny jako iterátory, pomocí `yield return` syntaxe k vytvoření pořadí hodnot.</span><span class="sxs-lookup"><span data-stu-id="b4245-148">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="b4245-149">`yield return` Příkaz není povolen v výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="b4245-149">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="b4245-150">Při místní funkce se může zdát redundantní výrazy lambda, se ve skutečnosti slouží k jiným účelům a mít jiný používá.</span><span class="sxs-lookup"><span data-stu-id="b4245-150">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="b4245-151">Lokální funkce jsou efektivnější pro případ, pokud chcete vytvořit funkci, která je volána pouze z kontextu jinou metodu.</span><span class="sxs-lookup"><span data-stu-id="b4245-151">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
