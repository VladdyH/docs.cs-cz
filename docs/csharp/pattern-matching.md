---
title: "Shoda vzoru – průvodce v C#"
description: "Další informace o výrazy v jazyce C# pro porovnávání"
keywords: "Rozhraní .NET, rozhraní .NET core, C#"
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 0c77c3c3da9983d20cdd86db18f60f83b86b07ea
ms.sourcegitcommit: 281070dee88db86ec3bb4634d5f558d1a4e159dd
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/11/2017
---
# <a name="pattern-matching"></a><span data-ttu-id="0da05-104">Porovnávání vzorů</span><span class="sxs-lookup"><span data-stu-id="0da05-104">Pattern Matching</span></span> #

<span data-ttu-id="0da05-105">Vzory otestovat, zda hodnota má určitou *tvaru*a můžete *extrahovat* informace z hodnotu, pokud má odpovídající tvaru.</span><span class="sxs-lookup"><span data-stu-id="0da05-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="0da05-106">Shoda vzoru poskytuje přesnější syntaxe pro algoritmy, které už používáte ještě dnes.</span><span class="sxs-lookup"><span data-stu-id="0da05-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="0da05-107">Vytvoříte již algoritmy pomocí stávající syntaxe porovnávání vzorů.</span><span class="sxs-lookup"><span data-stu-id="0da05-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="0da05-108">Psaní `if` nebo `switch` příkazy, které testovací hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0da05-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="0da05-109">Pokud tyto příkazy shodují, pak rozbalte a použít informace z tuto hodnotu.</span><span class="sxs-lookup"><span data-stu-id="0da05-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="0da05-110">Nové prvky syntaxe jsou rozšíření se příkazy, které jste již obeznámeni s: `is` a `switch`.</span><span class="sxs-lookup"><span data-stu-id="0da05-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="0da05-111">Tyto nové přípony kombinovat testování hodnotu a extrakci těchto informací.</span><span class="sxs-lookup"><span data-stu-id="0da05-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="0da05-112">V tomto tématu se podíváme na nové syntaxe ukazují, jak umožňuje čtení, přesné kódu.</span><span class="sxs-lookup"><span data-stu-id="0da05-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="0da05-113">Shoda vzoru umožňuje idioms kde dat a kód jsou oddělené, na rozdíl od objektově orientované návrhů kde data a metody, které s nimi manipulovat jsou úzce spojeny.</span><span class="sxs-lookup"><span data-stu-id="0da05-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="0da05-114">Pro ilustraci tyto nové idioms, budeme pracovat s struktury, které představují geometrické obrazce pomocí příkazů porovnávání vzorů.</span><span class="sxs-lookup"><span data-stu-id="0da05-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="0da05-115">Znáte pravděpodobně vytváření hierarchie tříd a vytváření [virtuální metody a přepsané metody](methods.md#inherited) k přizpůsobení chování objektů na základě runtime typu objektu.</span><span class="sxs-lookup"><span data-stu-id="0da05-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="0da05-116">Tyto techniky nejsou možné pro data, která neodpovídá struktuře hierarchie tříd.</span><span class="sxs-lookup"><span data-stu-id="0da05-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="0da05-117">Pokud data a metody jsou oddělené, je potřeba další nástroje.</span><span class="sxs-lookup"><span data-stu-id="0da05-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="0da05-118">Nové *porovnávání vzorů* konstrukce povolit čisticí syntaxe sloužící ke zkoumání dat a manipulaci s řízení toku na základě těchto dat žádné podmínky.</span><span class="sxs-lookup"><span data-stu-id="0da05-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="0da05-119">Již zápisu `if` příkazy a `switch` , testovací hodnoty proměnné.</span><span class="sxs-lookup"><span data-stu-id="0da05-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="0da05-120">Psaní `is` příkazy, které testovací typ proměnné.</span><span class="sxs-lookup"><span data-stu-id="0da05-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="0da05-121">*Shoda vzoru* přidá nové funkce se tyto příkazy.</span><span class="sxs-lookup"><span data-stu-id="0da05-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="0da05-122">V tomto tématu vytvoříte metodu, která vypočítá oblasti jiné geometrické obrazce.</span><span class="sxs-lookup"><span data-stu-id="0da05-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="0da05-123">Ale můžete to udělat bez nutnosti techniky objektově orientované a vytvoření hierarchie tříd pro různých tvarů.</span><span class="sxs-lookup"><span data-stu-id="0da05-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="0da05-124">Budete používat *porovnávání vzorů* místo.</span><span class="sxs-lookup"><span data-stu-id="0da05-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="0da05-125">Další zdůraznit, že používáme nejsou dědičnosti, budete provedete jednotlivé obrazce `struct` místo třídu.</span><span class="sxs-lookup"><span data-stu-id="0da05-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="0da05-126">Všimněte si, že jiný `struct` typy nelze zadat běžné uživatelem definovaný základní typ, takže dědičnosti není možné návrhu.</span><span class="sxs-lookup"><span data-stu-id="0da05-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="0da05-127">Při procházení této ukázce protějšek tento kód s tom, jak by strukturovaná jako objekt hierarchie.</span><span class="sxs-lookup"><span data-stu-id="0da05-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="0da05-128">Když data je nutné zadat dotaz a manipulaci s není hierarchie tříd, porovnávání vzorů umožňuje velmi elegantní návrhů.</span><span class="sxs-lookup"><span data-stu-id="0da05-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="0da05-129">Namísto spuštění pomocí definice abstraktní tvar a přidávání tříd různých konkrétní tvaru, začneme místo jednoduché datové pouze definice pro každý geometrické obrazce:</span><span class="sxs-lookup"><span data-stu-id="0da05-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="0da05-130">Z těchto struktur můžete napsat metodu, která vypočítá oblasti některé tvaru.</span><span class="sxs-lookup"><span data-stu-id="0da05-130">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="0da05-131">`is` Zadejte vzor výrazu</span><span class="sxs-lookup"><span data-stu-id="0da05-131">The `is` type pattern expression</span></span>

<span data-ttu-id="0da05-132">Před C# 7, museli byste otestujte všechny typy v řadě `if` a `is` příkazy:</span><span class="sxs-lookup"><span data-stu-id="0da05-132">Before C# 7, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="0da05-133">Jestli je výše uvedený kód classic výraz *typ vzor*: testujete proměnnou k určení typu a přepnutím různé akce v závislosti na typu.</span><span class="sxs-lookup"><span data-stu-id="0da05-133">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="0da05-134">Tento kód bude jednodušší pomocí rozšíření pro `is` výrazu přiřadit proměnné Pokud test úspěšné:</span><span class="sxs-lookup"><span data-stu-id="0da05-134">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="0da05-135">V této aktualizované verzi `is` výraz jak testy proměnnou a přiřadí ji k nové proměnné správné typu.</span><span class="sxs-lookup"><span data-stu-id="0da05-135">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="0da05-136">Navíc Všimněte si, že tato verze zahrnuje `Rectangle` typu, který je `struct`.</span><span class="sxs-lookup"><span data-stu-id="0da05-136">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="0da05-137">Nové `is` výraz funguje s typy hodnot, jakož i odkazové typy.</span><span class="sxs-lookup"><span data-stu-id="0da05-137">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="0da05-138">Jazyk pravidla pro vzor odpovídající výrazy umožňuje vyhnout se zneužití výsledky výrazu shody.</span><span class="sxs-lookup"><span data-stu-id="0da05-138">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="0da05-139">V příkladu výše, proměnné `s`, `c`, a `r` pouze v oboru a výborný přiřazený, když se odpovídající vzor shody výrazy `true` výsledky.</span><span class="sxs-lookup"><span data-stu-id="0da05-139">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="0da05-140">Pokud se pokusíte použít buď proměnné na jiné místo, vygeneruje kód chyby kompilátoru.</span><span class="sxs-lookup"><span data-stu-id="0da05-140">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="0da05-141">Podívejme se na obě tato pravidla podrobně počínaje oboru.</span><span class="sxs-lookup"><span data-stu-id="0da05-141">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="0da05-142">Proměnná `c` nachází v oboru pouze v `else` větev první `if` příkaz.</span><span class="sxs-lookup"><span data-stu-id="0da05-142">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="0da05-143">Proměnná `s` nachází v oboru v metodě `ComputeArea`.</span><span class="sxs-lookup"><span data-stu-id="0da05-143">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="0da05-144">Důvodem je, že každou větev `if` příkaz vytváří samostatný obor pro proměnné.</span><span class="sxs-lookup"><span data-stu-id="0da05-144">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="0da05-145">Ale `if` příkaz sám nemá.</span><span class="sxs-lookup"><span data-stu-id="0da05-145">However, the `if` statement itself does not.</span></span> <span data-ttu-id="0da05-146">To znamená proměnných deklarovaných v `if` příkaz jsou ve stejném oboru jako `if` – příkaz (metoda v tomto případě.) Toto chování není specifické pro porovnávání vzorů, ale je definovaný chování pro proměnné obory a `if` a `else` příkazy.</span><span class="sxs-lookup"><span data-stu-id="0da05-146">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="0da05-147">Proměnné `c` a `s` jsou přiřazeny, kdy příslušné `if` příkazy jsou splněny kvůli výborný přiřazené při true mechanismus.</span><span class="sxs-lookup"><span data-stu-id="0da05-147">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="0da05-148">Ukázky v tomto tématu použijte doporučené konstrukce, kde je vzor shody `is` výraz výborný přiřadí proměnné shoda v `true` větev `if` příkaz.</span><span class="sxs-lookup"><span data-stu-id="0da05-148">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="0da05-149">Bylo možné změnit logiku vyslovením `if (!(shape is Square s))` a proměnná `s` by výborný přiřadit pouze v `false` firemní pobočky.</span><span class="sxs-lookup"><span data-stu-id="0da05-149">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="0da05-150">To je platný C#, se nedoporučuje, protože je pro postupujte podle logiky více matoucí.</span><span class="sxs-lookup"><span data-stu-id="0da05-150">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="0da05-151">Tato pravidla znamená, že jste nepravděpodobné, že omylem přístupu výsledek výrazu vzor shody v případě, že tento vzor nebyl splněn.</span><span class="sxs-lookup"><span data-stu-id="0da05-151">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="0da05-152">Použití porovnávání vzorů `switch` příkazy</span><span class="sxs-lookup"><span data-stu-id="0da05-152">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="0da05-153">Odehrává ve, musíte pro podporu dalších typů tvaru.</span><span class="sxs-lookup"><span data-stu-id="0da05-153">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="0da05-154">S růstem počet podmínky testujete zjistíte to pomocí `is` výrazy pro porovnávání se může stát náročná.</span><span class="sxs-lookup"><span data-stu-id="0da05-154">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="0da05-155">Kromě nutnosti `if` příkazy pro každý typ, který chcete zkontrolovat, `is` výrazy jsou omezeny na testování, pokud odpovídá jeden typ vstupu.</span><span class="sxs-lookup"><span data-stu-id="0da05-155">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="0da05-156">V takovém případě budete zjistíte, že `switch` vzor odpovídající výrazy stane lepší volbou.</span><span class="sxs-lookup"><span data-stu-id="0da05-156">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="0da05-157">Tradiční `switch` příkaz byl výraz vzor: to, že nepodporuje konstantní vzor.</span><span class="sxs-lookup"><span data-stu-id="0da05-157">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="0da05-158">Může porovnat proměnnou, do které žádné konstanta použít v `case` příkaz:</span><span class="sxs-lookup"><span data-stu-id="0da05-158">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="0da05-159">Pouze vzoru podporovanému službou `switch` příkaz byl vzoru konstantní.</span><span class="sxs-lookup"><span data-stu-id="0da05-159">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="0da05-160">Byl další omezeno na číselnou typy a `string` typu.</span><span class="sxs-lookup"><span data-stu-id="0da05-160">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="0da05-161">Tato omezení jsme odebrali, a teď můžete napsat `switch` příkaz s použitím vzoru typu:</span><span class="sxs-lookup"><span data-stu-id="0da05-161">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="0da05-162">Shoda vzoru `switch` příkaz používá známé syntaxe pro vývojáře, kteří použili tradiční stylu jazyka C `switch` příkaz.</span><span class="sxs-lookup"><span data-stu-id="0da05-162">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="0da05-163">Každý `case` je vyhodnocena a spouští kód pod podmínku, která odpovídá vstupní proměnné.</span><span class="sxs-lookup"><span data-stu-id="0da05-163">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="0da05-164">Provádění kódu nelze "předáno" z jeden výraz case na další; syntaxe `case` příkaz vyžaduje, aby se každý `case` končit `break`, `return`, nebo `goto`.</span><span class="sxs-lookup"><span data-stu-id="0da05-164">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="0da05-165">`goto` Příkazy Přejít na jiný štítek jsou platné pouze pro konstantní vzor příkaz classic přepínače.</span><span class="sxs-lookup"><span data-stu-id="0da05-165">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="0da05-166">Důležité nové pravidel určujících `switch` příkaz.</span><span class="sxs-lookup"><span data-stu-id="0da05-166">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="0da05-167">Omezení pro typ proměnné v `switch` výraz se odebraly.</span><span class="sxs-lookup"><span data-stu-id="0da05-167">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="0da05-168">Jakýkoli typ, jako například `object` v tomto příkladu může použít.</span><span class="sxs-lookup"><span data-stu-id="0da05-168">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="0da05-169">Výrazy case již nejsou omezeny na konstantní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0da05-169">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="0da05-170">Odebrání tohoto omezení znamená, že změna `switch` části může změnit chování programu.</span><span class="sxs-lookup"><span data-stu-id="0da05-170">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="0da05-171">Pokud omezené na konstantní hodnoty, víc než jeden `case` popisek může odpovídat hodnotě `switch` výraz.</span><span class="sxs-lookup"><span data-stu-id="0da05-171">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="0da05-172">Kombinovat s pravidlo, všechny `switch` části nesmí přejít k další části, a ho a potom, `switch` části může měnit v libovolném pořadí bez ovlivnění chování.</span><span class="sxs-lookup"><span data-stu-id="0da05-172">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="0da05-173">Nyní, s více zobecněn `switch` záleží na pořadí každého oddílu, výrazy.</span><span class="sxs-lookup"><span data-stu-id="0da05-173">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="0da05-174">`switch` Výrazy jsou vyhodnocovány v textové pořadí.</span><span class="sxs-lookup"><span data-stu-id="0da05-174">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="0da05-175">Provádění přenese na první `switch` štítek, který odpovídá `switch` výraz.</span><span class="sxs-lookup"><span data-stu-id="0da05-175">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="0da05-176">Všimněte si, že `default` případu bude spuštěn pouze pokud odpovídají žádné případu popisky.</span><span class="sxs-lookup"><span data-stu-id="0da05-176">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="0da05-177">`default` Případ vyhodnotí poslední, bez ohledu na jeho textovou pořadí.</span><span class="sxs-lookup"><span data-stu-id="0da05-177">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="0da05-178">Pokud neexistuje žádné `default` případ a žádná druhá `case` příkazy shodují, provádění pokračuje na následující příkaz `switch` příkaz.</span><span class="sxs-lookup"><span data-stu-id="0da05-178">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="0da05-179">Žádná z `case` spuštění kódu popisky.</span><span class="sxs-lookup"><span data-stu-id="0da05-179">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="0da05-180">`when`Klauzule v `case` výrazy</span><span class="sxs-lookup"><span data-stu-id="0da05-180">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="0da05-181">Můžete použít zvláštní případy pro tyto obrazce, které mají 0 oblasti pomocí `when` klauzule ve `case` popisek.</span><span class="sxs-lookup"><span data-stu-id="0da05-181">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="0da05-182">Čtverce s délkou straně 0 nebo kruh se serverem radius 0 má 0 oblasti.</span><span class="sxs-lookup"><span data-stu-id="0da05-182">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="0da05-183">Určíte, že podmínky použití `when` klauzule ve `case` štítku:</span><span class="sxs-lookup"><span data-stu-id="0da05-183">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="0da05-184">Tato změna ukazuje několik důležitých bodů o nové syntaxe.</span><span class="sxs-lookup"><span data-stu-id="0da05-184">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="0da05-185">První, více `case` štítky můžete použít na jednu `switch` části.</span><span class="sxs-lookup"><span data-stu-id="0da05-185">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="0da05-186">Blok příkazu je provést, pokud žádné z těchto popisky je `true`.</span><span class="sxs-lookup"><span data-stu-id="0da05-186">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="0da05-187">V této instanci Pokud `switch` výraz je kruh nebo čtverce oblasti, 0, vrátí metoda konstanta 0.</span><span class="sxs-lookup"><span data-stu-id="0da05-187">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="0da05-188">V tomto příkladu představuje dvou různých proměnných ve dvou `case` štítky pro první `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="0da05-188">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="0da05-189">Všimněte si, že příkazy v tomto `switch` bloku nepoužívejte buď proměnné `c` (pro kruhu) nebo `s` (pro druhou mocninu).</span><span class="sxs-lookup"><span data-stu-id="0da05-189">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="0da05-190">Ani jeden z těchto proměnných výborný přiřazené v tomto `switch` bloku.</span><span class="sxs-lookup"><span data-stu-id="0da05-190">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="0da05-191">Pokud některý z těchto případů shodují, jasně proměnných byl přiřazen.</span><span class="sxs-lookup"><span data-stu-id="0da05-191">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="0da05-192">Je však možné zjistit *který* byl přiřazen při kompilaci, protože obou případech může odpovídat za běhu.</span><span class="sxs-lookup"><span data-stu-id="0da05-192">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="0da05-193">Z tohoto důvodu většina časy při použití více `case` štítky pro stejného bloku, nebude zavést nové proměnné v `case` příkaz, nebo se použije pouze proměnné v `when` klauzule.</span><span class="sxs-lookup"><span data-stu-id="0da05-193">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="0da05-194">S přidá tyto obrazce oblasti, 0, můžeme přidat několik další typy tvar: obdélníku a trojúhelník:</span><span class="sxs-lookup"><span data-stu-id="0da05-194">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="0da05-195">Tuto sadu změn přidá `case` popisky degenerovanou případu a popisky a bloky pro každou novou tvarů.</span><span class="sxs-lookup"><span data-stu-id="0da05-195">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="0da05-196">Nakonec můžete přidat `null` případ zajistit argument není `null`:</span><span class="sxs-lookup"><span data-stu-id="0da05-196">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="0da05-197">Zvláštní chování `null` vzor je zajímavé protože konstanta `null` ve vzoru nemá typ, ale může být převedena na všechny odkaz na typ nebo typ s možnou hodnotou Null.</span><span class="sxs-lookup"><span data-stu-id="0da05-197">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="0da05-198">Místo převést `null` do libovolného typu, který definuje jazyk `null` hodnota nebude odpovídat žádnému typ vzoru, bez ohledu na typ kompilaci proměnné.</span><span class="sxs-lookup"><span data-stu-id="0da05-198">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="0da05-199">Díky tomuto chování nové `switch` na základě typu vzor konzistentní s `is` příkaz: `is` příkazy vždy vrátí `false` po hodnotu, se kontroluje `null`.</span><span class="sxs-lookup"><span data-stu-id="0da05-199">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="0da05-200">Je také jednodušší: Po zaškrtnutí typ nepotřebujete dodatečnou kontrolu hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="0da05-200">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="0da05-201">Uvidíte, že ze skutečnosti, že neexistují žádné null kontroly v žádném případu bloků ukázky výše: nejsou potřebné, protože odpovídající vzoru typ zaručuje nenulovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="0da05-201">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="0da05-202">`var`deklarace v `case` výrazy</span><span class="sxs-lookup"><span data-stu-id="0da05-202">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="0da05-203">Zavedení `var` jako jeden z výrazů shodu porovnávací zavádí nové pravidel.</span><span class="sxs-lookup"><span data-stu-id="0da05-203">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="0da05-204">První pravidlo je, že `var` deklarace odpovídá normální typ odvozená pravidla: typ je odvodit jako statický typ výrazu přepínače.</span><span class="sxs-lookup"><span data-stu-id="0da05-204">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="0da05-205">Od tohoto pravidla vždy odpovídá typu.</span><span class="sxs-lookup"><span data-stu-id="0da05-205">From that rule, the type always matches.</span></span>

<span data-ttu-id="0da05-206">Druhé pravidlo je, že `var` deklarace nemá hodnotu null. Zkontrolujte, zda jiné výrazy typu vzor zahrnout.</span><span class="sxs-lookup"><span data-stu-id="0da05-206">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="0da05-207">To znamená, že proměnná může mít hodnotu null a v takovém případě je nutné kontrolu hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="0da05-207">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="0da05-208">Tyto dvě pravidla znamenají, že v mnoha případech `var` deklarace v `case` výraz odpovídá stejných podmínek, `default` výraz.</span><span class="sxs-lookup"><span data-stu-id="0da05-208">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="0da05-209">Protože všechny jiné než výchozí případem je upřednostňovaný k `default` případě `default` případ se nikdy neprovede.</span><span class="sxs-lookup"><span data-stu-id="0da05-209">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="0da05-210">Kompilátor není posílat upozornění v případech, kde `default` případ byla zapsána, ale nikdy spustí.</span><span class="sxs-lookup"><span data-stu-id="0da05-210">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="0da05-211">To je konzistentní s aktuálním `switch` chování příkaz, kde uvedeny všechny možné případy.</span><span class="sxs-lookup"><span data-stu-id="0da05-211">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="0da05-212">Třetí pravidlo zavádí používá kde `var` případě může být užitečná.</span><span class="sxs-lookup"><span data-stu-id="0da05-212">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="0da05-213">Představte si, že vedete porovnávací, kde je vstupní řetězec a hledání známých příkaz hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0da05-213">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="0da05-214">Můžete napsat něco podobného jako:</span><span class="sxs-lookup"><span data-stu-id="0da05-214">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="0da05-215">`var` Případ odpovídá `null`, prázdný řetězec nebo libovolný řetězec, který obsahuje jenom prázdné znaky.</span><span class="sxs-lookup"><span data-stu-id="0da05-215">The `var` case matches `null`, the empty string, or any string that contains only whitespace.</span></span> <span data-ttu-id="0da05-216">Všimněte si, že předchozí kód používá `?.` operátor zajistit, že nevyvolá omylem <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="0da05-216">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="0da05-217">`default` Případ zpracovává všechny řetězcové hodnoty, které nejsou rozumí analyzátor tento příkaz.</span><span class="sxs-lookup"><span data-stu-id="0da05-217">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="0da05-218">Toto je jeden příklad, kde můžete vzít v úvahu `var` výraz, který se liší od případu `default` výraz.</span><span class="sxs-lookup"><span data-stu-id="0da05-218">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="0da05-219">Závěrů</span><span class="sxs-lookup"><span data-stu-id="0da05-219">Conclusions</span></span>

<span data-ttu-id="0da05-220">*Vzor párování konstrukce* vám umožní snadno spravovat tok řízení mezi různé proměnné a typy, které nejsou spojené hierarchie dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="0da05-220">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="0da05-221">Můžete také ovládat logiku používat všechny podmínky, které můžete testovat na proměnnou.</span><span class="sxs-lookup"><span data-stu-id="0da05-221">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="0da05-222">Umožňuje vzory a idioms, které budete potřebovat více často, jak vytvořit více distribuovaných aplikací, kde jsou oddělené data a metody, které pracují s tato data.</span><span class="sxs-lookup"><span data-stu-id="0da05-222">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="0da05-223">Můžete si všimnout, že tvar struktury, použít v této ukázce neobsahují žádné metody, vlastnosti stačí jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="0da05-223">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="0da05-224">Porovnávání vzorů. funguje s žádným typem data.</span><span class="sxs-lookup"><span data-stu-id="0da05-224">Pattern Matching works with any data type.</span></span> <span data-ttu-id="0da05-225">Zápis výrazů, které prověřují objekt a rozhodnutí řízení toku na základě těchto podmínek.</span><span class="sxs-lookup"><span data-stu-id="0da05-225">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="0da05-226">Porovnat kód od této ukázky s návrh, který byste použili ve vytváření hierarchie tříd pro abstraktní `Shape` a konkrétní odvozené obrazce každou s vlastní implementace virtuální metodu pro výpočet oblasti.</span><span class="sxs-lookup"><span data-stu-id="0da05-226">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="0da05-227">Budete často zjistíte, že vzor odpovídající výrazy mohou být velmi užitečné nástroje při práci s daty a chcete si nemuseli dělat starosti úložiště dat nezávislá si nemuseli dělat starosti chování.</span><span class="sxs-lookup"><span data-stu-id="0da05-227">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

