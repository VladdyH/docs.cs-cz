---
title: Odkaz na sémantiku s typy hodnot
description: Porozumět funkcím jazyk, které bezpečně minimalizovat kopírování struktury
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 778897dc92f8a94178ebbbed7704c0dfe2397729
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/28/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="d3b7b-103">Odkaz na sémantiku s typy hodnot</span><span class="sxs-lookup"><span data-stu-id="d3b7b-103">Reference semantics with value types</span></span>

<span data-ttu-id="d3b7b-104">Výhodou použití jiných typů hodnot je, že často vyhnout přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="d3b7b-105">Nevýhodou je, že se kopírují hodnotou.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="d3b7b-106">Tato kompromis znesnadňuje optimalizovat algoritmy, které působí na velké objemy dat.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="d3b7b-107">Nové funkce jazyka v C# 7.2 poskytují mechanismy, které umožňují průchodu odkazem sémantiku s typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="d3b7b-108">Pomocí těchto funkcí dobře minimalizovat obou přidělení a operace kopírování.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="d3b7b-109">Tento článek popisuje tyto nové funkce.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-109">This article explores those new features.</span></span>

<span data-ttu-id="d3b7b-110">Velká část ukázkový kód v tomto článku ukazuje funkce přidané v C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="d3b7b-111">Chcete-li použít tyto funkce, je nutné nakonfigurovat projektu pro použití jazyka C# 7,2 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="d3b7b-112">Visual Studio můžete ho vyberte.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="d3b7b-113">Pro každý projekt, vyberte **projektu** z nabídky, pak **vlastnosti**.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="d3b7b-114">Vyberte **sestavení** a klikněte na **Upřesnit**.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="d3b7b-115">Z ní nakonfigurujte jazykové verzi.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-115">From there, configure the language version.</span></span> <span data-ttu-id="d3b7b-116">Vyberte buď "7.2" nebo "posledního".</span><span class="sxs-lookup"><span data-stu-id="d3b7b-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="d3b7b-117">Nebo můžete upravit *csproj* souboru a přidejte následující uzly:</span><span class="sxs-lookup"><span data-stu-id="d3b7b-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="d3b7b-118">Můžete buď "7,2" nebo "posledního" pro hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="d3b7b-119">Předání argumentů odkazem jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="d3b7b-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="d3b7b-120">C# 7.2 přidá `in` – klíčové slovo, aby doplňovala existující `ref` a `out` klíčová slova předání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="d3b7b-121">`in` – Klíčové slovo určuje předání odkazem argument, ale zavolat metodu nedojde ke změně hodnota.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="d3b7b-122">Přidání poskytuje úplné termínů k vyjádření vašich představ návrhu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="d3b7b-123">Typy hodnot se zkopírují, když uplyne volané metodě, když nezadáte žádný z následujících modifikátory podpis metody.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="d3b7b-124">Každý z těchto modifikátory Určuje, že typ hodnoty je předán odkazem, zabraňující kopie.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="d3b7b-125">Každý modifikátor vyjadřoval různých záměrů:</span><span class="sxs-lookup"><span data-stu-id="d3b7b-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="d3b7b-126">`out`: Tato metoda nastaví hodnota argumentu použít jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="d3b7b-127">`ref`: Tato metoda může nastavit hodnotu argumentu použít jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="d3b7b-128">`in`: Tato metoda nedojde ke změně hodnoty argumentu použít jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="d3b7b-129">Přidat `in` modifikátor předat argument odkazem a deklarovat vašich představ návrhu předání argumentů odkazem, aby se zabránilo zbytečným kopírování.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="d3b7b-130">Nemáte v úmyslu použít jako tento argument objekt upravit.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="d3b7b-131">Následující kód ukazuje příklad metody, která by vypočítala vzdálenost mezi dvěma body v 3D prostoru.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="d3b7b-132">Argumenty jsou dvě struktury, že každý obsahovat tři hodnoty Double.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="d3b7b-133">Datový typ double je 8 bajtů, takže každý argument je 24 bajtů.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="d3b7b-134">Zadáním `in` modifikátor, předáte 4bajtový nebo 8bajtový odkaz na těchto argumentů, v závislosti na architektuře počítače.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="d3b7b-135">Rozdíl ve velikosti je malý, ale ho můžete rychle přidat když aplikace zavolá tato metoda ve smyčce úzkou pomocí mnoha různých hodnot.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="d3b7b-136">`in` Modifikátor doplňuje `out` a `ref` také jiné způsoby.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="d3b7b-137">Nelze vytvořit přetížení metody, které se liší pouze v přítomnosti z `in`, `out`, nebo `ref`.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="d3b7b-138">Tyto nové pravidel rozšířit stejné chování, která měla vždy definována pro `out` a `ref` parametry.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="d3b7b-139">`in` Modifikátor mohou být použity u kteréhokoli člena, který používá parametry: metody, delegáti, lambdas, místní funkce, indexery, operátory.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="d3b7b-140">Na rozdíl od `ref` a `out` argumenty, můžete pomocí literálových hodnot nebo konstanty pro argument `in` parametr.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="d3b7b-141">Navíc na rozdíl od `ref` nebo `out` parametr, nemusíte použít `in` modifikátor v lokalitě volání.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="d3b7b-142">Následující kód ukazuje dva příklady volání `CalculateDistance` metoda.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="d3b7b-143">První používá dva místní proměnné předaná odkaz.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="d3b7b-144">Druhá zahrnuje dočasné proměnné, vytvořené jako součást volání metody.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="d3b7b-145">Existuje několik způsobů, ve kterých kompilátor zajišťuje, které povaze jen pro čtení `in` argument je vynucená.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="d3b7b-146">Nejprve zavolat metodu nelze přiřadit přímo `in` parametr.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="d3b7b-147">Nelze přiřadit přímo k žádné pole `in` parametr, pokud je tato hodnota `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="d3b7b-148">Kromě toho nelze předat `in` parametr pro jakékoli metoda pomocí `ref` nebo `out` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="d3b7b-149">Tato pravidla vztahují na všechny pole `in` pole je zadán parametr, `struct` typu a parametr je také `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="d3b7b-150">Ve skutečnosti, platí následující pravidla pro přístup ke členu několik vrstev zadané typy na všech úrovních přístup ke členu `structs`.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="d3b7b-151">Kompilátor vynucuje, který `struct` typy předány jako `in` argumenty a jejich `struct` členové jsou jen pro čtení proměnné, když se použije jako argumenty pro jiné metody.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="d3b7b-152">Použití `in` parametry zabraňuje náklady na potenciální výkon při kopie.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="d3b7b-153">Sémantika žádné volání metody nemění.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="d3b7b-154">Proto není potřeba zadat `in` modifikátor v lokalitě volání.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="d3b7b-155">Ale vynechání `in` modifikátor v lokalitě volání informuje kompilátor, že se může vytvořit kopii argument z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="d3b7b-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="d3b7b-156">Je implicitní převod, ale není identity konverzi z typ argumentu pro typ parametru.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="d3b7b-157">Argument je výraz, ale nemá žádné známé úložiště proměnné.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="d3b7b-158">Existuje přetížení, která se liší podle přítomnosti nebo absenci `in`.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="d3b7b-159">V takovém případě hodnota přetížení je lepší shodu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="d3b7b-160">Tato pravidla jsou užitečné při aktualizaci stávajícího kódu pro použití argumenty odkaz jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="d3b7b-161">Uvnitř metody volané můžete volat libovolné metody instance, která používá hodnoty parametrů.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="d3b7b-162">V těchto případech kopii `in` parametr je vytvořena.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="d3b7b-163">Protože kompilátor můžete vytvořit dočasnou proměnnou pro žádné `in` parametr, můžete také zadat výchozí hodnoty pro jakékoli `in` parametr.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="d3b7b-164">Následující kód určuje počátek (bod 0,0) jako výchozí hodnota pro druhý bod:</span><span class="sxs-lookup"><span data-stu-id="d3b7b-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="d3b7b-165">Chcete-li vynutit kompilátoru předání čtení pouze argumentů odkazem, zadejte `in` modifikačních na argumenty v lokalitě volání, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="d3b7b-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="d3b7b-166">Toto chování je jednodušší použít `in` parametry v čase ve velkých základy kódu, kde je možné, zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="d3b7b-167">Můžete přidat `in` modifikátor do signatur metoda první.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="d3b7b-168">Potom můžete přidat `in` modifikátor v callsites a vytvořit `readonly struct` typy Povolit kompilátor Vyhněte se vytváření Obranným kopie `in` parametry ve víc umístěních.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="d3b7b-169">`in` Parametr označení lze také s odkazové typy nebo číselné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="d3b7b-170">Výhody v obou případech jsou však minimální, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="d3b7b-171">`ref readonly` Vrátí</span><span class="sxs-lookup"><span data-stu-id="d3b7b-171">`ref readonly` returns</span></span>

<span data-ttu-id="d3b7b-172">Můžete také vrátí hodnotu typu odkazu, ale zakáže volající upravování tuto hodnotu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="d3b7b-173">Použití `ref readonly` modifikátor vyjádřit záměr tohoto návrhu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="d3b7b-174">Že jsou vrátí odkaz na existující data, ale neumožňuje úpravy upozorní čtečky.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="d3b7b-175">Kompilátor vynutí, že volající nelze změnit odkaz.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="d3b7b-176">Pokusy o přiřazení hodnoty přímo generovat chyby kompilace.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="d3b7b-177">Kompilátor však nemůže vědět, pokud žádné metodou member změní stav struct.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="d3b7b-178">Aby se zajistilo, že objekt se nemění, kompilátor vytvoří kopii a volá člen odkazů pomocí tuto kopii.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="d3b7b-179">Všechny změny se na tuto Obranným kopii.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="d3b7b-180">Je pravděpodobné, který pomocí knihovny `Point3D` by často používají počátek napříč kódem.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="d3b7b-181">Všechny instance vytvoří nový objekt v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="d3b7b-182">To může být výhodné vytvoření konstanta a vrátit odkaz.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="d3b7b-183">Ale pokud vrátíte odkaz na interní úložiště, můžete vynutit, aby volající nelze upravit odkazované úložiště.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="d3b7b-184">Následující kód definuje vlastnosti jen pro čtení, která vrátí `readonly ref` k `Point3D` určující počátek.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="d3b7b-185">Vytvoření kopie jen pro čtení ref návratový je snadné: právě přiřadit proměnné není deklarován s `ref readonly` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="d3b7b-186">Kompilátor generuje kód pro kopírování objektu jako součást přiřazení.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="d3b7b-187">Přiřadíte-li proměnnou, do které `ref readonly return`, můžete buď zadat `ref readonly` proměnnou nebo kopii-hodnota odkaz na jen pro čtení:</span><span class="sxs-lookup"><span data-stu-id="d3b7b-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="d3b7b-188">První přiřazení v předchozí kód vytvoří kopii `Origin` konstanta a přiřadí, které zkopírovat.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="d3b7b-189">Druhý přiřadí odkaz.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-189">The second assigns a reference.</span></span> <span data-ttu-id="d3b7b-190">Všimněte si, že `readonly` modifikátor musí být součástí deklarace proměnné.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="d3b7b-191">Odkaz, na který odkazuje nemůže být upraven.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="d3b7b-192">Pokusy o tak mít za následek chyby kompilace.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="d3b7b-193">`readonly struct` Typ</span><span class="sxs-lookup"><span data-stu-id="d3b7b-193">`readonly struct` type</span></span>

<span data-ttu-id="d3b7b-194">Použití `ref readonly` k velkým provozem použití struktury může být plně dostačující.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="d3b7b-195">Další dobu, můžete vytvořit neměnné struktura.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="d3b7b-196">Potom můžete vždy předat odkazem jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="d3b7b-197">Aby postup odebere Obranným zkopíruje které se provádějí při přístupu k metodám struktury použít jako `in` parametr.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="d3b7b-198">Můžete to udělat tak, že vytvoříte `readonly struct` typu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="d3b7b-199">Můžete přidat `readonly` modifikátor k deklaraci struktura.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="d3b7b-200">Kompilátor vynucuje, aby se všichni její členové instance dané struktury `readonly`; `struct` musí být neměnitelný.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="d3b7b-201">Existují další optimalizace pro `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="d3b7b-202">Můžete použít `in` modifikátor v každé umístění kde `readonly struct` je argument.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="d3b7b-203">Kromě toho se můžete vrátit `readonly struct` jako `ref return` když se vrátí objekt, jehož životnost rozšiřuje nad rámec metoda vrací objekt.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="d3b7b-204">Nakonec kompilátor generuje efektivnější kód při volání členy `readonly struct`: `this` odkaz, místo kopii příjemce, je vždy `in` parametr předaný odkazem na metodou member.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="d3b7b-205">Tato optimalizace uloží další kopírování při použití `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="d3b7b-206">`Point3D` Skvělé kandidátem pro tuto změnu.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="d3b7b-207">Následující kód ukazuje aktualizované `ReadonlyPoint3D` strukturu:</span><span class="sxs-lookup"><span data-stu-id="d3b7b-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="d3b7b-208">`ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="d3b7b-208">`ref struct` type</span></span>

<span data-ttu-id="d3b7b-209">Další související jazyk funkcí je schopnost deklarovat typ hodnoty, který musí být přidělena zásobníku.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="d3b7b-210">Jinými slovy tyto typy nikdy vytvořením v haldě jako člena jiné třídy.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="d3b7b-211">Primární motivace pro tuto funkci byl <xref:System.Span%601> a související struktury.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="d3b7b-212"><xref:System.Span%601> může obsahovat spravované ukazatel jako jeden z jejích členů, druhá je délka rozpětí.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="d3b7b-213">Je implementováno trochu jinak protože C# nepodporuje ukazatele na spravované paměti mimo kontextu unsafe.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="d3b7b-214">Všechny zápisu, které změní ukazatele a délka není atomic.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="d3b7b-215">To znamená <xref:System.Span%601> by podléhají mimo rozsah chyby nebo další narušení bezpečnosti typu není je omezená na jednom zásobníku.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="d3b7b-216">Kromě toho uvedení spravovaného ukazatel na haldě GC obvykle dojde k chybě během JIT.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="d3b7b-217">Můžete mít podobné požadavky práce paměti vytvořené pomocí [ `stackalloc` ](language-reference/keywords/stackalloc.md) nebo při použití paměti z spolupráce rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="d3b7b-218">Můžete definovat vlastní `ref struct` typy těchto potřeb.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="d3b7b-219">V tomto článku najdete příklady použití `Span<T>` pro jednoduchost.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="d3b7b-220">`ref struct` Deklarace deklaruje struktury tohoto typu musí být v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="d3b7b-221">Jazyk pravidla zajistit bezpečné používání těchto typů.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="d3b7b-222">Jiné typy deklarován jako `ref struct` zahrnují <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="d3b7b-223">Cílem zachování `ref struct` zadejte jako proměnnou přidělené zásobníku zavádí několik pravidel, která kompilátor vynucuje pro všechny `ref struct` typy.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="d3b7b-224">Nelze pole `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="d3b7b-225">Nelze přiřadit `ref struct` typ proměnné typu `object`, `dynamic`, nebo kterýkoli typ rozhraní.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="d3b7b-226">Nelze deklarovat `ref struct` jako člena třídy nebo normální struktury.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="d3b7b-227">Nelze deklarovat místní proměnné, které jsou `ref struct` typy v asynchronní metody.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="d3b7b-228">Je možné deklarovat v synchronních metod, které vracejí `Task`, `Task<T>` nebo typů úloh.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="d3b7b-229">Nelze deklarovat `ref struct` místní proměnné v iterátory.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="d3b7b-230">Nelze zachytit `ref struct` proměnných v výrazy lambda nebo lokální funkce.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="d3b7b-231">Tato omezení Ujistěte se, nepoužívejte omylem `ref struct` způsobem, který může podporovat spravovaná halda.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="d3b7b-232">`readonly ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="d3b7b-232">`readonly ref struct` type</span></span>

<span data-ttu-id="d3b7b-233">Deklarace struktury jako `readonly ref` kombinuje výhody a omezení `ref struct` a `readonly struct` delcarations.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="d3b7b-234">Následující příklad ukazuje deklaraci `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="d3b7b-235">Závěrů</span><span class="sxs-lookup"><span data-stu-id="d3b7b-235">Conclusions</span></span>

<span data-ttu-id="d3b7b-236">Tato vylepšení pro jazyk C# jsou navrženy pro výkon kritické algoritmy, kde může být rozhodující k dosažení nezbytné výkonu přidělení paměti.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="d3b7b-237">Můžete zjistit, že často nepoužíváte tyto funkce v kódu, kterou píšete.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="d3b7b-238">Tato vylepšení, ale byly přijaty v mnoho míst v rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="d3b7b-239">Jako zajistěte více rozhraní API pomocí těchto funkcí, uvidíte vaše vlastní aplikace zlepšit výkon.</span><span class="sxs-lookup"><span data-stu-id="d3b7b-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
