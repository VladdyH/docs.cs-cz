---
title: Referenční sémantika s typy hodnot
description: Funkce jazyka, které minimalizují kopírování struktury bezpečně pochopit
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: 8c2ece71e54f46aef9a2153540d0bda7e74b19a9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/11/2018
ms.locfileid: "44353915"
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="32746-103">Referenční sémantika s typy hodnot</span><span class="sxs-lookup"><span data-stu-id="32746-103">Reference semantics with value types</span></span>

<span data-ttu-id="32746-104">Výhodou použití typů hodnot je, že často vyhnout přidělení haldy.</span><span class="sxs-lookup"><span data-stu-id="32746-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="32746-105">Nevýhodou je, že se zkopírují podle hodnoty.</span><span class="sxs-lookup"><span data-stu-id="32746-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="32746-106">Tato kompromis učiní obtížnější pro optimalizaci algoritmů, které pracují na velkých objemů dat.</span><span class="sxs-lookup"><span data-stu-id="32746-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="32746-107">Nové funkce jazyků v jazyce C# 7.2 poskytují mechanismy, které umožňují pass referenční sémantika s typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="32746-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="32746-108">Pomocí těchto funkcí dobře minimalizovat obou přidělení a operací kopírování.</span><span class="sxs-lookup"><span data-stu-id="32746-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="32746-109">Tento článek se věnuje tyto nové funkce.</span><span class="sxs-lookup"><span data-stu-id="32746-109">This article explores those new features.</span></span>

<span data-ttu-id="32746-110">Většina ukázek kódu v tomto článku ukazuje funkce přidané v jazyce C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="32746-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="32746-111">Pokud chcete používat tyto funkce, je nutné nakonfigurovat projektu pro použití jazyka C# 7.2 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="32746-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="32746-112">Další informace o nastavení jazykové verze naleznete v tématu [konfigurace jazyková verze](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="32746-112">For more information on setting the language version see [configure the language version](language-reference/configure-language-version.md).</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="32746-113">Předání argumentů odkazem jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="32746-113">Passing arguments by readonly reference</span></span>

<span data-ttu-id="32746-114">C# 7.2 přidá `in` – klíčové slovo k doplnění stávající `ref` a `out` klíčových slov pro předání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="32746-114">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="32746-115">`in` – Klíčové slovo určuje předání argumentu podle odkazu, ale volaná metoda neupravuje hodnotu.</span><span class="sxs-lookup"><span data-stu-id="32746-115">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="32746-116">Toto přidání poskytuje úplné slovníku pro vyjádření záměr vašeho návrhu.</span><span class="sxs-lookup"><span data-stu-id="32746-116">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="32746-117">Typy hodnot se zkopírují po uplynutí volané metody, pokud nezadáte žádné následující modifikátory v podpisu metody.</span><span class="sxs-lookup"><span data-stu-id="32746-117">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="32746-118">Každá z těchto modifikátorů Určuje, že typ hodnoty je předána odkazem, jak se vyhnout kopírování.</span><span class="sxs-lookup"><span data-stu-id="32746-118">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="32746-119">Každý modifikátor vyjadřuje různých záměr:</span><span class="sxs-lookup"><span data-stu-id="32746-119">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="32746-120">`out`: Tato metoda nastaví hodnotu argument použitý jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="32746-120">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="32746-121">`ref`: Tato metoda může nastavit hodnotu argument použitý jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="32746-121">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="32746-122">`in`: Tato metoda neupravuje hodnotu argument použitý jako tento parametr.</span><span class="sxs-lookup"><span data-stu-id="32746-122">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="32746-123">Přidat `in` modifikátor předat argument odkazem a deklarovat vaším záměrem návrhu předání argumentů odkazem, aby předešel zbytečnému kopírování.</span><span class="sxs-lookup"><span data-stu-id="32746-123">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="32746-124">Nechcete změnit objekt použitý jako tento argument.</span><span class="sxs-lookup"><span data-stu-id="32746-124">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="32746-125">Následující kód ukazuje příklad metodu, která vypočítá vzdálenost mezi dvěma body v 3D prostoru.</span><span class="sxs-lookup"><span data-stu-id="32746-125">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="32746-126">Argumenty jsou dvě struktury, že každý obsahuje tří hodnot datového typu Double.</span><span class="sxs-lookup"><span data-stu-id="32746-126">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="32746-127">Double je 8 bajtů, takže každý argument je 24 bajtů.</span><span class="sxs-lookup"><span data-stu-id="32746-127">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="32746-128">Zadáním `in` modifikátor, předáte odkaz bajt 4 nebo 8 bajtů na tyto argumenty, v závislosti na architektuře počítače.</span><span class="sxs-lookup"><span data-stu-id="32746-128">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="32746-129">Rozdíl velikosti je malý, ale ji můžete rychle přidat po aplikace volá tuto metodu v těsné smyčce pomocí mnoha různých hodnot.</span><span class="sxs-lookup"><span data-stu-id="32746-129">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="32746-130">`in` Modifikační komplementy `out` a `ref` i jinými způsoby.</span><span class="sxs-lookup"><span data-stu-id="32746-130">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="32746-131">Nelze vytvořit přetížení metody, která se liší pouze v nichž se nachází z `in`, `out`, nebo `ref`.</span><span class="sxs-lookup"><span data-stu-id="32746-131">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="32746-132">Tato nová pravidla rozšíření stejné chování, která měla vždy definována pro `out` a `ref` parametry.</span><span class="sxs-lookup"><span data-stu-id="32746-132">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="32746-133">`in` Modifikátor se můžou vztahovat k libovolnému členovi, která přebírá parametry: metody, delegáti, lambda výrazy, místní funkce, indexery, operátory.</span><span class="sxs-lookup"><span data-stu-id="32746-133">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="32746-134">Na rozdíl od `ref` a `out` argumenty, můžete použít hodnoty literálu nebo konstanty pro argument `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="32746-134">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="32746-135">Navíc na rozdíl od `ref` nebo `out` parametr, není nutné použít `in` modifikátor na lokalitu volání.</span><span class="sxs-lookup"><span data-stu-id="32746-135">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="32746-136">Následující kód ukazuje, dva příklady volání `CalculateDistance` metody.</span><span class="sxs-lookup"><span data-stu-id="32746-136">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="32746-137">První způsob využívá dvě místní proměnné, které jsou předány podle odkazu.</span><span class="sxs-lookup"><span data-stu-id="32746-137">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="32746-138">Druhá zahrnuje dočasnou proměnnou vytvořených jako součást volání metody.</span><span class="sxs-lookup"><span data-stu-id="32746-138">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="32746-139">Existuje několik způsobů, ve kterých kompilátor pak zajistí, které povahy jen pro čtení `in` argument bude vynucovat.</span><span class="sxs-lookup"><span data-stu-id="32746-139">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="32746-140">Za prvé, volané metody nejde přiřadit přímo `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="32746-140">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="32746-141">Nelze přiřadit přímo z některého z polí `in` parametr, když je tato hodnota `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="32746-141">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="32746-142">Kromě toho nelze předat `in` parametr pomocí libovolné metody `ref` nebo `out` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="32746-142">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="32746-143">Tato pravidla platí pro všechny oblasti `in` pole je zadán parametr, `struct` typ a parametrem je také `struct` typu.</span><span class="sxs-lookup"><span data-stu-id="32746-143">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="32746-144">Ve skutečnosti, tato pravidla platí pro několik úrovní přístupu ke členu poskytuje, jsou tyto typy na všech úrovních přístupu ke členu `structs`.</span><span class="sxs-lookup"><span data-stu-id="32746-144">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="32746-145">Vynucuje kompilátor `struct` typů předané jako `in` argumenty a jejich `struct` členy jsou jen pro čtení proměnné, když se použije jako argumentů jiným metodám.</span><span class="sxs-lookup"><span data-stu-id="32746-145">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="32746-146">Použití `in` parametry se vyhnete potenciální výkon náklady na vytváření kopií.</span><span class="sxs-lookup"><span data-stu-id="32746-146">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="32746-147">Sémantika jakékoli volání metody nezmění.</span><span class="sxs-lookup"><span data-stu-id="32746-147">It does not change the semantics of any method call.</span></span> <span data-ttu-id="32746-148">Proto není potřeba zadat `in` modifikátor na lokalitu volání.</span><span class="sxs-lookup"><span data-stu-id="32746-148">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="32746-149">Ale vynechá `in` modifikátor na lokalitu volání informuje kompilátor, že ji může vytvořit kopii argumentu z následujících důvodů:</span><span class="sxs-lookup"><span data-stu-id="32746-149">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="32746-150">Je implicitní převod, ale není identity konverzi z typu argumentu na typ parametru.</span><span class="sxs-lookup"><span data-stu-id="32746-150">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="32746-151">Argument je výraz, ale nemá žádné známé úložiště proměnné.</span><span class="sxs-lookup"><span data-stu-id="32746-151">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="32746-152">Existuje přetížení, která se liší podle přítomnosti nebo nepřítomnosti `in`.</span><span class="sxs-lookup"><span data-stu-id="32746-152">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="32746-153">V takovém případě hodnota přetížení představuje lepší shodu.</span><span class="sxs-lookup"><span data-stu-id="32746-153">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="32746-154">Tato pravidla jsou užitečné, když aktualizujete existující kód, jak používat argumenty odkazu pouze pro čtení.</span><span class="sxs-lookup"><span data-stu-id="32746-154">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="32746-155">Uvnitř volané metody lze volat jakékoli metody instance, která používá parametry s hodnotou.</span><span class="sxs-lookup"><span data-stu-id="32746-155">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="32746-156">V těchto případech kopii `in` parametr se vytvoří.</span><span class="sxs-lookup"><span data-stu-id="32746-156">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="32746-157">Protože kompilátor může vytvořit dočasnou proměnnou pro všechny `in` parametr, můžete také určit výchozí hodnoty pro všechny `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="32746-157">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="32746-158">Následující kód určuje jako výchozí hodnotu pro druhý bod počátku (bod 0; 0):</span><span class="sxs-lookup"><span data-stu-id="32746-158">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="32746-159">Chcete-li vynutit, aby kompilátor mohl předat další argumenty pouze podle odkazu, zadejte `in` modifikačních na argumenty při volání webu, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="32746-159">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="32746-160">Toto chování je snazší přijmout `in` parametry v čase ve velkých základů kódu, kde je možné zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="32746-160">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="32746-161">Přidáte `in` modifikátor podpisy metod první.</span><span class="sxs-lookup"><span data-stu-id="32746-161">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="32746-162">Potom můžete přidat `in` modifikátor na callsites a vytvořit `readonly struct` typy umožňující vyhnout se vytváření obranná kopie kompilátor `in` parametry na více místech.</span><span class="sxs-lookup"><span data-stu-id="32746-162">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="32746-163">`in` Parametr označení lze také s typy odkazů nebo číselné hodnoty.</span><span class="sxs-lookup"><span data-stu-id="32746-163">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="32746-164">Ale v obou případech je minimální, pokud existuje.</span><span class="sxs-lookup"><span data-stu-id="32746-164">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="32746-165">`ref readonly` Vrátí</span><span class="sxs-lookup"><span data-stu-id="32746-165">`ref readonly` returns</span></span>

<span data-ttu-id="32746-166">Můžete také vrátit odkazem, typ hodnoty, ale zakázat volající v upravování této hodnoty.</span><span class="sxs-lookup"><span data-stu-id="32746-166">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="32746-167">Použití `ref readonly` modifikátor vyjádřit záměr tohoto návrhu.</span><span class="sxs-lookup"><span data-stu-id="32746-167">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="32746-168">Čtenáři upozorní, že se vrací odkazem na existující data, ale neumožňuje úpravy.</span><span class="sxs-lookup"><span data-stu-id="32746-168">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="32746-169">Kompilátor vynucuje, volající nemůžete měnit odkaz.</span><span class="sxs-lookup"><span data-stu-id="32746-169">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="32746-170">Se pokusí přiřadit hodnotu přímo generovat chybu v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="32746-170">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="32746-171">Kompilátor však nemůže vědět, pokud libovolné metody člen změní stav struktury.</span><span class="sxs-lookup"><span data-stu-id="32746-171">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="32746-172">Aby bylo zajištěno, že objekt není upraven, kompilátor vytvoří kopii a volá člen odkazů pomocí nástroje tuto kopii.</span><span class="sxs-lookup"><span data-stu-id="32746-172">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="32746-173">Všechny změny se do tohoto obranná kopie.</span><span class="sxs-lookup"><span data-stu-id="32746-173">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="32746-174">Je pravděpodobné, který pomocí knihovny `Point3D` by často používají původu v kódu.</span><span class="sxs-lookup"><span data-stu-id="32746-174">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="32746-175">Každá instance vytvoří nový objekt v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="32746-175">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="32746-176">Může být výhodné vytvořit konstantu a vrátit odkazem.</span><span class="sxs-lookup"><span data-stu-id="32746-176">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="32746-177">Ale pokud vrátíte odkaz na interní úložiště, můžete vynutit, aby volající nelze upravit odkazované úložiště.</span><span class="sxs-lookup"><span data-stu-id="32746-177">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="32746-178">Následující kód definuje vlastnost jen pro čtení, která vrací `readonly ref` k `Point3D` , který určuje původ.</span><span class="sxs-lookup"><span data-stu-id="32746-178">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="32746-179">Vytvoření kopie jen pro čtení ref návratový je jednoduché: stačí ji přiřadit proměnná není deklarovaná pomocí `ref readonly` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="32746-179">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="32746-180">Kompilátor generuje kód má objekt kopírovat jako součást tohoto přiřazení.</span><span class="sxs-lookup"><span data-stu-id="32746-180">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="32746-181">Když přiřadíte proměnnou, která `ref readonly return`, můžete zadat buď `ref readonly` proměnnou nebo podle hodnoty kopie odkazu pouze pro čtení:</span><span class="sxs-lookup"><span data-stu-id="32746-181">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="32746-182">První přiřazení v předchozím kódu vytvoří kopii `Origin` konstantě a přiřadí, které kopírují.</span><span class="sxs-lookup"><span data-stu-id="32746-182">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="32746-183">Druhá přiřadí odkaz.</span><span class="sxs-lookup"><span data-stu-id="32746-183">The second assigns a reference.</span></span> <span data-ttu-id="32746-184">Všimněte si, že `readonly` modifikátor musí být součástí deklarace proměnné.</span><span class="sxs-lookup"><span data-stu-id="32746-184">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="32746-185">Odkaz, na který odkazuje, nemůže být upraven.</span><span class="sxs-lookup"><span data-stu-id="32746-185">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="32746-186">O to mít za následek chybu v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="32746-186">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="32746-187">`readonly struct` Typ</span><span class="sxs-lookup"><span data-stu-id="32746-187">`readonly struct` type</span></span>

<span data-ttu-id="32746-188">Použití `ref readonly` vysokým provozem používá struktury mohou být dostatečné.</span><span class="sxs-lookup"><span data-stu-id="32746-188">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="32746-189">Jindy, můžete vytvořit neměnné struktury.</span><span class="sxs-lookup"><span data-stu-id="32746-189">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="32746-190">Potom můžete vždy předat odkazem. jenom pro čtení.</span><span class="sxs-lookup"><span data-stu-id="32746-190">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="32746-191">Které se provádějí, že postup odebere obranné zkopíruje, při přístupu k metody struktury použít jako `in` parametru.</span><span class="sxs-lookup"><span data-stu-id="32746-191">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="32746-192">Můžete to udělat tak, že vytvoříte `readonly struct` typu.</span><span class="sxs-lookup"><span data-stu-id="32746-192">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="32746-193">Můžete přidat `readonly` Modifikátor pro deklaraci struktury.</span><span class="sxs-lookup"><span data-stu-id="32746-193">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="32746-194">Kompilátor vynucuje, aby všichni členové instance struktury jsou `readonly`; `struct` musí být neměnitelný.</span><span class="sxs-lookup"><span data-stu-id="32746-194">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="32746-195">Další optimalizace `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="32746-195">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="32746-196">Můžete použít `in` modifikátor na jakémkoliv místě kde `readonly struct` je argumentem.</span><span class="sxs-lookup"><span data-stu-id="32746-196">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="32746-197">Kromě toho se můžete vrátit `readonly struct` jako `ref return` jsou při vrácení objektu, jehož doba života sahá nad rámec metoda vrací objekt.</span><span class="sxs-lookup"><span data-stu-id="32746-197">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="32746-198">A konečně, kompilátor vygeneruje kód efektivnější při volání členy `readonly struct`: `this` odkaz, namísto kopírování příjemce, je vždy `in` parametr předaný odkazem na metodu member.</span><span class="sxs-lookup"><span data-stu-id="32746-198">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="32746-199">Tato optimalizace uloží další kopírování při použití `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="32746-199">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="32746-200">`Point3D` Je vynikající kandidát pro tuto změnu.</span><span class="sxs-lookup"><span data-stu-id="32746-200">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="32746-201">Následující kód ukazuje aktualizovanou `ReadonlyPoint3D` struktury:</span><span class="sxs-lookup"><span data-stu-id="32746-201">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="32746-202">`ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="32746-202">`ref struct` type</span></span>

<span data-ttu-id="32746-203">Další související jazyk funkcí je schopnost deklarovat typ hodnoty, které musí být přiděleny.</span><span class="sxs-lookup"><span data-stu-id="32746-203">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="32746-204">Jinými slovy tyto typy může nikdy být vytvořen na haldě jako člena jiné třídy.</span><span class="sxs-lookup"><span data-stu-id="32746-204">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="32746-205">Byl primární motivace pro tuto funkci <xref:System.Span%601> a související struktury.</span><span class="sxs-lookup"><span data-stu-id="32746-205">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="32746-206"><xref:System.Span%601> může obsahovat spravovaného ukazatele jako jeden z jejích členů, druhá je délka značky span.</span><span class="sxs-lookup"><span data-stu-id="32746-206"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="32746-207">Je implementován trochu jinak než C# nepodporuje odkazy na spravované paměti mimo nezabezpečený kontext.</span><span class="sxs-lookup"><span data-stu-id="32746-207">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="32746-208">Žádné zápisu, která se mění ukazatele a délka není atomické.</span><span class="sxs-lookup"><span data-stu-id="32746-208">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="32746-209">To znamená, že <xref:System.Span%601> by podléhají mimo rozsah chyby nebo jiné porušení bezpečnosti typu byly, není omezen na blok zásobníku jeden.</span><span class="sxs-lookup"><span data-stu-id="32746-209">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="32746-210">Kromě toho uvedení spravovaného ukazatele na haldě uvolňování paměti obvykle dojde k chybě během JIT.</span><span class="sxs-lookup"><span data-stu-id="32746-210">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="32746-211">Máte podobné požadavky na práci s pamětí, které jsou vytvořené pomocí [ `stackalloc` ](language-reference/keywords/stackalloc.md) nebo při použití paměti z vzájemné spolupráce rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="32746-211">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="32746-212">Můžete definovat vlastní `ref struct` typy pro tyto potřeby.</span><span class="sxs-lookup"><span data-stu-id="32746-212">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="32746-213">V tomto článku vidíte příklad použití `Span<T>` pro zjednodušení.</span><span class="sxs-lookup"><span data-stu-id="32746-213">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="32746-214">`ref struct` Deklarace deklaruje strukturu tohoto typu musí být v zásobníku.</span><span class="sxs-lookup"><span data-stu-id="32746-214">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="32746-215">Jazyk pravidla zajistit bezpečné používání těchto typů.</span><span class="sxs-lookup"><span data-stu-id="32746-215">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="32746-216">Jiné typy deklarované jako `ref struct` zahrnují <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="32746-216">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="32746-217">Cílem vedení `ref struct` zadejte jako proměnnou přidělený na zásobník zavádí několik pravidel, které kompilátor vynucuje pro všechny `ref struct` typy.</span><span class="sxs-lookup"><span data-stu-id="32746-217">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="32746-218">Nelze pole `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="32746-218">You can't box a `ref struct`.</span></span> <span data-ttu-id="32746-219">Nelze přiřadit `ref struct` typ proměnné typu `object`, `dynamic`, nebo libovolný typ rozhraní.</span><span class="sxs-lookup"><span data-stu-id="32746-219">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="32746-220">Nelze deklarovat `ref struct` jako člen třídy nebo struktury normální.</span><span class="sxs-lookup"><span data-stu-id="32746-220">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="32746-221">Nelze deklarovat lokální proměnné, které jsou `ref struct` typy v asynchronních metodách.</span><span class="sxs-lookup"><span data-stu-id="32746-221">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="32746-222">Můžete je deklarovat v synchronní metody, které vracejí `Task`, `Task<T>` nebo typy podobné úlohám.</span><span class="sxs-lookup"><span data-stu-id="32746-222">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="32746-223">Nelze deklarovat `ref struct` lokální proměnné iterátory.</span><span class="sxs-lookup"><span data-stu-id="32746-223">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="32746-224">Nelze zachytit `ref struct` proměnné ve výrazech lambda nebo místní funkce.</span><span class="sxs-lookup"><span data-stu-id="32746-224">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="32746-225">Tato omezení zajistit nepoužijete omylem `ref struct` způsobem, který může převést na spravované haldě.</span><span class="sxs-lookup"><span data-stu-id="32746-225">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="32746-226">`readonly ref struct` Typ</span><span class="sxs-lookup"><span data-stu-id="32746-226">`readonly ref struct` type</span></span>

<span data-ttu-id="32746-227">Deklarace struktury jako `readonly ref` kombinuje výhody a omezení `ref struct` a `readonly struct` deklarace.</span><span class="sxs-lookup"><span data-stu-id="32746-227">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> 

<span data-ttu-id="32746-228">Následující příklad ukazuje deklaraci `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="32746-228">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="32746-229">Závěry</span><span class="sxs-lookup"><span data-stu-id="32746-229">Conclusions</span></span>

<span data-ttu-id="32746-230">Tato vylepšení pro jazyk C# jsou navržené pro kritické algoritmy výkonu kde přidělení paměti může být nezbytné k dosažení nezbytné výkonu.</span><span class="sxs-lookup"><span data-stu-id="32746-230">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="32746-231">Může se stát, že není často používají tyto funkce v kódu, který píšete.</span><span class="sxs-lookup"><span data-stu-id="32746-231">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="32746-232">Tato vylepšení však byly přijaty v mnoha umístěních v rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="32746-232">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="32746-233">Provádění více rozhraní API z těchto funkcí používat, zobrazí se výkon vašich vlastních aplikací vylepšit.</span><span class="sxs-lookup"><span data-stu-id="32746-233">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
