---
title: Vztah mezi funkce jazyka a typy knihovny | Microsoft Docs
description: Jazykové funkce často spoléhají na knihovny typů pro implementaci. Pochopení relace.
ms.date: 07/20/2017
ms.openlocfilehash: dfae7972af0a251a92700d7d33bd6f971eb1870e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33360080"
---
# <a name="relationships-between-language-features-and-library-types"></a><span data-ttu-id="b321a-104">Vztahy mezi funkce jazyka a knihovny typů</span><span class="sxs-lookup"><span data-stu-id="b321a-104">Relationships between language features and library types</span></span>

<span data-ttu-id="b321a-105">Definice jazyka C# vyžaduje standardní knihovnu, kterou chcete mít určité typy a členy určité dostupné v těchto typů.</span><span class="sxs-lookup"><span data-stu-id="b321a-105">The C# language definition requires a standard library to have certain types and certain accessible members on those types.</span></span> <span data-ttu-id="b321a-106">Kompilátor generuje kód, který používá tyto požadované typy a členy mnoha funkcí v jiném jazyce.</span><span class="sxs-lookup"><span data-stu-id="b321a-106">The compiler generates code that uses these required types and members for many different language features.</span></span> <span data-ttu-id="b321a-107">Pokud je to nezbytné, existují balíčky NuGet, které obsahují typy třeba novější verze jazyka při psaní kódu v prostředích, kde tyto typy nebo členy nebyly nasazeny ještě.</span><span class="sxs-lookup"><span data-stu-id="b321a-107">When necessary, there are NuGet packages that contain types needed for newer versions of the language when writing code for environments where those types or members have not been deployed yet.</span></span>

<span data-ttu-id="b321a-108">Tuto závislost na funkce standardní knihovny byl součástí jazyka C# od jeho první verzi.</span><span class="sxs-lookup"><span data-stu-id="b321a-108">This dependency on standard library functionality has been part of the C# language since its first version.</span></span> <span data-ttu-id="b321a-109">V této verzi zahrnuté příklady:</span><span class="sxs-lookup"><span data-stu-id="b321a-109">In that version, examples included:</span></span>

* <span data-ttu-id="b321a-110"><xref:System.Exception> -použít pro všechny výjimky kompilátoru vygenerovat.</span><span class="sxs-lookup"><span data-stu-id="b321a-110"><xref:System.Exception> - used for all compiler generated exceptions.</span></span>
* <span data-ttu-id="b321a-111"><xref:System.String> -C# `string` typ se jedná o synonymum <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="b321a-111"><xref:System.String> - the C# `string` type is a synonym for <xref:System.String>.</span></span>
* <span data-ttu-id="b321a-112"><xref:System.Int32> -synonymum z `int`.</span><span class="sxs-lookup"><span data-stu-id="b321a-112"><xref:System.Int32> - synonym of `int`.</span></span>

<span data-ttu-id="b321a-113">Tento první verze je jednoduchý: standardní knihovna a kompilátor dodané společně a došlo jenom jedna verze jednotlivých.</span><span class="sxs-lookup"><span data-stu-id="b321a-113">That first version was simple: the compiler and the standard library shipped together, and there was only one version of each.</span></span>

<span data-ttu-id="b321a-114">Další verze jazyka C# příležitostně přidali nové typy nebo členy pro závislosti.</span><span class="sxs-lookup"><span data-stu-id="b321a-114">Subsequent versions of C# have occasionally added new types or members to the dependencies.</span></span> <span data-ttu-id="b321a-115">Příklady: <xref:System.Runtime.CompilerServices.INotifyCompletion>, <xref:System.Runtime.CompilerServices.CallerFilePathAttribute> a <xref:System.Runtime.CompilerServices.CallerMemberNameAttribute>.</span><span class="sxs-lookup"><span data-stu-id="b321a-115">Examples include: <xref:System.Runtime.CompilerServices.INotifyCompletion>, <xref:System.Runtime.CompilerServices.CallerFilePathAttribute> and <xref:System.Runtime.CompilerServices.CallerMemberNameAttribute>.</span></span> <span data-ttu-id="b321a-116">C# 7.0 pokračuje to přidáním závislost na <xref:System.ValueTuple> implementovat [řazených kolekcí členů](../tuples.md) funkce jazyka.</span><span class="sxs-lookup"><span data-stu-id="b321a-116">C# 7.0 continues this by adding a dependency on <xref:System.ValueTuple> to implement the [tuples](../tuples.md) language feature.</span></span>

<span data-ttu-id="b321a-117">Tým návrhu jazyk pracuje na minimalizujte možnosti útoku typů a členů vyžaduje kompatibilní standardní knihovny.</span><span class="sxs-lookup"><span data-stu-id="b321a-117">The language design team works to minimize the surface area of the types and members required in a compliant standard library.</span></span> <span data-ttu-id="b321a-118">Tento cíl je porovnán s čistou návrhu, kde nových funkcí knihovny jsou bezproblémově součástí jazyk.</span><span class="sxs-lookup"><span data-stu-id="b321a-118">That goal is balanced against a clean design where new library features are incorporated seamlessly into the language.</span></span> <span data-ttu-id="b321a-119">Bude mít nové funkce v budoucích verzích systému C#, které vyžadují nové typy a členy ve standardní knihovně.</span><span class="sxs-lookup"><span data-stu-id="b321a-119">There will be new features in future versions of C# that require new types and members in a standard library.</span></span> <span data-ttu-id="b321a-120">Je důležité pochopit, jak ke správě těchto závislostí v práci.</span><span class="sxs-lookup"><span data-stu-id="b321a-120">It's important to understand how to manage those dependencies in your work.</span></span>

## <a name="managing-your-dependencies"></a><span data-ttu-id="b321a-121">Správa závislostmi</span><span class="sxs-lookup"><span data-stu-id="b321a-121">Managing your dependencies</span></span>

<span data-ttu-id="b321a-122">Nástroje pro kompilátor jazyka C# jsou nyní odpojené od vydání cyklus na knihovny .NET na podporovaných platformách.</span><span class="sxs-lookup"><span data-stu-id="b321a-122">C# compiler tools are now decoupled from the release cycle of the .NET libraries on supported platforms.</span></span> <span data-ttu-id="b321a-123">Ve skutečnosti různé knihovny .NET mít jinou verzi cykly: rozhraní .NET Framework v systému Windows je vydané jako Windows Update, .NET Core dodávky samostatné plán a Xamarin verzích lodě aktualizace knihovny nástroje Xamarin pro každou cílovou platformu.</span><span class="sxs-lookup"><span data-stu-id="b321a-123">In fact, different .NET libraries have different release cycles: the .NET Framework on Windows is released as a Windows Update, .NET Core ships on a separate schedule, and the Xamarin versions of library updates ship with the Xamarin tools for each target platform.</span></span>

<span data-ttu-id="b321a-124">Většinu doby, nebude zjistíte, tyto změny.</span><span class="sxs-lookup"><span data-stu-id="b321a-124">The majority of time, you won't notice these changes.</span></span> <span data-ttu-id="b321a-125">Při práci s novější verzí jazyka, který vyžaduje funkce není ještě v na knihovny .NET na této platformě, ale budete odkazovat balíčky NuGet k poskytování těchto nových typů.</span><span class="sxs-lookup"><span data-stu-id="b321a-125">However, when you are working with a newer version of the language that requires features not yet in the .NET libraries on that platform, you'll reference the NuGet packages to provide those new types.</span></span>
<span data-ttu-id="b321a-126">Jako platforem, vaše aplikace podporuje jsou aktualizované o nové instalace framework můžete odebrat odkaz na další.</span><span class="sxs-lookup"><span data-stu-id="b321a-126">As the platforms your app supports are updated with new framework installations, you can remove the extra reference.</span></span>

<span data-ttu-id="b321a-127">Toto rozdělení znamená, že můžete použít nové jazykové funkce i v případě, že volíte počítače, které nemusí mít odpovídající framework.</span><span class="sxs-lookup"><span data-stu-id="b321a-127">This separation means you can use new language features even when you are targeting machines that may not have the corresponding framework.</span></span>
