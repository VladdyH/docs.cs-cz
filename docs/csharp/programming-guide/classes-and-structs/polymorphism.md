---
title: Polymorfismus (Průvodce programováním v C#)
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 8bbf93d14a16b06441ba48b9d4e19cfd249e9146
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33328442"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="2caf7-102">Polymorfismus (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="2caf7-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="2caf7-103">Polymorfismus se často označuje jako třetím pilíře objektově orientované programování po zapouzdření a dědičnost.</span><span class="sxs-lookup"><span data-stu-id="2caf7-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="2caf7-104">Polymorfismus je řecké slovo, které znamená "mnoho ve tvaru" a má dva jedinečné aspekty:</span><span class="sxs-lookup"><span data-stu-id="2caf7-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
-   <span data-ttu-id="2caf7-105">V době běhu objekty odvozené třídy mohou být považovány za objekty základní třídy na místech, jako je například parametry metody a kolekce nebo pole.</span><span class="sxs-lookup"><span data-stu-id="2caf7-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="2caf7-106">V takovém případě deklarovaného typu objektu již není stejný jako její typ spuštění.</span><span class="sxs-lookup"><span data-stu-id="2caf7-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
-   <span data-ttu-id="2caf7-107">Třídy Base může definovat a implementovat [virtuální](../../../csharp/language-reference/keywords/virtual.md) *metody*, a odvozené třídy mohou [přepsat](../../../csharp/language-reference/keywords/override.md) sebou, což znamená, poskytují vlastní definice a implementace.</span><span class="sxs-lookup"><span data-stu-id="2caf7-107">Base classes may define and implement [virtual](../../../csharp/language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../../csharp/language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="2caf7-108">Při spuštění když kód klienta volá metodu, modulu CLR běhového typu objektu, a, vyvolá tento přepsání virtuální metody.</span><span class="sxs-lookup"><span data-stu-id="2caf7-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="2caf7-109">Proto ve zdrojovém kódu můžete volat metodu pro základní třídu a způsobit, že do odvozené třídy verzi metody spouštění.</span><span class="sxs-lookup"><span data-stu-id="2caf7-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="2caf7-110">Virtuální metody umožňují pracovat s skupiny související objekty jednotným způsobem.</span><span class="sxs-lookup"><span data-stu-id="2caf7-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="2caf7-111">Předpokládejme například, že máte kreslení aplikaci, která umožňuje uživateli vytvořit různé druhy tvarů na kreslicí plochy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="2caf7-112">Neznáte v době kompilace jaké konkrétní typy tvarů uživatel vytvoří.</span><span class="sxs-lookup"><span data-stu-id="2caf7-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="2caf7-113">Ale aplikace má ke sledování všech různé typy tvarů, které jsou vytvořené a má je aktualizovat v odpovědi na akce myši uživatele.</span><span class="sxs-lookup"><span data-stu-id="2caf7-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="2caf7-114">Polymorfismus můžete použít k vyřešení tohoto problému v dva základní kroky:</span><span class="sxs-lookup"><span data-stu-id="2caf7-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1.  <span data-ttu-id="2caf7-115">Vytvořte hierarchie tříd, ve kterém každá třída konkrétní tvaru odvozená z obecná základní třída.</span><span class="sxs-lookup"><span data-stu-id="2caf7-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2.  <span data-ttu-id="2caf7-116">Použijte virtuální metoda k vyvolání metody odpovídající na všechny odvozené třídy prostřednictvím jednoho volání metody základní třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="2caf7-117">Nejprve vytvořte základní třídu s názvem `Shape`a jsou odvozené třídy, jako `Rectangle`, `Circle`, a `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="2caf7-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="2caf7-118">Poskytnout `Shape` třídy virtuální metodu s názvem `Draw`, a představuje přepsání, v každém odvozené třídy za účelem kreslení konkrétní utvářejí třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="2caf7-119">Vytvoření `List<Shape>` objektu a přidejte do ní kruh, trojúhelníček a rámečku.</span><span class="sxs-lookup"><span data-stu-id="2caf7-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="2caf7-120">Chcete-li aktualizovat kreslicí plochy, použijte [foreach](../../../csharp/language-reference/keywords/foreach-in.md) smyčky k iteraci v rámci seznamu a volání `Draw` metoda na každém `Shape` objektu v seznamu.</span><span class="sxs-lookup"><span data-stu-id="2caf7-120">To update the drawing surface, use a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="2caf7-121">I když každý objekt v seznamu má deklarovaný typ `Shape`, je běhového typu (přepsané verze metodu každý odvozené třídy), která bude volána.</span><span class="sxs-lookup"><span data-stu-id="2caf7-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#50](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_1.cs)]  
  
 <span data-ttu-id="2caf7-122">V jazyce C#, každý typ je polymorfní, protože dědí všechny typy, včetně uživatelem definované typy <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="2caf7-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="2caf7-123">Polymorfismus – přehled</span><span class="sxs-lookup"><span data-stu-id="2caf7-123">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="2caf7-124">Virtuální členové</span><span class="sxs-lookup"><span data-stu-id="2caf7-124">Virtual Members</span></span>  
 <span data-ttu-id="2caf7-125">Když do odvozené třídy dědí vlastnosti ze základní třídy, získá všechny metody, pole, vlastnosti a události základní třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-125">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="2caf7-126">Můžete zvolit návrháře odvozené třídy, jestli se má</span><span class="sxs-lookup"><span data-stu-id="2caf7-126">The designer of the derived class can choose whether to</span></span>  
  
-   <span data-ttu-id="2caf7-127">přepsat virtuální členy v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="2caf7-127">override virtual members in the base class,</span></span>  
  
-   <span data-ttu-id="2caf7-128">Zdědit nejbližší metoda základní třídy bez jeho přepsání</span><span class="sxs-lookup"><span data-stu-id="2caf7-128">inherit the closest base class method without overriding it</span></span>  
  
-   <span data-ttu-id="2caf7-129">Definujte nové nevirtuálních implementace členů, které skrýt implementace třídy base</span><span class="sxs-lookup"><span data-stu-id="2caf7-129">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="2caf7-130">Odvozené třídy můžete přepsat člena základní třídy, pouze v případě, že je člen základní třídy je deklarován jako [virtuální](../../../csharp/language-reference/keywords/virtual.md) nebo [abstraktní](../../../csharp/language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="2caf7-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../../csharp/language-reference/keywords/virtual.md) or [abstract](../../../csharp/language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="2caf7-131">Odvozené člen musí používat [přepsat](../../../csharp/language-reference/keywords/override.md) – klíčové slovo explicitně indikující, že metoda je určena k účasti v virtuální volání.</span><span class="sxs-lookup"><span data-stu-id="2caf7-131">The derived member must use the [override](../../../csharp/language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="2caf7-132">Následující kód představuje příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-132">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_2.cs)]  
  
 <span data-ttu-id="2caf7-133">Pole nemůže být virtuální; pouze metody, vlastnosti, události a indexery může být virtuální.</span><span class="sxs-lookup"><span data-stu-id="2caf7-133">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="2caf7-134">Tento člen odvozené třídě přepsání člena virtuální, se nazývá i v případě, že instance této třídy je přistupuje jako instance základní třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="2caf7-135">Následující kód představuje příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-135">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_3.cs)]  
  
 <span data-ttu-id="2caf7-136">Virtuální metody a vlastnosti, povolte odvozené třídy rozšíření základní třídy bez nutnosti použít implementace základní třídy metody.</span><span class="sxs-lookup"><span data-stu-id="2caf7-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="2caf7-137">Další informace najdete v tématu [Správa verzí pomocí nové klíčových slov Override a](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="2caf7-137">For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="2caf7-138">Rozhraní poskytuje jiný způsob, jak definovat metody nebo sadu metod, jejichž implementace je ponechán do odvozených tříd.</span><span class="sxs-lookup"><span data-stu-id="2caf7-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="2caf7-139">Další informace najdete v tématu [rozhraní](../../../csharp/programming-guide/interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="2caf7-139">For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="2caf7-140">Skrytí členy základní třídy se nové členy</span><span class="sxs-lookup"><span data-stu-id="2caf7-140">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="2caf7-141">Pokud chcete, aby vaše odvozené člena do mají stejný název jako člen v základní třídě, ale nechcete, aby mohla účastnit virtuální volání, můžete použít [nové](../../../csharp/language-reference/keywords/new.md) – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="2caf7-141">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../../csharp/language-reference/keywords/new.md) keyword.</span></span> <span data-ttu-id="2caf7-142">`new` Je před návratový typ člena třídy, který se nahrazuje uveďte – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="2caf7-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="2caf7-143">Následující kód představuje příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-143">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_4.cs)]  
  
 <span data-ttu-id="2caf7-144">Členy skrytá základní třídy můžete dál dostat z kódu klienta podle přetypování instanci odvozené třídy do instance základní třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-144">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="2caf7-145">Příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-145">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_5.cs)]  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="2caf7-146">Odvozené třídy brání přepisování virtuální členové</span><span class="sxs-lookup"><span data-stu-id="2caf7-146">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="2caf7-147">Virtuální členové zůstat virtuální dobu neurčitou, bez ohledu na tom, kolik třídy byli deklarováni mezi člena virtuální a třídu, která ho původně deklarovány.</span><span class="sxs-lookup"><span data-stu-id="2caf7-147">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="2caf7-148">Pokud třídy A deklaruje člena virtuální třídy B je odvozena z A a b je odvozena třída C, třída C dědí člena virtuální a má možnost přepsat, bez ohledu na tom, jestli třídy B deklarovat přepsání pro tohoto člena.</span><span class="sxs-lookup"><span data-stu-id="2caf7-148">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="2caf7-149">Následující kód představuje příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-149">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_6.cs)]  
  
 <span data-ttu-id="2caf7-150">Odvozené třídy můžete zastavit virtuální dědičnost deklarováním přepsání jako [zapečetěné](../../../csharp/language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="2caf7-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../../csharp/language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="2caf7-151">To vyžaduje uvedení `sealed` – klíčové slovo před `override` – klíčové slovo v deklarace člena třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-151">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="2caf7-152">Následující kód představuje příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-152">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_7.cs)]  
  
 <span data-ttu-id="2caf7-153">V předchozím příkladu metoda `DoWork` již není virtuálních a všechny třídy odvozené od C. Je stále virtuální pro instance C, i když jsou přetypovat na typ nebo typ B A. zapečetěné metody lze nahradit odvozené třídy pomocí `new` – klíčové slovo, jak ukazuje následující příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_8.cs)]  
  
 <span data-ttu-id="2caf7-154">V takovém případě pokud `DoWork` je volána v D pomocí proměnné typu D, nové `DoWork` je volána.</span><span class="sxs-lookup"><span data-stu-id="2caf7-154">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="2caf7-155">Pokud proměnná typu C, B nebo A slouží k přístupu k instanci D, volání `DoWork` bude postupovat podle pravidla virtuální dědičnost, směrování těchto volání na implementaci `DoWork` u třídy C.</span><span class="sxs-lookup"><span data-stu-id="2caf7-155">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="2caf7-156">Přístup k virtuální členy základní třídy z odvozené třídy</span><span class="sxs-lookup"><span data-stu-id="2caf7-156">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="2caf7-157">Odvozené třídy, která má nahradit nebo přepsání metody nebo vlastnosti můžete pořád přístup k metody nebo vlastnosti na základní třídy pomocí base – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="2caf7-157">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the base keyword.</span></span> <span data-ttu-id="2caf7-158">Následující kód představuje příklad:</span><span class="sxs-lookup"><span data-stu-id="2caf7-158">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_9.cs)]  
  
 <span data-ttu-id="2caf7-159">Další informace najdete v tématu [základní](../../../csharp/language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="2caf7-159">For more information, see [base](../../../csharp/language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2caf7-160">Je doporučeno, použít virtuální členové `base` volat základní třída implementace tohoto člena v jejich vlastní implementaci.</span><span class="sxs-lookup"><span data-stu-id="2caf7-160">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="2caf7-161">Když necháte dojít umožňuje soustředit se na odvozené třídy základní třída chování implementace chování, které jsou specifické pro odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-161">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="2caf7-162">Pokud není volán implementaci základní třídy, je až odvozené třídy, aby jejich chování kompatibilní s chováním základní třídy.</span><span class="sxs-lookup"><span data-stu-id="2caf7-162">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="2caf7-163">V tomto oddílu</span><span class="sxs-lookup"><span data-stu-id="2caf7-163">In This Section</span></span>  
  
-   [<span data-ttu-id="2caf7-164">Správa verzí pomocí klíčových slov override a new</span><span class="sxs-lookup"><span data-stu-id="2caf7-164">Versioning with the Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="2caf7-165">Znalost, kdy použít klíčová slova override a new</span><span class="sxs-lookup"><span data-stu-id="2caf7-165">Knowing When to Use Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="2caf7-166">Postupy: Potlačení metody ToString</span><span class="sxs-lookup"><span data-stu-id="2caf7-166">How to: Override the ToString Method</span></span>](../../../csharp/programming-guide/classes-and-structs/how-to-override-the-tostring-method.md)  
  
## <a name="see-also"></a><span data-ttu-id="2caf7-167">Viz také</span><span class="sxs-lookup"><span data-stu-id="2caf7-167">See Also</span></span>  
 [<span data-ttu-id="2caf7-168">Průvodce programováním v jazyce C#</span><span class="sxs-lookup"><span data-stu-id="2caf7-168">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="2caf7-169">Průvodce programováním v jazyce C#</span><span class="sxs-lookup"><span data-stu-id="2caf7-169">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="2caf7-170">Dědičnost</span><span class="sxs-lookup"><span data-stu-id="2caf7-170">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)  
 [<span data-ttu-id="2caf7-171">Abstraktní a uzavřené třídy a jejich členové</span><span class="sxs-lookup"><span data-stu-id="2caf7-171">Abstract and Sealed Classes and Class Members</span></span>](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)  
 [<span data-ttu-id="2caf7-172">Metody</span><span class="sxs-lookup"><span data-stu-id="2caf7-172">Methods</span></span>](../../../csharp/programming-guide/classes-and-structs/methods.md)  
 [<span data-ttu-id="2caf7-173">Události</span><span class="sxs-lookup"><span data-stu-id="2caf7-173">Events</span></span>](../../../csharp/programming-guide/events/index.md)  
 [<span data-ttu-id="2caf7-174">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="2caf7-174">Properties</span></span>](../../../csharp/programming-guide/classes-and-structs/properties.md)  
 [<span data-ttu-id="2caf7-175">Indexery</span><span class="sxs-lookup"><span data-stu-id="2caf7-175">Indexers</span></span>](../../../csharp/programming-guide/indexers/index.md)  
 [<span data-ttu-id="2caf7-176">Typy</span><span class="sxs-lookup"><span data-stu-id="2caf7-176">Types</span></span>](../../../csharp/programming-guide/types/index.md)
