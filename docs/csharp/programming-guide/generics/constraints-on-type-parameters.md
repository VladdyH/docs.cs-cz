---
title: "Omezení parametrů typů (Průvodce programováním v C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f5382b0050b81ed3bb1a075a042bdc4034a3975d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/21/2017
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="dbda1-102">Omezení parametrů typů (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="dbda1-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="dbda1-103">Při definování obecné třídy, můžete použít omezení na typy typy, které kód klienta můžete použít pro argumenty typu při třídě.</span><span class="sxs-lookup"><span data-stu-id="dbda1-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="dbda1-104">Pokud kód klienta se pokusí vytvořit třídu pomocí typu, která není povolena omezení, výsledkem je chyba kompilace.</span><span class="sxs-lookup"><span data-stu-id="dbda1-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="dbda1-105">Tato omezení se nazývají omezení.</span><span class="sxs-lookup"><span data-stu-id="dbda1-105">These restrictions are called constraints.</span></span> <span data-ttu-id="dbda1-106">Omezení zadávají pomocí `where` kontextové klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="dbda1-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="dbda1-107">Následující tabulka uvádí šest typy omezení:</span><span class="sxs-lookup"><span data-stu-id="dbda1-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="dbda1-108">Omezení</span><span class="sxs-lookup"><span data-stu-id="dbda1-108">Constraint</span></span>|<span data-ttu-id="dbda1-109">Popis</span><span class="sxs-lookup"><span data-stu-id="dbda1-109">Description</span></span>|  
|----------------|-----------------|  
|<span data-ttu-id="dbda1-110">kde T: – struktura</span><span class="sxs-lookup"><span data-stu-id="dbda1-110">where T: struct</span></span>|<span data-ttu-id="dbda1-111">Argument typu musí být typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="dbda1-111">The type argument must be a value type.</span></span> <span data-ttu-id="dbda1-112">Některé hodnoty typ s výjimkou <xref:System.Nullable> lze zadat.</span><span class="sxs-lookup"><span data-stu-id="dbda1-112">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="dbda1-113">V tématu [pomocí typy s možnou hodnotou Null](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) Další informace.</span><span class="sxs-lookup"><span data-stu-id="dbda1-113">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|<span data-ttu-id="dbda1-114">kde T: – Třída</span><span class="sxs-lookup"><span data-stu-id="dbda1-114">where T : class</span></span>|<span data-ttu-id="dbda1-115">Argument typu musí být odkazového typu; To platí také pro třídu, rozhraní, delegát nebo typ pole.</span><span class="sxs-lookup"><span data-stu-id="dbda1-115">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|<span data-ttu-id="dbda1-116">kde T: new()</span><span class="sxs-lookup"><span data-stu-id="dbda1-116">where T : new()</span></span>|<span data-ttu-id="dbda1-117">Argument typu musí mít konstruktor public bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="dbda1-117">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="dbda1-118">Při použití spolu s jiná omezení `new()` omezení musí být uvedený jako poslední.</span><span class="sxs-lookup"><span data-stu-id="dbda1-118">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="dbda1-119">kde T: \<název základní třídy ></span><span class="sxs-lookup"><span data-stu-id="dbda1-119">where T : \<base class name></span></span>|<span data-ttu-id="dbda1-120">Argument typu musí být nebo odvozena od zadané základní třídy.</span><span class="sxs-lookup"><span data-stu-id="dbda1-120">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="dbda1-121">kde T: \<název rozhraní ></span><span class="sxs-lookup"><span data-stu-id="dbda1-121">where T : \<interface name></span></span>|<span data-ttu-id="dbda1-122">Argument typu musí být nebo implementovat rozhraní zadaný.</span><span class="sxs-lookup"><span data-stu-id="dbda1-122">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="dbda1-123">Je možné zadat více omezení rozhraní.</span><span class="sxs-lookup"><span data-stu-id="dbda1-123">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="dbda1-124">Omezení rozhraní může být také obecné.</span><span class="sxs-lookup"><span data-stu-id="dbda1-124">The constraining interface can also be generic.</span></span>|  
|<span data-ttu-id="dbda1-125">kde T: U</span><span class="sxs-lookup"><span data-stu-id="dbda1-125">where T : U</span></span>|<span data-ttu-id="dbda1-126">Argument typu zadaná pro T musí být nebo odvozena od argument zadaný pro U.</span><span class="sxs-lookup"><span data-stu-id="dbda1-126">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="dbda1-127">Proč používat omezení</span><span class="sxs-lookup"><span data-stu-id="dbda1-127">Why Use Constraints</span></span>  
 <span data-ttu-id="dbda1-128">Pokud chcete prozkoumat položky v seznamu obecné k určení, zda je platný a porovnejte je s některé jiné položky, musí mít kompilátor, některé zaručit, že operátor nebo metody, kterou musí volání bude podporovat některý argument typ, který může být určena co klienta Německo.</span><span class="sxs-lookup"><span data-stu-id="dbda1-128">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="dbda1-129">Tato záruka se získávají použitím jeden nebo více omezení na vaší definice – obecná třída.</span><span class="sxs-lookup"><span data-stu-id="dbda1-129">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="dbda1-130">Například omezení základní třídy říká kompilátoru, že pouze objekty tohoto typu nebo odvozené z tohoto typu se použije jako argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="dbda1-130">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="dbda1-131">Jakmile kompilátor tento záruka, můžete povolit metod k volání ve třídě obecného typu.</span><span class="sxs-lookup"><span data-stu-id="dbda1-131">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="dbda1-132">Omezení se aplikují pomocí kontextové klíčové slovo `where`.</span><span class="sxs-lookup"><span data-stu-id="dbda1-132">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="dbda1-133">Následující příklad kódu ukazuje funkci můžete přidáme `GenericList<T>` – třída (v [Úvod do obecných typů](../../../csharp/programming-guide/generics/introduction-to-generics.md)) použitím omezení základní třídy.</span><span class="sxs-lookup"><span data-stu-id="dbda1-133">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="dbda1-134">Omezení umožňuje obecná třída používat `Employee.Name` vlastnost vzhledem k tomu, že je zaručeno, že všechny položky typu t. buď `Employee` objekt nebo objekt, který dědí z `Employee`.</span><span class="sxs-lookup"><span data-stu-id="dbda1-134">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="dbda1-135">Více omezení lze použít pro stejný parametr typu a omezení sami lze obecné typy, následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="dbda1-135">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="dbda1-136">Omezíte parametr typu, můžete zvýšit počet povolených operací a volání metody jsou podporovány všechny typy v hierarchii dědičnosti a omezení typu.</span><span class="sxs-lookup"><span data-stu-id="dbda1-136">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="dbda1-137">Proto při navrhování obecné třídy nebo metody, pokud se budete provádět všechny operace v obecné členy nad rámec jednoduché přiřazení nebo volání žádné metody, které nepodporují `System.Object`, budete muset použít omezení pro parametr typu.</span><span class="sxs-lookup"><span data-stu-id="dbda1-137">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="dbda1-138">Při použití `where T : class` omezení, vyhněte se `==` a `!=` operátory na parametr typu vzhledem k tomu, že tyto operátory testovat pro referenční identity jenom, ne pro rovnosti hodnoty.</span><span class="sxs-lookup"><span data-stu-id="dbda1-138">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="dbda1-139">Toto je tento případ, i když jsou tyto operátory přetížené v typu, který se používá jako argument.</span><span class="sxs-lookup"><span data-stu-id="dbda1-139">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="dbda1-140">Následující kód ukazuje tento bod; i když je hodnota false výstup <xref:System.String> třídy přetížení `==` operátor.</span><span class="sxs-lookup"><span data-stu-id="dbda1-140">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="dbda1-141">Důvod pro toto chování je, že v době kompilace kompilátor pouze ví, že T typem je odkaz a proto musíte použít výchozí operátory, které jsou platné pro všechny typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="dbda1-141">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="dbda1-142">Pokud musíte otestovat rovnosti hodnotu, doporučený způsob je se rovněž vztahují `where T : IComparable<T>` omezení a implementace, která rozhraní do třídy, která se použije ke konstrukci obecná třída.</span><span class="sxs-lookup"><span data-stu-id="dbda1-142">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="dbda1-143">Chovaly několik parametrů</span><span class="sxs-lookup"><span data-stu-id="dbda1-143">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="dbda1-144">Omezení můžete použít pro několik parametrů a více omezení pro jeden parametr, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="dbda1-144">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="dbda1-145">Parametry typu bez vazby</span><span class="sxs-lookup"><span data-stu-id="dbda1-145">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="dbda1-146">Zadejte parametry, které mají žádná omezení, jako je například T v veřejnou třídu `SampleClass<T>{}`, se nazývají typu bez vazby parametrů.</span><span class="sxs-lookup"><span data-stu-id="dbda1-146">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="dbda1-147">Parametry typu bez vazby mají následující pravidla:</span><span class="sxs-lookup"><span data-stu-id="dbda1-147">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="dbda1-148">`!=` a `==` operátory nelze použít, protože není zaručeno, že konkrétní typ argumentu bude podporovat tyto operátory.</span><span class="sxs-lookup"><span data-stu-id="dbda1-148">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="dbda1-149">Mohou být převedeny do a z `System.Object` nebo explicitně převést na typ všech rozhraní.</span><span class="sxs-lookup"><span data-stu-id="dbda1-149">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="dbda1-150">Můžete porovnat s [null](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="dbda1-150">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="dbda1-151">Pokud se porovná bez vazby parametru `null`, porovnání vždy vrátí hodnotu false, pokud argument typ je typ hodnoty.</span><span class="sxs-lookup"><span data-stu-id="dbda1-151">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="dbda1-152">Parametry typu jako omezení</span><span class="sxs-lookup"><span data-stu-id="dbda1-152">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="dbda1-153">Použití parametr obecného typu jako omezení je užitečné, pokud členské funkce s parametrem vlastní typ má omezit tento parametr pro parametr typu obsahující typu, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="dbda1-153">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="dbda1-154">V předchozím příkladu `T` je omezení typu v kontextu `Add` metoda a parametru typu bez vazby v kontextu `List` třídy.</span><span class="sxs-lookup"><span data-stu-id="dbda1-154">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="dbda1-155">Parametry typu mohou sloužit také jako omezení v definicích – obecná třída.</span><span class="sxs-lookup"><span data-stu-id="dbda1-155">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="dbda1-156">Všimněte si, že parametr typu musí být deklarován v závorkách úhel spolu s dalšími parametry typu:</span><span class="sxs-lookup"><span data-stu-id="dbda1-156">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="dbda1-157">Užitečnost parametry typu jako omezení s obecné třídy jsou hodně omezené, protože kompilátor můžete předpokládat nic o parametr typu s tím rozdílem, že je odvozena z `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="dbda1-157">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="dbda1-158">Pomocí parametrů typu jako omezení obecných tříd ve scénářích, ve kterých chcete vynutit vztah dědičnosti mezi dvěma parametry typu.</span><span class="sxs-lookup"><span data-stu-id="dbda1-158">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dbda1-159">Viz také</span><span class="sxs-lookup"><span data-stu-id="dbda1-159">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="dbda1-160">Průvodce programováním v C#</span><span class="sxs-lookup"><span data-stu-id="dbda1-160">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="dbda1-161">Úvod do obecných typů</span><span class="sxs-lookup"><span data-stu-id="dbda1-161">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="dbda1-162">Obecné třídy</span><span class="sxs-lookup"><span data-stu-id="dbda1-162">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="dbda1-163">New – omezení</span><span class="sxs-lookup"><span data-stu-id="dbda1-163">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)
