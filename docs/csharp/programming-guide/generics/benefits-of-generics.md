---
title: "Výhody obecných typů (Průvodce programováním v C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords: generics [C#], benefits
ms.assetid: 80f037cd-9ea7-48be-bfc1-219bfb2d4277
caps.latest.revision: "23"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 9f46a328208b49aa33130a020e1a85b6f7aa7d97
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/21/2017
---
# <a name="benefits-of-generics-c-programming-guide"></a><span data-ttu-id="17149-102">Výhody obecných typů (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="17149-102">Benefits of Generics (C# Programming Guide)</span></span>
<span data-ttu-id="17149-103">Obecné typy poskytují řešení k omezení v dřívějších verzích modul common language runtime a ve kterém se provádí generalizace typy přetypování z universal základní typ a jazyk C# <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="17149-103">Generics provide the solution to a limitation in earlier versions of the common language runtime and the C# language in which generalization is accomplished by casting types to and from the universal base type <xref:System.Object>.</span></span> <span data-ttu-id="17149-104">Vytvořením obecné třídy můžete vytvořit kolekci, která je bezpečnost typů v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="17149-104">By creating a generic class, you can create a collection that is type-safe at compile-time.</span></span>  
  
 <span data-ttu-id="17149-105">Omezení používání negenerická kolekce tříd prokázat zápis krátký program, který používá <xref:System.Collections.ArrayList> třídy kolekce v knihovně tříd rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="17149-105">The limitations of using non-generic collection classes can be demonstrated by writing a short program that uses the <xref:System.Collections.ArrayList> collection class from the .NET Framework class library.</span></span> <span data-ttu-id="17149-106"><xref:System.Collections.ArrayList>je třída vysoce vhodnou kolekci, která lze použít bez úprav pro ukládání libovolného typu hodnotou nebo odkazem.</span><span class="sxs-lookup"><span data-stu-id="17149-106"><xref:System.Collections.ArrayList> is a highly convenient collection class that can be used without modification to store any reference or value type.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#4](../../../csharp/programming-guide/generics/codesnippet/CSharp/benefits-of-generics_1.cs)]  
  
 <span data-ttu-id="17149-107">Ale tato výhoda se dodává s náklady.</span><span class="sxs-lookup"><span data-stu-id="17149-107">But this convenience comes at a cost.</span></span> <span data-ttu-id="17149-108">Hodnotou nebo odkazem typ, který je přidán do <xref:System.Collections.ArrayList> je implicitně přetypování nahoru k <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="17149-108">Any reference or value type that is added to an <xref:System.Collections.ArrayList> is implicitly upcast to <xref:System.Object>.</span></span> <span data-ttu-id="17149-109">Pokud položky jsou typy hodnot, se musí zabalená, když jsou přidány do seznamu a nezabalený při načtení.</span><span class="sxs-lookup"><span data-stu-id="17149-109">If the items are value types, they must be boxed when they are added to the list, and unboxed when they are retrieved.</span></span> <span data-ttu-id="17149-110">Přetypování a operace zabalení a rozbalení snížit výkon; účinek zabalení a rozbalení může být velmi důležité ve scénářích, kde musí iterace v rozsáhlých kolekcí.</span><span class="sxs-lookup"><span data-stu-id="17149-110">Both the casting and the boxing and unboxing operations decrease performance; the effect of boxing and unboxing can be very significant in scenarios where you must iterate over large collections.</span></span>  
  
 <span data-ttu-id="17149-111">Další omezení je nedostatek typu kompilaci kontrolu. protože <xref:System.Collections.ArrayList> vrhá všechno k <xref:System.Object>, neexistuje žádný způsob při kompilaci kódu klienta zabránit dělat něco jako je tato:</span><span class="sxs-lookup"><span data-stu-id="17149-111">The other limitation is lack of compile-time type checking; because an <xref:System.Collections.ArrayList> casts everything to <xref:System.Object>, there is no way at compile-time to prevent client code from doing something such as this:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#5](../../../csharp/programming-guide/generics/codesnippet/CSharp/benefits-of-generics_2.cs)]  
  
 <span data-ttu-id="17149-112">I když je zcela přijatelné a někdy záměrné, pokud vytváříte kolekci heterogenní kombinovaných řetězců a `ints` v jediném <xref:System.Collections.ArrayList> může být chybě programování, a tato chyba nebudou zjištěna dokud modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="17149-112">Although perfectly acceptable and sometimes intentional if you are creating a heterogeneous collection, combining strings and `ints` in a single <xref:System.Collections.ArrayList> is more likely to be a programming error, and this error will not be detected until runtime.</span></span>  
  
 <span data-ttu-id="17149-113">V verze 1.0 a 1.1 jazyka C# se můžete vyhnout nebezpečích zobecněný kód v kolekce tříd rozhraní .NET Framework – základní třída knihovny pouze zápis vlastní typ konkrétní kolekce.</span><span class="sxs-lookup"><span data-stu-id="17149-113">In versions 1.0 and 1.1 of the C# language, you could avoid the dangers of generalized code in the .NET Framework base class library collection classes only by writing your own type specific collections.</span></span> <span data-ttu-id="17149-114">Samozřejmě protože taková třída není opakovaně použitelné pro více než jeden typ dat, ztratíte výhod Generalizace a máte přepsání třídu pro každý typ, který se uloží.</span><span class="sxs-lookup"><span data-stu-id="17149-114">Of course, because such a class is not reusable for more than one data type, you lose the benefits of generalization, and you have to rewrite the class for each type that will be stored.</span></span>  
  
 <span data-ttu-id="17149-115">Co <xref:System.Collections.ArrayList> a další podobné třídy skutečně potřebujete je způsob, jak kód klienta k určení, na základě jednotlivých instancí konkrétní datový typ, který mají v úmyslu použít.</span><span class="sxs-lookup"><span data-stu-id="17149-115">What <xref:System.Collections.ArrayList> and other similar classes really need is a way for client code to specify, on a per-instance basis, the particular data type that they intend to use.</span></span> <span data-ttu-id="17149-116">Který by eliminují nutnost použití přetypování nahoru k `T:System.Object` a by také umožnit kompilátor pro kontrolu typu.</span><span class="sxs-lookup"><span data-stu-id="17149-116">That would eliminate the need for the upcast to `T:System.Object` and would also make it possible for the compiler to do type checking.</span></span> <span data-ttu-id="17149-117">Jinými slovy <xref:System.Collections.ArrayList> potřebuje parametr typu.</span><span class="sxs-lookup"><span data-stu-id="17149-117">In other words, <xref:System.Collections.ArrayList> needs a type parameter.</span></span> <span data-ttu-id="17149-118">Který je právě co poskytují obecné typy.</span><span class="sxs-lookup"><span data-stu-id="17149-118">That is exactly what generics provide.</span></span> <span data-ttu-id="17149-119">V Obecné <xref:System.Collections.Generic.List%601> kolekce v `N:System.Collections.Generic` obor názvů, stejné operace přidání položky do kolekce vypadá takto:</span><span class="sxs-lookup"><span data-stu-id="17149-119">In the generic <xref:System.Collections.Generic.List%601> collection, in the `N:System.Collections.Generic` namespace, the same operation of adding items to the collection resembles this:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#6](../../../csharp/programming-guide/generics/codesnippet/CSharp/benefits-of-generics_3.cs)]  
  
 <span data-ttu-id="17149-120">Pro kód klienta jediný přidat syntaxi společně s <xref:System.Collections.Generic.List%601> ve srovnání s <xref:System.Collections.ArrayList> je argument typu deklarace a vytváření instancí.</span><span class="sxs-lookup"><span data-stu-id="17149-120">For client code, the only added syntax with <xref:System.Collections.Generic.List%601> compared to <xref:System.Collections.ArrayList> is the type argument in the declaration and instantiation.</span></span> <span data-ttu-id="17149-121">Po této složitost něco víc kódování, můžete vytvořit seznam, který není pouze bezpečnější než <xref:System.Collections.ArrayList>, ale také výrazně rychlejší, zejména v případě, že položky seznamu jsou typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="17149-121">In return for this slightly more coding complexity, you can create a list that is not only safer than <xref:System.Collections.ArrayList>, but also significantly faster, especially when the list items are value types.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="17149-122">Viz také</span><span class="sxs-lookup"><span data-stu-id="17149-122">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="17149-123">Průvodce programováním v C#</span><span class="sxs-lookup"><span data-stu-id="17149-123">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="17149-124">Úvod do obecných typů</span><span class="sxs-lookup"><span data-stu-id="17149-124">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="17149-125">Zabalení a rozbalení</span><span class="sxs-lookup"><span data-stu-id="17149-125">Boxing and Unboxing</span></span>](../../../csharp/programming-guide/types/boxing-and-unboxing.md)  
 [<span data-ttu-id="17149-126">Osvědčené postupy pro kolekce</span><span class="sxs-lookup"><span data-stu-id="17149-126">Collections Best Practices</span></span>](http://go.microsoft.com/fwlink/?LinkId=112403)
