---
title: "Postupy: Iterace v adresářovém stromě (Průvodce programováním v C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
caps.latest.revision: "10"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: c4851938aafefd93aa9189aecbb3f5cdd9a09ea0
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/21/2017
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="743e3-102">Postupy: Iterace v adresářovém stromě (Průvodce programováním v C#)</span><span class="sxs-lookup"><span data-stu-id="743e3-102">How to: Iterate Through a Directory Tree (C# Programming Guide)</span></span>
<span data-ttu-id="743e3-103">Fráze "iterace v adresářovém stromě" znamená přístup každý soubor v každé vnořené podadresáři složce zadaný kořenový na libovolnou hloubku.</span><span class="sxs-lookup"><span data-stu-id="743e3-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="743e3-104">Nemáte nutně otevřete každý soubor.</span><span class="sxs-lookup"><span data-stu-id="743e3-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="743e3-105">Název souboru nebo podadresáři jako můžete načíst právě `string`, nebo můžete získat další informace ve formě <xref:System.IO.FileInfo?displayProperty=nameWithType> nebo <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> objektu.</span><span class="sxs-lookup"><span data-stu-id="743e3-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="743e3-106">V systému Windows jsou podmínky "adresář" a "složka" použít zcela zaměnitelným významem.</span><span class="sxs-lookup"><span data-stu-id="743e3-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="743e3-107">Většina dokumentace a uživatelské rozhraní text používá termín "složka", ale [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] knihovny tříd se pod pojmem "adresář."</span><span class="sxs-lookup"><span data-stu-id="743e3-107">Most documentation and user interface text uses the term "folder," but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="743e3-108">V nejjednodušším případě, ve kterém nejste jisti, že máte oprávnění k přístupu pro všechny adresáře v rámci zadaného kořenové, můžete použít `System.IO.SearchOption.AllDirectories` příznak.</span><span class="sxs-lookup"><span data-stu-id="743e3-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="743e3-109">Tento příznak vrátí všechny vnořené podadresáře, které odpovídají zadanému vzoru.</span><span class="sxs-lookup"><span data-stu-id="743e3-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="743e3-110">Následující příklad ukazuje, jak používat tento příznak.</span><span class="sxs-lookup"><span data-stu-id="743e3-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="743e3-111">Slabé místo v tohoto přístupu je, že pokud kterákoli podadresáře v zadaném kořenovém způsobí, že <xref:System.IO.DirectoryNotFoundException> nebo <xref:System.UnauthorizedAccessException>, selže celý metodu a vrátí žádné adresáře.</span><span class="sxs-lookup"><span data-stu-id="743e3-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="743e3-112">Totéž platí při použití <xref:System.IO.DirectoryInfo.GetFiles%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="743e3-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="743e3-113">Pokud máte zpracování těchto výjimek na konkrétní podsložky, musí ručně provede stromu adresářů, jak je znázorněno v následujících příkladech.</span><span class="sxs-lookup"><span data-stu-id="743e3-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="743e3-114">Pokud jste ručně provede v adresářovém stromě, můžete nejdřív zpracovávat podadresáře (*před pořadí traversal*), nebo soubory první (*po pořadí traversal*).</span><span class="sxs-lookup"><span data-stu-id="743e3-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="743e3-115">Pokud provádíte traversal předběžné pořadí, provede celý strom v aktuální složce před iterace v rámci soubory, které jsou přímo v samotné složce.</span><span class="sxs-lookup"><span data-stu-id="743e3-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="743e3-116">Příklady později v tomto dokumentu provést po pořadí traversal, ale můžete je provést před pořadí traversal snadno upravit.</span><span class="sxs-lookup"><span data-stu-id="743e3-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="743e3-117">Další možností je, jestli se má používat rekurzi nebo základě zásobníku traversal.</span><span class="sxs-lookup"><span data-stu-id="743e3-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="743e3-118">Později v tomto dokumentu příkladech obou přístupů.</span><span class="sxs-lookup"><span data-stu-id="743e3-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="743e3-119">Pokud máte k provádění různých operací u souborů a složek, můžete rozčlenění tyto příklady moduly pomocí operace do samostatné funkce, které můžete vyvolat pomocí jednoho delegáta refaktoringu.</span><span class="sxs-lookup"><span data-stu-id="743e3-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="743e3-120">Systémy souborů NTFS může obsahovat *body rozboru* ve formě *spojovacích bodů*, *symbolické odkazy*, a *pevné odkazy*.</span><span class="sxs-lookup"><span data-stu-id="743e3-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="743e3-121">Metody rozhraní .NET Framework, jako <xref:System.IO.DirectoryInfo.GetFiles%2A> a <xref:System.IO.DirectoryInfo.GetDirectories%2A> nevrátí jakéhokoliv podadresáře pod bodem rozboru.</span><span class="sxs-lookup"><span data-stu-id="743e3-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="743e3-122">Toto chování chrání před rizikem zadáním v nekonečné smyčce, při dva body rozboru odkazovat navzájem.</span><span class="sxs-lookup"><span data-stu-id="743e3-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="743e3-123">Obecně platí by měl buďte velmi opatrní při řešit body rozboru používané k zajištění není neúmyslně upravovat a odstraňovat soubory.</span><span class="sxs-lookup"><span data-stu-id="743e3-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="743e3-124">Pokud budete potřebovat přesnou kontrolu nad spojovací body, použití vyvolání platformy nebo nativní kód pro volání odpovídající souboru Win32 systému metody přímo.</span><span class="sxs-lookup"><span data-stu-id="743e3-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="743e3-125">Příklad</span><span class="sxs-lookup"><span data-stu-id="743e3-125">Example</span></span>  
 <span data-ttu-id="743e3-126">Následující příklad ukazuje, jak vás v adresářovém stromě pomocí rekurze.</span><span class="sxs-lookup"><span data-stu-id="743e3-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="743e3-127">Rekurzivní přístup je elegantní, ale má potenciál být příčinou výjimce přetečení zásobníku, pokud je adresářový strom velké a hluboko vložené.</span><span class="sxs-lookup"><span data-stu-id="743e3-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="743e3-128">Konkrétní výjimky, které jsou zpracovávány a konkrétní akce, které se provádí na každý soubor nebo složku, jsou k dispozici pouze jako příklady.</span><span class="sxs-lookup"><span data-stu-id="743e3-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="743e3-129">Změňte tento kód podle specifických požadavků.</span><span class="sxs-lookup"><span data-stu-id="743e3-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="743e3-130">Zobrazte komentáře v kódu pro další informace.</span><span class="sxs-lookup"><span data-stu-id="743e3-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]  
  
## <a name="example"></a><span data-ttu-id="743e3-131">Příklad</span><span class="sxs-lookup"><span data-stu-id="743e3-131">Example</span></span>  
 <span data-ttu-id="743e3-132">Následující příklad ukazuje, jak k iteraci v rámci soubory a složky v adresářovém stromu bez použití rekurze.</span><span class="sxs-lookup"><span data-stu-id="743e3-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="743e3-133">Tento postup používá obecná <xref:System.Collections.Generic.Stack%601> typu kolekce, který je poslední v první out (LIFO) zásobníku.</span><span class="sxs-lookup"><span data-stu-id="743e3-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="743e3-134">Konkrétní výjimky, které jsou zpracovávány a konkrétní akce, které se provádí na každý soubor nebo složku, jsou k dispozici pouze jako příklady.</span><span class="sxs-lookup"><span data-stu-id="743e3-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="743e3-135">Změňte tento kód podle specifických požadavků.</span><span class="sxs-lookup"><span data-stu-id="743e3-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="743e3-136">Zobrazte komentáře v kódu pro další informace.</span><span class="sxs-lookup"><span data-stu-id="743e3-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]  
  
 <span data-ttu-id="743e3-137">Obecně je příliš zdlouhavý otestovat všechny složky k určení, zda má oprávnění k jeho otevření aplikace.</span><span class="sxs-lookup"><span data-stu-id="743e3-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="743e3-138">Proto příkladu kódu právě uzavře operace v příslušné části `try/catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="743e3-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="743e3-139">Můžete upravit `catch` blokovat tak, aby při je odepřen přístup do složky, pokusíte zvýšení oprávnění a poté přistoupit.</span><span class="sxs-lookup"><span data-stu-id="743e3-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="743e3-140">Platí pouze catch tyto výjimky, které může zpracovat, aniž byste museli opustit vaší aplikace v neznámém stavu.</span><span class="sxs-lookup"><span data-stu-id="743e3-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="743e3-141">Pokud je třeba uložit obsah v adresářovém stromě v paměti nebo na disku, nejlepší možnost je k uložení pouze <xref:System.IO.FileSystemInfo.FullName%2A> vlastnost (typu `string`) pro každý soubor.</span><span class="sxs-lookup"><span data-stu-id="743e3-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="743e3-142">Pak můžete použít tento řetězec pro vytvoření nového <xref:System.IO.FileInfo> nebo <xref:System.IO.DirectoryInfo> objektu podle potřeby nebo otevřít libovolný soubor, který vyžaduje další zpracování.</span><span class="sxs-lookup"><span data-stu-id="743e3-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="743e3-143">Robustní programování</span><span class="sxs-lookup"><span data-stu-id="743e3-143">Robust Programming</span></span>  
 <span data-ttu-id="743e3-144">Kód iterace robustní souboru musí vzít v úvahu mnoho složité kroky systému souborů.</span><span class="sxs-lookup"><span data-stu-id="743e3-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="743e3-145">Další informace najdete v tématu [technické informace o systému souborů NTFS](http://go.microsoft.com/fwlink/?LinkId=79488).</span><span class="sxs-lookup"><span data-stu-id="743e3-145">For more information, see [NTFS Technical Reference](http://go.microsoft.com/fwlink/?LinkId=79488).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="743e3-146">Viz také</span><span class="sxs-lookup"><span data-stu-id="743e3-146">See Also</span></span>  
 <xref:System.IO>  
 [<span data-ttu-id="743e3-147">LINQ a souborové adresáře</span><span class="sxs-lookup"><span data-stu-id="743e3-147">LINQ and File Directories</span></span>](http://msdn.microsoft.com/library/5a5d516c-0279-4a84-ac84-b87f54caa808)  
 [<span data-ttu-id="743e3-148">Systém souborů a registr (C# Průvodce programováním)</span><span class="sxs-lookup"><span data-stu-id="743e3-148">File System and the Registry (C# Programming Guide)</span></span>](../../../csharp/programming-guide/file-system/index.md)
