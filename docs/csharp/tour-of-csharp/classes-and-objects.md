---
title: "Třídy a objekty v jazyce C# – přehled používání jazyka C#"
description: "Nové jazyka C#? Přečtěte si tento přehled tříd, objekty a dědičnost"
keywords: "Rozhraní .NET, csharp, třídu, instance, objekt, dědičnosti, polymorfismus"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: 37e04e918ead283f474899a9421aee2140ab7c11
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/08/2017
---
# <a name="classes-and-objects"></a><span data-ttu-id="22674-105">Třídy a objekty</span><span class="sxs-lookup"><span data-stu-id="22674-105">Classes and objects</span></span>

<span data-ttu-id="22674-106">*Třídy* jsou nejvíce základní typy C# na.</span><span class="sxs-lookup"><span data-stu-id="22674-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="22674-107">Třída je datová struktura, která spojuje stavu (pole) a akce (metody a členy jiné funkce) v jediné jednotky.</span><span class="sxs-lookup"><span data-stu-id="22674-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="22674-108">Třída obsahuje definici pro dynamicky vytvořený *instance* třídy, také známé jako *objekty*.</span><span class="sxs-lookup"><span data-stu-id="22674-108">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="22674-109">Třídy podpory *dědičnosti* a *polymorfismus*, mechanismy které *odvozených třídách* můžete rozšířit a specialize *základní třídy*.</span><span class="sxs-lookup"><span data-stu-id="22674-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="22674-110">Nové třídy jsou vytvořeny pomocí deklarace tříd.</span><span class="sxs-lookup"><span data-stu-id="22674-110">New classes are created using class declarations.</span></span> <span data-ttu-id="22674-111">Deklarace třídy začíná hlavičku, která určuje, atributy a třídy modifikátory, název třídy základní třídy (je-li zadána) a rozhraní implementované v třídě.</span><span class="sxs-lookup"><span data-stu-id="22674-111">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="22674-112">Záhlaví následuje tělo třídy, které se skládá z seznam deklarace členů zapsána mezi oddělovače `{` a `}`.</span><span class="sxs-lookup"><span data-stu-id="22674-112">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="22674-113">Toto je prohlášení o jednoduché třídy s názvem `Point`:</span><span class="sxs-lookup"><span data-stu-id="22674-113">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="22674-114">Instance třídy jsou vytvořené pomocí `new` operátor, který se přidělí paměť pro novou instanci, volá konstruktor k inicializaci instance a vrátí odkaz na instanci.</span><span class="sxs-lookup"><span data-stu-id="22674-114">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="22674-115">Následující příkazy vytvořte dva objekty bodu a ukládání odkazů na tyto objekty ve dvou proměnných:</span><span class="sxs-lookup"><span data-stu-id="22674-115">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="22674-116">Paměti obsazené objektem je automaticky uvolní, pokud je objekt už nebude dostupný.</span><span class="sxs-lookup"><span data-stu-id="22674-116">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="22674-117">Je nutné ani možné explicitně navrácení objekty v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="22674-117">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="22674-118">Členové</span><span class="sxs-lookup"><span data-stu-id="22674-118">Members</span></span>

<span data-ttu-id="22674-119">Členy třídy jsou statické členy nebo členů instance.</span><span class="sxs-lookup"><span data-stu-id="22674-119">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="22674-120">Statické členy patřit do třídy a instance členy patří k objektům (instance třídy).</span><span class="sxs-lookup"><span data-stu-id="22674-120">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="22674-121">Následující část obsahuje přehled různých druhů členů, které může obsahovat třídu.</span><span class="sxs-lookup"><span data-stu-id="22674-121">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="22674-122">Konstanty</span><span class="sxs-lookup"><span data-stu-id="22674-122">Constants</span></span>
    - <span data-ttu-id="22674-123">Konstantní hodnoty, které jsou přidružené k třídě</span><span class="sxs-lookup"><span data-stu-id="22674-123">Constant values associated with the class</span></span>
* <span data-ttu-id="22674-124">Pole</span><span class="sxs-lookup"><span data-stu-id="22674-124">Fields</span></span>
    - <span data-ttu-id="22674-125">Proměnné třídy</span><span class="sxs-lookup"><span data-stu-id="22674-125">Variables of the class</span></span>
* <span data-ttu-id="22674-126">Metody</span><span class="sxs-lookup"><span data-stu-id="22674-126">Methods</span></span>
    - <span data-ttu-id="22674-127">Výpočty a akce, které lze provést pomocí třídy</span><span class="sxs-lookup"><span data-stu-id="22674-127">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="22674-128">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="22674-128">Properties</span></span>
    - <span data-ttu-id="22674-129">Akce přidružené k čtení a zápis s názvem vlastnosti třídy</span><span class="sxs-lookup"><span data-stu-id="22674-129">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="22674-130">Indexery</span><span class="sxs-lookup"><span data-stu-id="22674-130">Indexers</span></span>
    - <span data-ttu-id="22674-131">Akce přidružené k indexování instancí třídy jako pole</span><span class="sxs-lookup"><span data-stu-id="22674-131">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="22674-132">Události</span><span class="sxs-lookup"><span data-stu-id="22674-132">Events</span></span>
    - <span data-ttu-id="22674-133">Oznámení, která může být generována třídy</span><span class="sxs-lookup"><span data-stu-id="22674-133">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="22674-134">Operátory</span><span class="sxs-lookup"><span data-stu-id="22674-134">Operators</span></span>
    - <span data-ttu-id="22674-135">Převody a operátory výraz nepodporuje třídy</span><span class="sxs-lookup"><span data-stu-id="22674-135">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="22674-136">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="22674-136">Constructors</span></span>
    - <span data-ttu-id="22674-137">Akce potřebné k chybě při inicializaci instance třídy nebo vlastní třídy</span><span class="sxs-lookup"><span data-stu-id="22674-137">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="22674-138">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="22674-138">Finalizers</span></span>
    - <span data-ttu-id="22674-139">Akce, které je třeba provést před instancí třídy jsou trvale zahozeny.</span><span class="sxs-lookup"><span data-stu-id="22674-139">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="22674-140">Typy</span><span class="sxs-lookup"><span data-stu-id="22674-140">Types</span></span>
    - <span data-ttu-id="22674-141">Vnořené typy deklarovaná třídy</span><span class="sxs-lookup"><span data-stu-id="22674-141">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="22674-142">Usnadnění</span><span class="sxs-lookup"><span data-stu-id="22674-142">Accessibility</span></span>

<span data-ttu-id="22674-143">Každý člen třídy má přidružené usnadnění přístupu, který řídí oblasti program textu, která mají mít přístup k členovi.</span><span class="sxs-lookup"><span data-stu-id="22674-143">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="22674-144">Nejsou k dispozici pět možné formy usnadnění.</span><span class="sxs-lookup"><span data-stu-id="22674-144">There are five possible forms of accessibility.</span></span> <span data-ttu-id="22674-145">Tyto jsou shrnuté níž.</span><span class="sxs-lookup"><span data-stu-id="22674-145">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="22674-146">Přístup není omezené.</span><span class="sxs-lookup"><span data-stu-id="22674-146">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="22674-147">Přístup k omezené na této třídě nebo třídy odvozené z této třídy</span><span class="sxs-lookup"><span data-stu-id="22674-147">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="22674-148">Přístup omezený na aktuální sestavení (.exe, .dll atd.)</span><span class="sxs-lookup"><span data-stu-id="22674-148">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="22674-149">Přístup omezené na obsahující třídu nebo třídy odvozené od obsahující – třída</span><span class="sxs-lookup"><span data-stu-id="22674-149">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="22674-150">Přístup k omezené na tato třída</span><span class="sxs-lookup"><span data-stu-id="22674-150">Access limited to this class</span></span>
* `private protected`
    - <span data-ttu-id="22674-151">Přístup omezené na obsahující třídu nebo třídy odvozené od obsahující jsou dotčena typu do stejného sestavení</span><span class="sxs-lookup"><span data-stu-id="22674-151">Access limited to the containing class or classes derived from the containing type withing the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="22674-152">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="22674-152">Type parameters</span></span>

<span data-ttu-id="22674-153">Definice třídy může určit sadu parametrů typu podle názvu třídy s lomené závorky uzavření do seznamu názvy parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="22674-153">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="22674-154">Parametry typu pak lze v těle deklarace tříd členy třídy definovat.</span><span class="sxs-lookup"><span data-stu-id="22674-154">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="22674-155">V následujícím příkladu, parametry typu `Pair` jsou `TFirst` a `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="22674-155">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="22674-156">Typ třídy, který je deklarovaný typ parametry nazývá *typu obecné třídy*.</span><span class="sxs-lookup"><span data-stu-id="22674-156">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="22674-157">Typy struktura, rozhraní a delegáta může být také obecné.</span><span class="sxs-lookup"><span data-stu-id="22674-157">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="22674-158">Pokud se použije obecná třída, musí být uvedeny argumenty typu pro jednotlivé parametry typu:</span><span class="sxs-lookup"><span data-stu-id="22674-158">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="22674-159">Obecného typu s argumenty typu, jako je třeba zadat `Pair<int,string>` vyšších verzích se nazývá *sestavený typu*.</span><span class="sxs-lookup"><span data-stu-id="22674-159">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="22674-160">Základní třídy</span><span class="sxs-lookup"><span data-stu-id="22674-160">Base classes</span></span>

<span data-ttu-id="22674-161">Deklarace třídy mohou zadejte základní třídu třída název a typ parametry s dvojtečkou a název základní třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-161">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="22674-162">Vynechání specifikaci základní třída je stejný jako odvozování z typu `object`.</span><span class="sxs-lookup"><span data-stu-id="22674-162">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="22674-163">V následujícím příkladu, základní třídu `Point3D` je `Point`a základní třídu `Point` je `object`:</span><span class="sxs-lookup"><span data-stu-id="22674-163">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="22674-164">Třídy dědí členy základní třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-164">A class inherits the members of its base class.</span></span> <span data-ttu-id="22674-165">Dědičnost znamená, že třídu implicitně obsahuje všechny členy její základní třída, s výjimkou instance a statických konstruktorů a finalizační metody třídy base.</span><span class="sxs-lookup"><span data-stu-id="22674-165">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="22674-166">Odvozené třídy můžete přidat nové členy ty, které dědí, ale nemůže odstranit definici zděděného členu.</span><span class="sxs-lookup"><span data-stu-id="22674-166">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="22674-167">V předchozím příkladu `Point3D` dědí `x` a `y` pole z `Point`a každou `Point3D` instance obsahuje tři pole `x`, `y`, a `z`.</span><span class="sxs-lookup"><span data-stu-id="22674-167">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="22674-168">Implicitní převod existuje z typu třídy pro všechny typy jejich základní třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-168">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="22674-169">Proto můžete proměnné typu třídy odkazovat instance této třídy nebo instance všechny odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-169">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="22674-170">Například uděleno předchozí deklarace tříd proměnné typu `Point` může odkazovat buď `Point` nebo `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="22674-170">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="22674-171">Pole</span><span class="sxs-lookup"><span data-stu-id="22674-171">Fields</span></span>

<span data-ttu-id="22674-172">A *pole* je proměnná, která souvisí s třídy nebo instance třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-172">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="22674-173">Pole deklarovat s statický modifikátor definuje statické pole.</span><span class="sxs-lookup"><span data-stu-id="22674-173">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="22674-174">Statické pole identifikuje přesně jedno umístění úložiště.</span><span class="sxs-lookup"><span data-stu-id="22674-174">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="22674-175">Bez ohledu na to, kolik instancí třídy vytváří je někdy pouze jedné kopie statické pole.</span><span class="sxs-lookup"><span data-stu-id="22674-175">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="22674-176">Pole deklarované bez statický modifikátor definuje poli instance.</span><span class="sxs-lookup"><span data-stu-id="22674-176">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="22674-177">Každá instance třídy obsahuje kopii pole instance této třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-177">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="22674-178">V následujícím příkladu, každá instance `Color` třída má samostatnou kopii `r`, `g`, a `b` instance pole, ale existuje pouze jedna kopie `Black`, `White`, `Red`, `Green`, a `Blue` statických polí:</span><span class="sxs-lookup"><span data-stu-id="22674-178">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="22674-179">Jak je uvedeno v předchozím příkladu *pole jen pro čtení* může deklarovat s `readonly` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="22674-179">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="22674-180">Přiřazení `readonly` pole lze použít pouze v jako součást deklaraci pole nebo v konstruktoru ve stejné třídě.</span><span class="sxs-lookup"><span data-stu-id="22674-180">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="22674-181">Metody</span><span class="sxs-lookup"><span data-stu-id="22674-181">Methods</span></span>

<span data-ttu-id="22674-182">A *metoda* je člen, který implementuje výpočtu nebo akce, které lze provést pomocí objektu nebo třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-182">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="22674-183">*Statické metody* jsou přístupné prostřednictvím třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-183">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="22674-184">*Instance metody* jsou přístupné prostřednictvím instancí třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-184">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="22674-185">Metody může mít seznam *parametry*, které představují hodnoty nebo odkazy na proměnné předaný metodě a *návratový typ*, která určuje typ hodnoty počítaný a vrácený metodou.</span><span class="sxs-lookup"><span data-stu-id="22674-185">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="22674-186">Návratový typ metoda `void` Pokud nevrací hodnotu.</span><span class="sxs-lookup"><span data-stu-id="22674-186">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="22674-187">Podobně jako typy metody také obsahovat sadu parametrů typu, pro které argumenty typu se musí zadat při volání metody.</span><span class="sxs-lookup"><span data-stu-id="22674-187">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="22674-188">Na rozdíl od typů argumenty typu lze odvodit často z argumentů volání metody a nemusí být explicitně uvedena.</span><span class="sxs-lookup"><span data-stu-id="22674-188">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="22674-189">*Podpis* metody musí být jedinečný v třídě, ve kterém je deklarovaná metodu.</span><span class="sxs-lookup"><span data-stu-id="22674-189">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="22674-190">Podpis metody se skládá z název metody, počet parametrů typu a počtu, modifikátory a typy její parametry.</span><span class="sxs-lookup"><span data-stu-id="22674-190">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="22674-191">Podpis metody nezahrnuje návratový typ.</span><span class="sxs-lookup"><span data-stu-id="22674-191">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="22674-192">Parametry</span><span class="sxs-lookup"><span data-stu-id="22674-192">Parameters</span></span>

<span data-ttu-id="22674-193">Parametry se používají k předávání hodnot nebo proměnné odkazy na metody.</span><span class="sxs-lookup"><span data-stu-id="22674-193">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="22674-194">Parametry metody získat své skutečné hodnoty z *argumenty* které zadávají při vyvolání metody.</span><span class="sxs-lookup"><span data-stu-id="22674-194">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="22674-195">Existují čtyři typy parametrů: hodnoty parametrů, odkaz na parametry, výstupní parametry a pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="22674-195">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="22674-196">A *hodnota parametru* slouží k předávání vstupní argumenty.</span><span class="sxs-lookup"><span data-stu-id="22674-196">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="22674-197">Hodnota parametru odpovídá místní proměnné, která se získá z argument, který byl předán pro parametr počáteční hodnoty.</span><span class="sxs-lookup"><span data-stu-id="22674-197">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="22674-198">Úpravy na hodnotu parametr nemají vliv argument, který byl předán pro parametr.</span><span class="sxs-lookup"><span data-stu-id="22674-198">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="22674-199">Parametry s hodnotou může být volitelné, zadáním výchozí hodnotu tak, aby odpovídající argumenty lze vynechat.</span><span class="sxs-lookup"><span data-stu-id="22674-199">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="22674-200">A *odkazovat parametr* se používá pro předání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="22674-200">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="22674-201">Argument předaná pro parametr odkazu musí být proměnná s určitou hodnotu a během provádění metody parametr odkazu představuje stejné umístění úložiště jako proměnnou argument.</span><span class="sxs-lookup"><span data-stu-id="22674-201">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="22674-202">Parametr odkazu je deklarovaný s `ref` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="22674-202">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="22674-203">Následující příklad ukazuje použití `ref` parametry.</span><span class="sxs-lookup"><span data-stu-id="22674-203">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="22674-204">*Výstupní parametr* se používá pro předání argumentů odkazem.</span><span class="sxs-lookup"><span data-stu-id="22674-204">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="22674-205">Podobně jako parametr odkaz je s tím rozdílem, že není třeba explicitně přiřadit hodnotu na zadaný volající argument.</span><span class="sxs-lookup"><span data-stu-id="22674-205">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="22674-206">Výstupní parametr je deklarovaný s `out` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="22674-206">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="22674-207">Následující příklad ukazuje použití `out` parametry s využitím syntaxe byla zavedená v C# 7.</span><span class="sxs-lookup"><span data-stu-id="22674-207">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="22674-208">A *parametr pole* umožňuje proměnný počet argumentů mají být předány metodu.</span><span class="sxs-lookup"><span data-stu-id="22674-208">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="22674-209">Pole parametrů je deklarovaný s `params` modifikátor.</span><span class="sxs-lookup"><span data-stu-id="22674-209">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="22674-210">Pouze poslední parametr metody může být pole parametrů a typ pole parametrů musí být typu jednorozměrná pole.</span><span class="sxs-lookup"><span data-stu-id="22674-210">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="22674-211">Metody zápisu a WriteLine <xref:System.Console?displayProperty=nameWithType> třídy jsou dobrými příklady použití pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="22674-211">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="22674-212">Jsou deklarovány následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="22674-212">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="22674-213">V rámci metody, která používá pole parametrů pole parametrů se chová stejně jako regulární parametr pole typu.</span><span class="sxs-lookup"><span data-stu-id="22674-213">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="22674-214">V k vyvolání metody se pole parametrů, je možné předat buď jeden argument parametr pole typu nebo libovolný počet argumentů typu element pole parametrů.</span><span class="sxs-lookup"><span data-stu-id="22674-214">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="22674-215">V takovém případě je instance pole automaticky vytvořen a inicializován s danou argumenty.</span><span class="sxs-lookup"><span data-stu-id="22674-215">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="22674-216">Tento příklad</span><span class="sxs-lookup"><span data-stu-id="22674-216">This example</span></span>

[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="22674-217">je ekvivalentní zápis následující.</span><span class="sxs-lookup"><span data-stu-id="22674-217">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="22674-218">Metoda textu a lokální proměnné</span><span class="sxs-lookup"><span data-stu-id="22674-218">Method body and local variables</span></span>

<span data-ttu-id="22674-219">Metoda textu určuje příkazy provést při vyvolání metody.</span><span class="sxs-lookup"><span data-stu-id="22674-219">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="22674-220">Metoda text můžou deklarovat proměnné, které jsou specifické pro volání metody.</span><span class="sxs-lookup"><span data-stu-id="22674-220">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="22674-221">Tyto proměnné se nazývají *místní proměnné*.</span><span class="sxs-lookup"><span data-stu-id="22674-221">Such variables are called *local variables*.</span></span> <span data-ttu-id="22674-222">Místní deklarace proměnné Určuje název typu, název proměnné a pravděpodobně má počáteční hodnotu.</span><span class="sxs-lookup"><span data-stu-id="22674-222">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="22674-223">Následující příklad uvádí, místní proměnné `i` má počáteční hodnotu nula a místní proměnné `j` bez počáteční hodnoty.</span><span class="sxs-lookup"><span data-stu-id="22674-223">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="22674-224">C# vyžaduje místní proměnné být *výborný přiřazené* před jeho hodnotu lze získat.</span><span class="sxs-lookup"><span data-stu-id="22674-224">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="22674-225">Například pokud deklaraci předchozí `i` neobsahuje počáteční hodnotu, kompilátor zasílat zprávy o chybě pro následné použití `i` protože `i` nebude přiřazen výborný v těchto bodech v programu.</span><span class="sxs-lookup"><span data-stu-id="22674-225">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="22674-226">Můžete použít metodu `return` příkazy vrátit kontrolu jeho volajícího.</span><span class="sxs-lookup"><span data-stu-id="22674-226">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="22674-227">V metodě vrácení `void`, `return` příkazy nelze zadat výraz.</span><span class="sxs-lookup"><span data-stu-id="22674-227">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="22674-228">V metodě vrácení není void `return` příkazy musí obsahovat výraz, který vypočítá návratovou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="22674-228">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="22674-229">Statické a instance metody</span><span class="sxs-lookup"><span data-stu-id="22674-229">Static and instance methods</span></span>

<span data-ttu-id="22674-230">Je metoda deklarovat s statický modifikátor *statickou metodu*.</span><span class="sxs-lookup"><span data-stu-id="22674-230">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="22674-231">Statickou metodu nefunguje na konkrétní instanci a můžete pouze přímý přístup k statické členy.</span><span class="sxs-lookup"><span data-stu-id="22674-231">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="22674-232">Metoda deklarované bez je statický modifikátor *metodu instance*.</span><span class="sxs-lookup"><span data-stu-id="22674-232">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="22674-233">Metodu instance funguje na konkrétní instanci, můžete přístup jak statické a instance členy.</span><span class="sxs-lookup"><span data-stu-id="22674-233">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="22674-234">Instance, na kterém byl vyvolán metodu instance explicitně přístupná jako `this`.</span><span class="sxs-lookup"><span data-stu-id="22674-234">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="22674-235">Jedná se o chybu, který bude odkazovat na `this` v statickou metodu.</span><span class="sxs-lookup"><span data-stu-id="22674-235">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="22674-236">Následující `Entity` třída má statické a instanci členy.</span><span class="sxs-lookup"><span data-stu-id="22674-236">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="22674-237">Každý `Entity` instance obsahuje sériové číslo (a pravděpodobně z důvodu některé další informace, které není tady zobrazené).</span><span class="sxs-lookup"><span data-stu-id="22674-237">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="22674-238">`Entity` – Konstruktor (což je jako metodu instance) inicializuje novou instanci s další dostupné sériové číslo.</span><span class="sxs-lookup"><span data-stu-id="22674-238">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="22674-239">Protože konstruktoru instanci členu, ho povolený přístup i `serialNo` poli instance a `nextSerialNo` statické pole.</span><span class="sxs-lookup"><span data-stu-id="22674-239">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="22674-240">`GetNextSerialNo` a `SetNextSerialNo` přístup statických metod `nextSerialNo` statické pole, ale bude k chybě pro ně přímý přístup `serialNo` pole instance.</span><span class="sxs-lookup"><span data-stu-id="22674-240">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="22674-241">Následující příklad ukazuje použití třídy Entity.</span><span class="sxs-lookup"><span data-stu-id="22674-241">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="22674-242">Všimněte si, že `SetNextSerialNo` a `GetNextSerialNo` statické metody jsou vyvolány na třídu, zatímco `GetSerialNo` instance metoda je volána, instance této třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-242">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="22674-243">Virtuální, přepsání a abstraktní metody</span><span class="sxs-lookup"><span data-stu-id="22674-243">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="22674-244">Když metoda deklaraci instance obsahuje `virtual` modifikátor, metodu se říká, že *virtuální metoda*.</span><span class="sxs-lookup"><span data-stu-id="22674-244">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="22674-245">Pokud je k dispozici žádná virtuální modifikátor, metoda se říká, že *nevirtuální metoda*.</span><span class="sxs-lookup"><span data-stu-id="22674-245">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="22674-246">Pokud virtuální metoda je volána, *běhového typu* instance, které tento volání trvá místní určuje implementace skutečné metoda k vyvolání.</span><span class="sxs-lookup"><span data-stu-id="22674-246">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="22674-247">V metodě nevirtuální vyvolání *kompilaci typu* instance je určujícím faktorem.</span><span class="sxs-lookup"><span data-stu-id="22674-247">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="22674-248">Virtuální metoda může být *přepsat* v odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="22674-248">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="22674-249">Pokud deklarace metoda instance zahrnuje modifikátor přepsání, přepíše metodu zděděnou virtuální metodu se stejným podpisem.</span><span class="sxs-lookup"><span data-stu-id="22674-249">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="22674-250">Zatímco deklaraci virtuální metoda představuje nový způsob, deklarace přepsání metody tím, že poskytuje nové implementace této metody se specializuje existující zděděnou virtuální metodu.</span><span class="sxs-lookup"><span data-stu-id="22674-250">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="22674-251">*Abstraktní metody* je virtuální metoda s žádnou implementaci.</span><span class="sxs-lookup"><span data-stu-id="22674-251">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="22674-252">Abstraktní metodu je deklarovaný s modifikátorem abstraktní a smí obsahovat pouze třídu, která je také deklarována jako abstraktní.</span><span class="sxs-lookup"><span data-stu-id="22674-252">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="22674-253">Abstraktní metodu musí být přepsána nastaveními v každé Odvozené neabstraktní třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-253">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="22674-254">Následující příklad deklaruje abstraktní třídu, `Expression`, který představuje uzel stromu výraz a tři odvozených tříd, `Constant`, `VariableReference`, a `Operation`, které implementují uzly stromu výraz pro konstanty, proměnné odkazy a aritmetické operace.</span><span class="sxs-lookup"><span data-stu-id="22674-254">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="22674-255">(To je podobná, ale ne k termín nelze zaměňovat s typy výrazů stromu).</span><span class="sxs-lookup"><span data-stu-id="22674-255">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="22674-256">Lze použít předchozí čtyři třídy pro modelování aritmetických výrazech.</span><span class="sxs-lookup"><span data-stu-id="22674-256">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="22674-257">Například pomocí instancemi těchto tříd výraz `x + 3` může být reprezentován následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="22674-257">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="22674-258">`Evaluate` Metodu `Expression` instance je vyvolána k vyhodnocování daného výrazu a vytvořit `double` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="22674-258">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="22674-259">Tato metoda přebírá `Dictionary` argument, který obsahuje názvy proměnných (jako klíče položek) a hodnoty (jako hodnoty položek).</span><span class="sxs-lookup"><span data-stu-id="22674-259">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="22674-260">Protože `Evaluate` je abstraktní metodu neabstraktní třídy odvozené od `Expression` musí přepsat `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="22674-260">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="22674-261">A `Constant`na implementaci `Evaluate` jednoduše vrátí uložené konstanta.</span><span class="sxs-lookup"><span data-stu-id="22674-261">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="22674-262">A `VariableReference`je implementace vyhledává názvu proměnné ve slovníku a vrátí výslednou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="22674-262">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="22674-263">`Operation`Na implementaci nejprve vyhodnotí operandy vlevo a vpravo (vyvoláním rekurzivně jejich `Evaluate` metody) a potom provede daný aritmetické operace.</span><span class="sxs-lookup"><span data-stu-id="22674-263">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="22674-264">Tento program používá `Expression` třídy při vyhodnocování výrazu `x * (y + 2)` pro různé hodnoty `x` a `y`.</span><span class="sxs-lookup"><span data-stu-id="22674-264">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="22674-265">Přetěžování metody</span><span class="sxs-lookup"><span data-stu-id="22674-265">Method overloading</span></span>

<span data-ttu-id="22674-266">Metoda *přetížení* umožňuje několika metod ve stejné třídě do mají stejný název, dokud mají jedinečné podpisy.</span><span class="sxs-lookup"><span data-stu-id="22674-266">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="22674-267">Při kompilování k vyvolání přetížené metody, kompilátor použije *rozlišení přetěžování* určit konkrétní metody vyvolání.</span><span class="sxs-lookup"><span data-stu-id="22674-267">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="22674-268">Řešení přetížení vyhledá jednu metodu, nejlépe odpovídá argumenty nebo nahlásí chybu, pokud lze nalézt žádné jeden nejlepší shodu.</span><span class="sxs-lookup"><span data-stu-id="22674-268">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="22674-269">Následující příklad ukazuje rozlišení přetížení v platnosti.</span><span class="sxs-lookup"><span data-stu-id="22674-269">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="22674-270">Komentář pro každé vyvolání v `Main` metoda ukazuje, jakou metodu je ve skutečnosti vyvolat.</span><span class="sxs-lookup"><span data-stu-id="22674-270">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="22674-271">Jak ukazuje příklad, konkrétní metody lze vybrat vždy explicitně přetypování argumenty, které mají typy přesný parametrů nebo explicitně zadávání argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="22674-271">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="22674-272">Jiní členové – funkce</span><span class="sxs-lookup"><span data-stu-id="22674-272">Other function members</span></span>

<span data-ttu-id="22674-273">Členové, které obsahují spustitelného kódu, které se souhrnně označují jako *funkce členy* třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-273">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="22674-274">Předchozí část popisuje postupy, které se primární druh funkce členy.</span><span class="sxs-lookup"><span data-stu-id="22674-274">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="22674-275">Tato část popisuje typy členů funkce podporované v jazyce C#: konstruktory, vlastnosti, indexery, události, operátory a finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="22674-275">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="22674-276">Následující příklad zobrazuje obecný třídu s názvem seznamu<T>, který implementuje growable seznam objektů.</span><span class="sxs-lookup"><span data-stu-id="22674-276">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="22674-277">Třída obsahuje několik příkladů nejběžnější druhy funkce členů.</span><span class="sxs-lookup"><span data-stu-id="22674-277">The class contains several examples of the most common kinds of function members.</span></span>

[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="22674-278">Konstruktory</span><span class="sxs-lookup"><span data-stu-id="22674-278">Constructors</span></span>

<span data-ttu-id="22674-279">C# podporuje instance a statických konstruktorů.</span><span class="sxs-lookup"><span data-stu-id="22674-279">C# supports both instance and static constructors.</span></span> <span data-ttu-id="22674-280">*Konstruktoru instance* je člen, který implementuje akce potřebné k inicializaci instance třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-280">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="22674-281">A *statického konstruktoru* je člen, který implementuje akce potřebné k inicializaci třídy samotné při prvním načtení.</span><span class="sxs-lookup"><span data-stu-id="22674-281">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="22674-282">Konstruktor je deklarován jako metodu s žádný návratový typ a stejný název jako obsahující třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-282">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="22674-283">Pokud deklaraci konstruktor obsahuje statický modifikátor, deklaruje statického konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="22674-283">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="22674-284">Jinak deklaruje konstruktoru instance.</span><span class="sxs-lookup"><span data-stu-id="22674-284">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="22674-285">Konstruktory instancí mohou být přetíženy a můžou mít volitelné parametry.</span><span class="sxs-lookup"><span data-stu-id="22674-285">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="22674-286">Například `List<T>` třída deklaruje dva konstruktory instancí, s žádné parametry a ten, který přebírá `int` parametr.</span><span class="sxs-lookup"><span data-stu-id="22674-286">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="22674-287">Konstruktory instancí jsou vyvolány pomocí `new` operátor.</span><span class="sxs-lookup"><span data-stu-id="22674-287">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="22674-288">Následující příkazy přidělit dvě `List<string>` instance pomocí konstruktoru `List` třídy a bez nepovinný argument.</span><span class="sxs-lookup"><span data-stu-id="22674-288">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="22674-289">Na rozdíl od jiných členů nejsou zděděné konstruktory instancí a třída nemá žádné instance konstruktory než ty ve skutečnosti deklarované v třídě.</span><span class="sxs-lookup"><span data-stu-id="22674-289">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="22674-290">Pokud je zadaný žádný konstruktor instance pro třídu, pak prázdnou bez parametrů je automaticky zadáno.</span><span class="sxs-lookup"><span data-stu-id="22674-290">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="22674-291">Vlastnosti</span><span class="sxs-lookup"><span data-stu-id="22674-291">Properties</span></span>

<span data-ttu-id="22674-292">*Vlastnosti* jsou přirozené rozšíření polí.</span><span class="sxs-lookup"><span data-stu-id="22674-292">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="22674-293">Obě jsou pojmenované členy s přidružené typy a syntaxe pro přístup k pole a vlastnosti je stejný.</span><span class="sxs-lookup"><span data-stu-id="22674-293">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="22674-294">Na rozdíl od pole, ale vlastnosti není označují umístění úložiště.</span><span class="sxs-lookup"><span data-stu-id="22674-294">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="22674-295">Místo toho vlastnosti mají *přístupové objekty* , zadejte příkazy, které budou spuštěny při jejich hodnoty jsou číst nebo zapisovat.</span><span class="sxs-lookup"><span data-stu-id="22674-295">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="22674-296">Vlastnost je deklarován jako pole, s tím rozdílem, že deklaraci končí přistupující objekt get nebo přistupující objekt set zapsána mezi oddělovače `{` a `}` místo končící na středníkem.</span><span class="sxs-lookup"><span data-stu-id="22674-296">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="22674-297">Je vlastnost, která má přistupující objekt get a přistupující objekt set *pro čtení a zápis vlastnost*, je vlastnost, která má pouze přistupující *vlastnost určenou jen pro čtení*, a vlastnost, která má pouze přistupujícím objektem set *vlastnost jen pro zápis*.</span><span class="sxs-lookup"><span data-stu-id="22674-297">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="22674-298">Přistupující objekt get odpovídá bez parametrů metody s hodnotou návratový typ vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="22674-298">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="22674-299">S výjimkou jako cíl přiřazení, při odkazování na vlastnost ve výrazu, přistupující objekt get vlastnosti je vyvolána k výpočtu hodnoty vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="22674-299">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="22674-300">Přistupující objekt set odpovídá pomocí jediného parametru s názvem hodnota a žádný návratový typ metody.</span><span class="sxs-lookup"><span data-stu-id="22674-300">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="22674-301">Když se vlastnost odkazuje jako cílem přiřazení nebo jako operand ++ a--, přistupující objekt set volána s argumentem, který poskytuje novou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="22674-301">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="22674-302">`List<T>` Třída deklaruje dvě vlastnosti, počtu a kapacity, které jsou jen pro čtení a pro čtení a zápis, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="22674-302">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="22674-303">Následuje příklad použití těchto vlastností.</span><span class="sxs-lookup"><span data-stu-id="22674-303">The following is an example of use of these properties.</span></span>

[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="22674-304">Podobně jako u pole a metody, C# podporuje vlastnosti instance i statické vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="22674-304">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="22674-305">Statické vlastnosti, které jsou deklarovány s statický modifikátor a vlastnosti instance jsou deklarované bez ní.</span><span class="sxs-lookup"><span data-stu-id="22674-305">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="22674-306">Accessor(s) vlastnosti může být virtuální.</span><span class="sxs-lookup"><span data-stu-id="22674-306">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="22674-307">Pokud deklarace vlastnosti zahrnuje `virtual`, `abstract`, nebo `override` modifikátor, se vztahuje na accessor(s) vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="22674-307">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="22674-308">Indexery</span><span class="sxs-lookup"><span data-stu-id="22674-308">Indexers</span></span>

<span data-ttu-id="22674-309">*Indexer* je člen, který umožňuje objekty indexovaných stejným způsobem jako pole.</span><span class="sxs-lookup"><span data-stu-id="22674-309">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="22674-310">Indexer je deklarován jako vlastnost s tím rozdílem, že název člena je to následovaný seznamem parametr zapsána mezi oddělovače `[` a `]`.</span><span class="sxs-lookup"><span data-stu-id="22674-310">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="22674-311">Parametry jsou k dispozici v accessor(s) indexeru.</span><span class="sxs-lookup"><span data-stu-id="22674-311">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="22674-312">Podobně jako u vlastnosti, indexery může být pro čtení a zápis, jen pro čtení a jen pro zápis, a accessor(s) indexer může být virtuální.</span><span class="sxs-lookup"><span data-stu-id="22674-312">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="22674-313">`List` Třída deklaruje jednu indexeru pro čtení a zápis, který přebírá `int` parametr.</span><span class="sxs-lookup"><span data-stu-id="22674-313">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="22674-314">Indexer umožňuje indexu `List` instance s `int` hodnoty.</span><span class="sxs-lookup"><span data-stu-id="22674-314">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="22674-315">Příklad:</span><span class="sxs-lookup"><span data-stu-id="22674-315">For example:</span></span>

[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="22674-316">Indexery mohou být přetíženy, což znamená, že třídu můžou deklarovat několik indexerů tak dlouho, dokud číslo nebo typy jejich parametrů se liší.</span><span class="sxs-lookup"><span data-stu-id="22674-316">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="22674-317">Události</span><span class="sxs-lookup"><span data-stu-id="22674-317">Events</span></span>

<span data-ttu-id="22674-318">*Událostí* je člen, který umožňuje třídu nebo objekt, který chcete poskytnout oznámení.</span><span class="sxs-lookup"><span data-stu-id="22674-318">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="22674-319">Událost je deklarován jako pole s tím rozdílem, že deklarace obsahuje event – klíčové slovo a typ musí být typu delegáta.</span><span class="sxs-lookup"><span data-stu-id="22674-319">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="22674-320">V rámci třídy, který deklaruje člen události události se chová stejně jako pole typu delegáta (za předpokladu událost není abstraktní a nedeklaruje přístupových objektů).</span><span class="sxs-lookup"><span data-stu-id="22674-320">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="22674-321">Pole ukládá odkaz na delegáta, který představuje obslužné rutiny událostí, které byly přidány k události.</span><span class="sxs-lookup"><span data-stu-id="22674-321">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="22674-322">Pokud nejsou žádné obslužné rutiny událostí, je pole `null`.</span><span class="sxs-lookup"><span data-stu-id="22674-322">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="22674-323">`List<T>` Třída deklaruje jednu událost člena s názvem `Changed`, což naznačuje, že byl přidán do seznamu novou položku.</span><span class="sxs-lookup"><span data-stu-id="22674-323">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="22674-324">Změněno událost vyvolána pomocí `OnChanged` virtuální metoda, která první zkontroluje, zda je událost `null` (což znamená, že jsou k dispozici žádné obslužné rutiny).</span><span class="sxs-lookup"><span data-stu-id="22674-324">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="22674-325">Znalost problematicky vyvolání události přesněji odpovídá k vyvolání delegáta reprezentována událost – proto nejsou žádné zvláštní jazykové konstrukty pro vyvolávání událostí.</span><span class="sxs-lookup"><span data-stu-id="22674-325">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="22674-326">Klienti reagování na události prostřednictvím *obslužné rutiny událostí*.</span><span class="sxs-lookup"><span data-stu-id="22674-326">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="22674-327">Obslužné rutiny událostí jsou připojené pomocí `+=` operátor a odebrané pomocí `-=` operátor.</span><span class="sxs-lookup"><span data-stu-id="22674-327">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="22674-328">Následující příklad připojí obslužnou rutinu události a `Changed` události `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="22674-328">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="22674-329">Pro pokročilé scénáře, kde je žádoucí ovládací prvek základní úložiště události, může být explicitně deklaraci události `add` a `remove` přístupové objekty, které jsou částečně podobá `set` přistupujícího objektu vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="22674-329">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="22674-330">Operátory</span><span class="sxs-lookup"><span data-stu-id="22674-330">Operators</span></span>

<span data-ttu-id="22674-331">*Operátor* je člen, který určuje význam použití operátoru konkrétní výraz do instance třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-331">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="22674-332">Je možné definovat tři druhy operátory: unární operátory, binární operátory a operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="22674-332">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="22674-333">Všechny operátory musí být deklarována jako `public` a `static`.</span><span class="sxs-lookup"><span data-stu-id="22674-333">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="22674-334">`List<T>` Třída deklaruje dva operátory `operator ==` a `operator !=`a proto nabízí nové význam výrazy, které se vztahují tyto operátory `List` instance.</span><span class="sxs-lookup"><span data-stu-id="22674-334">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="22674-335">Konkrétně definování operátory rovnosti dvou `List<T>` instance jako porovnávání všechny obsažené objekty pomocí své metody rovná se.</span><span class="sxs-lookup"><span data-stu-id="22674-335">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="22674-336">Následující příklad používá `==` operátor k porovnání dvou `List<int>` instance.</span><span class="sxs-lookup"><span data-stu-id="22674-336">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="22674-337">První `Console.WriteLine` výstupy `True` vzhledem k tomu, že dva seznamy obsahovat stejný počet objektů se stejnými hodnotami ve stejném pořadí.</span><span class="sxs-lookup"><span data-stu-id="22674-337">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="22674-338">Měl `List<T>` není definována `operator ==`, první `Console.WriteLine` by být výstupu `False` protože `a` a `b` odkaz na jiný `List<int>` instance.</span><span class="sxs-lookup"><span data-stu-id="22674-338">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="22674-339">Finalizační metody</span><span class="sxs-lookup"><span data-stu-id="22674-339">Finalizers</span></span>

<span data-ttu-id="22674-340">A *finalizační metodu* je člen, který implementuje akcí požadovaných pro dokončení instance třídy.</span><span class="sxs-lookup"><span data-stu-id="22674-340">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="22674-341">Finalizační metody nemohou mít parametry, nemohou mít modifikátory dostupnosti a nemůže být explicitně volána.</span><span class="sxs-lookup"><span data-stu-id="22674-341">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="22674-342">Finalizační metodu pro instance je vyvolána automaticky během uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="22674-342">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="22674-343">Uvolňování paměti je povoleno široké zeměpisnou šířku při rozhodování, kdy se mají shromažďovat objekty a spustit finalizační metody.</span><span class="sxs-lookup"><span data-stu-id="22674-343">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="22674-344">Konkrétně načasování finalizační metodu volání není deterministický a finalizační metody mohou být spouštěny žádné přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="22674-344">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="22674-345">Pro tyto a z jiných důvodů by měla třídy implementovat finalizační metody jenom v případě, že jsou vhodná žádná jiná řešení.</span><span class="sxs-lookup"><span data-stu-id="22674-345">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="22674-346">`using` Příkaz poskytuje lepší přístup k odstranění objektu.</span><span class="sxs-lookup"><span data-stu-id="22674-346">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="22674-347">[Předchozí](statements.md)
[další](structs.md)</span><span class="sxs-lookup"><span data-stu-id="22674-347">[Previous](statements.md)
[Next](structs.md)</span></span>
