---
title: "Řazené kolekce členů – průvodce v C#"
description: "Další informace o typech pojmenované a nepojmenované řazené kolekce členů v jazyce C#"
keywords: "Rozhraní .NET, rozhraní .NET core, C#"
author: BillWagner
ms-author: wiwagn
ms.date: 11/23/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 58f76332a8f3717fe10788382552598d6693e7e3
ms.sourcegitcommit: 882e02b086d7cb9c75f748494cf7a8d3377c5874
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/17/2017
---
# <a name="c-tuple-types"></a><span data-ttu-id="a256f-104">Typy řazené kolekce členů C#</span><span class="sxs-lookup"><span data-stu-id="a256f-104">C# Tuple types</span></span> #

<span data-ttu-id="a256f-105">C# řazených kolekcí členů jsou typy, které definujete pomocí jednoduché syntaxe.</span><span class="sxs-lookup"><span data-stu-id="a256f-105">C# Tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="a256f-106">Výhody zahrnují jednodušší syntaxe, pravidla pro převody na základě číslo (označované jako mohutnost) a typy elementů a konzistentní pravidla pro kopie a přiřazení.</span><span class="sxs-lookup"><span data-stu-id="a256f-106">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies and assignments.</span></span> <span data-ttu-id="a256f-107">Jako kompromis řazené kolekce členů nepodporují některé idioms objektově orientované přidružené dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="a256f-107">As a tradeoff, Tuples do not support some of the object oriented idioms associated with inheritance.</span></span> <span data-ttu-id="a256f-108">V části můžete získat přehled [řazených kolekcí členů v co je nového v C# 7](whats-new/csharp-7.md#tuples) tématu.</span><span class="sxs-lookup"><span data-stu-id="a256f-108">You can get an overview in the section on [Tuples in the What's new in C# 7](whats-new/csharp-7.md#tuples) topic.</span></span>

<span data-ttu-id="a256f-109">V tomto tématu se dozvíte jazyk pravidla pro řazených kolekcí členů v C# 7, různé způsoby použití je a počáteční pokyny o práci s řazenými kolekcemi členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-109">In this topic, you'll learn the language rules governing Tuples in C# 7, different ways to use them, and initial guidance on working with Tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="a256f-110">Vyžadovat nové funkce řazených kolekcí členů <xref:System.ValueTuple> typy.</span><span class="sxs-lookup"><span data-stu-id="a256f-110">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="a256f-111">Je nutné přidat balíček NuGet [ `System.ValueTuple` ](https://www.nuget.org/packages/System.ValueTuple/) odborných na platformách, které neobsahují typy.</span><span class="sxs-lookup"><span data-stu-id="a256f-111">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="a256f-112">Toto je podobná jiné jazykové funkce, které závisí na typech doručit v rámci.</span><span class="sxs-lookup"><span data-stu-id="a256f-112">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="a256f-113">Mezi příklady patří `async` a `await` spoléhat na `INotifyCompletion` rozhraní a LINQ spoléhat na `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="a256f-113">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="a256f-114">Jak .NET se stává stále další platformy, které jsou nezávislé, mechanismus doručování mění.</span><span class="sxs-lookup"><span data-stu-id="a256f-114">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="a256f-115">Rozhraní .NET Framework nemusí vždy dodávat na stejné cadence jako kompilátor jazyka.</span><span class="sxs-lookup"><span data-stu-id="a256f-115">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="a256f-116">Nové jazykové funkce využívají nové typy, tyto typy nebudou mít k dispozici jako balíčků NuGet při odeslání funkce jazyka.</span><span class="sxs-lookup"><span data-stu-id="a256f-116">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="a256f-117">Tyto nové typy získat přidávají do rozhraní API .NET standardní a dodávána jako součást rozhraní, požadavek na balíček NuGet se odeberou.</span><span class="sxs-lookup"><span data-stu-id="a256f-117">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="a256f-118">Začněme důvody pro přidání nové podpory řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-118">Let's start with the reasons for adding new Tuple support.</span></span> <span data-ttu-id="a256f-119">Metody vrací jeden objekt.</span><span class="sxs-lookup"><span data-stu-id="a256f-119">Methods return a single object.</span></span> <span data-ttu-id="a256f-120">Řazené kolekce členů umožňují snadněji balíček více hodnot v jednom objektu.</span><span class="sxs-lookup"><span data-stu-id="a256f-120">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="a256f-121">Rozhraní .NET Framework již má obecný `Tuple` třídy.</span><span class="sxs-lookup"><span data-stu-id="a256f-121">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="a256f-122">Tyto třídy, ale měl dvě hlavní omezení.</span><span class="sxs-lookup"><span data-stu-id="a256f-122">These classes, however, had two major limitations.</span></span> <span data-ttu-id="a256f-123">Pro jeden `Tuple` třídy s názvem jejich vlastnosti `Item1`, `Item2`a tak dále.</span><span class="sxs-lookup"><span data-stu-id="a256f-123">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="a256f-124">Tyto názvy provádění žádné sémantické informace.</span><span class="sxs-lookup"><span data-stu-id="a256f-124">Those names carry no semantic information.</span></span> <span data-ttu-id="a256f-125">Použití těchto `Tuple` typy neumožňuje komunikaci význam každé z vlastností.</span><span class="sxs-lookup"><span data-stu-id="a256f-125">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="a256f-126">Mezi nové jazykové funkce umožňují deklarování a použití sémanticky smysluplné názvy pro elementy v řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-126">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="a256f-127">Jiný problém je, že `Tuple` třídy jsou odkazové typy.</span><span class="sxs-lookup"><span data-stu-id="a256f-127">Another concern is that the `Tuple` classes are reference types.</span></span> <span data-ttu-id="a256f-128">Pomocí jedné z `Tuple` typy znamená přidělování objektů.</span><span class="sxs-lookup"><span data-stu-id="a256f-128">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="a256f-129">V aktivní cesty to může být měřitelný dopad na výkon vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="a256f-129">On hot paths, this can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="a256f-130">Proto využívá nové jazyková podpora pro řazené kolekce členů `ValueTuple` struktury.</span><span class="sxs-lookup"><span data-stu-id="a256f-130">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="a256f-131">Abyste se vyhnuli tyto nedostatky, můžete vytvořit `class` nebo `struct` k provedení více elementů.</span><span class="sxs-lookup"><span data-stu-id="a256f-131">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="a256f-132">Bohužel se více práce pro uživatele a zakrývá vašich představ návrhu.</span><span class="sxs-lookup"><span data-stu-id="a256f-132">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="a256f-133">Vytváření `struct` nebo `class` znamená, že definujete typu s daty a chování.</span><span class="sxs-lookup"><span data-stu-id="a256f-133">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="a256f-134">Kolikrát jednoduše chcete uložit více hodnot v jednom objektu.</span><span class="sxs-lookup"><span data-stu-id="a256f-134">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="a256f-135">Funkce jazyka a `ValueTuple` obecné struktury vynutit pravidla, že není možné přidat žádné chování (metody) pro tyto typy řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-135">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="a256f-136">Všechny `ValueTuple` typy jsou *měnitelný struktury*.</span><span class="sxs-lookup"><span data-stu-id="a256f-136">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="a256f-137">Každý člen pole je veřejná pole.</span><span class="sxs-lookup"><span data-stu-id="a256f-137">Each member field is a public field.</span></span> <span data-ttu-id="a256f-138">Který umožní jejich velmi jednoduché.</span><span class="sxs-lookup"><span data-stu-id="a256f-138">That makes them very lightweight.</span></span> <span data-ttu-id="a256f-139">Ale, to znamená, že by se neměla používat řazených kolekcí členů kde neměnitelnosti je důležité.</span><span class="sxs-lookup"><span data-stu-id="a256f-139">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="a256f-140">Řazené kolekce členů jsou obě kontejnery data jednodušší a flexibilnější než `class` a `struct` typy.</span><span class="sxs-lookup"><span data-stu-id="a256f-140">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="a256f-141">Podíváme se na tyto rozdíly.</span><span class="sxs-lookup"><span data-stu-id="a256f-141">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="a256f-142">Pojmenované a nepojmenované řazených kolekcí členů</span><span class="sxs-lookup"><span data-stu-id="a256f-142">Named and unnamed tuples</span></span>

<span data-ttu-id="a256f-143">`ValueTuple` Struktura má pole s názvem `Item1`, `Item2`, `Item3` a tak dále, podobně jako vlastnosti definované ve stávající `Tuple` typy.</span><span class="sxs-lookup"><span data-stu-id="a256f-143">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3` and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="a256f-144">Tyto názvy jsou pouze názvy, které můžete použít pro *nepojmenované řazených kolekcí členů*.</span><span class="sxs-lookup"><span data-stu-id="a256f-144">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="a256f-145">Pokud nezadáte žádné pole alternativní názvy pro řazené kolekce členů, jste vytvořili nepojmenované řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="a256f-145">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="a256f-146">Řazené kolekce členů v předchozím příkladu byla inicializována pomocí literálu konstanty a nebude mít názvy elementů vytvořený *řazené kolekce členů pole Název projekce* v C# 7.1.</span><span class="sxs-lookup"><span data-stu-id="a256f-146">The tuple in the previous example was initialized using literal constants and won't have element names created using *Tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="a256f-147">Při inicializaci řazené kolekce členů, ale můžete použít nové jazykové funkce, která umožňují lepší názvy pro každé pole.</span><span class="sxs-lookup"><span data-stu-id="a256f-147">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="a256f-148">Tím vytvoříte *s názvem řazené kolekce členů*.</span><span class="sxs-lookup"><span data-stu-id="a256f-148">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="a256f-149">Pojmenované řazených kolekcí členů ještě elementů s názvem `Item1`, `Item2`, `Item3` a tak dále.</span><span class="sxs-lookup"><span data-stu-id="a256f-149">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="a256f-150">Ale mají také synonyma pro některý z těchto elementů, které mají pojmenované.</span><span class="sxs-lookup"><span data-stu-id="a256f-150">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="a256f-151">Vytvoříte tak, že zadáte názvy pro každý prvek s názvem řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-151">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="a256f-152">Jedním ze způsobů je zadejte názvy během inicializace řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="a256f-152">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="a256f-153">Tyto synonyma jsou zpracovávány kompilátoru a jazyk, aby můžete použít název řazených kolekcí členů efektivně.</span><span class="sxs-lookup"><span data-stu-id="a256f-153">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="a256f-154">Názvy těchto sémantického pomocí rozhraní API Roslyn může číst integrovaného vývojového prostředí a editory.</span><span class="sxs-lookup"><span data-stu-id="a256f-154">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="a256f-155">To umožňuje-elementů s názvem řazené kolekce členů podle těchto sémantického názvy kdekoli ve stejném sestavení.</span><span class="sxs-lookup"><span data-stu-id="a256f-155">This enables you to reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="a256f-156">Kompilátor nahradí názvy, které jste definovali s `Item*` ekvivalenty při generování kompilovaný výstup.</span><span class="sxs-lookup"><span data-stu-id="a256f-156">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="a256f-157">Kompilované Microsoft zprostředkující jazyk (MSIL) nezahrnuje názvy dali těchto elementů.</span><span class="sxs-lookup"><span data-stu-id="a256f-157">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="a256f-158">Od verze 7.1 C#, mohou být poskytovány názvy polí pro řazené kolekce členů z proměnných, které slouží k chybě při inicializaci řazenou kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-158">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="a256f-159">Tento proces se označuje jako  **[řazené kolekce členů projekce inicializátory](#tuple-projection-initializers)**.</span><span class="sxs-lookup"><span data-stu-id="a256f-159">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="a256f-160">Následující kód vytvoří řazené kolekce členů s názvem `accumulation` elementy `count` (celé číslo), a `sum` (dvojitou).</span><span class="sxs-lookup"><span data-stu-id="a256f-160">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="a256f-161">Kompilátor musí komunikovat tyto názvy, který jste vytvořili pro řazené kolekce členů, které jsou vráceny z veřejné metody nebo vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="a256f-161">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="a256f-162">V takových případech přidá kompilátor <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> atribut na metodu.</span><span class="sxs-lookup"><span data-stu-id="a256f-162">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="a256f-163">Tento atribut obsahuje <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> seznamu vlastnost, která obsahuje názvy zadané pro jednotlivé elementy v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-163">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the Tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="a256f-164">Vývojářské nástroje, jako je například Visual Studio, taky číst aby metadata a poskytnout IntelliSense a další funkce pomocí názvů polí metadat.</span><span class="sxs-lookup"><span data-stu-id="a256f-164">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="a256f-165">Je důležité si uvědomit, tyto základní základní informace o nové řazené kolekce členů a `ValueTuple` typu, chcete-li pochopit pravidla pro přiřazování s názvem řazených kolekcí členů k sobě navzájem.</span><span class="sxs-lookup"><span data-stu-id="a256f-165">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="a256f-166">Inicializátory projekce řazené kolekce členů</span><span class="sxs-lookup"><span data-stu-id="a256f-166">Tuple projection initializers</span></span>

<span data-ttu-id="a256f-167">Obecně platí řazené kolekce členů projekce inicializátory fungovat pomocí názvů pole nebo proměnné z pravé strany příkaz inicializace řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-167">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="a256f-168">Pokud je zadána explicitní název, který má přednost před libovolný předpokládané název.</span><span class="sxs-lookup"><span data-stu-id="a256f-168">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="a256f-169">Například v následujícím inicializátoru jsou elementy `explicitFieldOne` a `explicitFieldTwo`, nikoli `localVariableOne` a `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="a256f-169">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="a256f-170">Pro každé pole, kde není zadaný explicitní název bude k dispozici implicitní název promítat.</span><span class="sxs-lookup"><span data-stu-id="a256f-170">For any field where an explicit name is not provided, an applicable implicit name will be projected.</span></span> <span data-ttu-id="a256f-171">Všimněte si, že je nutné poskytnout sémantického názvy explicitně nebo implicitně.</span><span class="sxs-lookup"><span data-stu-id="a256f-171">Note that there is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="a256f-172">Následující inicializátoru budou mít názvy polí `Item1`, jehož hodnota je `42` a `StringContent`, jehož hodnota je "Odpověď na všechno":</span><span class="sxs-lookup"><span data-stu-id="a256f-172">The following initializer will have field names `Item1`, whose value is `42` and `StringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="a256f-173">Existují dvě podmínky, které nejsou názvy polí candidate promítnuta na pole řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="a256f-173">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="a256f-174">Pokud název candidate je název vyhrazené řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-174">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="a256f-175">Mezi příklady patří `Item3`, `ToString` nebo `Rest`.</span><span class="sxs-lookup"><span data-stu-id="a256f-175">Examples include `Item3`, `ToString` or `Rest`.</span></span>
1. <span data-ttu-id="a256f-176">Pokud je název candidate duplicitní jiný název pole řazené kolekce členů, explicitní nebo implicitní.</span><span class="sxs-lookup"><span data-stu-id="a256f-176">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="a256f-177">Tyto podmínky zabránilo nejednoznačnosti.</span><span class="sxs-lookup"><span data-stu-id="a256f-177">These conditions avoid ambiguity.</span></span> <span data-ttu-id="a256f-178">Tyto názvy by způsobilo to nejednoznačnost, pokud byly použity jako názvy polí pro pole v řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-178">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="a256f-179">Žádná z těchto podmínek způsobit kompilace čas chyby.</span><span class="sxs-lookup"><span data-stu-id="a256f-179">Neither of these conditions cause compile time errors.</span></span> <span data-ttu-id="a256f-180">Místo toho elementy bez předpokládané názvy nemají sémantického názvy pro ně k projekci.</span><span class="sxs-lookup"><span data-stu-id="a256f-180">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="a256f-181">Následující příklady ukazují tyto podmínky:</span><span class="sxs-lookup"><span data-stu-id="a256f-181">The following examples demonstrate these conditions:</span></span>

[!code-csharp[Ambiguity](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="a256f-182">V takových situacích nezpůsobí chyby kompilátoru, protože který by byl narušující změně kódu, které jsou napsané v C# 7.0, když řazené kolekce členů pole Název projekce nebyly dostupné.</span><span class="sxs-lookup"><span data-stu-id="a256f-182">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="a256f-183">Přiřazení a řazených kolekcí členů</span><span class="sxs-lookup"><span data-stu-id="a256f-183">Assignment and tuples</span></span>

<span data-ttu-id="a256f-184">Jazyk podporuje přiřazení mezi typy řazené kolekce členů, které mají stejný počet elementů a implicitní převody typů pro každou z těchto elementů.</span><span class="sxs-lookup"><span data-stu-id="a256f-184">The language supports assignment between tuple types that have the same number of elements and implicit conversions for the types for each of those elements.</span></span> <span data-ttu-id="a256f-185">Jiné převody nejsou považovány za přiřazení.</span><span class="sxs-lookup"><span data-stu-id="a256f-185">Other conversions are not considered for assignments.</span></span> <span data-ttu-id="a256f-186">Podívejme se na druhy přiřazení, které jsou povoleny mezi typy řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-186">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="a256f-187">Vezměte v úvahu tyto proměnné použít v následujících příkladech:</span><span class="sxs-lookup"><span data-stu-id="a256f-187">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="a256f-188">První dvě proměnné, `unnamed` a `anonymous` nemají sémantického názvy zadané pro elementy.</span><span class="sxs-lookup"><span data-stu-id="a256f-188">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="a256f-189">Názvy polí jsou `Item1` a `Item2`.</span><span class="sxs-lookup"><span data-stu-id="a256f-189">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="a256f-190">Poslední dvě proměnné, `named` a `differentName` sémantického názvy zadané pro elementy.</span><span class="sxs-lookup"><span data-stu-id="a256f-190">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="a256f-191">Všimněte si, že tyto dvě řazené kolekce členů mají odlišné názvy pro elementy.</span><span class="sxs-lookup"><span data-stu-id="a256f-191">Note that these two tuples have different names for the elements.</span></span>

<span data-ttu-id="a256f-192">Všechny čtyři tyto řazené kolekce členů mají stejný počet elementů (označované jako 'mohutnost') a jsou identické typy těchto elementů.</span><span class="sxs-lookup"><span data-stu-id="a256f-192">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="a256f-193">Proto všechny tyto přiřazení fungovat:</span><span class="sxs-lookup"><span data-stu-id="a256f-193">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="a256f-194">Všimněte si, že nejsou přiřazeny názvy řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-194">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="a256f-195">Hodnoty elementů jsou přiřazeny následující pořadí prvků v řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-195">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="a256f-196">Řazené kolekce členů různé typy nebo počtem elementů nejsou přiřadit:</span><span class="sxs-lookup"><span data-stu-id="a256f-196">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="a256f-197">Řazené kolekce členů jako metodu návratové hodnoty</span><span class="sxs-lookup"><span data-stu-id="a256f-197">Tuples as method return values</span></span>

<span data-ttu-id="a256f-198">Jednou z nejběžnějších použití řazených kolekcí členů je jako návratová hodnota metody.</span><span class="sxs-lookup"><span data-stu-id="a256f-198">One of the most common uses for Tuples is as a method return value.</span></span> <span data-ttu-id="a256f-199">Projděme jedním z příkladů.</span><span class="sxs-lookup"><span data-stu-id="a256f-199">Let's walk through one example.</span></span> <span data-ttu-id="a256f-200">Vezměte v úvahu tuto metodu, která vypočítá směrodatnou odchylku sekvenci čísla:</span><span class="sxs-lookup"><span data-stu-id="a256f-200">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="a256f-201">Tyto příklady výpočetní směrodatná odchylka neopravené vzorku.</span><span class="sxs-lookup"><span data-stu-id="a256f-201">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="a256f-202">Vzorec směrodatné odchylky vzorku opravené by rozdělení součet kvadratických odchylek od střední podle (N-1) namísto N, jako `Average` rozšíření metoda nepodporuje.</span><span class="sxs-lookup"><span data-stu-id="a256f-202">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="a256f-203">Další informace o rozdílech mezi tyto vzorce pro směrodatnou odchylku najdete statistiky text.</span><span class="sxs-lookup"><span data-stu-id="a256f-203">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="a256f-204">To odpovídá učebnice vzorec směrodatné odchylky.</span><span class="sxs-lookup"><span data-stu-id="a256f-204">This follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="a256f-205">Vyvolá správnou odpověď, ale je velmi neefektivní implementace.</span><span class="sxs-lookup"><span data-stu-id="a256f-205">It produces the correct answer, but it's a very inefficient implementation.</span></span> <span data-ttu-id="a256f-206">Tato metoda vytvoří výčet sekvenci dvakrát: jednou k vytvoření průměr a jednou k vytvoření průměr druhou mocninu rozdíl průměru.</span><span class="sxs-lookup"><span data-stu-id="a256f-206">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="a256f-207">(Nezapomeňte, že dotazů LINQ vyhodnocují líné, tak výpočet rozdíl oproti střední a průměr těchto rozdílů je pouze jeden výčet.)</span><span class="sxs-lookup"><span data-stu-id="a256f-207">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="a256f-208">Neexistuje alternativní vzorec, která vypočítá směrodatnou odchylku pomocí pouze jeden výčet pořadí.</span><span class="sxs-lookup"><span data-stu-id="a256f-208">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="a256f-209">Tento výpočet vytvoří dvě hodnoty při výčtu sekvenci: součet všechny položky v pořadí a součet každá hodnota spolehlivosti:</span><span class="sxs-lookup"><span data-stu-id="a256f-209">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="a256f-210">Tato verze zobrazí sekvenci právě jednou.</span><span class="sxs-lookup"><span data-stu-id="a256f-210">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="a256f-211">Ale není velmi opakovaně použitelný kód.</span><span class="sxs-lookup"><span data-stu-id="a256f-211">But, it's not very reusable code.</span></span> <span data-ttu-id="a256f-212">Jak můžete pokračovat v práci, zjistíte, že mnoho různých statistické výpočty používat počet položek v sekvenci, součet pořadí a součet kvadratických pořadí.</span><span class="sxs-lookup"><span data-stu-id="a256f-212">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="a256f-213">Pojďme Refaktorovat tuto metodu a zápis nástroj metoda, která vytváří všechny tři tyto hodnoty.</span><span class="sxs-lookup"><span data-stu-id="a256f-213">Let's refactor this method and write a utility method that produces all three of those values.</span></span>

<span data-ttu-id="a256f-214">Toto je, kde řazených kolekcí členů mají velmi užitečné.</span><span class="sxs-lookup"><span data-stu-id="a256f-214">This is where tuples come in very useful.</span></span> 

<span data-ttu-id="a256f-215">Umožňuje aktualizovat tuto metodu tak tři hodnoty počítaný během výčtu jsou uloženy v řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-215">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="a256f-216">Tato verze vytvářející:</span><span class="sxs-lookup"><span data-stu-id="a256f-216">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="a256f-217">Visual Studio Refactoring podpora snadno rozbalte funkce pro základní statistiky do soukromá metoda.</span><span class="sxs-lookup"><span data-stu-id="a256f-217">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="a256f-218">Toto vám `private static` metodu, která vrátí typ řazené kolekce členů s tři hodnoty `Sum`, `SumOfSquares`, a `Count`:</span><span class="sxs-lookup"><span data-stu-id="a256f-218">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]
 
<span data-ttu-id="a256f-219">Jazyk umožňuje několik další možnosti, které můžete použít, pokud chcete, aby několik rychlé úpravy ručně.</span><span class="sxs-lookup"><span data-stu-id="a256f-219">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="a256f-220">První, můžete použít `var` deklarace k chybě při inicializaci výsledek řazené kolekce členů z `ComputeSumAndSumOfSquares` volání metody.</span><span class="sxs-lookup"><span data-stu-id="a256f-220">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="a256f-221">Můžete také vytvořit tři proměnné diskrétní uvnitř `ComputeSumAndSumOfSquares` metoda.</span><span class="sxs-lookup"><span data-stu-id="a256f-221">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="a256f-222">Finální verzi je nižší než:</span><span class="sxs-lookup"><span data-stu-id="a256f-222">The final version is below:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="a256f-223">Tento poslední verze slouží pro libovolné metody, která vyžaduje tyto tři hodnoty, nebo jakékoli některé z nich.</span><span class="sxs-lookup"><span data-stu-id="a256f-223">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="a256f-224">Jazyk podporuje další možnosti ve správě názvy elementů v těchto metod vrací řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-224">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="a256f-225">Můžete odebrat z návratovou hodnotu deklarace názvy polí a vrátit nepojmenované řazené kolekce členů:</span><span class="sxs-lookup"><span data-stu-id="a256f-225">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="a256f-226">Musíte vyřešit, pole tento řazené kolekce členů jako `Item1`, `Item2`, a `Item3`.</span><span class="sxs-lookup"><span data-stu-id="a256f-226">You must address the fields of this tuple as `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="a256f-227">Doporučujeme zadat sémantického názvy elementů vrátila z metody řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-227">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="a256f-228">Jiné stylu, kde může být velmi užitečná řazených kolekcí členů je při vytváření dotazů LINQ, kde je konečný výsledek projekce, který obsahuje některé, ale ne všechny vlastnosti objektů vybrat.</span><span class="sxs-lookup"><span data-stu-id="a256f-228">Another idiom where tuples can be very useful is when you are authoring LINQ queries where the final result is a projection that contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="a256f-229">Výsledky dotazu by tradičně projektu do pořadí objektů, které byly anonymního typu.</span><span class="sxs-lookup"><span data-stu-id="a256f-229">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="a256f-230">Mnoho omezení, který zobrazí, primárně, protože anonymní typy nelze pojmenovat pohodlně v návratový typ pro metodu.</span><span class="sxs-lookup"><span data-stu-id="a256f-230">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="a256f-231">Alternativy pomocí `object` nebo `dynamic` jako typ výsledku byly dodány s náklady na významně zvýšit výkon.</span><span class="sxs-lookup"><span data-stu-id="a256f-231">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="a256f-232">Vrácení pořadí řazené kolekce členů typ je snadné a názvy a typy elementy jsou k dispozici, v době kompilace a nástrojích IDE.</span><span class="sxs-lookup"><span data-stu-id="a256f-232">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="a256f-233">Představte si třeba aplikace ToDo.</span><span class="sxs-lookup"><span data-stu-id="a256f-233">For example, consider a ToDo application.</span></span> <span data-ttu-id="a256f-234">Můžete třeba definovat třídu podobný následujícímu představují jednu položku v seznamu úkolů:</span><span class="sxs-lookup"><span data-stu-id="a256f-234">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="a256f-235">Mobilní aplikace může podporovat aktuální položek ToDo compact formulář, který se zobrazí jenom název.</span><span class="sxs-lookup"><span data-stu-id="a256f-235">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="a256f-236">Bude dotaz LINQ vytvořili projekci, obsahuje pouze ID a název.</span><span class="sxs-lookup"><span data-stu-id="a256f-236">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="a256f-237">Metoda, která vrátí pořadí řazené kolekce členů velmi dobře vyjadřoval tohoto návrhu:</span><span class="sxs-lookup"><span data-stu-id="a256f-237">A method that returns a sequence of tuples expresses that design very well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="a256f-238">V jazyce C# 7.1 řazené kolekce členů projekce umožňují vytvořit pojmenovaný řazených kolekcí členů pomocí elementů, podobně jako u vlastnosti názvu v anonymní typy způsobem.</span><span class="sxs-lookup"><span data-stu-id="a256f-238">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="a256f-239">Ve výše uvedeném kódu `select` příkaz v projekce dotazu vytvoří řazenou kolekci členů, která má elementy `ID` a `Title`.</span><span class="sxs-lookup"><span data-stu-id="a256f-239">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="a256f-240">Pojmenované řazené kolekce členů můžou být součástí podpis.</span><span class="sxs-lookup"><span data-stu-id="a256f-240">The named tuple can be part of the signature.</span></span> <span data-ttu-id="a256f-241">Umožňuje kompilátor a nástroje pro IDE poskytují statické kontroluje, že výsledek používáte správně.</span><span class="sxs-lookup"><span data-stu-id="a256f-241">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="a256f-242">Pojmenované řazené kolekce členů také přenáší informace statického typu, takže není nutné používat funkce nákladné běhu jako reflexe nebo dynamické vazby pro práci s výsledky.</span><span class="sxs-lookup"><span data-stu-id="a256f-242">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="a256f-243">Deconstruction</span><span class="sxs-lookup"><span data-stu-id="a256f-243">Deconstruction</span></span>

<span data-ttu-id="a256f-244">Můžete rozbalit všechny položky v řazené kolekce členů podle *deconstructing* řazené kolekce členů vrácená metodou.</span><span class="sxs-lookup"><span data-stu-id="a256f-244">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="a256f-245">Existují tři různé přístupy k deconstructing řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-245">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="a256f-246">Nejprve je možné deklarovat explicitně typ každé pole v závorkách vytváření diskrétní proměnných pro jednotlivé elementy v řazené kolekci členů:</span><span class="sxs-lookup"><span data-stu-id="a256f-246">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="a256f-247">Můžete také deklarovat implicitně typovaná proměnných pro každé pole v řazené kolekce členů s použitím `var` – klíčové slovo mimo závorkách:</span><span class="sxs-lookup"><span data-stu-id="a256f-247">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="a256f-248">Je také možné použít `var` – klíčové slovo pomocí některého nebo všech deklarace proměnných v závorkách.</span><span class="sxs-lookup"><span data-stu-id="a256f-248">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span> 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="a256f-249">Upozorňujeme, že nelze použít konkrétní typ mimo závorky, i když každé pole v řazené kolekci členů má stejný typ.</span><span class="sxs-lookup"><span data-stu-id="a256f-249">Note that you cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="a256f-250">Můžete deconstruct řazené kolekce členů s existující deklarace také:</span><span class="sxs-lookup"><span data-stu-id="a256f-250">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
>  <span data-ttu-id="a256f-251">Není možné kombinovat existující deklarace s deklaracemi v závorkách.</span><span class="sxs-lookup"><span data-stu-id="a256f-251">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="a256f-252">Například následující nepovolené: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="a256f-252">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="a256f-253">To vytváří chyba CS8184, protože *x* je deklarovaná do závorek a *y* je dříve deklarované jinde.</span><span class="sxs-lookup"><span data-stu-id="a256f-253">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="a256f-254">Deconstructing uživatelem definované typy</span><span class="sxs-lookup"><span data-stu-id="a256f-254">Deconstructing user defined types</span></span>

<span data-ttu-id="a256f-255">Jakýkoli typ řazené kolekce členů můžete deconstructed, jak je uvedeno výše.</span><span class="sxs-lookup"><span data-stu-id="a256f-255">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="a256f-256">Je také snadno povolit deconstruction na všechny uživatelem definovaný typ (třídy, struktury nebo i rozhraní).</span><span class="sxs-lookup"><span data-stu-id="a256f-256">It's also easy to enable deconstruction on any user defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="a256f-257">Typ Autor můžete definovat jeden nebo více `Deconstruct` metody, které hodnoty přiřadit libovolný počet `out` představující datové prvky, které tvoří typ proměnné.</span><span class="sxs-lookup"><span data-stu-id="a256f-257">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="a256f-258">Například následující `Person` definuje typ `Deconstruct` metoda, která deconstructs objekt osoba do elementů představující křestní jméno a příjmení:</span><span class="sxs-lookup"><span data-stu-id="a256f-258">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="a256f-259">Metoda deconstruct umožňuje přiřazení z `Person` na dva řetězce, představující `FirstName` a `LastName` vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="a256f-259">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="a256f-260">Můžete povolit deconstruction i pro typy, které není vytváříte.</span><span class="sxs-lookup"><span data-stu-id="a256f-260">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="a256f-261">`Deconstruct` Metoda může být metody rozšíření, který rozbalí dat dostupný členům v objektu.</span><span class="sxs-lookup"><span data-stu-id="a256f-261">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="a256f-262">V příkladu níže znázorňuje `Student` typ odvozený z `Person` typu a metody rozšíření, která deconstructs `Student` do tří proměnných, představující `FirstName`, `LastName` a `GPA`:</span><span class="sxs-lookup"><span data-stu-id="a256f-262">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName` and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="a256f-263">A `Student` objekt teď má dva přístupné `Deconstruct` metody: Metoda přípona deklarovaným pro `Student` typy a členem `Person` typu.</span><span class="sxs-lookup"><span data-stu-id="a256f-263">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="a256f-264">Obě jsou v oboru a která umožňuje `Student` k být deconstructed do proměnné dva nebo tři.</span><span class="sxs-lookup"><span data-stu-id="a256f-264">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="a256f-265">Chcete-li přiřadit student tří proměnných, křestní jméno, poslední název a GPA se všechny vrátí.</span><span class="sxs-lookup"><span data-stu-id="a256f-265">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="a256f-266">Pokud přiřadíte student dvě proměnné, vrátí se pouze křestní jméno a příjmení.</span><span class="sxs-lookup"><span data-stu-id="a256f-266">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="a256f-267">Měli byste být velmi opatrní definování více `Deconstruct` metody ve třídě nebo hierarchie tříd.</span><span class="sxs-lookup"><span data-stu-id="a256f-267">You should be very careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="a256f-268">Více `Deconstruct` metody, které mají stejný počet `out` parametry může způsobit rychle nejednoznačnosti.</span><span class="sxs-lookup"><span data-stu-id="a256f-268">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="a256f-269">Volající nemusí být možné snadno volání požadovanou `Deconstruct` metoda.</span><span class="sxs-lookup"><span data-stu-id="a256f-269">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="a256f-270">V tomto příkladu, existuje minimální pravděpodobnost pro nejednoznačné volání protože `Deconstruct` metodu pro `Person` má dva výstup parametrů a `Deconstruct` metodu pro `Student` má tři.</span><span class="sxs-lookup"><span data-stu-id="a256f-270">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

## <a name="conclusion"></a><span data-ttu-id="a256f-271">Závěr</span><span class="sxs-lookup"><span data-stu-id="a256f-271">Conclusion</span></span> 

<span data-ttu-id="a256f-272">Nová podpora jazyka a knihovny s názvem řazených kolekcí členů je mnohem jednodušší pro práci s návrhy, které používají datové struktury, které uložit více elementů, ale nejsou definovány chování, stejně jako třídy a struktury.</span><span class="sxs-lookup"><span data-stu-id="a256f-272">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="a256f-273">Je snadné a stručným použijte pro tyto typy řazených kolekcí členů.</span><span class="sxs-lookup"><span data-stu-id="a256f-273">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="a256f-274">Získáte všechny výhody Kontrola statické typu, aniž by museli vytvářet typy pomocí více podrobné `class` nebo `struct` syntaxe.</span><span class="sxs-lookup"><span data-stu-id="a256f-274">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="a256f-275">I tak se nejvíc hodí pro pomocné metody, které jsou `private`, nebo `internal`.</span><span class="sxs-lookup"><span data-stu-id="a256f-275">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="a256f-276">Vytvořit uživatelsky definované typy, buď `class` nebo `struct` typy při veřejné metody vrátit hodnotu, která má více elementů.</span><span class="sxs-lookup"><span data-stu-id="a256f-276">Create user defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
