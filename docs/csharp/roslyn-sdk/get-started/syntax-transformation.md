---
title: Začínáme s transformace syntaxe (Roslyn rozhraní API)
description: Úvod k procházení, dotazování a proti stromy syntaxe.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 04053645b91e8f74e890340fb9bba66a4efdce0c
ms.sourcegitcommit: 2ad7d06f4f469b5d8a5280ac0e0289a81867fc8e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/08/2018
ms.locfileid: "35231629"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="83f9d-103">Začínáme s syntaxe transformace</span><span class="sxs-lookup"><span data-stu-id="83f9d-103">Get started with syntax transformation</span></span>

<span data-ttu-id="83f9d-104">V tomto kurzu vychází koncepty a techniky prozkoumali v [začít pracovat s syntaxe analysis](syntax-analysis.md) a [začít pracovat s sémantického analysis](semantic-analysis.md) – elementy quickstart.</span><span class="sxs-lookup"><span data-stu-id="83f9d-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="83f9d-105">Pokud jste to ještě neudělali, musíte provést před zahájením této jeden těchto rychlých průvodců.</span><span class="sxs-lookup"><span data-stu-id="83f9d-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="83f9d-106">V tento rychlý start prozkoumejte techniky pro vytváření a transformace stromy syntaxe.</span><span class="sxs-lookup"><span data-stu-id="83f9d-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="83f9d-107">V kombinaci s postupy, které jste se naučili v předchozí – elementy QuickStart můžete vytvořit vaše první příkazového řádku refaktoring!</span><span class="sxs-lookup"><span data-stu-id="83f9d-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="83f9d-108">Neměnitelnosti a platformě .NET kompilátoru</span><span class="sxs-lookup"><span data-stu-id="83f9d-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="83f9d-109">**Neměnitelnosti** základní principem kompilátoru platformy .NET je.</span><span class="sxs-lookup"><span data-stu-id="83f9d-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="83f9d-110">Neměnné datové struktury nelze změnit po vytváří.</span><span class="sxs-lookup"><span data-stu-id="83f9d-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="83f9d-111">Neměnné datové struktury můžete bezpečně sdílet a analyzovat více příjemců současně.</span><span class="sxs-lookup"><span data-stu-id="83f9d-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="83f9d-112">Nehrozí nebezpečí, že jednoho příjemce ovlivňuje jiné nepředvídatelně.</span><span class="sxs-lookup"><span data-stu-id="83f9d-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="83f9d-113">Vaše analyzátor nepotřebuje zámky nebo jiných opatření souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="83f9d-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="83f9d-114">Toto pravidlo platí pro syntaxi stromy, kompilace, symbolů, sémantických modelů a každé další datová struktura, na které narazíte.</span><span class="sxs-lookup"><span data-stu-id="83f9d-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="83f9d-115">Místo úprava existující struktury, rozhraní API vytvářet nové objekty, které jsou založené na zadaný rozdíly, o staré.</span><span class="sxs-lookup"><span data-stu-id="83f9d-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="83f9d-116">Tento koncept použijete syntaxi stromů k vytvoření nových stromů použití transformací.</span><span class="sxs-lookup"><span data-stu-id="83f9d-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="83f9d-117">Vytvoření a transformace stromů</span><span class="sxs-lookup"><span data-stu-id="83f9d-117">Create and transform trees</span></span>

<span data-ttu-id="83f9d-118">Vyberte jednu ze dvou strategií pro syntaxi transformace.</span><span class="sxs-lookup"><span data-stu-id="83f9d-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="83f9d-119">**Metody vytváření** jsou nejvhodnější, pokud chcete vyhledat konkrétní uzlů nahradit nebo konkrétní umístění, kam chcete vložit nový kód.</span><span class="sxs-lookup"><span data-stu-id="83f9d-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="83f9d-120">**Programy** se nejlíp, když chcete prohledat celý projekt pro vzory kódu, které má být nahrazen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="83f9d-121">Vytvoření uzly s metodami pro vytváření</span><span class="sxs-lookup"><span data-stu-id="83f9d-121">Create nodes with factory methods</span></span>

<span data-ttu-id="83f9d-122">První transformace syntaxe ukazuje metodami pro vytváření.</span><span class="sxs-lookup"><span data-stu-id="83f9d-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="83f9d-123">Chcete nahradit `using System.Collections;` příkaz s `using System.Collections.Generic;` příkaz.</span><span class="sxs-lookup"><span data-stu-id="83f9d-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="83f9d-124">Tento příklad ukazuje, jak vytvořit <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objekty pomocí <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> metodami pro vytváření.</span><span class="sxs-lookup"><span data-stu-id="83f9d-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="83f9d-125">Pro každý typ z **uzlu**, **tokenu**, nebo **trivia** je metoda factory, která vytvoří instanci daného typu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="83f9d-126">Při vytváření stromů syntaxe skládání uzly hierarchicky způsobem zdola nahoru.</span><span class="sxs-lookup"><span data-stu-id="83f9d-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="83f9d-127">Potom budete transformace existující program nahrazujete stávající uzly s novou větev, které jste vytvořili.</span><span class="sxs-lookup"><span data-stu-id="83f9d-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="83f9d-128">Spuštění sady Visual Studio a vytvoření nového jazyka C# **samostatný nástroj pro analýzu kódu** projektu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="83f9d-129">V sadě Visual Studio, vyberte **soubor** > \**nový* > **projektu** zobrazíte dialogové okno Nový projekt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-129">In Visual Studio, choose **File** > \**New* > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="83f9d-130">V části **Visual C#** > **rozšiřitelnost** zvolte **samostatný nástroj pro analýzu kódu**.</span><span class="sxs-lookup"><span data-stu-id="83f9d-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="83f9d-131">Tento rychlý start má dva projekty příklad, takže název řešení **SyntaxTransformationQuickStart**a název projektu **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="83f9d-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="83f9d-132">Click **OK**.</span><span class="sxs-lookup"><span data-stu-id="83f9d-132">Click **OK**.</span></span>

<span data-ttu-id="83f9d-133">Používá tento projekt <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> metody pro vytvoření třídy <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> představující `System.Collections.Generic` oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="83f9d-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="83f9d-134">Přidejte následující using – direktiva do horní části `Program.cs` soubor k importu metody vytváření <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> třídy a metody <xref:System.Console> tak, aby je mohli používat později bez kvalifikace je:</span><span class="sxs-lookup"><span data-stu-id="83f9d-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="83f9d-135">Vytvoříte **název syntaxe uzly** k vytvoření stromové struktury, která představuje `using System.Collections.Generic;` příkaz.</span><span class="sxs-lookup"><span data-stu-id="83f9d-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="83f9d-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> je základní třída pro čtyři typy názvů, které se zobrazují v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="83f9d-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="83f9d-137">Můžete vytvořit tyto čtyři typy názvy dohromady a vytvoří libovolný název, který se může zobrazit v jazyce C#:</span><span class="sxs-lookup"><span data-stu-id="83f9d-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="83f9d-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, která představuje jednoduchý jeden identifikátor názvy jako `System` a `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="83f9d-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, která představuje obecný typ nebo metoda název, jako `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="83f9d-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, která představuje kvalifikovaný název ve tvaru `<left-name>.<right-identifier-or-generic-name>` například `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="83f9d-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, která představuje název pomocí sestavení extern alias takové `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="83f9d-142">Můžete použít <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> metodu pro vytvoření <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> uzlu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="83f9d-143">Přidejte následující kód ve vaší `Main` metoda v `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="83f9d-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="83f9d-144">Předchozí kód vytvoří <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> objektu a přiřadí ji k proměnné `name`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="83f9d-145">Mnoho Roslyn rozhraní API vrátí základní třídy, aby bylo snazší pro práci s souvisejících typů.</span><span class="sxs-lookup"><span data-stu-id="83f9d-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="83f9d-146">Proměnná `name`, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, lze opětovně použít během vytváření <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="83f9d-147">Nepoužívejte odvození typu, jak sestavit ukázku.</span><span class="sxs-lookup"><span data-stu-id="83f9d-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="83f9d-148">Tento krok v tomto projektu budete automatizovat.</span><span class="sxs-lookup"><span data-stu-id="83f9d-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="83f9d-149">Název jste vytvořili.</span><span class="sxs-lookup"><span data-stu-id="83f9d-149">You've created the name.</span></span> <span data-ttu-id="83f9d-150">Nyní je čas vytvořit více uzlů do stromu podle budovy <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="83f9d-151">Novou větev používá `name` jako nalevo od názvu a novou <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> pro `Collections` oboru názvů jako pravé straně <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="83f9d-152">Přidejte následující kód, který `program.cs`:</span><span class="sxs-lookup"><span data-stu-id="83f9d-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="83f9d-153">Znovu spustit kód a zobrazte si výsledky.</span><span class="sxs-lookup"><span data-stu-id="83f9d-153">Run the code again, and see the results.</span></span> <span data-ttu-id="83f9d-154">Umožňuje vytvářet stromu uzly, který představuje kód.</span><span class="sxs-lookup"><span data-stu-id="83f9d-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="83f9d-155">Tento vzor k vytvoření budete pokračovat <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> pro obor názvů `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="83f9d-156">Přidejte následující kód, který `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="83f9d-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="83f9d-157">Spusťte program zjistíte, že jste sestavení stromu pro kódu k přidání.</span><span class="sxs-lookup"><span data-stu-id="83f9d-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="83f9d-158">Vytvoření upravené stromové struktury</span><span class="sxs-lookup"><span data-stu-id="83f9d-158">Create a modified tree</span></span>

<span data-ttu-id="83f9d-159">Když jste sestavili malé syntaxe stromové struktury, která obsahuje jeden příkaz.</span><span class="sxs-lookup"><span data-stu-id="83f9d-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="83f9d-160">Rozhraní API pro vytvoření nové uzly jsou správná volba pro vytvoření jedné příkazy nebo jiné bloky malý kód.</span><span class="sxs-lookup"><span data-stu-id="83f9d-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="83f9d-161">Však vytvořit větší bloky kódu, byste měli použít metody, které nahradí uzly nebo vložit uzlů do stávající strom.</span><span class="sxs-lookup"><span data-stu-id="83f9d-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="83f9d-162">Mějte na paměti, že syntaxe stromy jsou neměnné.</span><span class="sxs-lookup"><span data-stu-id="83f9d-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="83f9d-163">**Syntaxe API** neposkytuje žádný mechanismus pro úpravy stávající strom syntaxe po konstrukce.</span><span class="sxs-lookup"><span data-stu-id="83f9d-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="83f9d-164">Namísto toho poskytuje metody, které vytvářejí nové stromy na základě změn existující.</span><span class="sxs-lookup"><span data-stu-id="83f9d-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="83f9d-165">`With*` metody jsou definovány v konkrétní třídy, které jsou odvozeny od <xref:Microsoft.CodeAnalysis.SyntaxNode> nebo v rozšiřující metody, které jsou deklarované v <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> třídy.</span><span class="sxs-lookup"><span data-stu-id="83f9d-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="83f9d-166">Tyto metody vytvořte nový uzel použitím změny vlastnosti podřízené stávající uzel.</span><span class="sxs-lookup"><span data-stu-id="83f9d-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="83f9d-167">Kromě toho <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> metoda rozšíření lze použít k nahrazení podřízené uzlu v podstrom.</span><span class="sxs-lookup"><span data-stu-id="83f9d-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="83f9d-168">Tato metoda také aktualizuje nadřazené tak, aby odkazovaly na nově vytvořený podřízené a opakuje tento proces se celý strom - tento proces se označuje jako _re spining_ stromu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spining_ the tree.</span></span>

<span data-ttu-id="83f9d-169">Dalším krokem je vytvoření stromové struktury, která představuje celou (malý) program a upravit ho.</span><span class="sxs-lookup"><span data-stu-id="83f9d-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="83f9d-170">Přidejte následující kód do začátku `Program` třídy:</span><span class="sxs-lookup"><span data-stu-id="83f9d-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="83f9d-171">Příklad kódu používá `System.Collections` obor názvů a ne `System.Collections.Generic` oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="83f9d-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="83f9d-172">V dalším kroku přidejte následující kód k dolnímu okraji `Main` metoda analyzovat text a vytvoření stromové struktury:</span><span class="sxs-lookup"><span data-stu-id="83f9d-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="83f9d-173">Tento příklad používá <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> metody lze nahradit název v <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> uzlu s jedním vytvořená v předchozím kódu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="83f9d-174">Vytvořte novou <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> uzlu pomocí <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> metoda aktualizace `System.Collections` název s názvem, který jste vytvořili v předchozí kód.</span><span class="sxs-lookup"><span data-stu-id="83f9d-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="83f9d-175">Přidejte následující kód k dolnímu okraji `Main` metoda:</span><span class="sxs-lookup"><span data-stu-id="83f9d-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="83f9d-176">Spusťte program a pečlivě si prohlédněte výstup.</span><span class="sxs-lookup"><span data-stu-id="83f9d-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="83f9d-177">`newusing` Nebyla umístěna ve stromové struktuře kořenové.</span><span class="sxs-lookup"><span data-stu-id="83f9d-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="83f9d-178">Původní stromu nebyl změněn.</span><span class="sxs-lookup"><span data-stu-id="83f9d-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="83f9d-179">Přidejte následující kód pomocí <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> rozšíření metodu pro vytvoření nové větve.</span><span class="sxs-lookup"><span data-stu-id="83f9d-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="83f9d-180">Novou větev je výsledkem nahraďte existující import aktualizovaný `newUsing` uzlu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="83f9d-181">Tento nový strom přiřadit stávající `root` proměnné:</span><span class="sxs-lookup"><span data-stu-id="83f9d-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="83f9d-182">Spusťte program znovu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-182">Run the program again.</span></span> <span data-ttu-id="83f9d-183">Tentokrát stromu nyní správně importuje `System.Collections.Generic` oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="83f9d-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="83f9d-184">Transformace pomocí stromové struktury `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="83f9d-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="83f9d-185">`With*` a <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> metody poskytují pohodlný způsob, jak transformace jednotlivých větví stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="83f9d-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="83f9d-186"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> Třída provádí více transformací stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="83f9d-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="83f9d-187"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> Třída je podtřídou třídy <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="83f9d-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> Transformace se vztahuje na určitý typ <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="83f9d-189">Transformace můžete použít pro více typů <xref:Microsoft.CodeAnalysis.SyntaxNode> objekty kdykoliv se objeví ve stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="83f9d-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="83f9d-190">Druhý projekt v tento rychlý start vytvoří příkazového řádku refaktoring, která odebere explicitní typy v místní deklarace proměnných, které by bylo možné použít kdekoli, který odvození typu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="83f9d-191">Vytvoření nového jazyka C# **samostatný nástroj pro analýzu kódu** projektu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="83f9d-192">V sadě Visual Studio, klikněte pravým tlačítkem myši `SyntaxTransformationQuickStart` uzel řešení.</span><span class="sxs-lookup"><span data-stu-id="83f9d-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="83f9d-193">Zvolte **přidat** > **nový projekt** zobrazíte **dialogové okno Nový projekt**.</span><span class="sxs-lookup"><span data-stu-id="83f9d-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="83f9d-194">V části **Visual C#** > **rozšiřitelnost**, zvolte **samostatný nástroj pro analýzu kódu**.</span><span class="sxs-lookup"><span data-stu-id="83f9d-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="83f9d-195">Název projektu `TransformationCS` a klikněte na tlačítko OK.</span><span class="sxs-lookup"><span data-stu-id="83f9d-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="83f9d-196">Prvním krokem je vytvoření třídu odvozenou z <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> k provádění vaší transformací.</span><span class="sxs-lookup"><span data-stu-id="83f9d-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="83f9d-197">Přidáte nový soubor třídu do projektu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-197">Add a new class file to the project.</span></span> <span data-ttu-id="83f9d-198">V sadě Visual Studio, vyberte **projektu** > **přidat třídu...** . V **přidat novou položku** typ dialogu `TypeInferenceRewriter.cs` jako název souboru.</span><span class="sxs-lookup"><span data-stu-id="83f9d-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="83f9d-199">Přidejte následující direktivy pro použití `TypeInferenceRewriter.cs` souboru:</span><span class="sxs-lookup"><span data-stu-id="83f9d-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="83f9d-200">Dále vytvořte `TypeInferenceRewriter` rozšíření třídy <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> – třída:</span><span class="sxs-lookup"><span data-stu-id="83f9d-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="83f9d-201">Přidejte následující kód k deklaraci soukromé pole jen pro čtení k uložení <xref:Microsoft.CodeAnalysis.SemanticModel> a provést jeho inicializaci v konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="83f9d-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="83f9d-202">Budete potřebovat později na Chcete-li určit, kde lze použít odvození typu:</span><span class="sxs-lookup"><span data-stu-id="83f9d-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="83f9d-203">Přepsání <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> metoda:</span><span class="sxs-lookup"><span data-stu-id="83f9d-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```C#
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="83f9d-204">Mnoho rozhraní API Roslyn deklarovat návratový typů, které jsou základní třídy typů skutečné runtime vrátila.</span><span class="sxs-lookup"><span data-stu-id="83f9d-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="83f9d-205">n mnoho scénářů, jeden druh uzlu mohou být zcela - nahrazuje jiný druh uzlu nebo i odebrat.</span><span class="sxs-lookup"><span data-stu-id="83f9d-205">n many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="83f9d-206">V tomto příkladu <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> metoda vrátí <xref:Microsoft.CodeAnalysis.SyntaxNode>, místo odvozené typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="83f9d-207">Vrátí novou tento RW <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> uzlu podle stávající.</span><span class="sxs-lookup"><span data-stu-id="83f9d-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="83f9d-208">Tento rychlý start zpracovává místní deklarace proměnných.</span><span class="sxs-lookup"><span data-stu-id="83f9d-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="83f9d-209">Ji můžete rozšířit do jiných deklarace, jako `foreach` smyčky, `for` smyčky, LINQ – výrazy a výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="83f9d-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="83f9d-210">Kromě toho tato RW transformuje jenom deklarace nejjednodušší forma:</span><span class="sxs-lookup"><span data-stu-id="83f9d-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="83f9d-211">Pokud chcete prozkoumat, vezměte v úvahu rozšíření bylo dokončeno ukázka pro tyto typy deklarace proměnných:</span><span class="sxs-lookup"><span data-stu-id="83f9d-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="83f9d-212">Přidejte následující kód k tělu `VisitLocalDeclarationStatement` metoda tak, aby přeskočil přepisování tyto formuláře deklarace:</span><span class="sxs-lookup"><span data-stu-id="83f9d-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="83f9d-213">Metoda určuje, že žádné přepisování probíhá vrácením `node` parametr ponechat beze změny.</span><span class="sxs-lookup"><span data-stu-id="83f9d-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="83f9d-214">Pokud žádná z nich `if` výrazy jsou splněny, představuje možné deklarace s inicializací uzel.</span><span class="sxs-lookup"><span data-stu-id="83f9d-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="83f9d-215">Přidejte tyto příkazy k extrakci název typu, který je zadaný v deklaraci a navázat jej pomocí <xref:Microsoft.CodeAnalysis.SemanticModel> pole, které chcete získat symbol typu:</span><span class="sxs-lookup"><span data-stu-id="83f9d-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="83f9d-216">Nyní přidejte tento příkaz k vytvoření vazby inicializátoru výraz:</span><span class="sxs-lookup"><span data-stu-id="83f9d-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="83f9d-217">Nakonec přidejte následující `if` příkaz, který má nahradit existující název typu s `var` – klíčové slovo, pokud typ výrazu inicializátoru odpovídá zadaný typ:</span><span class="sxs-lookup"><span data-stu-id="83f9d-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Replace the initializer node")]

<span data-ttu-id="83f9d-218">Zásad správy není nutná, protože deklaraci může přetypovat inicializátoru výraz, který se základní třídy nebo rozhraní.</span><span class="sxs-lookup"><span data-stu-id="83f9d-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="83f9d-219">V případě potřeby, typy na levé a pravé straně přiřazení se neshodují.</span><span class="sxs-lookup"><span data-stu-id="83f9d-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="83f9d-220">Odebírání explicitního typu v těchto případech změní sémantiku programu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="83f9d-221">`var` je zadán jako identifikátor, nikoli klíčové slovo, protože `var` je kontextové klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="83f9d-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="83f9d-222">Úvodní a koncové trivia (prázdné) přenášených z původní název typu k `var` – klíčové slovo zachování svislé prázdné znaky a odsazení.</span><span class="sxs-lookup"><span data-stu-id="83f9d-222">The leading and trailing trivia (whitespace) are transferred from the old type name to the `var` keyword to maintain vertical whitespace and indentation.</span></span> <span data-ttu-id="83f9d-223">Je jednodušší použít `ReplaceNode` místo `With*` k transformaci <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> vzhledem k tomu, že název typu je ve skutečnosti pod podřízená příkazu deklarace.</span><span class="sxs-lookup"><span data-stu-id="83f9d-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="83f9d-224">Když jste dokončení `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="83f9d-225">Nyní vraťte se do vaší `Program.cs` až se dokončí příklad souboru.</span><span class="sxs-lookup"><span data-stu-id="83f9d-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="83f9d-226">Vytvoření testu <xref:Microsoft.CodeAnalysis.Compilation> a získat <xref:Microsoft.CodeAnalysis.SemanticModel> z něj.</span><span class="sxs-lookup"><span data-stu-id="83f9d-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="83f9d-227">Použít <xref:Microsoft.CodeAnalysis.SemanticModel> pokusit vaší `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="83f9d-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="83f9d-228">Tento krok můžete to udělat poslední.</span><span class="sxs-lookup"><span data-stu-id="83f9d-228">You'll do this step last.</span></span> <span data-ttu-id="83f9d-229">Do té doby deklarujte proměnnou zástupný symbol představující vaše testovací kompilace:</span><span class="sxs-lookup"><span data-stu-id="83f9d-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="83f9d-230">Po pozastavení chvilku, měli byste vidět vlnovku chyba objeví, které žádné `CreateTestCompilation` metoda existuje.</span><span class="sxs-lookup"><span data-stu-id="83f9d-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="83f9d-231">Stiskněte klávesu **Ctrl + tečka** otevřít žárovky a stiskněte klávesu Enter pro vyvolání **generovat se zakázaným inzerováním metoda** příkaz.</span><span class="sxs-lookup"><span data-stu-id="83f9d-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="83f9d-232">Tento příkaz vytvoří metoda zástupnou proceduru pro `CreateTestCompilation` metoda v `Program` třídy.</span><span class="sxs-lookup"><span data-stu-id="83f9d-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="83f9d-233">Můžete budete se vraťte k později vyplňte takto:</span><span class="sxs-lookup"><span data-stu-id="83f9d-233">You'll come back to fill in this method later:</span></span>

![Metoda C# generování před využitím](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="83f9d-235">Uveďte následující kód, který iteraci každé <xref:Microsoft.CodeAnalysis.SyntaxTree> v testu <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="83f9d-236">U každé z nich, inicializujte nový `TypeInferenceRewriter` s <xref:Microsoft.CodeAnalysis.SemanticModel> pro stromové struktuře:</span><span class="sxs-lookup"><span data-stu-id="83f9d-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="83f9d-237">Uvnitř `foreach` příkaz jste vytvořili, přidejte následující kód k provedení transformace v každém stromu zdroje.</span><span class="sxs-lookup"><span data-stu-id="83f9d-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="83f9d-238">Tento kód stromu nové transformovaných podmíněně zapíše, pokud byly provedeny veškeré úpravy.</span><span class="sxs-lookup"><span data-stu-id="83f9d-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="83f9d-239">Vaše RW měli změnit, jenom stromu pokud zjistí jeden nebo více místní proměnné deklarace, které může zjednodušit pomocí odvození typu:</span><span class="sxs-lookup"><span data-stu-id="83f9d-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="83f9d-240">Měli byste vidět podtržení vlnovkou pod `File.WriteAllText` kódu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="83f9d-241">Vyberte žárovky a přidejte nezbytné `using System.IO;` příkaz.</span><span class="sxs-lookup"><span data-stu-id="83f9d-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="83f9d-242">Téměř Hotovo!</span><span class="sxs-lookup"><span data-stu-id="83f9d-242">You're almost done!</span></span> <span data-ttu-id="83f9d-243">Je jednou vlevo krok: vytvoření testu <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="83f9d-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="83f9d-244">Vzhledem k tomu, že nebyly byla používáte odvození typu vůbec během tento rychlý start, by ho udělali ideální testovacího případu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="83f9d-245">Vytvoření kompilace ze souboru projektu C# bohužel je nad rámec tohoto návodu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="83f9d-246">Naštěstí, pokud jste se podle pokynů pečlivě, není naděje ale.</span><span class="sxs-lookup"><span data-stu-id="83f9d-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="83f9d-247">Nahraďte obsah `CreateTestCompilation` metoda následujícím kódem.</span><span class="sxs-lookup"><span data-stu-id="83f9d-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="83f9d-248">Vytvoří kompilace test, který shodou odpovídá projektu popsané v této rychlý start:</span><span class="sxs-lookup"><span data-stu-id="83f9d-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="83f9d-249">Mezi prsty a spusťte projekt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="83f9d-250">V sadě Visual Studio, vyberte **ladění** > **spustit ladění**.</span><span class="sxs-lookup"><span data-stu-id="83f9d-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="83f9d-251">Musí se vás Visual Studio, že se změnily soubory v projektu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="83f9d-252">Klikněte na tlačítko "**Ano všem**" načtením změněné soubory.</span><span class="sxs-lookup"><span data-stu-id="83f9d-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="83f9d-253">Zkontrolujte, aby sledovat vaše awesomeness.</span><span class="sxs-lookup"><span data-stu-id="83f9d-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="83f9d-254">Všimněte si, kolik čisticí proces kód vypadá bez všechny tyto specifikátory explicitní a redundantní typu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="83f9d-255">Blahopřejeme!</span><span class="sxs-lookup"><span data-stu-id="83f9d-255">Congratulations!</span></span> <span data-ttu-id="83f9d-256">Jste použili **rozhraní API kompilátoru** zápis vlastní refaktoring, která hledá všechny soubory v projektu C# pro určité vzory syntaktické analyzuje sémantika zdrojový kód, který odpovídá tyto vzorce a převede jej.</span><span class="sxs-lookup"><span data-stu-id="83f9d-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="83f9d-257">Nyní jste Autor oficiálně refaktoring!</span><span class="sxs-lookup"><span data-stu-id="83f9d-257">You're now officially refactoring author!</span></span>