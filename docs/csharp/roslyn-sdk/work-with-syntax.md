---
title: Použití syntaxe modelu SDK pro platformu .NET kompilátoru
description: Tento přehled poskytuje představu o typy, které slouží k pochopení a manipulaci s uzly syntaxe.
author: billwagner
ms.author: wiwagn
ms.date: 10/15/2017
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 0230777c59185a6b50d5dac5066efc3afa347f44
ms.sourcegitcommit: b750a8e3979749b214e7e10c82efb0a0524dfcb1
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/10/2018
---
# <a name="work-with-syntax"></a><span data-ttu-id="5a9d8-103">Práce s syntaxe</span><span class="sxs-lookup"><span data-stu-id="5a9d8-103">Work with syntax</span></span>

<span data-ttu-id="5a9d8-104">**Stromu syntaxe** je základní datová struktura vystavené kompilátoru rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="5a9d8-105">Tyto stromy představují lexikální a syntaktická strukturu zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="5a9d8-106">Představují důležité dva účely:</span><span class="sxs-lookup"><span data-stu-id="5a9d8-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="5a9d8-107">Povolit nástroje – například IDE, doplňky, nástrojů pro analýzu a kódu refaktoring - zobrazit a zpracovat syntaktické strukturu zdrojového kódu v projektu uživatele.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="5a9d8-108">K povolení nástrojů – například refaktoring a IDE - Pokud chcete vytvořit, upravit a změna uspořádání zdrojového kódu přirozené způsobem bez nutnosti použití přímé textových úprav.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="5a9d8-109">Vytváření a manipulace s stromy, nástroje můžete snadno vytvořit a změna uspořádání zdrojového kódu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="5a9d8-110">Syntaxe stromů</span><span class="sxs-lookup"><span data-stu-id="5a9d8-110">Syntax trees</span></span>

<span data-ttu-id="5a9d8-111">Syntaxe stromy jsou primární struktura používá pro kompilaci, analýza kódu, vazbu, refaktoring, funkce IDE a generování kódu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="5a9d8-112">Žádná z částí zdrojový kód odhalíte bez nejprve se identifikovat a rozdělené do jednoho z mnoha dobře známé strukturální jazykové elementy.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span> 

<span data-ttu-id="5a9d8-113">Syntaxe stromy mít tři klíčové atributy.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="5a9d8-114">První atribut je v úplné věrnosti obsahovat všechny informace o zdroji stromy syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="5a9d8-115">To znamená, že ke stromu syntaxe obsahuje každá část informace o nacházejí v zdrojový text, každý gramaticky konstrukce, každý lexikální token a všem ostatním v mezi, včetně mezer, komentáře a preprocesor – direktivy.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="5a9d8-116">Například každý literál uvedeno ve zdroji je reprezentována přesně tak, jak byl zadán.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="5a9d8-117">Stromy syntaxe také představovat chyby ve zdrojovém kódu, když program je neúplný nebo nesprávně představující chybí nebo přeskočené tokeny ve stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>  

<span data-ttu-id="5a9d8-118">To umožňuje druhý atribut stromy syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="5a9d8-119">Text, který se získá analýzou z přesně může vytvářet získané z analyzátor stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="5a9d8-120">Z libovolného uzlu syntaxe je možné získat textovou reprezentaci, dílčí stromu kořenem v tomto uzlu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="5a9d8-121">To znamená, že syntaxe stromy lze použít jako způsob, jak vytvořit a upravit zdrojový text.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="5a9d8-122">Vytvořením stromu, které máte nepřímo vytvořit ekvivalentní text a úpravou stromu syntaxe vytváření novou větev změny mimo na stávající strom upravíte efektivně text.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span> 

<span data-ttu-id="5a9d8-123">Třetí atribut syntaxe stromů je, že jsou neměnné a bezpečné pro přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="5a9d8-124">To znamená, že po získání stromu je snímek aktuálního stavu kódu a nikdy se změní.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="5a9d8-125">To umožňuje více uživatelům interakci s stejném stromu syntaxe ve stejnou dobu v různých vláknech bez zamknutí nebo duplicita.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="5a9d8-126">Protože stromy jsou neměnné a žádné úpravy můžete provedeny přímo do stromu, metodami pro vytváření pomoci vytvořit a upravit tak, že vytvoříte další snímky stromu syntaxe stromy.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="5a9d8-127">Stromy jsou efektivní ve způsobu, jakým se opakovaně základní uzly, tak novou verzi může být znovu sestavit rychlých a s malým množstvím paměť navíc.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="5a9d8-128">Stromu syntaxe je oznámena stromová struktura dat, kde není konečný strukturální elementy nadřazených další prvky.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="5a9d8-129">Každý stromu syntaxe se skládá z uzlů, tokeny a trivia.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>  

## <a name="syntax-nodes"></a><span data-ttu-id="5a9d8-130">Syntaxe uzly</span><span class="sxs-lookup"><span data-stu-id="5a9d8-130">Syntax nodes</span></span>

<span data-ttu-id="5a9d8-131">Syntaxe uzly jsou jedním z primární elementy stromy syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="5a9d8-132">Tyto uzly představují syntaktické konstrukce, jako je například deklarace, příkazy, výrazy a klauzule.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="5a9d8-133">Každou kategorii uzly syntaxe je reprezentována samostatné třídy odvozené od <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5a9d8-134">Sada tříd uzlu není rozšiřitelný.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-134">The set of node classes is not extensible.</span></span> 

<span data-ttu-id="5a9d8-135">Není konečný uzly ve stromu syntaxe, což znamená, že vždy mají ostatní uzly a tokeny jako podřízené objekty jsou všechny uzly syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="5a9d8-136">Jako podřízený jiného uzlu, každý uzel má nadřazený uzel, který se dá dostat <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5a9d8-137">Vzhledem k tomu, že jsou neměnné uzly a stromy, změní se nikdy nadřazeného uzlu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="5a9d8-138">Kořen stromu má hodnotu null. nadřazený.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-138">The root of the tree has a null parent.</span></span>  

<span data-ttu-id="5a9d8-139">Každý uzel má <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> metoda, která vrátí seznam podřízené uzly v postupném pořadí podle jejich pozice v textu zdroje.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="5a9d8-140">Tento seznam neobsahuje tokeny.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-140">This list does not contain tokens.</span></span> <span data-ttu-id="5a9d8-141">Každý uzel má také metody prozkoumat následníky, jako například <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, nebo <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> – které představují seznam uzlů, tokeny nebo trivia, který neexistuje ve stromové struktuře dílčí root uzlu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia, that exist in the sub-tree rooted by that node.</span></span>  

<span data-ttu-id="5a9d8-142">Kromě toho každý uzel podtřídami syntaxe zpřístupňuje stejné podřízené objekty prostřednictvím vlastnosti silného typu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="5a9d8-143">Například <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> uzlu třída má tři další vlastnosti, které jsou specifické pro binární operátory: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="5a9d8-144">Typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> je <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>a typ <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> je <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="5a9d8-145">Některé uzly syntaxe mít volitelné podřízené položky.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="5a9d8-146">Například <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> má volitelný <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="5a9d8-147">Pokud podřízená není k dispozici, vrátí hodnotu null vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-147">If the child is not present, the property returns null.</span></span> 

## <a name="syntax-tokens"></a><span data-ttu-id="5a9d8-148">Syntaxe tokenů</span><span class="sxs-lookup"><span data-stu-id="5a9d8-148">Syntax tokens</span></span>

<span data-ttu-id="5a9d8-149">Syntaxe tokeny jsou terminály gramatika jazyka, která reprezentuje nejmenší syntaktické fragmenty kódu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="5a9d8-150">Nikdy jsou rodičů jiných uzlů nebo tokenů.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="5a9d8-151">Syntaxe tokenů obsahovat klíčová slova, identifikátory, literály a interpunkce.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span> 

<span data-ttu-id="5a9d8-152">Pro účely efektivitu <xref:Microsoft.CodeAnalysis.SyntaxToken> typ je typ CLR hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="5a9d8-153">Na rozdíl od syntaxe uzly neexistuje tedy pouze jeden struktury pro všechny typy tokenů se smíšenými vlastnosti, které mají význam v závislosti na druhu token, který je reprezentované.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="5a9d8-154">Například token literálu celé číslo reprezentuje číselnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="5a9d8-155">Kromě nezpracovaná zdrojový text tokenu rozsahy literálu token má <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> vlastnost, která zjistíte přesný dekódovat celočíselnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="5a9d8-156">Tato vlastnost je zadán jako <xref:System.Object> vzhledem k tomu může být jeden z mnoha primitivní typy.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="5a9d8-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> Vlastnost zjistíte stejné informace, jako <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> vlastnost; ale tato vlastnost je vždy typu <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="5a9d8-158">Identifikátor v C# zdrojový text může zahrnovat řídicí znaky Unicode, ale syntaxe řídicí sekvence samotné není považovány za součást název identifikátoru.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="5a9d8-159">Ano, i když nezpracovaný text předané token nezahrnuje řídicí sekvence <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> vlastnost neexistuje.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="5a9d8-160">Místo toho zahrnuje identifikovaný řídicí znaky Unicode.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="5a9d8-161">Pokud zdrojový text obsahuje identifikátor zapisují jako například `\u03C0`, pak se <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> vlastnost pro tento token vrátí `π`.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="5a9d8-162">Syntaxe trivia</span><span class="sxs-lookup"><span data-stu-id="5a9d8-162">Syntax trivia</span></span>

<span data-ttu-id="5a9d8-163">Syntaxe trivia představují části textu zdroje, které jsou z velké části zanedbatelné pro normální pochopení kódu, například mezera, komentáře a preprocesor – direktivy.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="5a9d8-164">Podobně jako syntaxe tokenů trivia jsou typy hodnot.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="5a9d8-165">Jedné <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> typ se používá k popisu nejrůznějších druhy trivia.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="5a9d8-166">Protože trivia nejsou součástí normálního jazykové syntaxe a může vyskytovat kdekoli mezi dvěma tokenů, nejsou zahrnuty ve stromu syntaxe jako podřízený uzel.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="5a9d8-167">Ještě protože jsou důležité při implementaci funkce jako Refaktoring a udržovat úplné věrnosti textem zdroje, existují v rámci stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="5a9d8-168">Dostanete trivia zkontrolováním token <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> nebo <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> kolekce.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="5a9d8-169">Pokud je zdrojový text analyzovat, jsou spojeny s tokeny pořadí trivia.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="5a9d8-170">Obecně platí token vlastní žádné trivia za ním na stejném řádku až na další token.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="5a9d8-171">Všechny trivia po daného řádku je přidružen následující token.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="5a9d8-172">Získá počáteční trivia prvního tokenu ve zdrojovém souboru, a poslední pořadí trivia v souboru je standardní na token end souboru, který jinak má nulové šířku.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="5a9d8-173">Na rozdíl od syntaxe uzly a tokeny nemají syntaxe trivia nadřazené položky.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="5a9d8-174">Ještě, protože jsou součástí stromové struktuře a každé je přidružen jeden token, můžete získat token je spojené s použitím <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="5a9d8-175">Rozpětí</span><span class="sxs-lookup"><span data-stu-id="5a9d8-175">Spans</span></span>

<span data-ttu-id="5a9d8-176">Každý uzel, token nebo trivia zná pozici v rámci zdrojový text a počet znaků, které obsahuje.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="5a9d8-177">Na pozici textu je reprezentován jako 32bitové celé číslo nulovým základem je `char` index.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="5a9d8-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> objekt počáteční pozice a počet znaků, obě vyjádřena jako celá čísla.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="5a9d8-179">Pokud <xref:Microsoft.CodeAnalysis.Text.TextSpan> má nulové délky, odkazuje na umístění mezi dva znaky.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="5a9d8-180">Každý uzel má dva <xref:Microsoft.CodeAnalysis.Text.TextSpan> vlastnosti: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> a <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span></span> 

<span data-ttu-id="5a9d8-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> Vlastnost je text období od začátku prvního tokenu v uzlu stromu dílčí na konec posledního token.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="5a9d8-182">Toto rozpětí nezahrnuje žádné trivia začátku nebo na konci.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="5a9d8-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> Vlastnost je značka span textu, která zahrnuje normální rozpětí uzlu plus rozpětí žádné trivia začátku nebo na konci.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="5a9d8-184">Příklad:</span><span class="sxs-lookup"><span data-stu-id="5a9d8-184">For example:</span></span> 

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="5a9d8-185">Příkaz uzel uvnitř bloku má rozpětí indikován jeden svislé čáry (|).</span><span class="sxs-lookup"><span data-stu-id="5a9d8-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="5a9d8-186">Obsahuje znaky `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="5a9d8-187">Úplná značka span je indikován dvojité svislé čáry (|).</span><span class="sxs-lookup"><span data-stu-id="5a9d8-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="5a9d8-188">Obsahuje stejné znaky jako rozpětí a přidružené trivia úvodní a koncové znaky.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="5a9d8-189">Typy</span><span class="sxs-lookup"><span data-stu-id="5a9d8-189">Kinds</span></span>

<span data-ttu-id="5a9d8-190">Má každý uzel, token nebo trivia <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> vlastnost typu <xref:System.Int32?displayProperty=nameWithType>, identifikující reprezentované element Přesná syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="5a9d8-191">Tato hodnota může být převeden na konkrétní jazyk výčet; Každý jazyk C# nebo VB, má jeden `SyntaxKind` – výčet (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> a <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, v uvedeném pořadí), jsou uvedeny všechny možné uzlů, tokeny a trivia prvky v gramatice.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-191">This value can be cast to a language-specific enumeration; each language, C# or VB, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="5a9d8-192">Tento převod je možné provést automaticky přímým přístupem <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> nebo <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> rozšiřující metody.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="5a9d8-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> Vlastnost umožňuje snadno rozlišení více tras syntaxe uzlu typů, které sdílejí stejnou třídu uzlu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="5a9d8-194">Pro tokeny a trivia tato vlastnost je jediný způsob, jak z jiné rozlišení jeden typ elementu.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span> 

<span data-ttu-id="5a9d8-195">Například jeden <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> třída má <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> jako podřízené objekty.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="5a9d8-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> Vlastnost odlišuje toho, jestli je <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, nebo <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> druh uzlu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="5a9d8-197">Chyby</span><span class="sxs-lookup"><span data-stu-id="5a9d8-197">Errors</span></span>

<span data-ttu-id="5a9d8-198">I v případě, že zdrojový text obsahuje syntaktické chyby, je vystaven úplnou syntaxí stromové struktury, která je odbavovaná ke zdroji.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="5a9d8-199">Pokud analyzátor nalezne kód, který není v souladu s definovanou syntaxe jazyka, používá jednu z dvě techniky k vytvoření stromu syntaxe.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="5a9d8-200">První Pokud analyzátor očekává konkrétní typ tokenu, ale nebyl nalezen, může vložit chybějící token do stromu syntaxe v umístění, aby byl očekáván token.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-200">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="5a9d8-201">Představuje skutečný token, který byl očekáván token chybí, ale má prázdný span a jeho <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> vlastnost vrátí `true`.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="5a9d8-202">Analyzátor, druhý může přeskočit tokeny, dokud nenalezne kde může pokračovat, analýze.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-202">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="5a9d8-203">V takovém případě jsou přeskočené tokeny připojené jako uzel trivia s druh <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="5a9d8-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
