---
title: "Dědičnost v jazyce C#"
description: "Naučte se používat dědičnosti knihovny jazyka C# a v aplikacích."
keywords: "dědičnost (C#), základní třídy odvozené třídy, základních tříd abstraktu"
author: rpetrusha
manager: wpickett
ms.author: ronpet
ms.date: 08/16/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 39de8879fd902c714a58cf59c70f0a4914b2ff6e
ms.sourcegitcommit: 9bee08539b1886c9d57fa3d5bd8a58dfdd7cad94
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/12/2017
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="b1a1c-104">Dědičnost v C# a rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="b1a1c-104">Inheritance in C# and .NET</span></span>

<span data-ttu-id="b1a1c-105">Tento kurz vás seznámí s dědičnosti v jazyce C#.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-105">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="b1a1c-106">Dědičnost je funkce objektově orientované programovací jazyky, která vám umožní zadat základní třídu, která poskytuje konkrétní funkce (dat a chování) a definovat odvozené třídy, které dědí nebo přepsání této funkce.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-106">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="b1a1c-107">Požadavky</span><span class="sxs-lookup"><span data-stu-id="b1a1c-107">Prerequisites</span></span>

<span data-ttu-id="b1a1c-108">Tento kurz předpokládá, že jste nainstalovali .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-108">This tutorial assumes that you've installed .NET Core.</span></span> <span data-ttu-id="b1a1c-109">Pokyny k instalaci naleznete v tématu [Průvodce instalací .NET Core](https://www.microsoft.com/net/core).</span><span class="sxs-lookup"><span data-stu-id="b1a1c-109">For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core).</span></span> <span data-ttu-id="b1a1c-110">Musíte také editor kódu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-110">You also need a code editor.</span></span> <span data-ttu-id="b1a1c-111">Tento kurz používá [Visual Studio Code](https://code.visualstudio.com), přestože je možné použít libovolný editor kódu podle svého výběru.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-111">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="b1a1c-112">Spuštění příkladů</span><span class="sxs-lookup"><span data-stu-id="b1a1c-112">Running the examples</span></span>

<span data-ttu-id="b1a1c-113">Chcete-li vytvořit a spustit v příkladech v tomto kurzu, je použít [dotnet](../../core/tools/dotnet.md) nástroj z příkazového řádku.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-113">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="b1a1c-114">Pomocí těchto kroků pro každý příklad:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-114">Follow these steps for each example:</span></span>

1. <span data-ttu-id="b1a1c-115">Vytvořte adresář k uložení v příkladu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-115">Create a directory to store the example.</span></span>
1. <span data-ttu-id="b1a1c-116">Zadejte [novou konzolu pro dotnet](../../core/tools/dotnet-new.md) příkazu na příkazovém řádku k vytvoření nového projektu .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-116">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="b1a1c-117">Zkopírujte a vložte kód z příkladu do vašeho kódu editoru.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-117">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="b1a1c-118">Zadejte [dotnet obnovení](../../core/tools/dotnet-restore.md) příkazu z příkazového řádku k načtení nebo obnovte závislosti projektu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-118">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="b1a1c-119">Zadejte [dotnet spustit](../../core/tools/dotnet-run.md) příkaz pro zkompilování a spuštění v příkladu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-119">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>


## <a name="background-what-is-inheritance"></a><span data-ttu-id="b1a1c-120">Pozadí: Co je dědičnosti?</span><span class="sxs-lookup"><span data-stu-id="b1a1c-120">Background: What is inheritance?</span></span>

<span data-ttu-id="b1a1c-121">*Dědičnost* je jedním z základní atributy objektově orientované programování.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-121">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="b1a1c-122">Umožňuje definovat podřízené třídu, která opětovně používá (dědí), rozšiřuje nebo mění chování nadřazené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-122">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="b1a1c-123">Je volána třídu, jejíž členové jsou děděné *základní třída*.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-123">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="b1a1c-124">Třídu, která dědí členy základní třídy se nazývá *odvozené třídy*.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-124">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="b1a1c-125">C# a rozhraní .NET podporují *jedna dědičnost* pouze.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-125">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="b1a1c-126">To znamená třídu může dědit vlastnosti pouze z jedné třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-126">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="b1a1c-127">Dědičnost je však přenositelné, který umožňuje definovat hierarchie dědičnosti pro sadu typů.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-127">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="b1a1c-128">Jinými slovy, zadejte `D` může dědit vlastnosti z typu `C`, který dědí od typu `B`, který dědí od typu základní třídy `A`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-128">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="b1a1c-129">Protože je dědičnosti přenositelné, členy typu `A` jsou k dispozici na typ `D`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-129">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="b1a1c-130">Ne všechny členy základní třídy jsou děděné odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-130">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="b1a1c-131">Nejsou zděděné následující členy:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-131">The following members are not inherited:</span></span>

- <span data-ttu-id="b1a1c-132">[Statické konstruktory](../programming-guide/classes-and-structs/static-constructors.md), který inicializovat statických dat třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-132">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="b1a1c-133">[Instance konstruktory](../programming-guide/classes-and-structs/constructors.md), která se volá vytvořit novou instanci třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-133">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="b1a1c-134">Každá třída musí definovat vlastní konstruktory.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-134">Each class must define its own constructors.</span></span>

- <span data-ttu-id="b1a1c-135">[Finalizační metody](../programming-guide/classes-and-structs/destructors.md), které jsou volány uvolňování paměti modulu runtime zrušení instance třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-135">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="b1a1c-136">Při odvozené třídy dědí všechny ostatní členy základní třídy, bez ohledu na jejich, jestli jsou viditelné závisí na jejich usnadnění.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-136">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="b1a1c-137">Člen usnadnění ovlivňuje jeho viditelnost odvozené třídy následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-137">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="b1a1c-138">[Privátní](../language-reference/keywords/private.md) členové jsou viditelné pouze v odvozených třídách, které jsou vnořené v jejich základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-138">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="b1a1c-139">Jinak nejsou viditelné v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-139">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="b1a1c-140">V následujícím příkladu `A.B` je vnořená třída odvozená z `A`, a `C` je odvozena z `A`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-140">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="b1a1c-141">Privátní `A.value` pole je viditelné v A.B.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-141">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="b1a1c-142">Ale pokud odeberete komentářů ze `C.GetValue` metoda a pokus o zkompilování příkladu vyvolá chyba kompilátoru CS0122: "'A.value' je nedostupná v důsledku úrovně ochrany."</span><span class="sxs-lookup"><span data-stu-id="b1a1c-142">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="b1a1c-143">[Chráněné](../language-reference/keywords/protected.md) členové jsou viditelné pouze v odvozených třídách.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-143">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="b1a1c-144">[Interní](../language-reference/keywords/internal.md) členové jsou viditelné pouze v odvozených třídách, které se nacházejí ve stejném sestavení jako základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-144">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="b1a1c-145">Nebyly viditelné v odvozených třídách umístěný v jiném sestavení ze základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-145">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="b1a1c-146">[Veřejné](../language-reference/keywords/public.md) členové jsou viditelné v odvozených třídách a jsou součástí veřejné rozhraní odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-146">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="b1a1c-147">Veřejné zděděné členy nelze volat, stejně, jako kdyby byly definovány v odvozené třídě.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-147">Public inherited members can be called just as if they were defined in the derived class.</span></span> <span data-ttu-id="b1a1c-148">V následujícím příkladu třída `A` definuje metodu s názvem `Method1`a třída `B` dědí z třídy `A`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-148">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="b1a1c-149">V příkladu pak zavolá `Method1` jako by šlo metodu instance na `B`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-149">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="b1a1c-150">Odvozené třídy mohou také *přepsat* zděděné členy tím, že poskytuje alternativní implementace.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-150">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="b1a1c-151">Aby bylo možné přepsat členem, musí být označen člen v základní třídě [virtuální](../language-reference/keywords/virtual.md) – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-151">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="b1a1c-152">Ve výchozím nastavení, členy základní třídy nejsou označeny jako `virtual` a nelze ji přepsat.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-152">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="b1a1c-153">Probíhá pokus o přepsání nevirtuálních člena, stejně jako v následujícím příkladu, vygeneruje Chyba kompilátoru CS0506: "<member> nejde přepsat zděděného členu <member> protože není označena jako virtuální, abstraktní, nebo potlačit.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-153">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="b1a1c-154">V některých případech odvozené třídě *musí* přepsat implementaci základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-154">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="b1a1c-155">Členy třídy, které jsou označené jako základní [abstraktní](../language-reference/keywords/abstract.md) – klíčové slovo vyžadují, aby odvozené třídy nepřepíšete.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-155">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="b1a1c-156">Pokus o kompilovat v následujícím příkladu vygeneruje Chyba kompilátoru CS0534, "<class> neimplementuje zděděného členu abstraktní <member>', protože třída `B` poskytuje žádné implementaci pro `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-156">Attempting to compile the following example generates compiler error CS0534, "<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="b1a1c-157">Dědičnost platí jenom pro třídy a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-157">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="b1a1c-158">Další typ kategorie (struktury, delegáti a výčty) nepodporují dědičnosti.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-158">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="b1a1c-159">Z toho důvodu pokusu kompilace kódu takto vytváří Chyba kompilátoru CS0527: "Typ"typ hodnoty' v seznamu rozhraní není rozhraní."</span><span class="sxs-lookup"><span data-stu-id="b1a1c-159">Because of this, attempting to compile code like the following produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="b1a1c-160">Chybová zpráva znamená, že i když můžete definovat rozhraní, která implementuje struktury, dědičnosti není podporovaný.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-160">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="b1a1c-161">Implicitní dědičnosti</span><span class="sxs-lookup"><span data-stu-id="b1a1c-161">Implicit inheritance</span></span>

<span data-ttu-id="b1a1c-162">Kromě toho všechny typy, které mohou dědit z prostřednictvím jedna dědičnost, všechny typy v rozhraní .NET typ systému implicitně dědí z <xref:System.Object> nebo typ z něj odvozenou.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-162">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="b1a1c-163">To zajistí, že běžné funkce je k dispozici k libovolnému typu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-163">This ensures that common functionality is available to any type.</span></span>

<span data-ttu-id="b1a1c-164">Pokud chcete zobrazit, jaké implicitní dědičnosti znamená, že umožňuje definovat novou třídu, `SimpleClass`, který je jednoduše definici prázdné třídy:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-164">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="b1a1c-165">Můžeme využít reflexe (které umožňují nám zkontrolovat typu metadat k načtení informací o typu) Chcete-li získat seznam členů, které patří do `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-165">We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="b1a1c-166">I když jsme nebyly definovány žádné členy v našem `SimpleClass` třída, výstup z příkladu znamená, že je ve skutečnosti má devět členů.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-166">Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="b1a1c-167">Jedním z nich je konstruktor bez parametrů (nebo výchozí), který automaticky poskytnutý `SimpleClass` typ kompilátorem C#.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-167">One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="b1a1c-168">Zbývající osm jsou členy <xref:System.Object>, typ, ze kterého všechny třídy a rozhraní .NET systém typů nakonec implicitně dědit vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-168">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="b1a1c-169">Implicitní dědění ze <xref:System.Object> třídu, můžete tyto metody `SimpleClass` třídy:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-169">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="b1a1c-170">Veřejnosti `ToString` metody, která převádí `SimpleClass` objektu na řetězcovou reprezentaci, vrátí typ plně kvalifikovaný název.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-170">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="b1a1c-171">V takovém případě `ToString` metoda vrátí řetězec "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="b1a1c-171">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="b1a1c-172">Tři metody, které testování rovnosti dvou objektů: veřejné instance `Equals(Object)` metoda, veřejné statické `Equals(Object, Object)` metoda a veřejné statické `ReferenceEquals(Object, Object)` metoda.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-172">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="b1a1c-173">Ve výchozím nastavení tyto metody testování rovnosti odkazů; To znamená si rovny dvě proměnné objektu musí odkazovat na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-173">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="b1a1c-174">Veřejnosti `GetHashCode` metodu, která vypočítá hodnotu, která umožňuje instanci typu, který se má použít v kolekcích hash.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-174">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="b1a1c-175">Veřejnosti `GetType` metoda, která vrátí hodnotu <xref:System.Type> objekt, který reprezentuje `SimpleClass` typu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-175">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="b1a1c-176">Chráněného <xref:System.Object.Finalize%2A> metodu, která slouží k uvolnění nespravovaných prostředků, než je paměť objektu uvolnit modulem garbage collector.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-176">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="b1a1c-177">Chráněného <xref:System.Object.MemberwiseClone%2A> metodu, která vytvoří bez podstruktury klon aktuálního objektu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-177">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="b1a1c-178">Z důvodu implicitní dědičnosti říkáme žádné zděděného členu z `SimpleClass` stejně, jako by byl ve skutečnosti členem objektu je definována v `SimpleClass` třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-178">Because of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="b1a1c-179">Například v následujícím příkladu volání `SimpleClass.ToString` metoda, která `SimpleClass` dědí z <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-179">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="b1a1c-180">Následující tabulka obsahuje seznam kategorií typů, které můžete vytvořit v jazyku C# a typy, ze kterých budou implicitně dědí.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-180">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="b1a1c-181">Každý základní typ zpřístupní jinou sadu členů prostřednictvím dědičnosti implicitně odvozené typy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-181">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="b1a1c-182">Typ kategorie</span><span class="sxs-lookup"><span data-stu-id="b1a1c-182">Type category</span></span> | <span data-ttu-id="b1a1c-183">Implicitně dědí z</span><span class="sxs-lookup"><span data-stu-id="b1a1c-183">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="b1a1c-184">třída</span><span class="sxs-lookup"><span data-stu-id="b1a1c-184">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="b1a1c-185">struct </span><span class="sxs-lookup"><span data-stu-id="b1a1c-185">struct</span></span>        | <span data-ttu-id="b1a1c-186"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="b1a1c-186"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="b1a1c-187">enum</span><span class="sxs-lookup"><span data-stu-id="b1a1c-187">enum</span></span>          | <span data-ttu-id="b1a1c-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="b1a1c-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="b1a1c-189">delegát</span><span class="sxs-lookup"><span data-stu-id="b1a1c-189">delegate</span></span>      | <span data-ttu-id="b1a1c-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="b1a1c-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="b1a1c-191">Dědičnost a "je" relace</span><span class="sxs-lookup"><span data-stu-id="b1a1c-191">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="b1a1c-192">Obvykle se používá dědičnosti vyjádřit "je" vztah mezi základní třídou a jeden nebo více odvozené třídy, které jsou odvozené třídy specializované verze základní třídy; odvozená třída je typu základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-192">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="b1a1c-193">Například `Publication` třída reprezentuje publikace libovolného typu a `Book` a `Magazine` třídy představují konkrétní typy publikací.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-193">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="b1a1c-194">Třídě nebo struktuře můžete implementovat jednu další rozhraní.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-194">A class or struct can implement one more interfaces.</span></span> <span data-ttu-id="b1a1c-195">Při implementaci rozhraní se často zobrazí jako alternativní řešení pro jedna dědičnost nebo jako způsob použití dědičnosti struktury, je určena k jiné relace ("provést" vztah) mezi rozhraní a jeho implementující typ než express dědičnost.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-195">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="b1a1c-196">Rozhraní definuje podmnožinu funkcí (například možnost k testování rovnosti k porovnání řazení objektů, nebo pro podporu jazykovou analýzy a formátování), které typy jejího implementující zpřístupní rozhraní.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-196">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="b1a1c-197">Všimněte si, že "je" také vyjadřuje vztah mezi typem a konkrétní instanci daného typu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-197">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="b1a1c-198">V následujícím příkladu `Automobile` je třída, která má tři jedinečné vlastnosti jen pro čtení: `Make`, výrobce automobilu; `Model`, druh automobilu; a `Year`, jeho rok výroby.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-198">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="b1a1c-199">Naše `Automobile` třída také obsahuje konstruktor jejichž argumenty jsou přiřazeny k hodnoty vlastností a přepíše <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodu pro vytvoření řetězec, který jednoznačně identifikuje `Automobile` instance místo `Automobile` třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-199">Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="b1a1c-200">V takovém případě jsme neměli spoléhat na dědičnosti k reprezentaci značky konkrétní car a modelu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-200">In this case, we should not rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="b1a1c-201">Například můžeme nemusíte definovat `Packard` typ, který má představovat automobilů pocházejí od společnosti Packard Motor Auto.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-201">For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="b1a1c-202">Místo toho jsme může reprezentovat vytvořením `Automobile` objekt s příslušnými hodnotami předaný konstruktor třídy, stejně jako v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-202">Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="b1a1c-203">Relace je a podle dědičnosti se nejlépe použije základní třída a odvozené třídy, přidejte další členy do základní třídu nebo, které vyžadují další funkce nejsou k dispozici v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-203">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="b1a1c-204">Navrhování základní třída a odvozené třídy</span><span class="sxs-lookup"><span data-stu-id="b1a1c-204">Designing the base class and derived classes</span></span>

<span data-ttu-id="b1a1c-205">Podívejme se na vytváření základní třídy a jejich odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-205">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="b1a1c-206">V této části se budeme definovat základní třídu, `Publication`, která představuje publikace libovolného typu, například knihy, časopise, novinách, deníku, článku atd. Budeme také definovat `Book` třídu odvozenou od `Publication`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-206">In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="b1a1c-207">Příklad můžete definovat další odvozené třídy, jako jsme může rozšířit snadno `Magazine`, `Journal`, `Newspaper`, a `Article`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-207">We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="b1a1c-208">Základní třída publikace</span><span class="sxs-lookup"><span data-stu-id="b1a1c-208">The base Publication class</span></span>

<span data-ttu-id="b1a1c-209">V návrhu naše `Publication` třídy, je třeba mít několik rozhodnutí o návrhu:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-209">In designing our `Publication` class, we need to make several design decisions:</span></span>

- <span data-ttu-id="b1a1c-210">Jaké členy pro zahrnutí do našich základní `Publication` třída a jestli `Publication` členy poskytovat metoda implementace, nebo jestli `Publication` je abstraktní základní třída, která slouží jako šablona pro jejich odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-210">What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="b1a1c-211">V takovém případě `Publication` třída bude poskytovat implementace metoda.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-211">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="b1a1c-212">[Navrhování abstraktní základní třídy a jejich odvozené třídy](#abstract) část obsahuje příklad, který se používá abstraktní základní třída pro definování metody, které odvozené třídy musí přepsat.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-212">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="b1a1c-213">Odvozené třídy mohou poskytnout žádnou implementaci, který je vhodný pro odvozený typ.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-213">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="b1a1c-214">Možnost pro opakované použití kódu (tedy více odvozené třídy sdílet deklarace a implementaci základní metody třídy a není potřeba nepřepíšete) je výhoda neabstraktní základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-214">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="b1a1c-215">Proto měli přidávat členy do `Publication` Pokud svůj kód je pravděpodobně sdílí některé nebo nejvíce specializuje `Publication` typy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-215">Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="b1a1c-216">Pokud se nám nepovedlo Uděláte to tak efektivní, jsme nakonec se museli zadávat implementace z velké části identické člen v odvozených třídách místo jediná implementace v základní třídě.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-216">If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="b1a1c-217">Je potřeba udržovat duplicitní kód v několika umístěních je potenciální příčinu chyby.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-217">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="b1a1c-218">Jak chcete maximalizovat kód opakované použití a vytvoření hierarchie dědičnosti logické a intuitivní, chceme mít jistotu, že jsme zahrnout do `Publication` třídy data a funkce, které jsou společné pro všechny nebo většinu publikace.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-218">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="b1a1c-219">Odvozené třídy pak implementovat členy, které jsou jedinečné pro konkrétní typy publikace, která představují.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-219">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="b1a1c-220">Jak daleko rozšířit naše hierarchie tříd.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-220">How far to extend our class hierarchy.</span></span> <span data-ttu-id="b1a1c-221">Chcete nám vyvíjet hierarchie tři nebo více tříd, nikoli jednoduše základní třída a jeden nebo více odvozené třídy?</span><span class="sxs-lookup"><span data-stu-id="b1a1c-221">Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="b1a1c-222">Například `Publication` může být základní třídě `Periodical`, který je zase základní třídě `Magazine`, `Journal` a `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-222">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="b1a1c-223">Pro náš příklad použijeme jednoduché hierarchii `Publication` třída a jeden odvozené třídy `Book`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-223">For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`.</span></span> <span data-ttu-id="b1a1c-224">Jsme může snadno rozšířit příklad k vytvoření počet další třídy, které jsou odvozeny od `Publication`, jako například `Magazine` a `Article`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-224">We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="b1a1c-225">Jestli má smysl pro vytvoření instance základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-225">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="b1a1c-226">Pokud ne, jsme by se měly používat [abstraktní](../language-reference/keywords/abstract.md) – klíčové slovo k třídě.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-226">If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="b1a1c-227">Pokud je proveden pokus o vytvoření instance třídy označené jako `abstract` – klíčové slovo přímé volání konstruktoru třídy kompilátor jazyka C# generuje chyby CS0144, "Nelze vytvořit instanci abstraktní třídy nebo rozhraní".</span><span class="sxs-lookup"><span data-stu-id="b1a1c-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="b1a1c-228">Pokud je k pokusu vytvořit instanci třídy pomocí reflexe, vrátí metoda reflexe <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span> <span data-ttu-id="b1a1c-229">V opačném naše `Publication` může vytvořit instanci třídy voláním konstruktor třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-229">Otherwise, our `Publication` class can be instantiated by calling its class constructor.</span></span>

  <span data-ttu-id="b1a1c-230">Ve výchozím nastavení můžete vytvořit instanci základní třídu voláním konstruktor třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-230">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="b1a1c-231">Všimněte si, že jsme není nutné explicitně definujte konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-231">Note that we do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="b1a1c-232">Pokud není přítomen ve zdrojovém kódu základní třídy, kompilátor jazyka C# automaticky poskytuje výchozí konstruktor (bez parametrů).</span><span class="sxs-lookup"><span data-stu-id="b1a1c-232">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="b1a1c-233">Pro náš příklad jsme budete označit `Publication` třídy jako [abstraktní](../language-reference/keywords/abstract.md) tak, aby ji nelze vytvořit instanci.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-233">For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>

- <span data-ttu-id="b1a1c-234">Jestli odvozené třídy musí dědit provádění konkrétní členy základní třídy, nebo jestli mají možnost přepsání implementaci základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-234">Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.</span></span> <span data-ttu-id="b1a1c-235">Budeme muset použít [virtuální](../language-reference/keywords/virtual.md) – klíčové slovo umožňující odvozené třídy přepsat metodu základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-235">We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="b1a1c-236">Ve výchozím nastavení, jsou metody definované v základní třídě *není* přepisovatelné.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-236">By default, methods defined in the base class are *not* overridable.</span></span>

- <span data-ttu-id="b1a1c-237">Jestli odvozené třídě představuje poslední třídu v hierarchii dědičnosti a nelze samotné použít jako základní třída pro další odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-237">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="b1a1c-238">Ve výchozím nastavení může jakákoli třída sloužit jako základní třída.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-238">By default, any class can serve as a base class.</span></span> <span data-ttu-id="b1a1c-239">Můžeme použít [zapečetěné](../language-reference/keywords/sealed.md) – klíčové slovo indikující, že třída nemůže sloužit jako základní třída pro všechny další třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-239">We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="b1a1c-240">Při pokusu o odvození z chyby kompilátoru zapečetěné třídy generované CS0509, "nelze odvodit z zapečetěné typ <typeName>".</span><span class="sxs-lookup"><span data-stu-id="b1a1c-240">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type <typeName>".</span></span>

  <span data-ttu-id="b1a1c-241">Pro náš příklad jsme budete označit naše odvozené třídy jako `sealed`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-241">For our example, we'll mark our derived class as `sealed`.</span></span>

<span data-ttu-id="b1a1c-242">Následující příklad ukazuje, zdrojový kód `Publication` třída, a také `PublicationType` výčet, který je vrácen rutinou `Publication.PublicationType` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-242">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="b1a1c-243">Kromě členů, které dědí z <xref:System.Object>, `Publication` třída definuje následující členy jedinečný a člen přepisuje:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-243">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="b1a1c-244">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="b1a1c-244">A constructor</span></span>

  <span data-ttu-id="b1a1c-245">Protože `Publication` třída je `abstract`, nelze vytvořit instanci přímo z kódu takto:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-245">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="b1a1c-246">Však lze volat jeho konstruktoru instance přímo z konstruktorů v odvozené třídě, jako zdrojový kód `Book` třídy ukazuje.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-246">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="b1a1c-247">Dvě vlastnosti související s publikace</span><span class="sxs-lookup"><span data-stu-id="b1a1c-247">Two publication-related properties</span></span>

  <span data-ttu-id="b1a1c-248">`Title`jen pro čtení <xref:System.String> vlastnost, jehož hodnota je poskytnuta voláním `Publication` konstruktor.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-248">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="b1a1c-249">`Pages`je pro čtení a zápis <xref:System.Int32> má vlastnost, která určuje, kolik celkem stránky publikace.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-249">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="b1a1c-250">Hodnota je uložena v soukromé pole s názvem `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-250">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="b1a1c-251">Musí být kladné číslo nebo <xref:System.ArgumentOutOfRangeException> je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-251">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="b1a1c-252">Související vydavatele členy</span><span class="sxs-lookup"><span data-stu-id="b1a1c-252">Publisher-related members</span></span>

  <span data-ttu-id="b1a1c-253">Dvě vlastnosti jen pro čtení, `Publisher` a `Type`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-253">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="b1a1c-254">Hodnoty jsou původně poskytl volání `Publication` konstruktoru třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-254">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="b1a1c-255">Publikování související členy</span><span class="sxs-lookup"><span data-stu-id="b1a1c-255">Publishing-related members</span></span>

  <span data-ttu-id="b1a1c-256">Dvě metody, `Publish` a `GetPublicationDate`, nastavení a vracení datum publikace.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-256">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="b1a1c-257">`Publish` Metoda nastaví privátního `published` příznak, který `true` kdy se nazývá a přiřadí datum do ní předán jako argument pro privátní `datePublished` pole.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-257">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="b1a1c-258">`GetPublicationDate` Metoda vrátí řetězec "NYP", pokud `published` příznak je `false`a hodnota `datePublished` pole, pokud je `true`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-258">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="b1a1c-259">Copyright související členy</span><span class="sxs-lookup"><span data-stu-id="b1a1c-259">Copyright-related members</span></span>

  <span data-ttu-id="b1a1c-260">`Copyright` Metoda přebírá název držitel autorských právech a rok copyrightu jako argumenty a přiřazuje jim `CopyrightName` a `CopyrightDate` vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-260">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="b1a1c-261">Přepsání `ToString` – metoda</span><span class="sxs-lookup"><span data-stu-id="b1a1c-261">An override of the `ToString` method</span></span>

  <span data-ttu-id="b1a1c-262">Pokud typ nepřepisuje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda, vrátí plně kvalifikovaný název typu, který je málo použití v rozlišení jednu instanci z jiné.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-262">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="b1a1c-263">`Publication` Třídy přepsání <xref:System.Object.ToString%2A?displayProperty=nameWithType> vrátit hodnotu `Title` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-263">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="b1a1c-264">Následující obrázek ukazuje vztah mezi naše základní `Publication` třídy a jeho implicitně zděděné <xref:System.Object> třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-264">The following figure illustrates the relationship between our base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Třídy objektu a publikace](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="b1a1c-266">`Book` – Třída</span><span class="sxs-lookup"><span data-stu-id="b1a1c-266">The `Book` class</span></span>

<span data-ttu-id="b1a1c-267">`Book` Třída reprezentuje knihy jako specializované typ publikace.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-267">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="b1a1c-268">Následující příklad ukazuje, zdrojový kód `Book` třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-268">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="b1a1c-269">Kromě členů, které dědí z `Publication`, `Book` třída definuje následující členy jedinečný a člen přepisuje:</span><span class="sxs-lookup"><span data-stu-id="b1a1c-269">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="b1a1c-270">Dva konstruktory</span><span class="sxs-lookup"><span data-stu-id="b1a1c-270">Two constructors</span></span>

  <span data-ttu-id="b1a1c-271">Dva `Book` konstruktory sdílet tři společné parametry.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-271">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="b1a1c-272">Dva, *název* a *vydavatele*, odpovídají parametry `Publication` konstruktor.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-272">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="b1a1c-273">Je třetí *Autor*, které se ukládají do privátního `authorName` pole.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-273">The third is *author*, which is stored to a private `authorName` field.</span></span> <span data-ttu-id="b1a1c-274">Obsahuje jeden konstruktor *isbn* parametr, který je uložen v `ISBN` vlastnost automaticky.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-274">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="b1a1c-275">První konstruktor používá [to](../language-reference/keywords/this.md) – klíčové slovo volat jiné konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-275">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="b1a1c-276">Toto je běžný vzor k definování konstruktory.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-276">This is a common pattern in defining constructors.</span></span> <span data-ttu-id="b1a1c-277">Konstruktory s méně parametry zadejte výchozí hodnoty při volání metody konstruktor s největší počet parametrů.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-277">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="b1a1c-278">Druhý konstruktor používá [základní](../language-reference/keywords/base.md) – klíčové slovo předat a vydavateli názvu konstruktor základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-278">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="b1a1c-279">Pokud neprovedete explicitní volání konstruktoru základní třídy ve zdrojovém kódu, kompilátor jazyka C# automaticky poskytuje volání výchozí základní třídu nebo konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-279">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="b1a1c-280">Jen pro čtení `ISBN` vlastnost, která vrací `Book` objektu mezinárodní standardní číslo knihy, jedinečné nebo 1310místné číslo.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-280">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="b1a1c-281">ISBN je zadaný jako argument pro jednu z `Book` konstruktory.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-281">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="b1a1c-282">V poli privátní zálohování, které je automaticky generované kompilátorem je uložený ISBN.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-282">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="b1a1c-283">Jen pro čtení `Author` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-283">A read-only `Author` property.</span></span> <span data-ttu-id="b1a1c-284">Jméno autora je zadaný jako argument pro obě `Book` konstruktory a je uložen v privátní `authorName` pole.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-284">The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field.</span></span>

- <span data-ttu-id="b1a1c-285">Dvě jen pro čtení související s cenami vlastnosti, `Price` a `Currency`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-285">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="b1a1c-286">Jejich hodnoty jsou uvedeny jako argumentů `SetPrice` volání metody.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-286">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="b1a1c-287">Ceny je uložen v soukromé pole `bookPrice`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-287">The price is stored in a private field, `bookPrice`.</span></span> <span data-ttu-id="b1a1c-288">`Currency` Vlastnost je symbolu měny ISO třímístné (například USD dolaru USA) a je uložen v privátní `ISOCurrencySymbol` pole.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-288">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field.</span></span> <span data-ttu-id="b1a1c-289">Symboly ISO měny je možné načíst z <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-289">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span>

- <span data-ttu-id="b1a1c-290">A `SetPrice` metoda, která nastavuje hodnoty `bookPrice` a `ISOCurrencySymbol` pole.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-290">A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields.</span></span> <span data-ttu-id="b1a1c-291">Jedná se o hodnoty vrácené `Price` a `Currency` vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-291">These are the values returned by the `Price` and `Currency` properties.</span></span>

- <span data-ttu-id="b1a1c-292">Přepsání `ToString` – metoda (zděděno z `Publication`) a <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> a <xref:System.Object.GetHashCode%2A> metody (zděděno z <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="b1a1c-292">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="b1a1c-293">Pokud není přepsána, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda testování rovnosti odkazů.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-293">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="b1a1c-294">Dvě proměnné objektu to znamená, se považují za rovna Pokud odkazují na stejný objekt.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-294">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="b1a1c-295">U `Book` třídy, na druhé straně dva `Book` objekty by měly být shodné v případě, že mají stejný ISBN.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-295">In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="b1a1c-296">Při přepsání <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda, je nutné také přepsat <xref:System.Object.GetHashCode%2A> metoda, která vrátí hodnotu, která používá modul runtime ukládá položky do kolekce hash pro efektivní načtení.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-296">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="b1a1c-297">Hodnota hash by měl vrátit hodnotu, která je konzistentní s testování rovnosti.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-297">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="b1a1c-298">Vzhledem k tomu, že jsme jste přepsat <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> vrátit `true` Pokud ISBN vlastnosti dva `Book` objekty jsou stejné, se vrací hodnota hash vypočítaného voláním <xref:System.String.GetHashCode%2A> metoda řetězec vrácený `ISBN` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-298">Since we've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="b1a1c-299">Následující obrázek ukazuje vztah mezi `Book` třídy a `Publication`, jeho základní třída.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-299">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Třídy publikace a adresáře](media/book-class.jpg)

<span data-ttu-id="b1a1c-301">Nyní jsme můžete vytvořit instanci `Book` objektu vyvolání její jedinečný a zděděné členy a předat jako argument pro metodu, která očekává parametr typu `Publication` nebo typu `Book`, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-301">We can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="b1a1c-302">Navrhování abstraktní základní třídy a jejich odvozené třídy</span><span class="sxs-lookup"><span data-stu-id="b1a1c-302">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="b1a1c-303">V předchozím příkladu jsme definovali základní třídu, která poskytuje implementaci pro počet metody, které umožňují sdílet kód odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-303">In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="b1a1c-304">V mnoha případech ale základní třída není očekáván poskytnout implementaci.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-304">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="b1a1c-305">Místo toho je základní třída *abstraktní třída*; slouží jako šablonu, která definuje členy, že všechny odvozené třídy musí implementovat.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-305">Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="b1a1c-306">V případě abstraktní základní třídu, je obvykle jedinečné pro daný typ provádění jednotlivých odvozeného typu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-306">Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</span></span>

<span data-ttu-id="b1a1c-307">Například každý uzavřený obrazec dvourozměrná geometrickou obsahuje dvě vlastnosti: oblasti, vnitřní rozsah tvaru; a hraniční, nebo vzdálenosti na okrajů tvaru.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-307">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="b1a1c-308">Způsob, ve kterém jsou vypočítávány tyto vlastnosti, ale závisí zcela na konkrétní tvaru.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-308">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="b1a1c-309">Vzorec pro výpočet hraniční (nebo obvodu) kruh, například je příliš neliší od trojúhelníku.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-309">The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</span></span>

<span data-ttu-id="b1a1c-310">V následujícím příkladu definuje abstraktní základní třídu s názvem `Shape` , který definuje dvě vlastnosti: `Area` a `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-310">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="b1a1c-311">Všimněte si, že, kromě třídu označit pomocí [abstraktní](../language-reference/keywords/abstract.md) – klíčové slovo, každý člen instance je také označené jako [abstraktní](../language-reference/keywords/abstract.md) – klíčové slovo.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-311">Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="b1a1c-312">V takovém případě `Shape` také přepsání <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda vrátí název typu, nikoli plně kvalifikovaným názvem.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-312">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="b1a1c-313">A definuje dvě statické členy `GetArea` a `GetPerimeter`, které umožňují volající k snadnému načtení oblasti a hraniční instance všechny odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-313">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="b1a1c-314">Když jsme instanci odvozené třídy předat do jedné z těchto metod, modul runtime volá přepsání metody odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-314">When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="b1a1c-315">Jsme můžete pak odvozovat některé z `Shape` které představují konkrétní obrazce.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-315">We can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="b1a1c-316">V následujícím příkladu definuje tři třídy `Triangle`, `Rectangle`, a `Circle`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-316">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="b1a1c-317">Vzorec pro tento konkrétní tvar jedinečné každá používá k výpočtu oblasti a hraniční.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-317">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="b1a1c-318">Některé z odvozené třídy definovat také vlastnosti, jako například `Rectangle.Diagonal` a `Circle.Diameter`, které jsou jedinečné pro obrazec, který představují.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-318">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="b1a1c-319">Následující příklad používá objekty, které jsou odvozené z `Shape`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-319">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="b1a1c-320">Vytvoření instance pole objektů, které jsou odvozené z `Shape` a volání statických metod `Shape` třídy, která zabalí vrátit `Shape` hodnot vlastností.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-320">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="b1a1c-321">Všimněte si, že modul runtime načítá hodnoty ze přepsané vlastnosti u odvozeného typu.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-321">Note that the runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="b1a1c-322">Tento příklad také vrhá každý `Shape` objekt v poli, aby jeho odvozený typ a pokud přetypování úspěšné, načte vlastnosti této konkrétní podtřídou třídy `Shape`.</span><span class="sxs-lookup"><span data-stu-id="b1a1c-322">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="b1a1c-323">Viz také</span><span class="sxs-lookup"><span data-stu-id="b1a1c-323">See also</span></span>

<span data-ttu-id="b1a1c-324">[Třídy a objekty](../tour-of-csharp/classes-and-objects.md) </span><span class="sxs-lookup"><span data-stu-id="b1a1c-324">[Classes and objects](../tour-of-csharp/classes-and-objects.md) </span></span>  
[<span data-ttu-id="b1a1c-325">Dědičnost (C# Průvodce programováním)</span><span class="sxs-lookup"><span data-stu-id="b1a1c-325">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
