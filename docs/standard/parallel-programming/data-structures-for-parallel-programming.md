---
title: Datové struktury pro paralelní programování
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 99d62eca26e19d343b3f8f6afb9824c009610fb4
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33585084"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="e8fd4-102">Datové struktury pro paralelní programování</span><span class="sxs-lookup"><span data-stu-id="e8fd4-102">Data Structures for Parallel Programming</span></span>
<span data-ttu-id="e8fd4-103">Rozhraní .NET Framework verze 4 zavádí několik nových typů, které jsou užitečné v paralelní programování, včetně sadu souběžných kolekce tříd, zjednodušené synchronizace primitiv a typy pro opožděné inicializace.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-103">The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="e8fd4-104">Všechny aplikace s více vlákny kód, včetně Task Parallel Library a PLINQ můžete používat tyto typy.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="e8fd4-105">Souběžná kolekce tříd</span><span class="sxs-lookup"><span data-stu-id="e8fd4-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="e8fd4-106">Třídy kolekce v <xref:System.Collections.Concurrent?displayProperty=nameWithType> oboru názvů zadejte vláken přidávat a odstraňovat operace, které vyhnout zámky, pokud je to možné a pomocí podrobných zamykání, kde jsou potřebné zámky.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="e8fd4-107">Na rozdíl od kolekcí, které byly zavedeny v rozhraní .NET Framework verze 1.0 a 2.0 nevyžaduje třídu souběžných kolekce uživatelského kódu se má provést jakékoli zámky při přistupuje k položky.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-107">Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="e8fd4-108">Třídy souběžných kolekce může výrazně zlepšit výkon nad typy, jako <xref:System.Collections.ArrayList?displayProperty=nameWithType> a <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (s implementované uživatele uzamčení) ve scénářích, kde více vláken, přidání a odebrání položek z kolekce.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="e8fd4-109">Následující tabulka uvádí nové třídy souběžných kolekce:</span><span class="sxs-lookup"><span data-stu-id="e8fd4-109">The following table lists the new concurrent collection classes:</span></span>  
  
|<span data-ttu-id="e8fd4-110">Typ</span><span class="sxs-lookup"><span data-stu-id="e8fd4-110">Type</span></span>|<span data-ttu-id="e8fd4-111">Popis</span><span class="sxs-lookup"><span data-stu-id="e8fd4-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-112">Poskytuje blokování a možnosti pro kolekce bezpečné pro přístup z více vláken, které implementují ohraničujícího <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8fd4-113">Producent vláken blok, pokud nejsou dostupné žádné sloty nebo pokud kolekce je plný.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="e8fd4-114">Příjemce vláken blokovat, pokud se kolekce je prázdná.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="e8fd4-115">Tento typ podporuje také neblokující přístup spotřebitelů a výrobců.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="e8fd4-116"><xref:System.Collections.Concurrent.BlockingCollection%601> lze použít jako základní třída nebo zálohování úložiště k poskytování blokování a ohraničujícího pro třídy kolekce, které podporuje <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-117">Implementace bezpečné pro přístup z více vláken kontejner objektů a dat, která poskytuje škálovatelné přidejte a získejte operace.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-118">Typ souběžných a škálovatelné slovníku.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-119">Fronty FIFO souběžných a škálovatelnost.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-120">Zásobník LIFO souběžných a škálovatelnost.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="e8fd4-121">Další informace najdete v tématu [kolekce se zabezpečenými vlákny](../../../docs/standard/collections/thread-safe/index.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-121">For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="e8fd4-122">Synchronizace primitiv</span><span class="sxs-lookup"><span data-stu-id="e8fd4-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="e8fd4-123">Nové synchronizace primitiv v <xref:System.Threading?displayProperty=nameWithType> obor názvů povolit podrobné souběžnosti a vyšší výkon vyhnout nákladné uzamčení mechanismy nalezen v kódu starší verze více vláken.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-123">The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span> <span data-ttu-id="e8fd4-124">Některé z nových typů, jako například <xref:System.Threading.Barrier?displayProperty=nameWithType> a <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> mít žádné svými protějšky v dřívějších verzích rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-124">Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.</span></span>  
  
 <span data-ttu-id="e8fd4-125">Následující tabulka uvádí nové typy synchronizace:</span><span class="sxs-lookup"><span data-stu-id="e8fd4-125">The following table lists the new synchronization types:</span></span>  
  
|<span data-ttu-id="e8fd4-126">Typ</span><span class="sxs-lookup"><span data-stu-id="e8fd4-126">Type</span></span>|<span data-ttu-id="e8fd4-127">Popis</span><span class="sxs-lookup"><span data-stu-id="e8fd4-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-128">Umožňuje více vláken pro práci na algoritmus paralelně tím, že poskytuje bod, kdy každý úkol signál jeho doručení a potom zablokuje, dokud se zobrazila některé nebo všechny úlohy.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="e8fd4-129">Další informace najdete v tématu [Barrier](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-129">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-130">Zjednodušuje tím, že poskytuje mechanismus snadno potkávací scénáře rozvětvení a připojení.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="e8fd4-131">Další informace najdete v tématu [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-131">For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-132">Podobně jako synchronizace primitivní <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8fd4-133"><xref:System.Threading.ManualResetEventSlim> je světlejšího váhy, ale lze použít pouze pro komunikace uvnitř procesy.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span> <span data-ttu-id="e8fd4-134">Další informace najdete v tématu [ManualResetEvent a ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-134">For more information, see [ManualResetEvent and ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-135">Primitivní synchronizace, která omezuje počet vláken, které můžou současně získat přístup k prostředku nebo fond prostředků.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-135">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="e8fd4-136">Další informace najdete v tématu [semafor a SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-136">For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-137">Primitivní zámku vzájemné vyloučení, která způsobuje vlákno, které se pokouší získat zámek čekat ve smyčce, nebo *typu číselník*, dobu než je jeho quantum.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-137">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="e8fd4-138">Ve scénářích, kde je očekávána čekání zámek být krátký <xref:System.Threading.SpinLock> nabízí vyšší výkon než jiné formy uzamčení.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-138">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="e8fd4-139">Další informace najdete v tématu [SpinLock](../../../docs/standard/threading/spinlock.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-139">For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-140">Malé, lightweight typ, který bude číselníku po určitou dobu a nakonec vlákno uvést do stavu čekání, pokud dojde k překročení počtu typu číselník.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-140">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="e8fd4-141">Další informace najdete v tématu [objektu SpinWait](../../../docs/standard/threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-141">For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="e8fd4-142">Další informace naleznete v tématu:</span><span class="sxs-lookup"><span data-stu-id="e8fd4-142">For more information, see:</span></span>  
  
-   [<span data-ttu-id="e8fd4-143">Postupy: Použití struktury SpinLock pro synchronizaci nízké úrovně</span><span class="sxs-lookup"><span data-stu-id="e8fd4-143">How to: Use SpinLock for Low-Level Synchronization</span></span>](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
-   <span data-ttu-id="e8fd4-144">[Postupy: synchronizace souběh operací pomocí bariéry](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-144">[How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="e8fd4-145">Opožděná inicializace třídy</span><span class="sxs-lookup"><span data-stu-id="e8fd4-145">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="e8fd4-146">Pomocí opožděné inicializace není přidělit paměť pro objekt, dokud nebude potřeba.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-146">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="e8fd4-147">Opožděná inicializace může zlepšit výkon rovnoměrně rozloží objekt přidělení napříč životnost program.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-147">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="e8fd4-148">Můžete povolit opožděné inicializace pro každý vlastní typ zabalení typ <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-148">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="e8fd4-149">Následující tabulka uvádí typy opožděné inicializace:</span><span class="sxs-lookup"><span data-stu-id="e8fd4-149">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="e8fd4-150">Typ</span><span class="sxs-lookup"><span data-stu-id="e8fd4-150">Type</span></span>|<span data-ttu-id="e8fd4-151">Popis</span><span class="sxs-lookup"><span data-stu-id="e8fd4-151">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-152">Poskytuje odlehčený, bezpečné pro přístup z více vláken opožděné inicializace.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-152">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-153">Poskytuje hodnotu líné inicializovat na základě vlákna, každý podproces líné – vyvolání funkce inicializace.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-153">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="e8fd4-154">Poskytuje statické metody, které nemuseli přidělit instance vyhrazené, opožděné inicializace.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-154">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="e8fd4-155">Místo toho používají odkazy pro zajistěte, aby byly inicializovány cíle, jako jsou přístupná.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-155">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="e8fd4-156">Další informace najdete v tématu [opožděné inicializace](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-156">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="e8fd4-157">Agregační výjimky</span><span class="sxs-lookup"><span data-stu-id="e8fd4-157">Aggregate Exceptions</span></span>  
 <span data-ttu-id="e8fd4-158"><xref:System.AggregateException?displayProperty=nameWithType> Typ lze použít k zachycení několik výjimek, které jsou vyvolány souběžně v samostatných vláknech a vrátí je do spojovacího vlákna jako jeden výjimka.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-158">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="e8fd4-159"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> typy a PLINQ použít <xref:System.AggregateException> hojně pro tento účel.</span><span class="sxs-lookup"><span data-stu-id="e8fd4-159">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="e8fd4-160">Další informace najdete v tématu [NIB: postupy: zpracování výjimek vyvolaných úlohami](https://msdn.microsoft.com/library/d6c47ec8-9de9-4880-beb3-ff19ae51565d) a [postupy: zpracování výjimek v PLINQ dotazu](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="e8fd4-160">For more information, see [NIB: How to: Handle Exceptions Thrown by Tasks](https://msdn.microsoft.com/library/d6c47ec8-9de9-4880-beb3-ff19ae51565d) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e8fd4-161">Viz také</span><span class="sxs-lookup"><span data-stu-id="e8fd4-161">See Also</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
 <xref:System.Threading?displayProperty=nameWithType>  
 [<span data-ttu-id="e8fd4-162">Paralelní programování</span><span class="sxs-lookup"><span data-stu-id="e8fd4-162">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
