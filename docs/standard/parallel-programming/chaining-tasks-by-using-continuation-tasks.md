---
title: Řetězení úloh pomocí úloh pokračování
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: f5c5cd2fd4d9c334d45a52e23bb0d320abd13cb5
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/04/2018
ms.locfileid: "43563069"
---
# <a name="chaining-tasks-by-using-continuation-tasks"></a><span data-ttu-id="21d25-102">Řetězení úloh pomocí úloh pokračování</span><span class="sxs-lookup"><span data-stu-id="21d25-102">Chaining Tasks by Using Continuation Tasks</span></span>
<span data-ttu-id="21d25-103">V asynchronním programování je velmi běžné, že jedna asynchronní operace při dokončení vyvolá druhou operaci a předá jí data.</span><span class="sxs-lookup"><span data-stu-id="21d25-103">In asynchronous programming, it is very common for one asynchronous operation, on completion, to invoke a second operation and pass data to it.</span></span> <span data-ttu-id="21d25-104">Tradičně se to stalo pomocí metod zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="21d25-104">Traditionally, this has been done by using callback methods.</span></span> <span data-ttu-id="21d25-105">V Task Parallel Library je stejná funkčnost zajištěna pomocí *pokračujících úloh*.</span><span class="sxs-lookup"><span data-stu-id="21d25-105">In the Task Parallel Library, the same functionality is provided by *continuation tasks*.</span></span> <span data-ttu-id="21d25-106">Pokračující úloha (nazývaná také pouze pokračování) je asynchronní úloha, která je vyvolána jinou úlohou, která se nazývá *předchůdce*, jakmile je předchůdce dokončen.</span><span class="sxs-lookup"><span data-stu-id="21d25-106">A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the *antecedent*, when the antecedent finishes.</span></span>  
  
 <span data-ttu-id="21d25-107">Pokračování jsou relativně snadno použitelná, ale přesto jsou velmi výkonná a flexibilní.</span><span class="sxs-lookup"><span data-stu-id="21d25-107">Continuations are relatively easy to use, but are nevertheless very powerful and flexible.</span></span> <span data-ttu-id="21d25-108">Například můžete:</span><span class="sxs-lookup"><span data-stu-id="21d25-108">For example, you can:</span></span>  
  
-   <span data-ttu-id="21d25-109">Předejte data z předchůdce do pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-109">Pass data from the antecedent to the continuation.</span></span>  
  
-   <span data-ttu-id="21d25-110">Určete přesné podmínky, za kterých bude vyvolána pokračování nebo není vyvolána.</span><span class="sxs-lookup"><span data-stu-id="21d25-110">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>  
  
-   <span data-ttu-id="21d25-111">Zrušte pokračování před spuštěním nebo kooperativně za běhu.</span><span class="sxs-lookup"><span data-stu-id="21d25-111">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>  
  
-   <span data-ttu-id="21d25-112">Poskytnout nápovědu, jak by měl být pokračování naplánováno.</span><span class="sxs-lookup"><span data-stu-id="21d25-112">Provide hints about how the continuation should be scheduled.</span></span>  
  
-   <span data-ttu-id="21d25-113">Vyvolejte ze stejného předchůdce více pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-113">Invoke multiple continuations from the same antecedent.</span></span>  
  
-   <span data-ttu-id="21d25-114">Vyvolejte jedno pokračování, až skončí všichni nebo jeden z více předchůdců.</span><span class="sxs-lookup"><span data-stu-id="21d25-114">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>  
  
-   <span data-ttu-id="21d25-115">Zřetězit pokračování jedno po druhém do jakékoli libovolné délky.</span><span class="sxs-lookup"><span data-stu-id="21d25-115">Chain continuations one after another to any arbitrary length.</span></span>  
  
-   <span data-ttu-id="21d25-116">Použijte pokračování pro zpracování výjimek vyvolaných předchůdcem.</span><span class="sxs-lookup"><span data-stu-id="21d25-116">Use a continuation to handle exceptions thrown by the antecedent.</span></span>  
  
## <a name="about-continuations"></a><span data-ttu-id="21d25-117">Informace o pokračování</span><span class="sxs-lookup"><span data-stu-id="21d25-117">About continuations</span></span>  
 <span data-ttu-id="21d25-118">Pokračování je úkol, který je vytvořen v <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> stavu.</span><span class="sxs-lookup"><span data-stu-id="21d25-118">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="21d25-119">Je aktivována automaticky po dokončení jeho předchozí úlohy nebo úlohy.</span><span class="sxs-lookup"><span data-stu-id="21d25-119">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="21d25-120">Volání <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> na pokračování v uživatelském kódu vyvolá <xref:System.InvalidOperationException?displayProperty=nameWithType> výjimky.</span><span class="sxs-lookup"><span data-stu-id="21d25-120">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>  
  
 <span data-ttu-id="21d25-121">Pokračování je samo o sobě <xref:System.Threading.Tasks.Task> a neblokuje vlákno, na kterém je spuštěno.</span><span class="sxs-lookup"><span data-stu-id="21d25-121">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="21d25-122">Volání <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metoda blokuje, dokud neskončí úloha pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-122">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>  
  
## <a name="creating-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="21d25-123">Vytváření pro jeden předchůdce pokračování</span><span class="sxs-lookup"><span data-stu-id="21d25-123">Creating a continuation for a single antecedent</span></span>  
 <span data-ttu-id="21d25-124">Vytvořit pokračování, který se spustí po dokončení jeho předchůdce voláním <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="21d25-124">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="21d25-125">Následující příklad zobrazuje základní vzor (pro přehlednost je vynecháno zpracování výjimek).</span><span class="sxs-lookup"><span data-stu-id="21d25-125">The following example shows the basic pattern (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="21d25-126">Je spuštěn předchozí úlohy, `taskA`, která vrací <xref:System.DayOfWeek> objekt, který určuje název aktuální den v týdnu.</span><span class="sxs-lookup"><span data-stu-id="21d25-126">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="21d25-127">Jakmile je předchůdce dokončen, úkol pokračování `continuation`, je předán předchůdce a zobrazí řetězec, který obsahuje výsledek.</span><span class="sxs-lookup"><span data-stu-id="21d25-127">When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result.</span></span>  
  
 [!code-csharp[TPL_Continuations#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/simple1.cs#1)]
 [!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]  
  
## <a name="creating-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="21d25-128">Vytváření pokračování pro více předchůdců</span><span class="sxs-lookup"><span data-stu-id="21d25-128">Creating a continuation for multiple antecedents</span></span>  
 <span data-ttu-id="21d25-129">Můžete také vytvořit pokračování, které se spustí po dokončení některých nebo všech skupiny úkolů.</span><span class="sxs-lookup"><span data-stu-id="21d25-129">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="21d25-130">Provést pokračování po dokončení všechny předchozí úkoly, zavolejte statickou (`Shared` v jazyce Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> metodu nebo instanci <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="21d25-130">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="21d25-131">Provést pokračování, až všechny předchozí úkoly dokončí, zavolejte statickou (`Shared` v jazyce Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> metodu nebo instanci <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="21d25-131">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="21d25-132">Všimněte si, že se volá, aby <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> přetížení nedochází k blokování volajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="21d25-132">Note that calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span>  <span data-ttu-id="21d25-133">Však obvykle volat pouze na <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> a <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> metody pro načtení vráceného <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost, která blokování volajícího vlákna.</span><span class="sxs-lookup"><span data-stu-id="21d25-133">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and  <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>  
  
 <span data-ttu-id="21d25-134">Následující příklad volá <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> metody k vytvoření pokračování úlohy, která odráží výsledky jeho deset předchozí úlohy.</span><span class="sxs-lookup"><span data-stu-id="21d25-134">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its ten antecedent tasks.</span></span> <span data-ttu-id="21d25-135">Každé předchozí úlohy squares hodnotu indexu, který se pohybuje od jedné až deset.</span><span class="sxs-lookup"><span data-stu-id="21d25-135">Each antecedent task squares an index value that ranges from one to ten.</span></span> <span data-ttu-id="21d25-136">Pokud předchůdců úspěšně dokončit (jejich <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> vlastnost <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost pokračování je pole <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> hodnoty vrácené každou předchůdce.</span><span class="sxs-lookup"><span data-stu-id="21d25-136">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="21d25-137">V příkladu se přidají k výpočtu součet kvadratických hodnot pro všechna čísla v rozsahu od 1 do 10.</span><span class="sxs-lookup"><span data-stu-id="21d25-137">The example adds them to compute the sum of squares for all numbers between one and ten.</span></span>  
  
 [!code-csharp[TPL_Continuations#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/whenall1.cs#5)]
 [!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]  
  
## <a name="continuation-options"></a><span data-ttu-id="21d25-138">Možnosti pokračování</span><span class="sxs-lookup"><span data-stu-id="21d25-138">Continuation options</span></span>  
 <span data-ttu-id="21d25-139">Při vytváření pokračování jedné úlohy, můžete použít <xref:System.Threading.Tasks.Task.ContinueWith%2A> přetížení, které přijímá <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> hodnotu výčtu pro určení podmínek, za kterých pokračování spustí.</span><span class="sxs-lookup"><span data-stu-id="21d25-139">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="21d25-140">Například můžete určit, že pokračování má spustit jenom v případě, že je předchůdce dokončen úspěšně, nebo pouze v případě, že dokončení v chybovém stavu.</span><span class="sxs-lookup"><span data-stu-id="21d25-140">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="21d25-141">Pokud podmínka není splněna, kdy je předchůdce připraven k vyvolání pokračování, pokračování přechází přímo <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> stavu a nemůže být dále spuštěno.</span><span class="sxs-lookup"><span data-stu-id="21d25-141">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and cannot be started after that.</span></span>  
  
 <span data-ttu-id="21d25-142">Počet metod víceúlohového pokračování, jako jsou přetížení <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> metoda, také zahrnovat <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parametr.</span><span class="sxs-lookup"><span data-stu-id="21d25-142">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="21d25-143">Pouze podmnožinu všech <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> členy výčtu jsou platné, ale.</span><span class="sxs-lookup"><span data-stu-id="21d25-143">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="21d25-144">Můžete zadat <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> hodnoty, které mají jejich protějšky v <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> výčtu, například <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, a <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="21d25-144">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="21d25-145">Pokud je zadána některá z `NotOn` nebo `OnlyOn` možnosti s víceúlohovým pokračováním <xref:System.ArgumentOutOfRangeException> v době běhu, bude vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="21d25-145">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>  
  
 <span data-ttu-id="21d25-146">Další informace o možnosti pokračování úlohy, najdete v článku <xref:System.Threading.Tasks.TaskContinuationOptions> tématu.</span><span class="sxs-lookup"><span data-stu-id="21d25-146">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>  
  
## <a name="passing-data-to-a-continuation"></a><span data-ttu-id="21d25-147">Předávání údajů do pokračování</span><span class="sxs-lookup"><span data-stu-id="21d25-147">Passing Data to a Continuation</span></span>  
 <span data-ttu-id="21d25-148"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> Metoda předává reference na předchůdce uživatelskému delegátovi pokračování jako argument.</span><span class="sxs-lookup"><span data-stu-id="21d25-148">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="21d25-149">Pokud je předchůdce <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> objekt a tato úloha spustila úspěšně dokončen, pak může pokračování přistupovat <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnosti úlohy.</span><span class="sxs-lookup"><span data-stu-id="21d25-149">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>  
  
 <span data-ttu-id="21d25-150"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Vlastnost blokuje, dokud není úloha dokončena.</span><span class="sxs-lookup"><span data-stu-id="21d25-150">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="21d25-151">Nicméně, pokud byla úloha zrušena nebo došlo k chybě, pokusu o přístup <xref:System.Threading.Tasks.Task%601.Result%2A> vyvolá vlastnost <xref:System.AggregateException> výjimky.</span><span class="sxs-lookup"><span data-stu-id="21d25-151">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="21d25-152">Tento problém můžete vyhnout použitím <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> možnosti, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="21d25-152">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Continuations#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result1.cs#2)]
 [!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]  
  
 <span data-ttu-id="21d25-153">Pokud chcete, aby pokračování spuštěno i v případě, že předchůdce nebyl spuštěn na úspěšné dokončení, musí se proti výjimce chránit.</span><span class="sxs-lookup"><span data-stu-id="21d25-153">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="21d25-154">Jedním z přístupů je otestovat <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> pokus o přístup k vlastnosti předchozí a jenom <xref:System.Threading.Tasks.Task%601.Result%2A> vlastnost Pokud stav není <xref:System.Threading.Tasks.TaskStatus.Faulted> nebo <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="21d25-154">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="21d25-155">Můžete také prozkoumat <xref:System.Threading.Tasks.Task.Exception%2A> vlastnosti předchůdce.</span><span class="sxs-lookup"><span data-stu-id="21d25-155">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="21d25-156">Další informace najdete v tématu [zpracování výjimek](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="21d25-156">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="21d25-157">Následující příklad upravuje předchozí příklad přístup předchůdce <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> vlastnost pouze v případě, že má stav <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="21d25-157">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[TPL_Continuations#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result2.cs#7)]
 [!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]  
  
## <a name="canceling-a-continuation"></a><span data-ttu-id="21d25-158">Zrušení pokračování</span><span class="sxs-lookup"><span data-stu-id="21d25-158">Canceling a Continuation</span></span>  
 <span data-ttu-id="21d25-159"><xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> Pokračování je nastavena na <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> v následujících situacích:</span><span class="sxs-lookup"><span data-stu-id="21d25-159">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>  
  
-   <span data-ttu-id="21d25-160">Vyvolá <xref:System.OperationCanceledException> výjimky v reakci na žádost o zrušení.</span><span class="sxs-lookup"><span data-stu-id="21d25-160">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="21d25-161">Stejně jako u každého úkolu, pokud výjimka obsahuje stejný token, který byl předán pokračování, je považován za potvrzení kooperativního zrušení.</span><span class="sxs-lookup"><span data-stu-id="21d25-161">Just as with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgement of cooperative cancellation.</span></span>  
  
-   <span data-ttu-id="21d25-162">Pokračování je předán <xref:System.Threading.CancellationToken?displayProperty=nameWithType> jehož <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> vlastnost `true`.</span><span class="sxs-lookup"><span data-stu-id="21d25-162">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="21d25-163">V takovém případě pokračování nespustí a přechází do <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> stavu.</span><span class="sxs-lookup"><span data-stu-id="21d25-163">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>  
  
-   <span data-ttu-id="21d25-164">Pokračování nikdy nespustí, protože podmínka nastavená jeho <xref:System.Threading.Tasks.TaskContinuationOptions> argument nebyl splněn.</span><span class="sxs-lookup"><span data-stu-id="21d25-164">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="21d25-165">Například, pokud předchozí přejde do <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> stavu, její pokračování, který byl předán <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> možnost se nespustí, ale nahradí <xref:System.Threading.Tasks.TaskStatus.Canceled> stavu.</span><span class="sxs-lookup"><span data-stu-id="21d25-165">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="21d25-166">Pokud úlohu a její pokračování představují dvě části stejné logické operace, můžete předat stejný token zrušení oběma úkolům, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="21d25-166">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="21d25-167">Zahrnuje předchůdce, který generuje seznam celých čísel, která jsou dělitelná 33, který předá do pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-167">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="21d25-168">Pokračování zase zobrazí v seznamu.</span><span class="sxs-lookup"><span data-stu-id="21d25-168">The continuation in turn displays the list.</span></span> <span data-ttu-id="21d25-169">Předchůdce a pokračování pozastavení pravidelně náhodných intervalech.</span><span class="sxs-lookup"><span data-stu-id="21d25-169">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="21d25-170">Kromě toho <xref:System.Threading.Timer?displayProperty=nameWithType> objekt se používá ke spuštění `Elapsed` metoda po pěti sekundách časový limit.</span><span class="sxs-lookup"><span data-stu-id="21d25-170">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="21d25-171">Volá <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodu, která způsobí, že právě prováděnou úlohu k volání <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="21d25-171">This calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="21d25-172">Zda <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metoda se volá, když je předchůdce nebo jeho pokračování provádí závisí na době trvání náhodně generované pozastaví.</span><span class="sxs-lookup"><span data-stu-id="21d25-172">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="21d25-173">Pokud je předchůdce zrušen, pokračování nespustí.</span><span class="sxs-lookup"><span data-stu-id="21d25-173">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="21d25-174">Pokud není předchůdce zrušen, token je stále možné pro zrušení pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-174">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>  
  
 [!code-csharp[TPL_Continuations#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation1.cs#3)]
 [!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]  
  
 <span data-ttu-id="21d25-175">Můžete také zabránit pokračování v provádění, zda je zrušen předchůdce bez poskytnutí pokračování token zrušení tak, že zadáte <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> při vytváření pokračování možnost.</span><span class="sxs-lookup"><span data-stu-id="21d25-175">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="21d25-176">Níže je jednoduchý příklad.</span><span class="sxs-lookup"><span data-stu-id="21d25-176">The following is a simple example.</span></span>  
  
 [!code-csharp[TPL_Continuations#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation2.cs#8)]
 [!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]  
  
 <span data-ttu-id="21d25-177">Přechod pokračování do <xref:System.Threading.Tasks.TaskStatus.Canceled> stavu, může ovlivnit pokračování, které následují, v závislosti na tom <xref:System.Threading.Tasks.TaskContinuationOptions> , které bylo zadáno pro tyto pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-177">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>  
  
 <span data-ttu-id="21d25-178">Pokračování, které jsou odstraněny se nespustí.</span><span class="sxs-lookup"><span data-stu-id="21d25-178">Continuations that are disposed will not start.</span></span>  
  
## <a name="continuations-and-child-tasks"></a><span data-ttu-id="21d25-179">Pokračování a podřízené úlohy</span><span class="sxs-lookup"><span data-stu-id="21d25-179">Continuations and Child Tasks</span></span>  
 <span data-ttu-id="21d25-180">Pokračování nespustí až do předchůdce a všechny jeho připojené podřízené úlohy dokončeny.</span><span class="sxs-lookup"><span data-stu-id="21d25-180">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="21d25-181">Pokračování nečeká na dokončení odpojených podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="21d25-181">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="21d25-182">Následující dva příklady ilustrují podřízených úloh, které jsou připojeny k a Odpojit z předchozí, která vytvoří pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-182">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="21d25-183">V následujícím příkladu se pokračování nespustí až po dokončení všech podřízených úloh a spuštění příkladu vytvoří více než jednou identické výstupu pokaždé, když.</span><span class="sxs-lookup"><span data-stu-id="21d25-183">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="21d25-184">Všimněte si, že v příkladu spustí předchůdce voláním <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody, protože ve výchozím nastavení <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metoda vytvoří nadřazenou úlohu, jejíž výchozí možnost vytváření úloh je <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="21d25-184">Note that the example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[TPL_Continuations#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/attached1.cs#9)]
 [!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]  
  
 <span data-ttu-id="21d25-185">Pokud podřízených úloh jsou odpojeny od předchůdce, ale pokračování spustí, jakmile je předchůdce byl ukončen, bez ohledu na stav podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="21d25-185">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="21d25-186">V důsledku toho více běhů v následujícím příkladu může vytvořit výstup proměnné, na kterém závisí způsob zpracování každá podřízená úloha Plánovač úloh.</span><span class="sxs-lookup"><span data-stu-id="21d25-186">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>  
  
 [!code-csharp[TPL_Continuations#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/detached1.cs#10)]
 [!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]  
  
 <span data-ttu-id="21d25-187">Konečný stav předchozí úlohy závisí na konečném stavu všech připojených podřízených úloh.</span><span class="sxs-lookup"><span data-stu-id="21d25-187">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="21d25-188">Stav odpojených podřízených úloh nemá vliv na nadřazený.</span><span class="sxs-lookup"><span data-stu-id="21d25-188">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="21d25-189">Další informace najdete v tématu [připojené a odpojené podřízené úlohy](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="21d25-189">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="associating-state-with-continuations"></a><span data-ttu-id="21d25-190">Přidružení stavu s pokračováními</span><span class="sxs-lookup"><span data-stu-id="21d25-190">Associating State with Continuations</span></span>  
 <span data-ttu-id="21d25-191">Pokračování úlohy lze přidružit libovolný stav.</span><span class="sxs-lookup"><span data-stu-id="21d25-191">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="21d25-192"><xref:System.Threading.Tasks.Task.ContinueWith%2A> Metoda poskytuje přetížené verze, která každá převezme <xref:System.Object> hodnotu, která představuje stav pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-192">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="21d25-193">Můžete později přístup k tomuto objektu stavu pomocí <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="21d25-193">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="21d25-194">Tento objekt stavu je `null` Pokud nezadáte hodnotu.</span><span class="sxs-lookup"><span data-stu-id="21d25-194">This state object is `null` if you do not provide a value.</span></span>  
  
 <span data-ttu-id="21d25-195">Stav pokračování je užitečný při převádění existujícího kódu, který se používá [asynchronního programovacího modelu (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) pro používání TPL.</span><span class="sxs-lookup"><span data-stu-id="21d25-195">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="21d25-196">V APM obvykle poskytnete stav objektů v **začít *** metoda* metoda a později získáte přístup k tomuto stavu pomocí <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="21d25-196">In the APM, you typically provide object state in the **Begin***Method* method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="21d25-197">S použitím <xref:System.Threading.Tasks.Task.ContinueWith%2A> metodu, můžete zachovat tento stav při převodu kódu, který používá APM pro použití TPL.</span><span class="sxs-lookup"><span data-stu-id="21d25-197">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>  
  
 <span data-ttu-id="21d25-198">Stav pokračování může také být užitečné při práci s <xref:System.Threading.Tasks.Task> objektů v ladicím programu sady Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="21d25-198">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="21d25-199">Například v **paralelní úlohy** okně **úloh** sloupec zobrazuje řetězcovou reprezentaci objektu stav pro každý úkol.</span><span class="sxs-lookup"><span data-stu-id="21d25-199">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="21d25-200">Další informace o **paralelní úlohy** okna, naleznete v tématu [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span><span class="sxs-lookup"><span data-stu-id="21d25-200">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>  
  
 <span data-ttu-id="21d25-201">Následující příklad ukazuje způsob použití stavu pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-201">The following example shows how to use continuation state.</span></span> <span data-ttu-id="21d25-202">Vytvoří řetězec pokračujících úloh.</span><span class="sxs-lookup"><span data-stu-id="21d25-202">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="21d25-203">Každá úloha obsahuje aktuální čas <xref:System.DateTime> objektu, pro `state` parametr <xref:System.Threading.Tasks.Task.ContinueWith%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="21d25-203">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="21d25-204">Každý <xref:System.DateTime> objekt představuje čas, kdy se vytvoří úkol pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-204">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="21d25-205">Každý úkol vytváří jako svůj výsledek a druhý <xref:System.DateTime> objekt, který představuje čas, kdy úloha dokončí.</span><span class="sxs-lookup"><span data-stu-id="21d25-205">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="21d25-206">Po dokončení všech úkolů tento příklad zobrazuje čas vytvoření a čas, ve které každý pokračování neskončí úloha.</span><span class="sxs-lookup"><span data-stu-id="21d25-206">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>  
  
 [!code-csharp[TPL_ContinuationState#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
## <a name="handling-exceptions-thrown-from-continuations"></a><span data-ttu-id="21d25-207">Zpracování výjimek vyvolaných z pokračování</span><span class="sxs-lookup"><span data-stu-id="21d25-207">Handling Exceptions Thrown from Continuations</span></span>  
 <span data-ttu-id="21d25-208">Vztah předchůdce pokračování není vztah nadřízenosti a podřízenosti.</span><span class="sxs-lookup"><span data-stu-id="21d25-208">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="21d25-209">Výjimky vyvolané pokračováním nejsou šířeny do předchůdce.</span><span class="sxs-lookup"><span data-stu-id="21d25-209">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="21d25-210">Proto zpracujte výjimky vyvolané v pokračování stejně jako je v libovolné jiné úloze a následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="21d25-210">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>  
  
-   <span data-ttu-id="21d25-211">Můžete použít <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, nebo <xref:System.Threading.Tasks.Task.WaitAny%2A> metody nebo jejich obecné protějšky pro čekání na pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-211">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="21d25-212">Můžete počkat předchůdce a jeho pokračování ve stejném `try` příkaz, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="21d25-212">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>  
  
     [!code-csharp[TPL_Continuations#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception1.cs#6)]
     [!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]  
  
-   <span data-ttu-id="21d25-213">Pomocí druhého pokračování sledovat <xref:System.Threading.Tasks.Task.Exception%2A> vlastnosti prvního pokračování.</span><span class="sxs-lookup"><span data-stu-id="21d25-213">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="21d25-214">V následujícím příkladu úlohu pokouší číst ze souboru neexistuje.</span><span class="sxs-lookup"><span data-stu-id="21d25-214">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="21d25-215">Pokračování pak zobrazí informace o výjimce v předchozí úlohy.</span><span class="sxs-lookup"><span data-stu-id="21d25-215">The continuation then displays information about the exception in the antecedent task.</span></span>  
  
     [!code-csharp[TPL_Continuations#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#4)]
     [!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]  
  
     <span data-ttu-id="21d25-216">Vzhledem k tomu, že byla spuštěna s <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> možnost, že pokračování spustí pouze v případě, že dojde k výjimce v předchůdce, a proto by ji můžete předpokládat, že je předchůdce <xref:System.Threading.Tasks.Task.Exception%2A> jedná o vlastnost neumožňující `null`.</span><span class="sxs-lookup"><span data-stu-id="21d25-216">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="21d25-217">Pokud pokračování spustí, zda je výjimka vyvolána v předchůdce, bude mít ke kontrole, jestli je předchůdce <xref:System.Threading.Tasks.Task.Exception%2A> jedná o vlastnost neumožňující `null` před pokusem o zpracování výjimky, jako následující fragment kódu ukazuje.</span><span class="sxs-lookup"><span data-stu-id="21d25-217">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>  
  
     [!code-csharp[TPL_Continuations#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#11)]
     [!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]  
  
     <span data-ttu-id="21d25-218">Další informace najdete v tématu [zpracování výjimek](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="21d25-218">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
-   <span data-ttu-id="21d25-219">Pokud je pokračování připojené podřízené úlohy, který byl vytvořen pomocí <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> možnost, výjimky se šířeny přes nadřízenou zpět do volajícího vlákna, stejně jako v případě v libovolného jiného připojeného podřízeného.</span><span class="sxs-lookup"><span data-stu-id="21d25-219">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="21d25-220">Další informace najdete v tématu [připojené a odpojené podřízené úlohy](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="21d25-220">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="21d25-221">Viz také</span><span class="sxs-lookup"><span data-stu-id="21d25-221">See Also</span></span>  
 [<span data-ttu-id="21d25-222">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="21d25-222">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
