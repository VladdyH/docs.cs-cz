---
title: "Porozumění zrychlení v PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 7d94a1fa4c559552a32140fd172c0c62e033f7a8
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/23/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="ebda2-102">Porozumění zrychlení v PLINQ</span><span class="sxs-lookup"><span data-stu-id="ebda2-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="ebda2-103">Primárním účelem PLINQ je pro urychlení provádění LINQ na objekty dotazy spuštěním dotazu delegáty paralelně na počítačích s více jádry.</span><span class="sxs-lookup"><span data-stu-id="ebda2-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="ebda2-104">Při zpracování jednotlivých prvků ve zdrojové kolekci je nezávislé, bez sdíleného stavu související se situací mezi jednotlivé delegáty se nejlépe provádí PLINQ.</span><span class="sxs-lookup"><span data-stu-id="ebda2-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="ebda2-105">Tyto operace jsou obvyklé v technologii LINQ to objekty a PLINQ a se často nazývají "*delightfully paralelní*" vzhledem k tomu, že je to možné snadno plánování na více vláken.</span><span class="sxs-lookup"><span data-stu-id="ebda2-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="ebda2-106">Nicméně ne všechny dotazy skládat delightfully paralelních operací; ve většině případů dotazu zahrnuje některé operátory buď nesmí být paralelizovaná málo, nebo které zpomalit paralelní provádění.</span><span class="sxs-lookup"><span data-stu-id="ebda2-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="ebda2-107">A dokonce i s dotazy, které jsou zcela delightfully paralelní, musí PLINQ stále oddílu zdroj dat a plánování práce na vláken a obvykle sloučení výsledků po dokončení dotazu.</span><span class="sxs-lookup"><span data-stu-id="ebda2-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="ebda2-108">Všechny tyto operace přidání do výpočetní náklady paralelizace; Tyto náklady přidávání paralelizace se nazývají *režijní náklady na*.</span><span class="sxs-lookup"><span data-stu-id="ebda2-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="ebda2-109">Cílem je dosáhnout optimálního výkonu v PLINQ dotazu, maximalizovat částí, které jsou delightfully paralelní a minimalizovat částí, které vyžadují režijní náklady.</span><span class="sxs-lookup"><span data-stu-id="ebda2-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="ebda2-110">Tento článek obsahuje informace, které vám pomohou psát dotazy PLINQ, které jsou co nejúčinnější při stále vracet správné výsledky.</span><span class="sxs-lookup"><span data-stu-id="ebda2-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="ebda2-111">Faktory, které mají vliv na výkon dotazu PLINQ</span><span class="sxs-lookup"><span data-stu-id="ebda2-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="ebda2-112">V následujících částech jsou uvedeny některé nejdůležitější faktorů, že dopad výkon paralelního dotazu.</span><span class="sxs-lookup"><span data-stu-id="ebda2-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="ebda2-113">Jedná se o Obecné příkazy, které samy o sobě nejsou dostatečná k předvídání výkon dotazů ve všech případech.</span><span class="sxs-lookup"><span data-stu-id="ebda2-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="ebda2-114">Jako vždy je důležité k měření skutečným výkonem konkrétní dotazů na počítačích s rozsahem reprezentativní konfigurace a zatížení.</span><span class="sxs-lookup"><span data-stu-id="ebda2-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="ebda2-115">Výpočetní náklady na celkový práce.</span><span class="sxs-lookup"><span data-stu-id="ebda2-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="ebda2-116">K dosažení zrychlení, musí mít dotazu PLINQ dostatek delightfully paralelní práce k posunutí režijní náklady.</span><span class="sxs-lookup"><span data-stu-id="ebda2-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="ebda2-117">Práce může být vyjádřený jako výpočetní náklady na každý delegáta násobí hodnotou počet elementů ve zdrojové kolekci.</span><span class="sxs-lookup"><span data-stu-id="ebda2-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="ebda2-118">Za předpokladu, že operace může být paralelizovaná málo, čím výpočetně nákladné je, tím větší možnost pro zrychlení.</span><span class="sxs-lookup"><span data-stu-id="ebda2-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="ebda2-119">Například pokud funkci přijímá jeden milisekund k provedení, může trvat sekvenční dotazu více než 1000 elementy bude trvat jednu sekundu k provedení této operace, zatímco paralelní dotaz na počítači s čtyři jader pouze 250 milisekund.</span><span class="sxs-lookup"><span data-stu-id="ebda2-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="ebda2-120">Dostaneme zrychlení 750 milisekund.</span><span class="sxs-lookup"><span data-stu-id="ebda2-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="ebda2-121">V případě potřeby sekundu provést pro každý prvek funkce by být zrychlení 750 sekund.</span><span class="sxs-lookup"><span data-stu-id="ebda2-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="ebda2-122">Pokud delegát je velmi náročná, může PLINQ nabízí významné zrychlení s pouze několik položek ve zdrojové kolekci.</span><span class="sxs-lookup"><span data-stu-id="ebda2-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="ebda2-123">Naopak malé zdroj kolekce s trivial delegáti nejsou obvykle vhodnými kandidáty pro PLINQ.</span><span class="sxs-lookup"><span data-stu-id="ebda2-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="ebda2-124">V následujícím příkladu je queryA pravděpodobně vhodným kandidátem pro PLINQ, za předpokladu, že jeho vyberte funkce zahrnuje značné úsilí.</span><span class="sxs-lookup"><span data-stu-id="ebda2-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="ebda2-125">queryB je pravděpodobně není vhodným kandidátem, protože není k dispozici dostatek pracovních v příkazu Select a režii paralelizace bude posunut většinu nebo všechny zrychlení.</span><span class="sxs-lookup"><span data-stu-id="ebda2-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="ebda2-126">Počet logických jádra systému (stupně paralelního zpracování).</span><span class="sxs-lookup"><span data-stu-id="ebda2-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="ebda2-127">Tento bod je zřejmé důsledkem v předchozí části, dotazy, které jsou delightfully paralelní rychleji, na počítače s více jader protože práce je možné rozdělit mezi více souběžných vláken.</span><span class="sxs-lookup"><span data-stu-id="ebda2-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="ebda2-128">Celkové množství zrychlení závisí na to, jaké procento celkové práce dotazu je může běžet paralelně.</span><span class="sxs-lookup"><span data-stu-id="ebda2-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="ebda2-129">Ale Nepředpokládejte, že všechny dotazy se spustí dvakrát jako rychlé v počítači osm jader jako čtyři základní počítač.</span><span class="sxs-lookup"><span data-stu-id="ebda2-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="ebda2-130">Při ladění dotazy pro optimální výkon, je důležité k měření skutečné výsledky na počítačích s různým počtem jader.</span><span class="sxs-lookup"><span data-stu-id="ebda2-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="ebda2-131">Tento bod má vztah k bodu #1: větších datových sad jsou nutné k využít větší výpočetní prostředky.</span><span class="sxs-lookup"><span data-stu-id="ebda2-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="ebda2-132">Počet a typ operací.</span><span class="sxs-lookup"><span data-stu-id="ebda2-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="ebda2-133">PLINQ poskytuje AsOrdered operátor pro situace, ve kterých je potřeba udržovat pořadí elementů ve zdrojové sekvence.</span><span class="sxs-lookup"><span data-stu-id="ebda2-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="ebda2-134">Náklady spojené s řazení, ale je obvykle mírné tyto poplatky.</span><span class="sxs-lookup"><span data-stu-id="ebda2-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="ebda2-135">Operace GroupBy a připojení k podobně zpoplatněná režijní náklady.</span><span class="sxs-lookup"><span data-stu-id="ebda2-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="ebda2-136">PLINQ poskytuje nejlepší výkon, pokud je povoleno pro zpracování elementů ve zdrojové kolekci v libovolném pořadí a předat další operátor, jakmile jsou připravené.</span><span class="sxs-lookup"><span data-stu-id="ebda2-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="ebda2-137">Další informace najdete v tématu [zachování pořadí v PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ebda2-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="ebda2-138">Formulář spuštění dotazu.</span><span class="sxs-lookup"><span data-stu-id="ebda2-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="ebda2-139">Pokud ukládáte voláním ToArray nebo ToList výsledků dotazu, musí být výsledky ze všech paralelních vláken sloučeny do jednoho datového struktury.</span><span class="sxs-lookup"><span data-stu-id="ebda2-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="ebda2-140">To zahrnuje výpočetní nákladů na nevyhnutelné použít.</span><span class="sxs-lookup"><span data-stu-id="ebda2-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="ebda2-141">Podobně pokud jste výsledky iteraci pomocí příkazu foreach (pro každou v jazyce Visual Basic) smyčky, výsledků pracovních vláken muset serializovat do vlákno enumerátor.</span><span class="sxs-lookup"><span data-stu-id="ebda2-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="ebda2-142">Ale pokud chcete provést některé akce na základě výsledku z každé vlákno, můžete použít metodu ForAll pro práci na více vláken.</span><span class="sxs-lookup"><span data-stu-id="ebda2-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="ebda2-143">Typ možností sloučení.</span><span class="sxs-lookup"><span data-stu-id="ebda2-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="ebda2-144">PLINQ lze nakonfigurovat buď jeho výstupní vyrovnávací paměť a ho vytvořit bloky dat nebo všechny najednou, po celou sadu výsledků vytváří, nebo jednotlivé výsledky datového proudu jako se vytváří.</span><span class="sxs-lookup"><span data-stu-id="ebda2-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="ebda2-145">Bývalé výsledkem je ke snížení celkové čas spuštění a druhá možnost vede ke snížení latence mezi poskytuje elementy.</span><span class="sxs-lookup"><span data-stu-id="ebda2-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="ebda2-146">Při možností sloučení nemají vždy významný vliv na celkový výkon dotazů, můžou ovlivnit dosahovaný výkon protože budou řídit, jak dlouho uživatel musí počkat a zobrazte výsledky.</span><span class="sxs-lookup"><span data-stu-id="ebda2-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="ebda2-147">Další informace najdete v tématu [možnosti sloučení v PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ebda2-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="ebda2-148">Druh rozdělení do oddílů.</span><span class="sxs-lookup"><span data-stu-id="ebda2-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="ebda2-149">V některých případech může způsobit dotazu PLINQ přes kolekci indexovanou zdroje nevyváženou pracovní zatížení.</span><span class="sxs-lookup"><span data-stu-id="ebda2-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="ebda2-150">V takovém případě je možné zvýšit výkon dotazů tak, že vytvoříte vlastní dělicí metody.</span><span class="sxs-lookup"><span data-stu-id="ebda2-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="ebda2-151">Další informace najdete v tématu [vlastní dělicí metody pro PLINQ a TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="ebda2-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="ebda2-152">Když PLINQ zvolí sekvenční režimu</span><span class="sxs-lookup"><span data-stu-id="ebda2-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="ebda2-153">PLINQ se vždy pokusí o spuštění dotazu alespoň tak rychlý jako dotaz se spouští sekvenčně.</span><span class="sxs-lookup"><span data-stu-id="ebda2-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="ebda2-154">I když PLINQ zdá o tom, jak u nákladné delegáty uživatele, nebo jak velkou vstupního zdroje, vyhledejte určité dotazu "tvarů."</span><span class="sxs-lookup"><span data-stu-id="ebda2-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="ebda2-155">Konkrétně vypadá pro operátory dotazu nebo kombinace operátory, které obvykle způsobí dotazu na provedení pomaleji v paralelním režimu.</span><span class="sxs-lookup"><span data-stu-id="ebda2-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="ebda2-156">Pokud najde takové tvarů, PLINQ ve výchozím nastavení přejde zpět do sekvenční režimu.</span><span class="sxs-lookup"><span data-stu-id="ebda2-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="ebda2-157">Ale po měření výkonu konkrétní dotaz, může určit, že ve skutečnosti běží rychleji v paralelním režimu.</span><span class="sxs-lookup"><span data-stu-id="ebda2-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="ebda2-158">V takových případech můžete použít <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> příznak prostřednictvím <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> metoda k vynucení PLINQ paralelní dotaz.</span><span class="sxs-lookup"><span data-stu-id="ebda2-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="ebda2-159">Další informace najdete v tématu [postupy: určení režimu spouštění v PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ebda2-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="ebda2-160">Následující seznam popisuje tvary dotazu, které PLINQ ve výchozím nastavení bude vykonán v sekvenčním režimu:</span><span class="sxs-lookup"><span data-stu-id="ebda2-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="ebda2-161">Dotazy, které obsahují s výběrem indexované kde indexované označit více, nebo klauzuli ElementAt po řazení nebo filtrování operátor, který se má odebrat nebo změně uspořádání původní indexy.</span><span class="sxs-lookup"><span data-stu-id="ebda2-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="ebda2-162">Dotazy obsahující proveďte TakeWhile, přeskočit, SkipWhile – operátor a kde indexy ve zdrojové sekvence nejsou ve stejném pořadí.</span><span class="sxs-lookup"><span data-stu-id="ebda2-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="ebda2-163">Dotazy, které obsahují Zip nebo SequenceEquals, pokud se některý ze zdrojů dat má indexu původně seřazené a jiný zdroj dat je indexovanou (tj. pole nebo IList(T)).</span><span class="sxs-lookup"><span data-stu-id="ebda2-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="ebda2-164">Dotazy, které obsahují Concat, pokud je tato indexovanou datové zdroje.</span><span class="sxs-lookup"><span data-stu-id="ebda2-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="ebda2-165">Dotazy, které obsahují vrátit, pokud se použije ke zdroji dat indexovanou.</span><span class="sxs-lookup"><span data-stu-id="ebda2-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ebda2-166">Viz také</span><span class="sxs-lookup"><span data-stu-id="ebda2-166">See Also</span></span>  
 [<span data-ttu-id="ebda2-167">Paralelní LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="ebda2-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
