---
title: "Komunikace v architektury mikroslužby"
description: "Architektura Mikroslužeb .NET pro aplikace .NET Kontejnerizované | Komunikace v architektura architektury mikroslužby"
keywords: "Docker, Mikroslužeb, ASP.NET, kontejneru"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 3920160697c55a81a131a7d8c40b096b064a6f03
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/23/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="5ad4f-104">Komunikace v architektury mikroslužby</span><span class="sxs-lookup"><span data-stu-id="5ad4f-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="5ad4f-105">V monolitický aplikace běžící v jednom procesu vyvolají komponenty navzájem pomocí metody úroveň jazyka nebo volání funkce.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="5ad4f-106">To může být silného spojen při vytváření objektů s kódem (například `new ClassName()`), nebo můžete vyvolat odpojeného způsobem, pokud používáte vkládání závislostí odkazem abstrakce, nikoli konkrétní objekt instancí.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="5ad4f-107">V obou případech objekty jsou spuštěny v rámci stejného procesu.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="5ad4f-108">Největší výzvou při změně z monolitický aplikace k aplikaci na základě mikroslužeb spočívá v změna komunikační mechanizmus.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="5ad4f-109">Přímé převod z volání metod v procesu do volání vzdáleného volání Procedur služby způsobí, že chatty a není efektivní komunikaci, která nebude provádět i v distribuovaných prostředích.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="5ad4f-110">Obtíže spojené s navrhování distribuovaného systému správně jsou dostatečně dobře známé se i canon, označuje jako [fallacies distribuovaných počítačů](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) , uvádí předpoklady, které vývojáři často při přesouvání z monolitický k distribuované návrhů.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="5ad4f-111">Není jedno řešení, ale některé.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-111">There is not one solution, but several.</span></span> <span data-ttu-id="5ad4f-112">Jedno řešení zahrnuje izolace co nejvíce obchodní mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="5ad4f-113">Potom použít asynchronní komunikaci mezi interní mikroslužeb a nahraďte podrobných komunikaci, která je typické v komunikaci mezi objekty s hrubší podrobných komunikace uvnitř procesy.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="5ad4f-114">To můžete udělat, tím, že volání a vrácením data, která agreguje výsledky více interní volání do klienta.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="5ad4f-115">Aplikace založené na mikroslužeb na je distribuovaný systém systémem více procesů nebo služeb, obvykle to i v rámci více serverů nebo hostitele.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="5ad4f-116">Každá instance služby je obvykle proces.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-116">Each service instance is typically a process.</span></span> <span data-ttu-id="5ad4f-117">Proto služby musí komunikovat pomocí protokol komunikaci mezi procesy, jako je například HTTP, AMQP nebo binární protokol například TCP, v závislosti na povaze jednotlivých služeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="5ad4f-118">Mikroslužbu Společenství podporuje filosofie z "[inteligentní koncových bodů a vlečný kanály](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)."</span><span class="sxs-lookup"><span data-stu-id="5ad4f-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="5ad4f-119">Jedná o tento reklamní umožňuje návrh, který je jako odpojené možném mezi mikroslužeb a jako získá na ucelenosti nejblíže v rámci jedné mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="5ad4f-120">Jak je popsáno výše, každý mikroslužbu vlastní svá vlastní data a vlastní logiku domény.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="5ad4f-121">Ale mikroslužeb skládání začátku do konce aplikace jsou obvykle jednoduše choreographed pomocí komunikaci REST místo komplexní protokoly, jako je například WS -\* a centralizované flexibilní komunikace místo založeného na událostech obchodní proces orchestrators.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="5ad4f-122">Dva běžně používané protokoly jsou požadavek/odpověď HTTP s prostředkem rozhraní API (při dotazování většinu všech) a lightweight asynchronní zasílání zpráv při komunikaci aktualizace napříč více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="5ad4f-123">Tyto jsou vysvětlené podrobněji v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="5ad4f-124">Typy komunikace</span><span class="sxs-lookup"><span data-stu-id="5ad4f-124">Communication types</span></span>

<span data-ttu-id="5ad4f-125">Klienta a služby mohou komunikovat prostřednictvím různých typech komunikace, každé z nich cílené na jiný scénář a cíle.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="5ad4f-126">Tyto typy komunikace původně, můžou být klasifikované v dvěma osami.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="5ad4f-127">První osa je definování, pokud je protokol synchronní nebo asynchronní:</span><span class="sxs-lookup"><span data-stu-id="5ad4f-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="5ad4f-128">Synchronní protokol.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-128">Synchronous protocol.</span></span> <span data-ttu-id="5ad4f-129">HTTP je synchronní protokol.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="5ad4f-130">Klient odešle požadavek a čeká na odpověď ze služby.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="5ad4f-131">Která je nezávislá provádění kódu klienta, které by mohly být synchronní (vlákno je blokované) nebo asynchronní (vlákno není blokované a odpovědi bude nakonec dosáhnout zpětné volání).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="5ad4f-132">Zde důležité je, že protokol (HTTP nebo HTTPS), je synchronní a kód klienta můžete jenom pokračovat úkolu, když obdrží odpověď HTTP serveru.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="5ad4f-133">Asynchronní protokol.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-133">Asynchronous protocol.</span></span> <span data-ttu-id="5ad4f-134">Asynchronní zprávy používají jiné protokoly, jako je AMQP (protokol, který podporuje mnoho operačních systémů a prostředí cloudu).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="5ad4f-135">Odesílatel kódu nebo zprávy klienta obvykle není čekat na odpověď.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="5ad4f-136">Právě odešle zprávu jako při odesílání zprávy do fronty RabbitMQ nebo jiné zprostředkovatele zpráv.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="5ad4f-137">Druhý osy je definování komunikace má jednoho příjemce nebo několika příjemců:</span><span class="sxs-lookup"><span data-stu-id="5ad4f-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="5ad4f-138">Jednoho příjemce.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-138">Single receiver.</span></span> <span data-ttu-id="5ad4f-139">Každý požadavek musí být zpracovává přesně jeden příjemce nebo službu.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="5ad4f-140">Je například tato komunikace [příkaz vzor](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="5ad4f-141">Několika příjemců.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-141">Multiple receivers.</span></span> <span data-ttu-id="5ad4f-142">Každý požadavek může zpracovat nula do několika příjemců.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="5ad4f-143">Tento typ komunikace musí být asynchronní.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="5ad4f-144">Příkladem je [publikování a přihlášení k odběru](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanismus používaný v vypadají podobně jako [událostmi řízené architektura](http://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="5ad4f-145">To je založené na zprostředkovatele rozhraní nebo zprávy událostí bus při šíření aktualizace dat mezi několika mikroslužeb prostřednictvím událostí; Obvykle se implementuje prostřednictvím sběrnice nebo podobné artefaktů jako [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) pomocí [témat a odběrů](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="5ad4f-146">Aplikace založené na mikroslužbu na se často používají kombinaci těchto styly komunikace.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="5ad4f-147">Nejběžnějším typem je jeden příjemce komunikace s synchronní protokol například HTTP nebo HTTPS, při vyvolání regulární služby webového rozhraní API HTTP.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="5ad4f-148">Mikroslužeb také běžně používají protokoly zasílání zpráv pro asynchronní komunikaci mezi mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="5ad4f-149">Tyto osy je dobré vědět, takže máte přehlednost na možné komunikační mechanizmy, ale nejsou důležité aspekty při sestavování mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="5ad4f-150">Asynchronní povaha provádění vlákna klienta ani asynchronní povaze vybrané protokolu jsou důležité body při integraci mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="5ad4f-151">Co *je* důležité je třeba možnost integrovat vaši mikroslužeb asynchronně při zachování nezávislost mikroslužeb, jak je popsáno v následující části.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="5ad4f-152">Asynchronní mikroslužbu integrace vynucuje nezávislé na mikroslužbu</span><span class="sxs-lookup"><span data-stu-id="5ad4f-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="5ad4f-153">Jak je uvedeno, důležité při vytváření aplikace založenou na mikroslužeb je způsob, jak integrovat váš mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="5ad4f-154">V ideálním případě by se pokuste minimalizovat komunikace mezi interní mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="5ad4f-155">Menší komunikace mezi mikroslužeb, tím lépe.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="5ad4f-156">Můžete ale samozřejmě v mnoha případech je nutné k nějakým způsobem integraci mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="5ad4f-157">Když potřebujete udělat, kritické pravidlo je, že by měla být asynchronní komunikaci mezi mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="5ad4f-158">To neznamená, že budete muset použít konkrétní protokol (například asynchronní zasílání zpráv a synchronní HTTP).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="5ad4f-159">Ji právě znamená, že by mělo být provedeno pouze pomocí šíření data asynchronně komunikace mezi mikroslužeb, ale nepokusí závisí na jiné interní mikroslužeb jako součást počáteční službu operace požadavků a odpovědí HTTP.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="5ad4f-160">Pokud je to možné se nikdy závisí na synchronní komunikace (požadavků a odpovědí) mezi více mikroslužeb, ani pro dotazy.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="5ad4f-161">Cílem každé mikroslužbu je jako autonomní a dostupné k příjemce klienta, i v případě ostatních služeb, které jsou součástí aplikace začátku do konce neběží nebo není v pořádku.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="5ad4f-162">Pokud se domníváte, že budete muset udělat volání z jednoho mikroslužbu jiné mikroslužeb (např. provádění požadavku HTTP pro dotaz na data) v pořadí, abyste mohli zadat odpovědi na klientskou aplikaci, je třeba architekturu, která nebude odolné, pokud některé mikroslužeb nezdaří.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="5ad4f-163">Kromě toho s HTTP závislosti mezi mikroslužeb, jako při vytváření dlouhé cykly žádosti a odpovědi s protokolem HTTP žádosti o řetězcích, jak je znázorněno v první části z 15-obrázek 4, ne jenom vaše mikroslužeb není autonomního se ale je také jejich výkonu dopad na co nejrychleji a jedné ze služeb v tomto řetězci neprovádí.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="5ad4f-164">Čím víc přidat synchronní závislosti mezi mikroslužeb, například požadavky na dotaz, zhoršení získá celková doba odezvy pro klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="5ad4f-165">**Obrázek 4 až 15**.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-165">**Figure 4-15**.</span></span> <span data-ttu-id="5ad4f-166">Proti vzory a vzory komunikace mezi mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="5ad4f-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="5ad4f-167">Pokud vaše mikroslužbu potřebuje vyvolat další akce v jiné mikroslužbu, pokud je to možné, není provedení této akce synchronně a v rámci původní operace dotazů a odpovědí mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="5ad4f-168">Místo toho provést asynchronně (pomocí asynchronní zasílání zpráv nebo události integrace, fronty, atd.).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="5ad4f-169">Ale v maximální míře, nevolejte akce synchronně jako součást původní synchronní operace dotazů a odpovědí.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="5ad4f-170">A nakonec (a to je, kde Většina problémů nastat při sestavování mikroslužeb), pokud vaše počáteční mikroslužbu potřebuje data, která je původně vlastníkem jiných mikroslužeb, nespoléhejte na provedení synchronní požadavky na data.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="5ad4f-171">Místo toho replikovat nebo rozšíření dat (pouze atributy, které potřebujete) do databáze počáteční služby pomocí konzistence typu případné (obvykle pomocí události integrace, jak je popsáno v části nadcházející).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="5ad4f-172">Jak jsme uvedli dříve v části [identifikace modelu domény hranice pro každou mikroslužbu](#identifying-domain-model-boundaries-for-each-microservice), duplikování některá data mezi několik mikroslužeb není nesprávný návrhu – naopak, pokud to, které může překládat data do konkrétní jazyk nebo podmínky této další domény nebo ohraničenou kontextu.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="5ad4f-173">Například v [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) aplikací mít mikroslužbu, s názvem identity.api, který má na starosti většinu dat uživatele s entitou, pojmenovaného uživatele.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="5ad4f-174">Ale pokud budete potřebovat k ukládání dat o uživateli v rámci mikroslužbu řazení, můžete ho uložit jako jiné entity s názvem kupujících.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="5ad4f-175">Entity kupujících sdílí stejnou identitu původního uživatele entity, ale může mít pouze několik atributů, které jsou potřeba domény řazení a ne celou uživatelský profil.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="5ad4f-176">Můžete použít libovolný protokol pro komunikaci a asynchronně rozšíří data na mikroslužeb aby bylo možné používat konzistence typu případné.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="5ad4f-177">Jak už bylo zmíněno, můžete použít integrace událostí pomocí sběrnice událostí nebo zpráva, že zprostředkovatel nebo i mohl použít HTTP pomocí cyklického dotazování služby jiné místo.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="5ad4f-178">Nezáleží.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-178">It does not matter.</span></span> <span data-ttu-id="5ad4f-179">Je důležité pravidlo tak, aby nevytvářela synchronní závislosti mezi vaší mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="5ad4f-180">Následující části popisují různé styly komunikace můžete zvážit použití v aplikaci na základě mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="5ad4f-181">Styly komunikace</span><span class="sxs-lookup"><span data-stu-id="5ad4f-181">Communication styles</span></span>

<span data-ttu-id="5ad4f-182">Existuje mnoho protokoly a možnosti, které můžete použít pro komunikaci, v závislosti na typu komunikace, kterou chcete použít.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="5ad4f-183">Pokud používáte mechanismus synchronní založené na požadavku nebo odpovědi komunikace, jsou protokoly, například HTTP a REST přístupy nejběžnější, zvlášť pokud publikujete vašim službám mimo cluster hostitele nebo mikroslužbu Docker.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="5ad4f-184">Pokud jsou komunikaci mezi službami interně (v rámci hostitele nebo mikroslužeb clusteru Docker) můžete také použít binární formát komunikační mechanizmy (jako je vzdálené komunikace Service Fabric nebo WCF pomocí TCP a binární formát).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="5ad4f-185">Alternativně můžete použít asynchronní, na základě zpráv komunikace mechanismy, například AMQP.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="5ad4f-186">Existují také více formáty zpráv jako XML nebo JSON nebo i binární formáty, které může být efektivnější.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="5ad4f-187">Pokud vaše zvolené binární formát není standard, je pravděpodobně není vhodné veřejně publikovat vašim službám pomocí tohoto formátu.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="5ad4f-188">Můžete použít jinou než standardní formát pro interní komunikaci mezi vaší mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="5ad4f-189">Můžete to třeba udělat při komunikaci mezi mikroslužeb v rámci Docker hostitele nebo mikroslužbu clusteru (Docker orchestrators nebo Azure Service Fabric) nebo pro vlastní klientských aplikací, které komunikují s mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="5ad4f-190">Požadavek a odpověď komunikaci přes protokol HTTP a REST</span><span class="sxs-lookup"><span data-stu-id="5ad4f-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="5ad4f-191">Pokud klient používá komunikaci požadavků a odpovědí, odešle žádost o služby, potom zpracuje služba žádost a odešle odpověď zpět.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="5ad4f-192">Komunikace požadavek a odpověď je velmi dobře vhodné pro dotazování dat v reálném čase uživatelského rozhraní (za provozu uživatelské rozhraní) z klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="5ad4f-193">Proto v architektury mikroslužby pravděpodobně použijete tento komunikační mechanizmus pro většinu dotazů, jak ukazuje obrázek 4-16.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="5ad4f-194">**Obrázek 4-16**.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-194">**Figure 4-16**.</span></span> <span data-ttu-id="5ad4f-195">Pomocí požadavků a odpovědí komunikaci pomocí protokolu HTTP (synchronní nebo asynchronní)</span><span class="sxs-lookup"><span data-stu-id="5ad4f-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="5ad4f-196">Pokud klient používá komunikaci požadavek a odpověď, předpokládá, že odpověď budou doručeny v krátkém čase, obvykle menší než druhý nebo pár sekund nejvíce.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="5ad4f-197">Pro zpožděné odpovědi, potřebujete implementovat asynchronní komunikaci na základě [zasílání zpráv vzory](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) a [zasílání zpráv technologie](https://en.wikipedia.org/wiki/Message-oriented_middleware), který je jiný přístup, který vám vysvětlíme v další části.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="5ad4f-198">Populární architektury styl pro komunikaci požadavek a odpověď je [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="5ad4f-199">Tento přístup je založena na a úzce kombinovanou, [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protokolu, příkaz HTTP jako GET, POST, přijetí a PUT.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="5ad4f-200">Při vytváření služby REST je nejčastěji používané přístup architektury komunikace.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="5ad4f-201">Při vývoji webové rozhraní API ASP.NET Core services můžete implementovat služby REST.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="5ad4f-202">Při použití služeb HTTP REST jazyka definice rozhraní je další hodnota.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="5ad4f-203">Například pokud použijete [Swagger metadata](http://swagger.io/) Pokud chcete popisují vaše rozhraní API služby, můžete použít nástroje, které generování zástupných procedur klienta, které můžete přímo zjištění a použití vašich služeb.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="5ad4f-204">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="5ad4f-204">Additional resources</span></span>

-   <span data-ttu-id="5ad4f-205">**Martin Fowler. Ryšánková vyspělosti modelu.**</span><span class="sxs-lookup"><span data-stu-id="5ad4f-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="5ad4f-206">Popis modelu REST.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-206">A description of the REST model.</span></span>
    [<span data-ttu-id="5ad4f-207">*http://martinfowler.com/articles/richardsonMaturityModel.HTML*</span><span class="sxs-lookup"><span data-stu-id="5ad4f-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="5ad4f-208">**Swagger.**</span><span class="sxs-lookup"><span data-stu-id="5ad4f-208">**Swagger.**</span></span> <span data-ttu-id="5ad4f-209">Oficiální web.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-209">The official site.</span></span>
    [<span data-ttu-id="5ad4f-210">*http://swagger.IO/*</span><span class="sxs-lookup"><span data-stu-id="5ad4f-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="5ad4f-211">Nabízení a komunikaci v reálném čase, které jsou založené na protokolu HTTP</span><span class="sxs-lookup"><span data-stu-id="5ad4f-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="5ad4f-212">Další možností (obvykle pro jiné účely než REST) je v reálném čase a na více komunikace s vyšší úrovně rozhraní, jako například [ASP.NET SignalR](https://www.asp.net/signalr) a protokoly, jako [Websocket](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="5ad4f-213">Jak ukazuje obrázek 4-17, v reálném čase komunikaci pomocí protokolu HTTP znamená, že můžete mít kódu serveru nabízet obsah připojeným klientům, jakmile data k dispozici, místo aby se server čekat na klienta k žádosti o nová data.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="5ad4f-214">**Obrázek 4-17**.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-214">**Figure 4-17**.</span></span> <span data-ttu-id="5ad4f-215">1: 1 zpráv v reálném čase asynchronní komunikaci</span><span class="sxs-lookup"><span data-stu-id="5ad4f-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="5ad4f-216">Vzhledem k tomu, že komunikace je v reálném čase, klientské aplikace zobrazit změny prakticky okamžitě.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="5ad4f-217">To je obvykle provádí protokol třeba Websocket pomocí mnoha připojení Websocket (jeden na každého klienta).</span><span class="sxs-lookup"><span data-stu-id="5ad4f-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="5ad4f-218">Typickým příkladem je, když služba komunikuje změnu skóre sportu hry s mnoha klienta webových aplikací současně.</span><span class="sxs-lookup"><span data-stu-id="5ad4f-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="5ad4f-219">[Předchozí] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Další] (asynchronní – zpráva – na základě communication.md)</span><span class="sxs-lookup"><span data-stu-id="5ad4f-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
