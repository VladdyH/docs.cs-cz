---
title: "Problémy a řešení pro správu distribuovaných dat"
description: "Architektura Mikroslužeb .NET pro aplikace .NET Kontejnerizované | Problémy a řešení pro správu distribuovaných dat"
keywords: "Docker, Mikroslužeb, ASP.NET, kontejneru"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f961475b40c74bf448cff1aeae04ae4866360e52
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/22/2017
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="0236a-104">Problémy a řešení pro správu distribuovaných dat</span><span class="sxs-lookup"><span data-stu-id="0236a-104">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="0236a-105">Výzvy \#1: definování hranice každý mikroslužbu</span><span class="sxs-lookup"><span data-stu-id="0236a-105">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="0236a-106">Definování hranice mikroslužbu je pravděpodobně v prvním kroku, které každý, kdo zaznamená.</span><span class="sxs-lookup"><span data-stu-id="0236a-106">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="0236a-107">Každý mikroslužbu musí být část vaší aplikace a každý mikroslužbu musí být autonomního všechny výhody a problémy, které se přenese tak.</span><span class="sxs-lookup"><span data-stu-id="0236a-107">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="0236a-108">Ale jak můžete určit tyto hranice?</span><span class="sxs-lookup"><span data-stu-id="0236a-108">But how do you identify those boundaries?</span></span>

<span data-ttu-id="0236a-109">Nejdřív je potřeba zaměřit se na logické domény modely aplikace a související data.</span><span class="sxs-lookup"><span data-stu-id="0236a-109">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="0236a-110">Musí se pokusí identifikovat odpojeného ostrovy dat a různých kontextů stejné aplikace.</span><span class="sxs-lookup"><span data-stu-id="0236a-110">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="0236a-111">Každý kontext může mít jiné organizační jazyk (různých obchodních podmínky).</span><span class="sxs-lookup"><span data-stu-id="0236a-111">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="0236a-112">Kontexty by měl být definovaný a spravovat nezávisle.</span><span class="sxs-lookup"><span data-stu-id="0236a-112">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="0236a-113">Podmínky a entit používaných v těchto různých kontextech zvukových podobné může, ale může zjistit, že v určitém kontextu, obchodní koncept s jedním používá pro jiný účel v jiném kontextu a může mít i jiný název.</span><span class="sxs-lookup"><span data-stu-id="0236a-113">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="0236a-114">Uživatel například může označuje jako uživatel v rámci identity nebo členství jako zákazníka v kontextu CRM, jako kupujících v kontextu řazení a tak dále.</span><span class="sxs-lookup"><span data-stu-id="0236a-114">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="0236a-115">Způsob, jak identifikovat hranice mezi více kontexty aplikaci s jinou doménu pro každý kontext je přesně identifikaci hranice pro každou obchodní mikroslužbu a jeho souvisejících modelu domény a data.</span><span class="sxs-lookup"><span data-stu-id="0236a-115">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="0236a-116">Vždy pokusí minimalizovat párování mezi těmito mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-116">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="0236a-117">Tato příručka obsahuje větší podrobnosti o tomto návrhu modelu identifikace a domény v části [identifikace modelu domény hranice pro každou mikroslužbu](#identifying-domain-model-boundaries-for-each-microservice) později.</span><span class="sxs-lookup"><span data-stu-id="0236a-117">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="0236a-118">Výzvy \#2: vytvoření dotazů, které načtení dat z několika mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="0236a-118">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="0236a-119">Druhá výzva je postup implementovat dotazy, které načtení dat z několika mikroslužeb, aniž by chatty komunikace na mikroslužeb od aplikace vzdáleného klienta.</span><span class="sxs-lookup"><span data-stu-id="0236a-119">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="0236a-120">Příkladem může být jeden obrazovky z mobilní aplikace, která potřebuje zobrazit informace o uživateli, který je vlastněn košík, katalogu a mikroslužeb identity uživatele.</span><span class="sxs-lookup"><span data-stu-id="0236a-120">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="0236a-121">Dalším příkladem může být složité sestavy zahrnující mnoho tabulek, které jsou umístěné v několika mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-121">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="0236a-122">Správné řešení závisí na složitosti dotazy.</span><span class="sxs-lookup"><span data-stu-id="0236a-122">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="0236a-123">Ale v žádném případě musíte způsob, jak agregační informace, pokud chcete zlepšit efektivitu při komunikaci vašeho systému.</span><span class="sxs-lookup"><span data-stu-id="0236a-123">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="0236a-124">Nejčastěji používané řešení jsou následující.</span><span class="sxs-lookup"><span data-stu-id="0236a-124">The most popular solutions are the following.</span></span>

<span data-ttu-id="0236a-125">**Brána rozhraní API**.</span><span class="sxs-lookup"><span data-stu-id="0236a-125">**API Gateway**.</span></span> <span data-ttu-id="0236a-126">Za účelem agregace jednoduché data z více mikroslužeb, který vlastní různých databází doporučuje se agregaci mikroslužbu označuje jako bránu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0236a-126">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="0236a-127">Ale musíte pečlivě o implementaci tohoto vzoru, protože v systému může být bod potlačení a ho můžete porušují Princip mikroslužbu nezávislé.</span><span class="sxs-lookup"><span data-stu-id="0236a-127">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="0236a-128">Pro zmírnění této možnosti, můžete mít více bran pokutu podrobných rozhraní API každý jeden zaměřené na svislé "řez" nebo obchodní oblast systému.</span><span class="sxs-lookup"><span data-stu-id="0236a-128">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="0236a-129">Vzor Brána rozhraní API je vysvětlené podrobněji v příslušné části na pomocí později bránu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0236a-129">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="0236a-130">**CQRS s tabulkami dotazu nebo čtení**.</span><span class="sxs-lookup"><span data-stu-id="0236a-130">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="0236a-131">Jiné řešení pro agregaci dat z více mikroslužeb je [Materializována zobrazení vzor](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="0236a-131">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="0236a-132">V tomto přístupu můžete vygenerovat, předem (připravit nenormalizované data, před dojít skutečné dotazy), jen pro čtení tabulku s daty, který je vlastněn více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-132">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="0236a-133">Tabulka má formát vhodné potřebám klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="0236a-133">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="0236a-134">Zvažte něco podobného jako na obrazovce pro mobilní aplikace.</span><span class="sxs-lookup"><span data-stu-id="0236a-134">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="0236a-135">Pokud máte jednu databázi, může být společně vyžádá data pro tuto obrazovku pomocí dotaz SQL, který provádí komplexní spojení zahrnující více tabulek.</span><span class="sxs-lookup"><span data-stu-id="0236a-135">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="0236a-136">Ale pokud máte více databází a jiné mikroslužbu vlastní každou databázi, nelze dotaz tyto databáze a vytvořit připojení k SQL.</span><span class="sxs-lookup"><span data-stu-id="0236a-136">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="0236a-137">Komplexní dotazu se změní na výzvu.</span><span class="sxs-lookup"><span data-stu-id="0236a-137">Your complex query becomes a challenge.</span></span> <span data-ttu-id="0236a-138">Můžete vyřešit požadavek CQRS přístup – vytvořit nenormalizované tabulku v jiné databázi, která se používá pouze pro dotazy.</span><span class="sxs-lookup"><span data-stu-id="0236a-138">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="0236a-139">V tabulce můžete určený speciálně pro data, která je nutné pro komplexní dotaz s relací mezi poli potřebují obrazovky vaší aplikace a sloupců v tabulce dotazu.</span><span class="sxs-lookup"><span data-stu-id="0236a-139">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="0236a-140">Také může fungovat pro účely vytváření sestav.</span><span class="sxs-lookup"><span data-stu-id="0236a-140">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="0236a-141">Tento přístup nejen řeší původní problém (jak dotaz a spojení mezi mikroslužeb); také zlepšuje výkon výrazně ve srovnání s komplexní spojení, vzhledem k tomu, že již máte data, která aplikace je v tabulce dotazu.</span><span class="sxs-lookup"><span data-stu-id="0236a-141">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="0236a-142">Samozřejmě příkazů a dotazů odpovědnost oddělení (CQRS) pomocí dotazu nebo čtení tabulky znamená další vývojové práci a budete muset použít konzistence typu případné.</span><span class="sxs-lookup"><span data-stu-id="0236a-142">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="0236a-143">Nicméně požadavky na výkon a škálovatelnost vysoké v [spolupráce scénáře](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (nebo konkurenční scénářů, v závislosti na hlediska) je, kde byste měli použít CQRS s více databází.</span><span class="sxs-lookup"><span data-stu-id="0236a-143">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="0236a-144">**"Pomaleji přístupná data" centrální databáze**.</span><span class="sxs-lookup"><span data-stu-id="0236a-144">**“Cold data” in central databases**.</span></span> <span data-ttu-id="0236a-145">Pro komplexní sestavy a dotazy, které nemusejí být nutné dat v reálném čase je běžný postup exportovat vaší "horkého data" (transakční data z mikroslužeb) jako "pomaleji přístupná data" do velké databáze, které se používají pouze pro vytváření sestav.</span><span class="sxs-lookup"><span data-stu-id="0236a-145">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="0236a-146">Tento systém centrální databáze může být systém na základě velkých objemů dat, jako jsou Hadoop, datového skladu jako jeden založené na Azure SQL Data Warehouse nebo i jedné databáze SQL (Pokud je velikost nebude problém) používá pouze pro sestavy.</span><span class="sxs-lookup"><span data-stu-id="0236a-146">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="0236a-147">Uvědomte si, že tato centralizované databáze budou použita pouze pro dotazy a sestavy, které není nutné data v reálném čase.</span><span class="sxs-lookup"><span data-stu-id="0236a-147">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="0236a-148">Původní aktualizace a transakce, jako zdroj pravdivosti, musí být ve vašich datech mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-148">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="0236a-149">Způsob, jakým byste synchronizaci dat bude pomocí komunikace založeného na událostech (popsané v následujících částech) nebo pomocí jiných nástrojů databáze infrastruktury importu a exportu.</span><span class="sxs-lookup"><span data-stu-id="0236a-149">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="0236a-150">Pokud použijete komunikaci založeného na událostech, by tento proces integrace podobným způsobem, jak je popsáno výše pro CQRS dotazu na tabulky se rozšíří data.</span><span class="sxs-lookup"><span data-stu-id="0236a-150">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="0236a-151">Ale pokud váš návrh aplikace zahrnuje neustále agregující informace z více mikroslužeb pro složité dotazy, může být příznakem chybný návrhu – mikroslužbu by měl být jako izolované nejblíže z jiných mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-151">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="0236a-152">(Nezahrnuje to sestavy nebo analýz, které se vždycky měli použít centrální databáze studený data.) Často má tento problém může být důvod sloučit mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-152">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="0236a-153">Musíte vyvážit samostatnost vývoj a nasazení každé mikroslužbu s silné závislosti, soudržnost a agregace dat.</span><span class="sxs-lookup"><span data-stu-id="0236a-153">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="0236a-154">Výzvy \#3: jak k zajištění konzistence mezi více mikroslužeb</span><span class="sxs-lookup"><span data-stu-id="0236a-154">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="0236a-155">Jak jsme uvedli dříve, data vlastníkem jednotlivých mikroslužbu soukromý této mikroslužbu a může otevřít pouze pomocí jeho mikroslužbu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0236a-155">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="0236a-156">Zobrazí výzvu je proto, jak implementovat začátku do konce obchodních procesů při zachování konzistence napříč více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-156">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="0236a-157">K analýze tento problém, podíváme se na příklad z [eShopOnContainers odkazovat aplikace](http://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="0236a-157">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="0236a-158">Mikroslužbu katalogu uchovává informace o všech produktů, včetně jejich uložených úroveň.</span><span class="sxs-lookup"><span data-stu-id="0236a-158">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="0236a-159">Mikroslužbu řazení spravuje objednávky a musí ověřit, že nové pořadí nepřekročí stock produktu katalog k dispozici.</span><span class="sxs-lookup"><span data-stu-id="0236a-159">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="0236a-160">(Nebo scénář mohou zahrnovat logiky, která zpracovává produkty doobjednáno.) V hypotetický monolitický verze této aplikace řazení subsystému jednoduše použít transakci ACID kontrolovat dostupného, vytvořit pořadí v tabulce objednávky, a aktualizovat dostupné stock v tabulce produkty.</span><span class="sxs-lookup"><span data-stu-id="0236a-160">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="0236a-161">Ale v mikroslužeb – na základě aplikací, pořadí a produktu tabulky jsou vlastněny jejich odpovídajících mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-161">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="0236a-162">Žádné mikroslužbu někdy obsahovat databází, které vlastní jiný mikroslužbu ve vlastní transakce nebo dotazy, jak ukazuje obrázek 4 – 9.</span><span class="sxs-lookup"><span data-stu-id="0236a-162">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="0236a-163">**Obrázek 4 – 9**.</span><span class="sxs-lookup"><span data-stu-id="0236a-163">**Figure 4-9**.</span></span> <span data-ttu-id="0236a-164">Mikroslužbu nemají přímý přístup do tabulky v jiné mikroslužbu</span><span class="sxs-lookup"><span data-stu-id="0236a-164">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="0236a-165">Mikroslužbu řazení nesmí přímo, aktualizovat tabulky produktů, protože vlastníkem tabulky produktů je mikroslužbu katalogu.</span><span class="sxs-lookup"><span data-stu-id="0236a-165">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="0236a-166">Chcete-li provést aktualizaci katalogu mikroslužbu, měli mikroslužbu řazení pouze někdy použít asynchronní komunikaci například integrace událostí (zpráv a komunikaci na bázi události).</span><span class="sxs-lookup"><span data-stu-id="0236a-166">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="0236a-167">Jedná se jak [eShopOnContainers](http://aka.ms/eshoponcontainers) aplikace referenční provede tento typ aktualizace.</span><span class="sxs-lookup"><span data-stu-id="0236a-167">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="0236a-168">Podle [věta CAP](https://en.wikipedia.org/wiki/CAP_theorem), budete muset zvolit dostupnosti a ACID silnou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="0236a-168">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="0236a-169">Většina scénářů mikroslužbu na základě poptávky dostupnost a škálovatelnost vysoké a silnou konzistenci.</span><span class="sxs-lookup"><span data-stu-id="0236a-169">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="0236a-170">Kritické aplikace musí zůstat nahoru a spuštěná a vývojářům můžete obejít silnou konzistenci pomocí techniky pro práci s slabá nebo případné konzistence.</span><span class="sxs-lookup"><span data-stu-id="0236a-170">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="0236a-171">Jedná se o postup provedenou většina architektury na základě mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="0236a-171">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="0236a-172">Kromě toho kyseliny stylu nebo dvojfázového zápisu transakce nejsou právě proti mikroslužeb zásad; Většina databáze NoSQL (např. Azure Cosmos DB, MongoDB atd.) nepodporují dvojfázového zápisu transakce.</span><span class="sxs-lookup"><span data-stu-id="0236a-172">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="0236a-173">Udržování dat konzistence napříč služby a databáze je však nezbytné.</span><span class="sxs-lookup"><span data-stu-id="0236a-173">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="0236a-174">Tento problém souvisí otázku o tom, jak rozšířit změny napříč více mikroslužeb, když některá data, je potřeba redundantní – například když potřebujete mít název nebo popis v katalogu mikroslužbu a košíku produktu mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="0236a-174">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="0236a-175">Dobrým řešením tohoto problému je použití konzistence typu případné mezi mikroslužeb kloubové prostřednictvím událostmi řízené komunikace a systémem publikování a odběru.</span><span class="sxs-lookup"><span data-stu-id="0236a-175">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="0236a-176">Tato témata jsou popsané v části [asynchronní komunikaci událostmi řízené](#async_event_driven_communication) dál v této příručce.</span><span class="sxs-lookup"><span data-stu-id="0236a-176">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="0236a-177">Výzvy \#4: navrhování komunikaci napříč hranicemi mikroslužbu</span><span class="sxs-lookup"><span data-stu-id="0236a-177">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="0236a-178">Komunikace v rámci mikroslužbu hranice je skutečné výzvu.</span><span class="sxs-lookup"><span data-stu-id="0236a-178">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="0236a-179">V tomto kontextu komunikace neodkazuje na co protokolu můžete využít (HTTP a REST, AMQP, zasílání zpráv a tak dále).</span><span class="sxs-lookup"><span data-stu-id="0236a-179">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="0236a-180">Místo toho řeší, jaké komunikace styl, měli byste použít, a jak párované vaší mikroslužeb by se měly používat.</span><span class="sxs-lookup"><span data-stu-id="0236a-180">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="0236a-181">V závislosti na úrovni párování když dojde k selhání, dopad tohoto selhání v systému se bude lišit výrazně.</span><span class="sxs-lookup"><span data-stu-id="0236a-181">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="0236a-182">V distribuované systému jako aplikace na základě mikroslužeb, s tolika artefakty pohyb a distribuované služby napříč mnoha servery nebo hostitele selžou nakonec součásti.</span><span class="sxs-lookup"><span data-stu-id="0236a-182">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="0236a-183">Částečné selhání a i větší výpadky vzhledem k tomu, takže je třeba navrhnout vaše mikroslužeb a komunikace mezi nimi zohledněním rizika běžné u tohoto typu distribuovaného systému.</span><span class="sxs-lookup"><span data-stu-id="0236a-183">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="0236a-184">Oblíbené přístupem je implementace protokolu HTTP (REST) – na základě mikroslužeb z důvodu jejich jednoduchost.</span><span class="sxs-lookup"><span data-stu-id="0236a-184">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="0236a-185">Přístup založený na protokolu HTTP je zcela přijatelné; Zde problém se týká jeho použití.</span><span class="sxs-lookup"><span data-stu-id="0236a-185">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="0236a-186">Pokud použijete jenom k interakci s vaší mikroslužeb z klientské aplikace nebo z rozhraní API brány požadavky a odpovědi HTTP, který je v pořádku.</span><span class="sxs-lookup"><span data-stu-id="0236a-186">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="0236a-187">Ale pokud vytvoříte dlouho řetězy synchronní volání protokolu HTTP mezi mikroslužeb, komunikaci přes jejich hranice, jako kdyby mikroslužeb objekty monolitický aplikace, spustí se vaše aplikace nakonec k potížím.</span><span class="sxs-lookup"><span data-stu-id="0236a-187">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="0236a-188">Představte si například, že klientské aplikace provede volání rozhraní API HTTP jednotlivých mikroslužbu jako mikroslužbu řazení.</span><span class="sxs-lookup"><span data-stu-id="0236a-188">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="0236a-189">Pokud mikroslužbu řazení volá další cyklus mikroslužeb pomocí protokolu HTTP v rámci stejné požadavků a odpovědí, vytváříte řetěz volání protokolu HTTP.</span><span class="sxs-lookup"><span data-stu-id="0236a-189">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="0236a-190">Ho může zvukových přiměřené původně.</span><span class="sxs-lookup"><span data-stu-id="0236a-190">It might sound reasonable initially.</span></span> <span data-ttu-id="0236a-191">Existují však body důležité zvážit při směrem dolů tuto cestu:</span><span class="sxs-lookup"><span data-stu-id="0236a-191">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="0236a-192">Blokování a nízkou výkon.</span><span class="sxs-lookup"><span data-stu-id="0236a-192">Blocking and low performance.</span></span> <span data-ttu-id="0236a-193">Z důvodu synchronní povaha HTTP nebude původní žádost získat odpověď až do dokončení všech interní volání protokolu HTTP.</span><span class="sxs-lookup"><span data-stu-id="0236a-193">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="0236a-194">Představte si, pokud počet těchto volání výrazně zvyšuje a ve stejnou dobu, kdy jeden zprostředkující HTTP volá, aby se mikroslužbu je blokovaná.</span><span class="sxs-lookup"><span data-stu-id="0236a-194">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="0236a-195">Výsledkem je, že ovlivněn výkon a celkovou škálovatelnost exponenciálnímu ovlivní jako další zvýšení požadavky HTTP.</span><span class="sxs-lookup"><span data-stu-id="0236a-195">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="0236a-196">Párování mikroslužeb s protokolem HTTP.</span><span class="sxs-lookup"><span data-stu-id="0236a-196">Coupling microservices with HTTP.</span></span> <span data-ttu-id="0236a-197">Obchodní mikroslužeb by neměl kombinaci s mikroslužeb jiné firmy.</span><span class="sxs-lookup"><span data-stu-id="0236a-197">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="0236a-198">V ideálním případě by neměl "znají" o existenci jiných mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-198">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="0236a-199">Pokud vaše aplikace využívá spojovacích mikroslužeb jako v příkladu, bude téměř znemožněno dosažení nezávislé na mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="0236a-199">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="0236a-200">Došlo k selhání všech jeden mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="0236a-200">Failure in any one microservice.</span></span> <span data-ttu-id="0236a-201">Pokud jste implementovali řetěz mikroslužeb propojeny prostřednictvím volání protokolu HTTP, některé mikroslužeb nezdaří (a nakonec se nezdaří) celý řetězec mikroslužeb se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="0236a-201">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="0236a-202">Chcete-li pokračovat v práci a také možné při částečné selhání by se měly navrhovat systému mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="0236a-202">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="0236a-203">I v případě, že budete implementovat logiku klienta, která používá opakování exponenciálního omezení rychlosti nebo jistič mechanismy, další volání řetězy komplexní HTTP jsou, tím složitější je ho implementovat strategie selhání založené na protokolu HTTP.</span><span class="sxs-lookup"><span data-stu-id="0236a-203">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="0236a-204">Ve skutečnosti Pokud vaše interní mikroslužeb komunikují vytvořením řetězy požadavků HTTP, jak je popsáno, může být uvedl, že je k dispozici monolitický aplikace, ale jeden založené na protokolu HTTP mezi procesy místo intraprocess komunikační mechanizmy.</span><span class="sxs-lookup"><span data-stu-id="0236a-204">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="0236a-205">Proto aby bylo možné vynutit mikroslužbu nezávislé a mají lepší odolnost proti chybám, měli byste minimalizovat použití řetězy požadavků a odpovědí komunikace mezi mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="0236a-205">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="0236a-206">Doporučujeme používat pouze asynchronní interakce pro komunikaci mezi mikroslužbu, buď pomocí asynchronní zpráva - a na základě událostí komunikace, nebo pomocí protokolu HTTP dotazování nezávisle na původní cyklus požadavků a odpovědí HTTP.</span><span class="sxs-lookup"><span data-stu-id="0236a-206">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="0236a-207">Další podrobnosti o později v tomto průvodci v částech je popsané použití asynchronní komunikaci [asynchronní mikroslužbu integrace vynucuje nezávislé na mikroslužbu](#asynchronous-microservice-integration-enforce-microservices-autonomy) a [asynchronního komunikace na základě zpráv](#asynchronous-message-based-communication).</span><span class="sxs-lookup"><span data-stu-id="0236a-207">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="0236a-208">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="0236a-208">Additional resources</span></span>

-   <span data-ttu-id="0236a-209">**Zakončení věta**
    [*https://en.wikipedia.org/wiki/CAP\_věta*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="0236a-209">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="0236a-210">**Konzistence typu případné**
    [*https://en.wikipedia.org/wiki/Eventual\_konzistence*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="0236a-210">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="0236a-211">**Úvod do konzistence dat**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="0236a-211">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="0236a-212">**Martin Fowler. CQRS (příkaz a dotaz odpovědnost oddělení)**
    [*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="0236a-212">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="0236a-213">**Materializovat zobrazení**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="0236a-213">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="0236a-214">**Charlese řádek. ACID vs. Základní: Parametr Shifting zpracování transakcí databáze**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="0236a-214">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="0236a-215">**Kompenzace transakce**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="0236a-215">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="0236a-216">**UDI Dahan. Služba zaměřené na konkrétní složení**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="0236a-216">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="0236a-217">[Předchozí] (logické a fyzického architecture.md) [Další] (identifikovat mikroslužbu domain modelu boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="0236a-217">[Previous] (logical-versus-physical-architecture.md) [Next] (identify-microservice-domain-model-boundaries.md)</span></span>
