---
title: "Strategie pro zpracování částečné selhání"
description: "Architektura Mikroslužeb .NET pro aplikace .NET Kontejnerizované | Strategie pro zpracování částečné selhání"
keywords: "Docker, Mikroslužeb, ASP.NET, kontejneru"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 86b8ccc467128970b60ba37f890057654ce682ef
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/23/2017
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="5303c-104">Strategie pro zpracování částečné selhání</span><span class="sxs-lookup"><span data-stu-id="5303c-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="5303c-105">Strategie pro práci s částečné selhání patří.</span><span class="sxs-lookup"><span data-stu-id="5303c-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="5303c-106">**Použít asynchronní komunikaci (například na základě zpráv) ve vnitřní mikroslužeb**.</span><span class="sxs-lookup"><span data-stu-id="5303c-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="5303c-107">Se důrazně doporučuje není vytvoření dlouho řetězy synchronní volání protokolu HTTP mezi interní mikroslužeb vzhledem k tomu, že nesprávné návrhu nakonec bude hlavní příčinou chybný výpadků.</span><span class="sxs-lookup"><span data-stu-id="5303c-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="5303c-108">Naopak, s výjimkou front-end komunikace mezi klientskými aplikacemi a první úroveň mikroslužeb nebo podrobných brány rozhraní API, doporučuje se použít jenom asynchronní (na základě zpráv) komunikaci jednou po počáteční žádosti nebo odpověď cyklus napříč interní mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="5303c-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="5303c-109">Konzistence typu případné a událostmi řízené architektury pomůže omezit ripple účinky.</span><span class="sxs-lookup"><span data-stu-id="5303c-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="5303c-110">Tyto přístupy vynutit na vyšší úrovni mikroslužbu nezávislé a proto zabránit proti problém, jsou tady uvedené.</span><span class="sxs-lookup"><span data-stu-id="5303c-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="5303c-111">**Pomocí opakování exponenciálního omezení rychlosti**.</span><span class="sxs-lookup"><span data-stu-id="5303c-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="5303c-112">Tato technika pomáhá zamezit krátký a občasné chyby provedením volání opakování počet dobu, v případě, že služba nebyla k dispozici pouze po krátkou dobu.</span><span class="sxs-lookup"><span data-stu-id="5303c-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="5303c-113">Mohlo to být kvůli problémům se sítí přerušované nebo mikroslužbu nebo kontejner je přesunut do jiného uzlu v clusteru.</span><span class="sxs-lookup"><span data-stu-id="5303c-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="5303c-114">Pokud tyto opakování nejsou správně navržený s moduly dělení okruh, je však zhoršit ripple důsledky, nakonec i což způsobilo [útok na dostupnost služby (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="5303c-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="5303c-115">**Práce mimo časové limity sítě**.</span><span class="sxs-lookup"><span data-stu-id="5303c-115">**Work around network timeouts**.</span></span> <span data-ttu-id="5303c-116">Klienti musí být navrženy tak, není k blokování po neomezenou dobu a používat překročení časového limitu při čekání na odpověď.</span><span class="sxs-lookup"><span data-stu-id="5303c-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="5303c-117">Použití časových limitů zajistí, že prostředky jsou nikdy svázané po neomezenou dobu.</span><span class="sxs-lookup"><span data-stu-id="5303c-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="5303c-118">**Použití vzoru jistič**.</span><span class="sxs-lookup"><span data-stu-id="5303c-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="5303c-119">V tomto přístupu procesu klienta sleduje počet neúspěšných požadavků.</span><span class="sxs-lookup"><span data-stu-id="5303c-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="5303c-120">Pokud je míra chyb překračuje limit konfiguraci cest "jistič" tak, aby další pokusy o neúspěšné okamžitě.</span><span class="sxs-lookup"><span data-stu-id="5303c-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="5303c-121">(Pokud se nedaří velký počet požadavků, která během psaní navrhuje služba není dostupná a že je zbytečný odesílání požadavků.) Po uplynutí doby vypršení časového limitu klienta by měl zkuste to znovu a, pokud jsou úspěšné, nové požadavky zavřete vypínač.</span><span class="sxs-lookup"><span data-stu-id="5303c-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="5303c-122">**Zadejte případech Přejít**.</span><span class="sxs-lookup"><span data-stu-id="5303c-122">**Provide fallbacks**.</span></span> <span data-ttu-id="5303c-123">V tento přístup procesu klienta provede záložní Pokud se požadavek nezdaří, jako je například vrací data uložená v mezipaměti nebo výchozí hodnotu.</span><span class="sxs-lookup"><span data-stu-id="5303c-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="5303c-124">Toto je vhodný pro dotazy přístup a složitější pro aktualizace nebo příkazy.</span><span class="sxs-lookup"><span data-stu-id="5303c-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="5303c-125">**Omezit počet požadavků ve frontě**.</span><span class="sxs-lookup"><span data-stu-id="5303c-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="5303c-126">Klienti musí také jiné než horní mez počtu nevyřízených požadavků, které mikroslužbu klient může odesílat do konkrétní služby.</span><span class="sxs-lookup"><span data-stu-id="5303c-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="5303c-127">Pokud bylo dosaženo limitu, je pravděpodobně neúčinná provádět další požadavky a těmito pokusy má okamžitě selhat.</span><span class="sxs-lookup"><span data-stu-id="5303c-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="5303c-128">Z hlediska implementace, Polly [přepážkovou izolace](https://github.com/App-vNext/Polly/wiki/Bulkhead) zásadu lze použít ke splnění tohoto požadavku.</span><span class="sxs-lookup"><span data-stu-id="5303c-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="5303c-129">Tento přístup je v podstatě paralelizace omezení s [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) jako implementace.</span><span class="sxs-lookup"><span data-stu-id="5303c-129">This approach is essentially a parallelization throttle with [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) as the implementation.</span></span> <span data-ttu-id="5303c-130">Token taky umožňuje "fronty" mimo přepážka.</span><span class="sxs-lookup"><span data-stu-id="5303c-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="5303c-131">Můžete proaktivně přenesen nadbytečné zatížení i před spuštěním, (například proto kapacity se považuje úplná).</span><span class="sxs-lookup"><span data-stu-id="5303c-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="5303c-132">Díky tomu odpovědi na určité scénáře selhání rychleji, než by bylo jistič, protože čeká jistič selhání.</span><span class="sxs-lookup"><span data-stu-id="5303c-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="5303c-133">Objekt BulkheadPolicy v Polly zpřístupňuje jak úplné přepážkovou a jsou fronty a nabízí události přetečení tak mohou sloužit také k řízení automatizované vodorovné škálování.</span><span class="sxs-lookup"><span data-stu-id="5303c-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="5303c-134">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="5303c-134">Additional resources</span></span>

-   <span data-ttu-id="5303c-135">**Odolnost proti chybám vzory**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="5303c-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="5303c-136">**Přidání odolnost a optimalizace výkonu**
    [*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="5303c-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="5303c-137">**Přepážkovou.**</span><span class="sxs-lookup"><span data-stu-id="5303c-137">**Bulkhead.**</span></span> <span data-ttu-id="5303c-138">Úložiště GitHub.</span><span class="sxs-lookup"><span data-stu-id="5303c-138">GitHub repo.</span></span> <span data-ttu-id="5303c-139">Implementace zásadám Polly. \\</span><span class="sxs-lookup"><span data-stu-id="5303c-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="5303c-140">*https://github.com/App-vNext/Polly/Wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="5303c-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="5303c-141">**Návrh odolný aplikací pro Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="5303c-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="5303c-142">**Přechodná chyba zpracování**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="5303c-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="5303c-143">[Předchozí] (popisovač partial-failure.md) [Další] (implementace opakování exponenciální backoff.md)</span><span class="sxs-lookup"><span data-stu-id="5303c-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
