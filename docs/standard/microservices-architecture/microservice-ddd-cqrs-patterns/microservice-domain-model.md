---
title: Navržení modelu mikroslužbu domény
description: Architektura Mikroslužeb .NET pro aplikace .NET Kontejnerizované | Navržení modelu mikroslužbu domény
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/09/2017
ms.openlocfilehash: 2776412b96d4ed141f48814d19d2deaa1a71520d
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33579454"
---
# <a name="designing-a-microservice-domain-model"></a><span data-ttu-id="482d3-103">Navržení modelu mikroslužbu domény</span><span class="sxs-lookup"><span data-stu-id="482d3-103">Designing a microservice domain model</span></span>

<span data-ttu-id="482d3-104">*Definovat jeden model bohaté domény pro každou obchodní mikroslužbu nebo ohraničenou kontextu*</span><span class="sxs-lookup"><span data-stu-id="482d3-104">*Define one rich domain model for each business microservice or Bounded Context*</span></span>

<span data-ttu-id="482d3-105">Vaším cílem je pro vytvoření modelu získá na ucelenosti jednu doménu pro každou obchodní mikroslužbu nebo ohraničenou kontextu (BC).</span><span class="sxs-lookup"><span data-stu-id="482d3-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="482d3-106">Mějte na paměti, ale který BC nebo obchodní mikroslužbu může někdy skládat několik fyzických služeb, které sdílí jedinou doménu modelu.</span><span class="sxs-lookup"><span data-stu-id="482d3-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="482d3-107">Model domény nutné zaznamenat pravidla, chování, obchodní jazyk a omezení jednotlivý kontext ohraničenou nebo mikroslužbu firmy, která reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="482d3-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="482d3-108">Entita domény vzor</span><span class="sxs-lookup"><span data-stu-id="482d3-108">The Domain Entity pattern</span></span>

<span data-ttu-id="482d3-109">Entity reprezentaci objektů domény a jejich identitu, kontinuitu a trvalost v čase a ne jenom atributy, které tvoří jejich jsou primárně definováno.</span><span class="sxs-lookup"><span data-stu-id="482d3-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="482d3-110">Jako zařízení Evans Erica informacemi o tom, "objekt primárně definováno svou identitu se nazývá Entity."</span><span class="sxs-lookup"><span data-stu-id="482d3-110">As Eric Evans says, “an object primarily defined by its identity is called an Entity.”</span></span> <span data-ttu-id="482d3-111">Entity jsou velmi důležité v modelu domény, protože jsou základ pro model.</span><span class="sxs-lookup"><span data-stu-id="482d3-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="482d3-112">Proto musí identifikovat a je pečlivě návrhu.</span><span class="sxs-lookup"><span data-stu-id="482d3-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="482d3-113">*Entity identity můžete mezi více mikroslužeb nebo ohraničenou kontextů.*</span><span class="sxs-lookup"><span data-stu-id="482d3-113">*An entity’s identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="482d3-114">Stejnou identitu (i když není stejná entita) můžete modelován mezi více ohraničenou kontexty nebo mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="482d3-114">The same identity (though not the same entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="482d3-115">Nicméně, neznamená ve více ohraničenou kontexty by být implementována stejné entity se stejným atributy a logiku.</span><span class="sxs-lookup"><span data-stu-id="482d3-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="482d3-116">Místo toho entity v kontextu jednotlivých ohraničenou omezte jejich atributů a chování pro tyto požadované v tomto ohraničenou kontextu domény.</span><span class="sxs-lookup"><span data-stu-id="482d3-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context’s domain.</span></span>

<span data-ttu-id="482d3-117">Pro instanci entity kupujících pravděpodobně většinu atributů osoby, které jsou definovány v entity uživatele v profilu nebo identita mikroslužbu, včetně identity.</span><span class="sxs-lookup"><span data-stu-id="482d3-117">For instance, the buyer entity might have most of a person’s attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="482d3-118">Ale kupujících entity v řazení mikroslužbu pravděpodobně méně atributů, protože je jenom určité kupujících data související s procesem pořadí.</span><span class="sxs-lookup"><span data-stu-id="482d3-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="482d3-119">Kontext každý mikroslužbu nebo ohraničenou kontextu ovlivňuje jeho modelu domény.</span><span class="sxs-lookup"><span data-stu-id="482d3-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="482d3-120">*Domény entit musí implementovat chování kromě implementace atributy dat*</span><span class="sxs-lookup"><span data-stu-id="482d3-120">*Domain entities must implement behavior in addition to implementing data attributes*</span></span>

<span data-ttu-id="482d3-121">Entita domény v DDD musí implementovat logiku domény nebo chování týkající se dat entity (objekt získat přístup do paměti).</span><span class="sxs-lookup"><span data-stu-id="482d3-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="482d3-122">Jako součást třídu entity pořadí je třeba musí mít operace implementované jako metody pro úlohy, jako je například přidávání pořadí položek, ověřování dat a celkový počet výpočtu a obchodní logiku.</span><span class="sxs-lookup"><span data-stu-id="482d3-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="482d3-123">Metody entity postará výstupních podmínek a pravidel entity místo nutnosti tato pravidla rozloženy aplikační vrstvu.</span><span class="sxs-lookup"><span data-stu-id="482d3-123">The entity’s methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="482d3-124">Obrázek 9 – 8 znázorňuje entita domény, která implementuje nejen atributy datového ale operace nebo metody s logiku související domény.</span><span class="sxs-lookup"><span data-stu-id="482d3-124">Figure 9-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![](./media/image9.png)

<span data-ttu-id="482d3-125">**Obrázek 9 – 8**.</span><span class="sxs-lookup"><span data-stu-id="482d3-125">**Figure 9-8**.</span></span> <span data-ttu-id="482d3-126">Příklad implementace data plus chování entit návrhu domény</span><span class="sxs-lookup"><span data-stu-id="482d3-126">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="482d3-127">Samozřejmě v některých případech může mít entit, které neimplementují veškeré logiky v rámci třídy entity.</span><span class="sxs-lookup"><span data-stu-id="482d3-127">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="482d3-128">To může nastat v podřízených entit v rámci agregace, když se entita na podřízené nemá žádné speciální logiku, protože většina logiku je definováno v kořenu agregační.</span><span class="sxs-lookup"><span data-stu-id="482d3-128">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="482d3-129">Pokud máte komplexní mikroslužbu, který má spoustu logiku implementaci třídy služeb místo v entity domény, může být spadajících do modelu anemic domény, popsané v následující části.</span><span class="sxs-lookup"><span data-stu-id="482d3-129">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="482d3-130">Bohaté domény modelu a modelu anemic domény</span><span class="sxs-lookup"><span data-stu-id="482d3-130">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="482d3-131">V jeho post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler popisuje model anemic domény takto:</span><span class="sxs-lookup"><span data-stu-id="482d3-131">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="482d3-132">Základní příznakem Model Anemic domény je, že v první blush to vypadá Opravdová věc.</span><span class="sxs-lookup"><span data-stu-id="482d3-132">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="482d3-133">Existují objekty, řada s názvem po podstatná jména v oboru domény a tyto objekty jsou spojeny s bohatou vztahy a struktury, která má hodnotu true domény modely.</span><span class="sxs-lookup"><span data-stu-id="482d3-133">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="482d3-134">Catch pochází, když se podíváte na chování a zjistíte, zda je na tyto objekty špatně žádné chování přitom něco více než sáčky mechanismy získání a nastavení.</span><span class="sxs-lookup"><span data-stu-id="482d3-134">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="482d3-135">Samozřejmě, pokud používáte model anemic domény, tyto datové modely se použije ze sady objektů služby (tradičně s názvem *vrstvě podnikání*) který zaznamenat všechny domény nebo obchodní logiku.</span><span class="sxs-lookup"><span data-stu-id="482d3-135">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="482d3-136">Obchodní vrstva je umístěna nad datový model a používá datový model stejně jako data.</span><span class="sxs-lookup"><span data-stu-id="482d3-136">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="482d3-137">Model anemic domény je právě návrh procedurální stylu.</span><span class="sxs-lookup"><span data-stu-id="482d3-137">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="482d3-138">Objekty anemic entity nejsou skutečné objekty tím, že neobsahují chování (metody).</span><span class="sxs-lookup"><span data-stu-id="482d3-138">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="482d3-139">Drží vlastnosti dat, a proto není objektově orientované návrhu.</span><span class="sxs-lookup"><span data-stu-id="482d3-139">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="482d3-140">Vložením všechny chování odhlašování do služby objektů (business layer) v podstatě skončili s [špagety kódu](https://en.wikipedia.org/wiki/Spaghetti_code) nebo [transakce skripty](https://martinfowler.com/eaaCatalog/transactionScript.html), a proto ztratit výhod modelu domény poskytuje.</span><span class="sxs-lookup"><span data-stu-id="482d3-140">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="482d3-141">Bez ohledu na to, pokud je velmi jednoduchý mikroslužbu nebo ohraničenou kontextu (CRUD služby), modelu anemic domény v podobě objektů entity se jenom vlastnosti dat může být dostatečně funkční a nemusí být vhodné implementace složitější DDD vzorů.</span><span class="sxs-lookup"><span data-stu-id="482d3-141">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="482d3-142">V takovém případě bude jednoduše trvalost modelu, protože se pouze data pro účely CRUD záměrně vytvoření entity.</span><span class="sxs-lookup"><span data-stu-id="482d3-142">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="482d3-143">To je důvod, proč jsou ideální pro více architektury přístup v závislosti na kontextu jednotlivých ohraničenou mikroslužeb architektury.</span><span class="sxs-lookup"><span data-stu-id="482d3-143">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="482d3-144">Například v eShopOnContainers, řazení mikroslužbu implementuje vzory DDD, ale mikroslužbu katalog, který je jednoduchý služba CRUD, nemá.</span><span class="sxs-lookup"><span data-stu-id="482d3-144">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="482d3-145">Někteří uživatelé říkají, že model anemic domény je proti vzor.</span><span class="sxs-lookup"><span data-stu-id="482d3-145">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="482d3-146">Ve skutečnosti závisí na co jsou implementace.</span><span class="sxs-lookup"><span data-stu-id="482d3-146">It really depends on what you are implementing.</span></span> <span data-ttu-id="482d3-147">Pokud je mikroslužbu vytvoříte jednoduchou dostatečně (například služba CRUD), následující modelu anemic domény není proti vzor.</span><span class="sxs-lookup"><span data-stu-id="482d3-147">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="482d3-148">Ale pokud budete potřebovat řešení složitost mikroslužbu domény, který má spoustu proměnlivých obchodní pravidla, modelu anemic domény může být proti vzor pro dané mikroslužbu nebo ohraničenou kontextu.</span><span class="sxs-lookup"><span data-stu-id="482d3-148">However, if you need to tackle the complexity of a microservice’s domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="482d3-149">V takovém případě je navrhování jako s formátováním model, který obsahuje entity obsahující data plus chování a také implementace další DDD vzorů (agregace, hodnota objekty atd.) může mít velký výhody pro dlouhodobý úspěch takové mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="482d3-149">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="482d3-150">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="482d3-150">Additional resources</span></span>

-   <span data-ttu-id="482d3-151">**DevIQ. Entita domény**
    [*http://deviq.com/entity/*](http://deviq.com/entity/)</span><span class="sxs-lookup"><span data-stu-id="482d3-151">**DevIQ. Domain Entity**
[*http://deviq.com/entity/*](http://deviq.com/entity/)</span></span>

-   <span data-ttu-id="482d3-152">**Martin Fowler. Model domény**
    [*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span><span class="sxs-lookup"><span data-stu-id="482d3-152">**Martin Fowler. The Domain Model**
[*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span></span>

-   <span data-ttu-id="482d3-153">**Martin Fowler. Model Anemic domény**</span><span class="sxs-lookup"><span data-stu-id="482d3-153">**Martin Fowler. The Anemic Domain Model**</span></span>

    <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="482d3-154">Vzor hodnota objektu</span><span class="sxs-lookup"><span data-stu-id="482d3-154">The Value Object pattern</span></span>

<span data-ttu-id="482d3-155">Jak je uvedeno zařízení Evans Erica, "mnoho objektů nemají koncepční identity.</span><span class="sxs-lookup"><span data-stu-id="482d3-155">As Eric Evans has noted, “Many objects do not have conceptual identity.</span></span> <span data-ttu-id="482d3-156">Tyto objekty popisují některé charakteristiky co".</span><span class="sxs-lookup"><span data-stu-id="482d3-156">These objects describe certain characteristics of a thing.”</span></span>

<span data-ttu-id="482d3-157">Entita vyžaduje identity, ale v systému, které nepodporují, existuje mnoho objektů, jako vzor objektu hodnotu.</span><span class="sxs-lookup"><span data-stu-id="482d3-157">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="482d3-158">Objekt hodnoty je objekt s žádná koncepční identita, která popisuje aspekt domény.</span><span class="sxs-lookup"><span data-stu-id="482d3-158">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="482d3-159">Tyto jsou objekty, které můžete vytvořit instanci představují prvků návrhu, které se týkají pouze můžete dočasně.</span><span class="sxs-lookup"><span data-stu-id="482d3-159">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="482d3-160">Kterých vám nejvíc záleží *co* nejsou, *kdo* jsou.</span><span class="sxs-lookup"><span data-stu-id="482d3-160">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="482d3-161">Příklady zahrnují čísla a řetězce, ale může být také vyšší úrovně koncepty jako skupiny atributů.</span><span class="sxs-lookup"><span data-stu-id="482d3-161">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="482d3-162">Vzhledem k tomu, že v druhém případě kontext ohraničenou může mít jiný význam něco, co je entita v mikroslužbu nemusí být entity v jiné mikroslužby.</span><span class="sxs-lookup"><span data-stu-id="482d3-162">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="482d3-163">Například adresu v aplikaci elektronického obchodování nemusí mít identity vůbec, protože ho může jenom představují skupinu atributů zákazníka profilu pro uživatele nebo společnosti.</span><span class="sxs-lookup"><span data-stu-id="482d3-163">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer’s profile for a person or company.</span></span> <span data-ttu-id="482d3-164">V takovém případě adresu by se měly klasifikovat jako objekt hodnoty.</span><span class="sxs-lookup"><span data-stu-id="482d3-164">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="482d3-165">V aplikaci pro firmu nástroj elektrické energie, může být důležité pro doménu firmy adresa zákazníka.</span><span class="sxs-lookup"><span data-stu-id="482d3-165">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="482d3-166">Adresu proto musí mít identity, takže fakturační systém může být přímo spojeny s adresu.</span><span class="sxs-lookup"><span data-stu-id="482d3-166">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="482d3-167">V takovém případě adresu by se měly klasifikovat jako entita domény.</span><span class="sxs-lookup"><span data-stu-id="482d3-167">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="482d3-168">Osoba s jméno a příjmení je obvykle entita, protože uživatel má identitu, i v případě, že jméno a příjmení shoduje s jinou sadu hodnot, jako třeba když tyto názvy také odkazuje na jinou osobu.</span><span class="sxs-lookup"><span data-stu-id="482d3-168">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="482d3-169">Hodnota objekty jsou obtížné spravovat v relačních databází a ORMs jako EF, zatímco v dokumentu zaměřené na konkrétní databáze, které jsou jednodušší k implementaci a použití.</span><span class="sxs-lookup"><span data-stu-id="482d3-169">Value objects are hard to manage in relational databases and ORMs like EF, whereas in document oriented databases they are easier to implement and use.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="482d3-170">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="482d3-170">Additional resources</span></span>

-   <span data-ttu-id="482d3-171">**Martin Fowler. Vzor hodnota objektu**
    [*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span><span class="sxs-lookup"><span data-stu-id="482d3-171">**Martin Fowler. Value Object pattern**
[*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span></span>

-   <span data-ttu-id="482d3-172">**Hodnota objektu**
    [*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span><span class="sxs-lookup"><span data-stu-id="482d3-172">**Value Object**
[*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span></span>

-   <span data-ttu-id="482d3-173">**Hodnota objekty v Test-Driven vývoj**
    [*https://leanpub.com/tdd-ebook/read\#leanpub automaticky hodnota objekty*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span><span class="sxs-lookup"><span data-stu-id="482d3-173">**Value Objects in Test-Driven Development**
[*https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span></span>

-   <span data-ttu-id="482d3-174">**Zařízení Evans Erica. Řízené domény návrhu: Boji se složitostí při vysílat softwaru.**</span><span class="sxs-lookup"><span data-stu-id="482d3-174">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="482d3-175">(Sešit; zahrnuje diskuzi o hodnotu objekty) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="482d3-175">(Book; includes a discussion of value objects) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="482d3-176">Agregační vzor</span><span class="sxs-lookup"><span data-stu-id="482d3-176">The Aggregate pattern</span></span>

<span data-ttu-id="482d3-177">Model domény obsahuje clustery různých datových entit a procesy, které můžete řídit důležité oblasti funkce, například pořadí platbu nebo z inventáře.</span><span class="sxs-lookup"><span data-stu-id="482d3-177">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfilment or inventory.</span></span> <span data-ttu-id="482d3-178">Podrobnějšího jednotka DDD je agregaci, která popisuje cluster nebo skupinu entit a chování, které mohou být považovány za získá na ucelenosti jednotku.</span><span class="sxs-lookup"><span data-stu-id="482d3-178">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="482d3-179">Obvykle definujete agregaci podle transakcí, které potřebujete.</span><span class="sxs-lookup"><span data-stu-id="482d3-179">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="482d3-180">Classic příkladem je pořadí, které obsahuje také pořadí položek seznamu.</span><span class="sxs-lookup"><span data-stu-id="482d3-180">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="482d3-181">Položku pořadí bude obvykle entity.</span><span class="sxs-lookup"><span data-stu-id="482d3-181">An order item will usually be an entity.</span></span> <span data-ttu-id="482d3-182">Ale bude podřízené entity v rámci pořadí agregace, který bude také obsahovat entity pořadí jako jeho kořenový entitu, obvykle nazývá agregační root.</span><span class="sxs-lookup"><span data-stu-id="482d3-182">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="482d3-183">Identifikace agregace může být složité.</span><span class="sxs-lookup"><span data-stu-id="482d3-183">Identifying aggregates can be hard.</span></span> <span data-ttu-id="482d3-184">Agregace je pro skupinu objektů, které musí být konzistentní společně, ale nemůže právě vyberte skupinu objektů a označovat je agregace.</span><span class="sxs-lookup"><span data-stu-id="482d3-184">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="482d3-185">Musí začínat koncept domény a vezměte v úvahu entitami, které se používají v nejběžnější transakce související pro daný koncept.</span><span class="sxs-lookup"><span data-stu-id="482d3-185">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="482d3-186">Tyto entity, které musí být stavu transakční konzistence se, co tvoří agregace.</span><span class="sxs-lookup"><span data-stu-id="482d3-186">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="482d3-187">Zamyšlení operací transakce je pravděpodobně nejlepší způsob, jak identifikovat agregace.</span><span class="sxs-lookup"><span data-stu-id="482d3-187">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="482d3-188">Vzor agregační kořenovou nebo kořenové Entity</span><span class="sxs-lookup"><span data-stu-id="482d3-188">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="482d3-189">Agregace se skládá z nejméně jedna entita: agregační kořenový adresář, označovaný taky jako kořenové entity nebo primární entity.</span><span class="sxs-lookup"><span data-stu-id="482d3-189">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="482d3-190">Kromě toho může mít více podřízených entit a hodnota objekty s všechny entity a objekty, které pracují společně k implementaci požadované chování a transakce.</span><span class="sxs-lookup"><span data-stu-id="482d3-190">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="482d3-191">Účelem agregační kořenové je zajištění konzistence agregace; je nutné pouze vstupní bod pro aktualizace agregace prostřednictvím metody nebo operace v souhrnném kořenová třída.</span><span class="sxs-lookup"><span data-stu-id="482d3-191">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="482d3-192">Entity v rámci agregace pouze prostřednictvím kořenu agregační měli provádět změny.</span><span class="sxs-lookup"><span data-stu-id="482d3-192">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="482d3-193">Je na agregaci konzistence ochrany, vezme v úvahu výstupních podmínek a konzistence pravidla, která může být nutné v souladu se ve vašem agregace.</span><span class="sxs-lookup"><span data-stu-id="482d3-193">It is the aggregate’s consistency guardian, taking into account all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="482d3-194">Pokud změníte podřízený objekt entity nebo hodnota nezávisle, kořenu agregační nelze zajistěte, aby byl agregace v platném stavu.</span><span class="sxs-lookup"><span data-stu-id="482d3-194">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="482d3-195">Je jako tabulku s přijít větev.</span><span class="sxs-lookup"><span data-stu-id="482d3-195">It would be like a table with a loose leg.</span></span> <span data-ttu-id="482d3-196">Údržba konzistence je hlavním účelem agregační kořenu.</span><span class="sxs-lookup"><span data-stu-id="482d3-196">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="482d3-197">Obrázek 9 – 9 uvidíte ukázka agregace jako kupujících agregační, která obsahuje jednu entitu (Kořenová agregační kupujících).</span><span class="sxs-lookup"><span data-stu-id="482d3-197">In Figure 9-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="482d3-198">Agregace pořadí obsahuje více entit a objekt hodnoty.</span><span class="sxs-lookup"><span data-stu-id="482d3-198">The order aggregate contains multiple entities and a value object.</span></span>

![](./media/image10.png)

<span data-ttu-id="482d3-199">**Obrázek 9 – 9**.</span><span class="sxs-lookup"><span data-stu-id="482d3-199">**Figure 9-9**.</span></span> <span data-ttu-id="482d3-200">Příklad agregace s více neboli jednotlivých entit</span><span class="sxs-lookup"><span data-stu-id="482d3-200">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="482d3-201">Všimněte si, že agregace kupujících může mít další podřízené entity, v závislosti na vaší domény, stejně jako v řazení mikroslužbu v eShopOnContainers odkaz na aplikaci.</span><span class="sxs-lookup"><span data-stu-id="482d3-201">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="482d3-202">Obrázek 9 – 9 právě znázorňuje případ, ve kterém má kupující jedna entita, jako příklad agregaci, která obsahuje jenom agregační root.</span><span class="sxs-lookup"><span data-stu-id="482d3-202">Figure 9-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="482d3-203">Abyste mohli udržovat oddělené agregací a zachovat zřetelnými hranicemi mezi nimi, je dobrým zvykem v modelu DDD domény tak, aby zakázala přímé navigace mezi agregace, které mají pouze pole cizí klíč (Cizíklíč), jak jsou implementované ve [ Řazení modelu domény mikroslužbu](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="482d3-203">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="482d3-204">Entity pořadí pouze obsahuje pole, cizího klíče pro odběratele, ale ne základní EF navigační vlastnost, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="482d3-204">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="482d3-205">Identifikace a práci s agregace vyžaduje výzkum a prostředí.</span><span class="sxs-lookup"><span data-stu-id="482d3-205">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="482d3-206">Další informace najdete v seznamu následující další prostředky.</span><span class="sxs-lookup"><span data-stu-id="482d3-206">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="482d3-207">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="482d3-207">Additional resources</span></span>

-   <span data-ttu-id="482d3-208">**Vaughn Vernon. Efektivní návrh agregace - část I: modelování jeden agregace**
    [*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_KOMUNITY\_KOMPOZICE\_AGREGACE\_část \_1. pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span><span class="sxs-lookup"><span data-stu-id="482d3-208">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate**
[*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_COMMUNITY\_ESSAY\_AGGREGATES\_PART\_1.pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span></span>

-   <span data-ttu-id="482d3-209">**Vaughn Vernon. Efektivní agregační návrh – část II: Provádění agregací pracovní společně**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf> *</span><span class="sxs-lookup"><span data-stu-id="482d3-209">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf> *</span></span>

-   <span data-ttu-id="482d3-210">**Vaughn Vernon. Efektivní agregační návrh – část III: Získání přehledu prostřednictvím zjišťování**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf> *</span><span class="sxs-lookup"><span data-stu-id="482d3-210">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf> *</span></span>

-   <span data-ttu-id="482d3-211">**Sergey Grybniak. Vzory návrhu taktické DDD**
    [*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span><span class="sxs-lookup"><span data-stu-id="482d3-211">**Sergey Grybniak. DDD Tactical Design Patterns**
[*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span></span>

-   <span data-ttu-id="482d3-212">**Jan Ryšánková. Vývoj transakční Mikroslužeb používající agregované hodnoty**
    [*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span><span class="sxs-lookup"><span data-stu-id="482d3-212">**Chris Richardson. Developing Transactional Microservices Using Aggregates**
[*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span></span>

-   <span data-ttu-id="482d3-213">**DevIQ. Agregační vzor**
    [*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span><span class="sxs-lookup"><span data-stu-id="482d3-213">**DevIQ. The Aggregate pattern**
[*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="482d3-214">[Předchozí] (ddd-zaměřené na konkrétní microservice.md) [Další] (net – základní – mikroslužbu domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="482d3-214">[Previous] (ddd-oriented-microservice.md) [Next] (net-core-microservice-domain-model.md)</span></span>
