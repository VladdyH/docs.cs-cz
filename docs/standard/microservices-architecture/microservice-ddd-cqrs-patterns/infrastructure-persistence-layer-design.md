---
title: Návrh vrstvy trvalosti infrastruktury
description: Zjistěte, jak navrhnout vrstvy trvalosti infrastruktury.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 06/28/2017
ms.openlocfilehash: a0fcaead363e41f0dd02ed1e2ddfc90afb8d0c57
ms.sourcegitcommit: 4c158beee818c408d45a9609bfc06f209a523e22
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/03/2018
ms.locfileid: "37404470"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="0767f-103">Návrh vrstvy trvalosti infrastruktury</span><span class="sxs-lookup"><span data-stu-id="0767f-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="0767f-104">Komponenty trvalosti dat poskytují přístup k datům hostovaným v rámci hranic mikroslužby (to znamená mikroslužeb databáze).</span><span class="sxs-lookup"><span data-stu-id="0767f-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="0767f-105">Obsahují aktuální implementaci komponent, jako jsou úložiště a [pracovní jednotky](https://martinfowler.com/eaaCatalog/unitOfWork.html) třídy, jako jsou vlastní Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objekty.</span><span class="sxs-lookup"><span data-stu-id="0767f-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="0767f-106">Model úložiště</span><span class="sxs-lookup"><span data-stu-id="0767f-106">The Repository pattern</span></span>

<span data-ttu-id="0767f-107">Úložiště jsou třídy nebo komponenty, které provádí zapouzdření logiku potřebnou pro přístup ke zdrojům dat.</span><span class="sxs-lookup"><span data-stu-id="0767f-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="0767f-108">Centralizujte jsou běžné funkce přístupu k datům, poskytuje lepší udržovatelnost a oddělení infrastruktury nebo technologie používané pro přístup k databázím z vrstvě doménového modelu.</span><span class="sxs-lookup"><span data-stu-id="0767f-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="0767f-109">Pokud používáte objektově relační mapování (ORM určené) jako Entity Framework, je zjednodušená kód, který musí implementovat, díky LINQ a silných typů.</span><span class="sxs-lookup"><span data-stu-id="0767f-109">If you use an object-relational mapping (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="0767f-110">To umožňuje zaměřit se na logiku trvalosti dat, nikoli na datový přístup k vložení.</span><span class="sxs-lookup"><span data-stu-id="0767f-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="0767f-111">Model úložiště je dobře zdokumentovaná způsob práce se zdroji dat.</span><span class="sxs-lookup"><span data-stu-id="0767f-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="0767f-112">V knize [vzory Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martina Fowlera popisuje úložiště následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="0767f-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="0767f-113">Úložiště provádí úkoly prostředník mezi vrstvami modelu domény a mapování dat v podobným způsobem jako sada domény objektů v paměti.</span><span class="sxs-lookup"><span data-stu-id="0767f-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="0767f-114">Klientské objekty deklarativně vytvářet dotazy a odeslat je do úložiště pro odpovědi.</span><span class="sxs-lookup"><span data-stu-id="0767f-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="0767f-115">Entity úložiště zapouzdřuje sadu objektů uložených v databázi a operace, které lze provést s nimi, poskytuje způsob, který je blíž ke vrstvy trvalosti.</span><span class="sxs-lookup"><span data-stu-id="0767f-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="0767f-116">Úložiště, navíc podporují účel oddělení jasně a v jednom směru závislosti mezi doménou práce a přidělený objem dat nebo mapování.</span><span class="sxs-lookup"><span data-stu-id="0767f-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="0767f-117">Definovat jedno úložiště za agregace</span><span class="sxs-lookup"><span data-stu-id="0767f-117">Define one repository per aggregate</span></span>

<span data-ttu-id="0767f-118">Pro každé agregace nebo agregační kořenový adresář měli byste vytvořit jednu třídu úložiště.</span><span class="sxs-lookup"><span data-stu-id="0767f-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="0767f-119">V mikroslužbě závislosti na vzorech návrhu řízeného doménou (DDD) by měl být jediným kanál, který použijete k aktualizaci databáze úložiště.</span><span class="sxs-lookup"><span data-stu-id="0767f-119">In a microservice based on domain-driven design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="0767f-120">Je to proto, že mají vztah 1: 1 s agregační kořenový adresář, který řídí agregaci výstupních podmínek a transakční konzistence.</span><span class="sxs-lookup"><span data-stu-id="0767f-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="0767f-121">Je možné k dotazování databáze prostřednictvím dalších kanálů (jak vám pomůžou následující přístup modelu CQRS), protože dotazy neměnit stav databáze.</span><span class="sxs-lookup"><span data-stu-id="0767f-121">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="0767f-122">Transakční oblasti (to znamená, aktualizace) však musí být vždy kontrolován úložiště a agregační kořenové adresáře.</span><span class="sxs-lookup"><span data-stu-id="0767f-122">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="0767f-123">V podstatě úložiště vám umožní naplnit data v paměti, která pochází z databáze ve formuláři entity domény.</span><span class="sxs-lookup"><span data-stu-id="0767f-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="0767f-124">Po entity, které jsou v paměti, může se změnit a pak trvalé zpět do databáze do transakce.</span><span class="sxs-lookup"><span data-stu-id="0767f-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="0767f-125">Jak je uvedeno dříve, pokud používáte model architektury CQS/CQRS, počáteční dotazy provádějí dotazy na straně mimo doménový model, provádí jednoduché příkazy SQL s použitím Dapperem.</span><span class="sxs-lookup"><span data-stu-id="0767f-125">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="0767f-126">Tento přístup je toho mnohem víc, potřebujete flexibilní než úložiště, protože se můžete dotazovat a připojte se k žádné tabulky a tyto dotazy nejsou omezená pravidly agregací.</span><span class="sxs-lookup"><span data-stu-id="0767f-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="0767f-127">Tato data přejde do prezentační vrstvy nebo klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="0767f-127">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="0767f-128">Pokud uživatel provede změny, data, která mají být aktualizovány pochází z klienta aplikace nebo prezentační vrstvy do vrstvy aplikace (jako je například služba webového rozhraní API).</span><span class="sxs-lookup"><span data-stu-id="0767f-128">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="0767f-129">Přijmout příkaz s daty v obslužná rutina příkazu, použijete k získání dat, které chcete aktualizovat z databáze úložiště.</span><span class="sxs-lookup"><span data-stu-id="0767f-129">When you receive a command with data in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="0767f-130">Aktualizujete v paměti s informacemi o byla dokončena s příkazy, a pak přidat nebo aktualizovat data (domény entity) v databázi pomocí transakce.</span><span class="sxs-lookup"><span data-stu-id="0767f-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="0767f-131">Mějte na paměti, že tento pouze jedno úložiště by měl definovat pro kořenovém adresáři každého agregace, jak je znázorněno v obrázek 9-17.</span><span class="sxs-lookup"><span data-stu-id="0767f-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="0767f-132">K dosažení cíle agregační kořenových zachovat transakční konzistenci mezi všechny objekty v rámci agregace, měli byste nikdy vytvořit úložiště pro každou tabulku v databázi.</span><span class="sxs-lookup"><span data-stu-id="0767f-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="0767f-133">**Obrázek 9-17**.</span><span class="sxs-lookup"><span data-stu-id="0767f-133">**Figure 9-17**.</span></span> <span data-ttu-id="0767f-134">Vztah mezi úložišť, agregace a databázových tabulek</span><span class="sxs-lookup"><span data-stu-id="0767f-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="0767f-135">Vynucování jeden kořenový agregační na úložiště</span><span class="sxs-lookup"><span data-stu-id="0767f-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="0767f-136">Může být užitečné k implementaci návrhu úložiště tak, že vynutí toto pravidlo, že by měl mít jenom agregační kořeny úložišť.</span><span class="sxs-lookup"><span data-stu-id="0767f-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="0767f-137">Můžete vytvořit typ obecného nebo základního úložiště, který omezí typ entity funguje s zajistit, že mají `IAggregateRoot` rozhraní značek.</span><span class="sxs-lookup"><span data-stu-id="0767f-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="0767f-138">Každá třída úložiště implementované ve vrstvě infrastruktury implementuje proto svůj vlastní kontrakt nebo rozhraní, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="0767f-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="0767f-139">Každé rozhraní konkrétního úložiště implementuje obecné rozhraní IRepository:</span><span class="sxs-lookup"><span data-stu-id="0767f-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="0767f-140">Ale lepší způsob, jak kód vynutit konvenci, že každé úložiště se vztahuje k jedné agregace je implementace typu obecného úložiště.</span><span class="sxs-lookup"><span data-stu-id="0767f-140">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="0767f-141">Tímto způsobem je explicitní, že používáte úložiště cílit na konkrétní agregace.</span><span class="sxs-lookup"><span data-stu-id="0767f-141">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="0767f-142">To jde snadno udělat pomocí implementace obecný `IRepository` základní rozhraní, jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="0767f-142">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="0767f-143">Vzor úložiště usnadňuje testování vaší aplikace logiky</span><span class="sxs-lookup"><span data-stu-id="0767f-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="0767f-144">Vzor úložiště umožňuje snadno testujte aplikace s testy jednotek.</span><span class="sxs-lookup"><span data-stu-id="0767f-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="0767f-145">Mějte na paměti, že testy jednotek pouze test kód, ne na infrastrukturu, tak úložiště abstrakce zjednodušují dosažení tohoto cíle.</span><span class="sxs-lookup"><span data-stu-id="0767f-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="0767f-146">Jak je uvedeno v předchozí části, se doporučuje definovat a umístěte rozhraní úložiště ve vrstvě doménového modelu, aplikační vrstvy, jako je například vaše webové rozhraní API mikroslužby nezávisí přímo na vrstvě infrastruktury kde jsme implementovali třídy skutečné úložiště.</span><span class="sxs-lookup"><span data-stu-id="0767f-146">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="0767f-147">To a využitím vkládání závislostí do kontrolerů webového rozhraní API, můžete implementovat mock úložišť, které vracejí falešné data namísto dat z databáze.</span><span class="sxs-lookup"><span data-stu-id="0767f-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="0767f-148">Tento přístup oddělení umožňuje vytvořit a spustit testy jednotky, které můžete testovat logiku aplikace bez nutnosti připojení k databázi.</span><span class="sxs-lookup"><span data-stu-id="0767f-148">This decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="0767f-149">Připojení k databázím může selhat a důležitější je, provozování testů pro databázi je chybný pro dva důvody.</span><span class="sxs-lookup"><span data-stu-id="0767f-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="0767f-150">Nejdřív může trvat dlouhou dobu z důvodu velkého počtu testů.</span><span class="sxs-lookup"><span data-stu-id="0767f-150">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="0767f-151">Za druhé může být záznamů databáze změnit a ovlivnit výsledky testů, takže se nemusí být konzistentní vzhledem k aplikacím.</span><span class="sxs-lookup"><span data-stu-id="0767f-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="0767f-152">Testování proti databázi není testování částí, ale o test integrace.</span><span class="sxs-lookup"><span data-stu-id="0767f-152">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="0767f-153">Měli byste mít mnoho testů jednotek rychlé spuštění, ale méně integrace testy proti databáze.</span><span class="sxs-lookup"><span data-stu-id="0767f-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="0767f-154">Z hlediska oddělení oblastí zájmu pro testování částí pracuje svoji logiku domény entity v paměti.</span><span class="sxs-lookup"><span data-stu-id="0767f-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="0767f-155">Předpokládá se, že ty dodal třídu úložiště.</span><span class="sxs-lookup"><span data-stu-id="0767f-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="0767f-156">Jakmile svoji logiku upraví domény entity, předpokládá se, že třídu úložiště bude správně uložit.</span><span class="sxs-lookup"><span data-stu-id="0767f-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="0767f-157">Důležitý bod je vytvoření testů jednotek pro doménový model a jeho logiku domény.</span><span class="sxs-lookup"><span data-stu-id="0767f-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="0767f-158">Agregační kořeny jsou hranice hlavní konzistence v DDD.</span><span class="sxs-lookup"><span data-stu-id="0767f-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="0767f-159">Rozdíl mezi použitému vzoru a starší verze třídy (třídy DAL) vzor přístupu k datům</span><span class="sxs-lookup"><span data-stu-id="0767f-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="0767f-160">Datový objekt přímo provádí operace přístupu a trvalost dat využívající službu storage.</span><span class="sxs-lookup"><span data-stu-id="0767f-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="0767f-161">Úložiště označí data s operacemi, které chcete provést v paměti objektu pracovní jednotka (stejně jako v EF při použití <xref:Microsoft.EntityFrameworkCore.DbContext> třídy), ale tyto aktualizace se neprovádí hned.</span><span class="sxs-lookup"><span data-stu-id="0767f-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="0767f-162">Určitou jednotku práce se označuje jako jedna transakce, která zahrnuje více vložení, aktualizace nebo odstranění operace.</span><span class="sxs-lookup"><span data-stu-id="0767f-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="0767f-163">Jednoduše řečeno znamená to, že pro konkrétního uživatele akce, jako je registrace na webu, insert, update a delete transakce jsou zpracovány v rámci jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="0767f-163">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="0767f-164">To je mnohem efektivnější než zpracování více transakcí databáze chattier způsobem.</span><span class="sxs-lookup"><span data-stu-id="0767f-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="0767f-165">Tyto trvalost provádí více operací se později v rámci jedné akce při příkazy kódu z aplikační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="0767f-165">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="0767f-166">Rozhodnutí o aplikování změn v paměti úložiště skutečné databáze je obvykle na základě [pracovní jednotky vzor](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="0767f-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="0767f-167">V EF, vzor pracovní jednotky je implementovaný jako <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="0767f-167">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="0767f-168">V mnoha případech se může tento vzor nebo způsob použití operací s úložištěm zvýšit výkon aplikace a snížení rizika vzniku nekonzistence.</span><span class="sxs-lookup"><span data-stu-id="0767f-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="0767f-169">Také snižuje transakcí, zablokování v tabulkách databáze, protože všechny odpovídající operace usilujeme o to jako součást jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="0767f-169">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="0767f-170">To je mnohem efektivnější porovnání provádí mnoho operací izolované databázi.</span><span class="sxs-lookup"><span data-stu-id="0767f-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="0767f-171">Vybrané ORM proto můžete optimalizovat spuštění proti databázi seskupením několika akcí aktualizace v rámci jedné transakce, na rozdíl od mnoha malých a samostatné transakce spuštění.</span><span class="sxs-lookup"><span data-stu-id="0767f-171">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="0767f-172">Úložiště by neměly být povinné</span><span class="sxs-lookup"><span data-stu-id="0767f-172">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="0767f-173">Vlastní úložiště jsou užitečné z důvodů uvedených výše, tedy přístup pro objednávání mikroslužeb v aplikaci eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="0767f-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="0767f-174">Však není základní vzor, který se má implementovat v návrhu DDD nebo dokonce obecně vývoj na platformě .NET.</span><span class="sxs-lookup"><span data-stu-id="0767f-174">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="0767f-175">Například Jimmy Bogard, při poskytnutí zpětné vazby s přímým přístupem k této příručce se říká, že následující:</span><span class="sxs-lookup"><span data-stu-id="0767f-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="0767f-176">To bude pravděpodobně Moje největší zpětnou vazbu.</span><span class="sxs-lookup"><span data-stu-id="0767f-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="0767f-177">Nejsem skutečně ventilátor úložišť, zejména proto, že skrývají důležité podrobnosti základní mechanismus trvalosti.</span><span class="sxs-lookup"><span data-stu-id="0767f-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="0767f-178">Jeho proč můžu získat MediatR příkazy příliš.</span><span class="sxs-lookup"><span data-stu-id="0767f-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="0767f-179">Můžu plně využijte potenciál vrstvy trvalosti a nasdílení změn do mé agregační kořeny toto chování domény.</span><span class="sxs-lookup"><span data-stu-id="0767f-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="0767f-180">Nechci obvykle napodobení Moje úložiště – stále je potřeba tuto integraci test s Opravdová věc.</span><span class="sxs-lookup"><span data-stu-id="0767f-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="0767f-181">Přechod CQRS určená, že nebyly k dispozici skutečně potřeba pro úložiště víc.</span><span class="sxs-lookup"><span data-stu-id="0767f-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="0767f-182">Úložiště jsou užitečné, ale nejsou důležité pro váš DDD ve způsobu, jakým agregační vzor a bohaté doménový model se.</span><span class="sxs-lookup"><span data-stu-id="0767f-182">Repositories are useful, but they aren't critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="0767f-183">Proto se ale nemusíte používat úložiště vzor, podle svých potřeb.</span><span class="sxs-lookup"><span data-stu-id="0767f-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="0767f-184">Vzor specifikace</span><span class="sxs-lookup"><span data-stu-id="0767f-184">The Specification pattern</span></span>

<span data-ttu-id="0767f-185">Vzor specifikace (úplného názvu bude vzor dotazu specification) je vzor DDD navržený místem, kde můžete ukládat definice dotazu s volitelné, řazení a stránkování logiku.</span><span class="sxs-lookup"><span data-stu-id="0767f-185">The specification pattern (its full name would be Query-specification pattern) is a DDD pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="0767f-186">Vzor specifikace definuje dotaz v objektu.</span><span class="sxs-lookup"><span data-stu-id="0767f-186">The specification pattern defines a query in an object.</span></span> <span data-ttu-id="0767f-187">Například k zapouzdření stránkovaného dotaz, který vyhledá některé produkty, můžete vytvořit `PagedProduct` specifikace, která přebírá nezbytné vstupní parametry, jako například `pageNumber`, `pageSize`, `filter`atd. Poté, v rámci metody jakékoli úložiště (obvykle List() přetížení) se bude přijímat `ISpecification` a spusťte dotaz očekávané založené na specifikaci.</span><span class="sxs-lookup"><span data-stu-id="0767f-187">For example, to encapsulate a paged query that searches for some products, you can create a `PagedProduct` specification that takes the necessary input parameters, such as `pageNumber`, `pageSize`, `filter`, etc. Then, within any Repository method (usually a List() overload), it'd accept an `ISpecification` and run the expected query based on that specification.</span></span>

<span data-ttu-id="0767f-188">Existuje více výhod tohoto přístupu:</span><span class="sxs-lookup"><span data-stu-id="0767f-188">There are several benefits to this approach:</span></span>

- <span data-ttu-id="0767f-189">Specifikace má název (na rozdíl od jen hromada LINQ – výrazy), které můžete diskutovat o.</span><span class="sxs-lookup"><span data-stu-id="0767f-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

- <span data-ttu-id="0767f-190">Specifikace může být jednotka testovány v izolaci Ujistěte se, že je správný.</span><span class="sxs-lookup"><span data-stu-id="0767f-190">The specification can be unit tested in isolation to ensure it's right.</span></span> <span data-ttu-id="0767f-191">Můžete použít také snadno opakovaně, pokud potřebujete podobné chování.</span><span class="sxs-lookup"><span data-stu-id="0767f-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="0767f-192">Například na akci zobrazení MVC a webového rozhraní API akce i v různých služeb.</span><span class="sxs-lookup"><span data-stu-id="0767f-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

- <span data-ttu-id="0767f-193">Specifikace je také možné popisující tvar dat, který se má vrátit, tak, aby dotazy mohou vracet pouze data jsou povinné.</span><span class="sxs-lookup"><span data-stu-id="0767f-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="0767f-194">Tím se eliminuje potřebu opožděné načtení webové aplikace, což obvykle nedoporučujeme, a pomáhá udržovat implementace úložiště z stávají nepotřebná data o tyto podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="0767f-194">This eliminates the need for lazy loading in web applications, which is usually not recommended, and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="0767f-195">Příklad obecného specifikace rozhraní je následující kód z [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb).</span><span class="sxs-lookup"><span data-stu-id="0767f-195">An example of a generic specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="0767f-196">V nadcházejících částech popisují, jak implementovat vzor specifikace s EF Core 2.x a jak ji používat z jiné třídy úložiště.</span><span class="sxs-lookup"><span data-stu-id="0767f-196">The upcoming sections explain how to implement the specification pattern with EF Core 2.x and how to use it from any Repository class.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0767f-197">Specifikace vzor je starý vzor, který je možné implementovat mnoha různými způsoby, stejně jako v následujících zdrojích.</span><span class="sxs-lookup"><span data-stu-id="0767f-197">The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="0767f-198">Jako vzor/nápad je vhodné vědět, ale mějte na paměti, starší implementace, které nejsou využít moderní jazyk funkce, jako je Linq a výrazy starší přístupy.</span><span class="sxs-lookup"><span data-stu-id="0767f-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="0767f-199">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="0767f-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="0767f-200">Model úložiště</span><span class="sxs-lookup"><span data-stu-id="0767f-200">The Repository pattern</span></span>

- <span data-ttu-id="0767f-201">**Model úložiště**
  [https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="0767f-201">**The Repository pattern**
[https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span></span>

- <span data-ttu-id="0767f-202">**EDWARD Hieatt a Rob mi. Model úložiště.**
  [_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="0767f-202">**Edward Hieatt and Rob Mee. Repository pattern.**
[_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

- <span data-ttu-id="0767f-203">**Model úložiště**
  [_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span><span class="sxs-lookup"><span data-stu-id="0767f-203">**The Repository pattern**
[_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span></span>

- <span data-ttu-id="0767f-204">**Eric Evans. Návrhy řízené doménou: Použití složitosti srdce softwaru.**</span><span class="sxs-lookup"><span data-stu-id="0767f-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="0767f-205">(Kniha; obsahuje diskusi o vzor úložiště) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="0767f-205">(Book; includes a discussion of the Repository pattern) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="0767f-206">Jednotka pracovní postup</span><span class="sxs-lookup"><span data-stu-id="0767f-206">Unit of Work pattern</span></span>

- <span data-ttu-id="0767f-207">**Martina Fowlera. Jednotka pracovní postup.**
  [_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="0767f-207">**Martin Fowler. Unit of Work pattern.**
[_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

- <span data-ttu-id="0767f-208">**Implementace úložiště a jednotky pracovních vzorů v aplikaci ASP.NET MVC**
  [_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="0767f-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="0767f-209">Vzor specifikace</span><span class="sxs-lookup"><span data-stu-id="0767f-209">The Specification pattern</span></span>

- <span data-ttu-id="0767f-210">**Specifikace vzor.**
  [_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="0767f-210">**The Specification pattern.**
[_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/)</span></span>

- <span data-ttu-id="0767f-211">**Evans, Eric (2004). Návrhu na základě domény. Addison Wesley. p. 224.**</span><span class="sxs-lookup"><span data-stu-id="0767f-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

- <span data-ttu-id="0767f-212">**Specifikace. Martina Fowlera**
  [_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="0767f-212">**Specifications. Martin Fowler**
[_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="0767f-213">[Předchozí](domain-events-design-implementation.md)
[další](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="0767f-213">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
