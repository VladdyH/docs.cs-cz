---
title: Navrhování vrstvu trvalosti infrastruktury
description: Architektura Mikroslužeb .NET pro aplikace .NET Kontejnerizované | Navrhování vrstvu trvalosti infrastruktury
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/08/2017
ms.openlocfilehash: 2b15fcaeaa8934caceaeab963123650354abf291
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33578910"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="f1946-103">Navrhování vrstvu trvalosti infrastruktury</span><span class="sxs-lookup"><span data-stu-id="f1946-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="f1946-104">Součásti trvalosti dat poskytnout přístup k datům hostovaným v rámci hranice mikroslužbu (to znamená, databáze mikroslužbu).</span><span class="sxs-lookup"><span data-stu-id="f1946-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="f1946-105">Obsahují skutečné implementace komponenty, například úložiště a [jednotky práce](https://martinfowler.com/eaaCatalog/unitOfWork.html) třídy, jako jsou vlastní EF DBContexts.</span><span class="sxs-lookup"><span data-stu-id="f1946-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="f1946-106">Vzor úložiště</span><span class="sxs-lookup"><span data-stu-id="f1946-106">The Repository pattern</span></span>

<span data-ttu-id="f1946-107">Úložiště jsou třídy nebo součásti, které zapouzdřují logiku potřebnou k přistupovat ke zdrojům dat.</span><span class="sxs-lookup"><span data-stu-id="f1946-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="f1946-108">Jejich centralizovat běžné funkce přístupu dat, poskytuje lepší udržovatelnosti a oddělení infrastrukturu nebo technologie používané pro přístup k databázím z vrstvy modelu domény.</span><span class="sxs-lookup"><span data-stu-id="f1946-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="f1946-109">Pokud používáte ORM jako Entity Framework, je zjednodušená kód, který musí být implementována, díky LINQ a silného typování.</span><span class="sxs-lookup"><span data-stu-id="f1946-109">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="f1946-110">Tento přístup umožňuje zaměřit se na logice trvalosti dat, ne na data k vložení.</span><span class="sxs-lookup"><span data-stu-id="f1946-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="f1946-111">Vzor úložiště je dobře zdokumentovaných způsob práce se zdrojem dat.</span><span class="sxs-lookup"><span data-stu-id="f1946-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="f1946-112">V seznamu [vzory Architektura aplikace Enterprise](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler popisuje úložiště následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="f1946-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="f1946-113">Úložiště provádí úlohy zprostředkovatele mezi domény modelu vrstev a mapování dat, který funguje podobným způsobem sadu objektů domény v paměti.</span><span class="sxs-lookup"><span data-stu-id="f1946-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="f1946-114">Objekty klienta deklarativně vytvořit dotazy a odeslat je do úložiště pro odpovědi.</span><span class="sxs-lookup"><span data-stu-id="f1946-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="f1946-115">Úložiště koncepčně, zapouzdří sadu objektů, které jsou uloženy v databázi a operací, které lze provést na, poskytuje tak, že bude co nejblíže ke vrstvu trvalosti.</span><span class="sxs-lookup"><span data-stu-id="f1946-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="f1946-116">Úložiště, navíc podporují účel jasně a v jednom směru oddělení závislost mezi pracovní domény a požadavky na data nebo mapování.</span><span class="sxs-lookup"><span data-stu-id="f1946-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="f1946-117">Definovat jeden úložiště pro agregace</span><span class="sxs-lookup"><span data-stu-id="f1946-117">Define one repository per aggregate</span></span>

<span data-ttu-id="f1946-118">Pro každý kořenový agregační nebo agregační byste měli vytvořit jednu třídu úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1946-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="f1946-119">Mikroslužbu, na základě způsobů funguje na základě domény musí být pouze kanál, který byste měli použít k aktualizaci databáze úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1946-119">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="f1946-120">Je to proto, že jsou v relaci s agregační kořenový adresář, který řídí výstupních podmínek na agregaci a transakční konzistence.</span><span class="sxs-lookup"><span data-stu-id="f1946-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="f1946-121">Je to v pořádku pro dotazování databáze prostřednictvím jiné kanály (jako je tomu následující CQRS přístup), protože dotazy neměňte stav databáze.</span><span class="sxs-lookup"><span data-stu-id="f1946-121">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="f1946-122">Ale oblasti transakcí – aktualizace – musí být vždy kontrolován úložiště a agregační kořenové adresáře.</span><span class="sxs-lookup"><span data-stu-id="f1946-122">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="f1946-123">V podstatě úložiště vám umožní naplnit data v paměti, který přichází z databáze ve formě entity domény.</span><span class="sxs-lookup"><span data-stu-id="f1946-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="f1946-124">Jakmile entity, které jsou v paměti, může být změnit a pak trvalé zpět do databáze pomocí transakce.</span><span class="sxs-lookup"><span data-stu-id="f1946-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="f1946-125">Jak jsme uvedli dříve, pokud používáte CQS/CQRS architekturní vzor, provede počáteční dotazy straně dotazy z modelu domény, provádí pomocí Dapper jednoduché příkazů SQL.</span><span class="sxs-lookup"><span data-stu-id="f1946-125">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="f1946-126">Tento přístup je mnohem víc, stačí flexibilní než úložiště, protože můžete vyhledat a připojit k žádné tabulky, a tyto dotazy nejsou omezeny pravidla z agregace.</span><span class="sxs-lookup"><span data-stu-id="f1946-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="f1946-127">Tato data budou moct prezentační vrstvy nebo klientské aplikace.</span><span class="sxs-lookup"><span data-stu-id="f1946-127">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="f1946-128">Pokud uživatel provede změny, aktualizace dat bude pocházet z klienta aplikace nebo prezentační vrstvy do vrstvy aplikace (například webového rozhraní API služby).</span><span class="sxs-lookup"><span data-stu-id="f1946-128">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="f1946-129">Jakmile se zobrazí příkaz (s daty) v obslužná rutina příkazu, použijete úložiště získat data, která chcete aktualizovat z databáze.</span><span class="sxs-lookup"><span data-stu-id="f1946-129">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="f1946-130">Aktualizujete v paměti s informacemi o byla dokončena s příkazy, a pak přidáte nebo aktualizujete data (domény entity) v databázi pomocí transakce.</span><span class="sxs-lookup"><span data-stu-id="f1946-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="f1946-131">Pamatovat na to, že pouze jeden úložiště by měl být definován pro každý agregační kořenový adresář, jak je znázorněno v obrázek 9-17.</span><span class="sxs-lookup"><span data-stu-id="f1946-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="f1946-132">K dosažení cíle agregační kořenové zachování transakční konzistence mezi všechny objekty v rámci agregace, měli byste nikdy vytvořit úložiště pro každou tabulku v databázi.</span><span class="sxs-lookup"><span data-stu-id="f1946-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="f1946-133">**Obrázek 9-17**.</span><span class="sxs-lookup"><span data-stu-id="f1946-133">**Figure 9-17**.</span></span> <span data-ttu-id="f1946-134">Vztah mezi úložiště, agregace a tabulek databáze</span><span class="sxs-lookup"><span data-stu-id="f1946-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="f1946-135">Vynucování jeden kořenový agregační na úložiště</span><span class="sxs-lookup"><span data-stu-id="f1946-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="f1946-136">Může být užitečné k implementaci návrhu úložiště tak, že vynucuje pravidlo, že pouze agregační kořenových certifikačních autorit by měl mít úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1946-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="f1946-137">Můžete vytvořit úložiště obecné nebo základní typ, který omezí typ entity, které funguje s zajistit, že mají rozhraní IAggregateRoot značky.</span><span class="sxs-lookup"><span data-stu-id="f1946-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="f1946-138">Každá třída úložiště implementována ve vrstvě infrastruktury implementuje proto vlastní kontrakt nebo rozhraní, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="f1946-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="f1946-139">Každé rozhraní konkrétní úložiště implementuje obecné rozhraní IRepository:</span><span class="sxs-lookup"><span data-stu-id="f1946-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="f1946-140">Však lepší způsob, jak mají kód vynutit konvence, každý úložiště by měl mít relace k jedné agregaci by implementovat typu Obecné úložiště tak, aby byl explicitní, že používáte úložiště pro konkrétní agregace.</span><span class="sxs-lookup"><span data-stu-id="f1946-140">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="f1946-141">Můžete snadno provést implementací této obecné v IRepository základní rozhraní, jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="f1946-141">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="f1946-142">Vzor úložiště usnadňuje testování vaší aplikace logiky</span><span class="sxs-lookup"><span data-stu-id="f1946-142">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="f1946-143">Vzor úložiště umožňuje snadno testování vaší aplikace pomocí jednotkových testů.</span><span class="sxs-lookup"><span data-stu-id="f1946-143">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="f1946-144">Mějte na paměti, že testy jednotek pouze zkušební kód, není infrastrukturu, tak abstrakce úložiště usnadňují dosažení tohoto cíle.</span><span class="sxs-lookup"><span data-stu-id="f1946-144">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="f1946-145">Jak je uvedeno v předchozí části, se doporučuje definovat a umístit rozhraní úložiště vrstva modelu domény, aplikační vrstvu (například vaše mikroslužbu webového rozhraní API) nezávisí přímo na vrstvě infrastruktury kde máte implementované tříd skutečné úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1946-145">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="f1946-146">Díky tomuto a využitím vkládání závislostí v řadiče webové rozhraní API, můžete implementovat imitované úložiště, které vracejí místo data falešných dat z databáze.</span><span class="sxs-lookup"><span data-stu-id="f1946-146">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="f1946-147">Že odpojeného přístup umožňuje vytvořit a spuštění jednotky testy, které můžete testovat logiku aplikace bez nutnosti připojení k databázi.</span><span class="sxs-lookup"><span data-stu-id="f1946-147">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="f1946-148">Připojení k databázím může selhat a důležitější, spuštěn stovky testy s databází je chybný. dvou důvodů.</span><span class="sxs-lookup"><span data-stu-id="f1946-148">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="f1946-149">První může trvat mnoho času z důvodu velkého počtu testy.</span><span class="sxs-lookup"><span data-stu-id="f1946-149">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="f1946-150">Druhý záznamů databáze může změnit a ovlivnit výsledky testů, takže se nemusí být v souladu.</span><span class="sxs-lookup"><span data-stu-id="f1946-150">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="f1946-151">Testování v databázi není jednotka testy ale integrační testování.</span><span class="sxs-lookup"><span data-stu-id="f1946-151">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="f1946-152">Měli byste mít mnoho testy jednotek rychlé spuštění, ale méně integrace testy s databází.</span><span class="sxs-lookup"><span data-stu-id="f1946-152">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="f1946-153">Z hlediska oddělené oblasti zájmu pro testy logika funguje na domény entity v paměti.</span><span class="sxs-lookup"><span data-stu-id="f1946-153">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="f1946-154">Předpokládá se, že se že má doručit třídu úložiště, ty.</span><span class="sxs-lookup"><span data-stu-id="f1946-154">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="f1946-155">Jakmile logika upraví entity domény, předpokládá se, že třídu úložiště bude správně uložit.</span><span class="sxs-lookup"><span data-stu-id="f1946-155">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="f1946-156">Zde důležité je, chcete-li vytvářet testy částí proti modelu domény a jeho logiku domény.</span><span class="sxs-lookup"><span data-stu-id="f1946-156">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="f1946-157">Agregační kořeny jsou hlavní konzistence hranice v DDD.</span><span class="sxs-lookup"><span data-stu-id="f1946-157">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="f1946-158">Rozdíl mezi použitému vzoru a starší verze třídy (třídy DAL) vzor přístupu k datům</span><span class="sxs-lookup"><span data-stu-id="f1946-158">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="f1946-159">Datový objekt přístup přímo provádí operace přístupu a trvalosti dat pro úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1946-159">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="f1946-160">Úložiště značky, které dat pomocí operace, které chcete provést v paměti jednotky práce objektu (jako EF při použití DbContext), ale tyto aktualizace se neprovádí okamžitě.</span><span class="sxs-lookup"><span data-stu-id="f1946-160">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="f1946-161">Jednotka práce, se označuje jako jediná transakce, který zahrnuje několik vložení, aktualizaci nebo odstranění operace.</span><span class="sxs-lookup"><span data-stu-id="f1946-161">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="f1946-162">Jednoduše řečeno znamená to, že pro akci konkrétního uživatele (například registrace na webu), insert, update a delete transakce jsou zpracovávány v rámci jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="f1946-162">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="f1946-163">Toto je efektivnější než zpracování více transakcí databáze chattier způsobem.</span><span class="sxs-lookup"><span data-stu-id="f1946-163">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="f1946-164">Tyto více trvalost operací později v rámci jedné akce při kódu z aplikační vrstvu příkazů ho.</span><span class="sxs-lookup"><span data-stu-id="f1946-164">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="f1946-165">Rozhodnutí o provádění změn v paměti pro úložiště skutečná databáze obvykle závisí na [jednotky práce vzor](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="f1946-165">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="f1946-166">V EF vzoru pracovní jednotky je implementovaný jako DBContext.</span><span class="sxs-lookup"><span data-stu-id="f1946-166">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="f1946-167">V řadě případů můžete tento vzor nebo způsob použití operace u úložiště zvýšit výkon aplikace a omezit možnost nekonzistence.</span><span class="sxs-lookup"><span data-stu-id="f1946-167">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="f1946-168">Také zmenšuje transakce blokování v tabulkách databáze, protože všechny zamýšlené operace potvrzeny jako součást jedné transakce.</span><span class="sxs-lookup"><span data-stu-id="f1946-168">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="f1946-169">Toto je efektivnější oproti provádění mnoho izolované operací v databázi.</span><span class="sxs-lookup"><span data-stu-id="f1946-169">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="f1946-170">Vybrané ORM tedy moci optimalizovat provádění proti dané databázi seskupením několik akcí aktualizace v rámci stejné transakci oproti spuštěních mnoho malých a samostatné transakce.</span><span class="sxs-lookup"><span data-stu-id="f1946-170">Therefore, the selected ORM is able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="f1946-171">Úložiště by neměl být povinné</span><span class="sxs-lookup"><span data-stu-id="f1946-171">Repositories should not be mandatory</span></span>

<span data-ttu-id="f1946-172">Vlastní úložiště jsou užitečné z důvodů citovalo dříve a který je přístup pro řazení mikroslužbu v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="f1946-172">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="f1946-173">Je však není základní vzor implementovat v návrhu DDD nebo dokonce obecně vývoj v rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="f1946-173">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="f1946-174">Například uvedená Jimmy Bogard, při poskytování zpětné vazby přímé Tato příručka následující:</span><span class="sxs-lookup"><span data-stu-id="f1946-174">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="f1946-175">Toto budete pravděpodobně Moje největších zpětnou vazbu.</span><span class="sxs-lookup"><span data-stu-id="f1946-175">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="f1946-176">Nejsem skutečně ventilátor úložišť, především, protože se skrýt důležité podrobnosti o základní mechanismus trvalosti.</span><span class="sxs-lookup"><span data-stu-id="f1946-176">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="f1946-177">Jeho proč vrátit pro MediatR pro příkazy, příliš.</span><span class="sxs-lookup"><span data-stu-id="f1946-177">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="f1946-178">I použít potenciál vrstvu trvalosti a vkládání daná chování domény do mé agregační kořenových certifikačních autorit.</span><span class="sxs-lookup"><span data-stu-id="f1946-178">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="f1946-179">Model Moje úložiště nechci obvykle – je třeba mít této integrace testu s Opravdová věc.</span><span class="sxs-lookup"><span data-stu-id="f1946-179">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="f1946-180">Budete CQRS určená, že nebyly k dispozici skutečně potřeba úložiště víc.</span><span class="sxs-lookup"><span data-stu-id="f1946-180">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="f1946-181">Jsme užitečné úložiště, ale nemůžeme na vědomí, že nejsou důležité pro vaši DDD, způsobem, jakým jsou agregační vzor a modelu bohaté domény.</span><span class="sxs-lookup"><span data-stu-id="f1946-181">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="f1946-182">Proto použití vzoru úložiště, nebo Ne, jak můžete vidět odpovídat.</span><span class="sxs-lookup"><span data-stu-id="f1946-182">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="f1946-183">Specifikace vzor</span><span class="sxs-lookup"><span data-stu-id="f1946-183">The Specification pattern</span></span>

<span data-ttu-id="f1946-184">Vzor specifikace (plným názvem být specifikaci dotazu vzor) je vzor návrhu Domain-Driven určená jako místo, kde můžete ukládat definici dotazu s volitelné, řazení a stránkování logiku.</span><span class="sxs-lookup"><span data-stu-id="f1946-184">The Specification pattern (its full name would be Query-specification pattern) is a Domain-Driven Design pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="f1946-185">Vzor specifikace definuje dotazu v objektu.</span><span class="sxs-lookup"><span data-stu-id="f1946-185">The Specification pattern defines a query in an object.</span></span> <span data-ttu-id="f1946-186">Chcete-li zapouzdření stránkové dotaz, který hledá některé produkty, například můžete vytvořit specifikaci PagedProduct, která se mají potřebné vstupní parametry (pageNumber pageSize, filtr, atd.).</span><span class="sxs-lookup"><span data-stu-id="f1946-186">For example, in order to encapsulate a paged query that searches for some products, you can create a PagedProduct specification that takes the necessary input parameters (pageNumber, pageSize, filter, etc.).</span></span> <span data-ttu-id="f1946-187">Poté v libovolné metody úložiště (obvykle přetížení List()) by přijmout ISpecification a spusťte očekávané dotaz založený na této specifikaci.</span><span class="sxs-lookup"><span data-stu-id="f1946-187">Then, within any Repository method (usually a List() overload) it would accept an ISpecification and run the expected query based on that specification.</span></span>

<span data-ttu-id="f1946-188">Existuje několik výhod tohoto přístupu:</span><span class="sxs-lookup"><span data-stu-id="f1946-188">There are several benefits to this approach:</span></span>

* <span data-ttu-id="f1946-189">Specifikace má název (na rozdíl od právě bunch LINQ – výrazy), který lze diskutovat o o.</span><span class="sxs-lookup"><span data-stu-id="f1946-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

* <span data-ttu-id="f1946-190">Specifikace může být jednotka otestována izolace Ujistěte se, že je správný.</span><span class="sxs-lookup"><span data-stu-id="f1946-190">The specification can be unit tested in isolation to ensure it is right.</span></span> <span data-ttu-id="f1946-191">Můžete se také snadno znovu, pokud potřebujete podobné chování.</span><span class="sxs-lookup"><span data-stu-id="f1946-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="f1946-192">Například na akci zobrazení MVC a akce webového rozhraní API a také různé služby.</span><span class="sxs-lookup"><span data-stu-id="f1946-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

* <span data-ttu-id="f1946-193">Specifikaci lze také použít k popisu tvaru data, která mají být vráceny, tak, aby dotazy mohou vracet pouze data, se vyžaduje.</span><span class="sxs-lookup"><span data-stu-id="f1946-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="f1946-194">Tím se eliminuje potřeba opožděného načítání webových aplikací, (což je obvykle není vhodné) a pomáhá udržovat implementace úložiště z stal zaplněny, tyto podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="f1946-194">This eliminates the need for lazy loading in web applications (which is usually not a good idea) and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="f1946-195">Následující kód je například obecné specifikace rozhraní [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span><span class="sxs-lookup"><span data-stu-id="f1946-195">An example of a generic Specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb 
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="f1946-196">V nadcházejících částech se vysvětluje, jak implementovat vzor specifikace s Entity Framework Core 2.0 a způsobu jeho použití z libovolné třídy úložiště.</span><span class="sxs-lookup"><span data-stu-id="f1946-196">In the upcoming sections, it is explained how to implement the Specification pattern with Entity Framework Core 2.0 and how to use it from any Repository class.</span></span>

<span data-ttu-id="f1946-197">**Důležité upozornění:** specifikace vzor je starý vzor, který můžou se implementovat v mnoha různými způsoby, stejně jako v následujících zdrojích.</span><span class="sxs-lookup"><span data-stu-id="f1946-197">**Important note:** The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="f1946-198">Jako vzor nebo nápad jsou dobré vědět, ale pozor starší implementací, které nejsou využívat výhod moderní jazyk funkcí, jako Linq a výrazy starší přístupy.</span><span class="sxs-lookup"><span data-stu-id="f1946-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="f1946-199">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="f1946-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="f1946-200">Vzor úložiště</span><span class="sxs-lookup"><span data-stu-id="f1946-200">The Repository pattern</span></span>

-   <span data-ttu-id="f1946-201">**EDWARD Hieatt a Rob mi. Vzor úložiště.**
    [*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="f1946-201">**Edward Hieatt and Rob Mee. Repository pattern.**
[*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="f1946-202">**Vzor úložiště**
    [*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="f1946-202">**The Repository pattern**
[*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="f1946-203">**Použitému vzoru: Data abstrakce**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="f1946-203">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="f1946-204">**Zařízení Evans Erica. Řízené domény návrhu: Boji se složitostí při vysílat softwaru.**</span><span class="sxs-lookup"><span data-stu-id="f1946-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="f1946-205">(Sešit; zahrnuje diskuzi o vzoru úložiště) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="f1946-205">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="f1946-206">Jednotka práce vzor</span><span class="sxs-lookup"><span data-stu-id="f1946-206">Unit of Work pattern</span></span>

-   <span data-ttu-id="f1946-207">**Martin Fowler. Jednotka práce vzor.**
    [*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="f1946-207">**Martin Fowler. Unit of Work pattern.**
[*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="f1946-208">**Implementace úložiště a jednotky pracovních vzorů v aplikaci ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="f1946-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="f1946-209">Specifikace vzor</span><span class="sxs-lookup"><span data-stu-id="f1946-209">The Specification pattern</span></span>

-   <span data-ttu-id="f1946-210">**Specifikace vzor.**
    [*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="f1946-210">**The Specification pattern.**
[*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span></span>

-   <span data-ttu-id="f1946-211">**Zařízení Evans Erica (2004). Doména řízené návrhu. Addison-Wesley. p. 224.**</span><span class="sxs-lookup"><span data-stu-id="f1946-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

-   <span data-ttu-id="f1946-212">**Specifikace. Martin Fowler**
    [*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="f1946-212">**Specifications. Martin Fowler**
[*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="f1946-213">[Předchozí] (domény události návrhu implementation.md) [Další] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="f1946-213">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
