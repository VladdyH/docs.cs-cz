---
title: Události domény. Návrh a implementaci
description: Architektura Mikroslužeb .NET pro aplikace .NET Kontejnerizované | Události domény, návrhu a implementace
keywords: Docker, Mikroslužeb, ASP.NET, kontejneru
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 12/11/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bec1341df85f86d5f2aa15753a11a9c4a2d0173f
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/18/2018
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="850d5-105">Události domény: návrhu a implementace</span><span class="sxs-lookup"><span data-stu-id="850d5-105">Domain events: design and implementation</span></span>

<span data-ttu-id="850d5-106">Explicitní implementace vedlejší účinky změn ve vaší doméně pomocí události domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="850d5-107">V jiná slova a používá terminologie DDD používejte domény události explicitní implementace vedlejší účinky napříč více agregace.</span><span class="sxs-lookup"><span data-stu-id="850d5-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="850d5-108">Volitelně můžete pro účely lepší škálovatelnosti a menší dopad na uzamčení databáze pomocí konzistence typu případné mezi agregace ve stejné doméně.</span><span class="sxs-lookup"><span data-stu-id="850d5-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="850d5-109">Co je událost domény?</span><span class="sxs-lookup"><span data-stu-id="850d5-109">What is a domain event?</span></span>

<span data-ttu-id="850d5-110">Událost je něco, co došlo v minulosti.</span><span class="sxs-lookup"><span data-stu-id="850d5-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="850d5-111">Událost domény, logicky, něco, co se stalo v určité doméně, a něco chcete jiných součástí stejné domény (v procesu), aby mít na paměti a potenciálně reagovat na ně.</span><span class="sxs-lookup"><span data-stu-id="850d5-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="850d5-112">Důležité výhodou události domény je, že vedlejší účinky po se něco stalo v doméně, může být vyjádřený explicitně místo implicitně.</span><span class="sxs-lookup"><span data-stu-id="850d5-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="850d5-113">Tyto straně důsledky musí být konzistentní, proto dojít buď všechny operace související s obchodní úlohy, nebo žádná z nich.</span><span class="sxs-lookup"><span data-stu-id="850d5-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="850d5-114">Kromě toho události domény umožňuje lepší oddělené oblasti zájmu v rámci třídy ve stejné doméně.</span><span class="sxs-lookup"><span data-stu-id="850d5-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="850d5-115">Například pokud právě používáte rozhraní Entity Framework a entity nebo i agregace, pokud musí existovat vedlejší účinky provoked případem použití, ty budou prováděny jako implicitní koncept v párované kódu po se něco stalo.</span><span class="sxs-lookup"><span data-stu-id="850d5-115">For example, if you're just using Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="850d5-116">Ale pokud se zobrazí pouze tento kód, možná nevíte, pokud tento kód (vedlejším účinkem) je součástí hlavní operaci, nebo pokud se ve skutečnosti je vedlejším účinkem.</span><span class="sxs-lookup"><span data-stu-id="850d5-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="850d5-117">Na druhé straně pomocí události domény mohou koncept explicitní a součástí všudypřítomný jazyk.</span><span class="sxs-lookup"><span data-stu-id="850d5-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="850d5-118">Například v aplikaci eShopOnContainers vytváření pořadí není jenom o pořadí; aktualizací nebo vytvoří kupujících agregační na základě původního uživatele, protože uživatel není kupující dokud pořadí na místě.</span><span class="sxs-lookup"><span data-stu-id="850d5-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="850d5-119">Pokud používáte události domény, můžete explicitně express pravidlo této domény založené na všudypřítomný jazyk zadaný odborníky domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="850d5-120">Události domény jsou trochu podobné události zasílání zpráv ve stylu s jeden podstatným rozdílem.</span><span class="sxs-lookup"><span data-stu-id="850d5-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="850d5-121">S skutečné zasílání zpráv služby Řízení front zpráv, zpráv zprostředkovatelé nebo služby service bus pomocí AMPQ se zprávu vždy odesílají asynchronně a předávat v rámci procesy a počítače.</span><span class="sxs-lookup"><span data-stu-id="850d5-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="850d5-122">To je užitečné pro integraci více ohraničenou kontexty, mikroslužeb nebo i jiné aplikace.</span><span class="sxs-lookup"><span data-stu-id="850d5-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="850d5-123">S událostmi domény chcete vyvolat událost z operace domény, které jsou aktuálně spuštěné, ale chcete, aby žádné vedlejší účinky v rámci stejné domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="850d5-124">Události domény a jejich vedlejší efekty (akce aktivuje později spravovaná obslužné rutiny událostí) provedeno téměř okamžitě, obvykle v rámci procesu a v rámci stejné domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="850d5-125">Proto události domény může být synchronní nebo asynchronní.</span><span class="sxs-lookup"><span data-stu-id="850d5-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="850d5-126">Události integrace, ale musí být vždy asynchronní.</span><span class="sxs-lookup"><span data-stu-id="850d5-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="850d5-127">Události domény oproti události integrace</span><span class="sxs-lookup"><span data-stu-id="850d5-127">Domain events versus integration events</span></span>

<span data-ttu-id="850d5-128">Sémanticky, domény a integrace události jsou samé: oznámení o něco, které právě došlo.</span><span class="sxs-lookup"><span data-stu-id="850d5-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="850d5-129">Implementace však musí být jiný.</span><span class="sxs-lookup"><span data-stu-id="850d5-129">However, their implementation must be different.</span></span> <span data-ttu-id="850d5-130">Události domény jsou jenom zpráv nabídnutých do dispečeru událostí domény, který by mohl implementovaný jako zprostředkovatel v paměti na základě kontejner IoC nebo jiným způsobem.</span><span class="sxs-lookup"><span data-stu-id="850d5-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="850d5-131">Na druhé straně účelem události integrace je potřebný k šíření potvrzené transakce a aktualizace další subsystémy, jestli jsou v jiné mikroslužeb nebo ohraničenou kontextu i externími aplikacemi.</span><span class="sxs-lookup"><span data-stu-id="850d5-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="850d5-132">Proto má vzniknout jen pokud entita je úspěšně jako trvalé, od v mnoha scénářích Pokud se to nezdaří, celou operaci efektivně nikdy došlo.</span><span class="sxs-lookup"><span data-stu-id="850d5-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="850d5-133">Kromě toho a jako uvedených, integrace události musí být založená na asynchronní komunikaci mezi více mikroslužeb (jiných kontextech s ohraničenou) nebo i externími systémy nebo aplikacemi.</span><span class="sxs-lookup"><span data-stu-id="850d5-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="850d5-134">Proto musí rozhraní sběrnice událostí některé infrastrukturu, která umožňuje mezi proces a distribuovaných komunikace mezi potenciálně vzdálené.</span><span class="sxs-lookup"><span data-stu-id="850d5-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="850d5-135">Ho může být založen na komerční služby service bus, fronty, sdílenou databázi použít jako poštovní schránku nebo jakékoliv distribuované a v ideálním případě push založené na systému zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="850d5-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="850d5-136">Události domény jako upřednostňovaný způsob, jak aktivovat vedlejší účinky napříč více agregace ve stejné doméně</span><span class="sxs-lookup"><span data-stu-id="850d5-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="850d5-137">Pokud spuštění příkazu vztahující se k jednomu agregační instance vyžaduje další domény pravidla ke spuštění na jeden nebo více dalších agregace, by měl navrhujete a implementujete tyto vedlejší účinky, aby se spouštěly domény událostmi.</span><span class="sxs-lookup"><span data-stu-id="850d5-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="850d5-138">Jak je uvedené v obrázek 9-14 a jako jeden z nejdůležitějších případy použití, domény událostí se používá k rozšíří změny stavu na více agregace v rámci stejného modelu domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="850d5-139">**Obrázek 9-14**.</span><span class="sxs-lookup"><span data-stu-id="850d5-139">**Figure 9-14**.</span></span> <span data-ttu-id="850d5-140">Události domény chcete zajistit konzistenci mezi několika agregace ve stejné doméně</span><span class="sxs-lookup"><span data-stu-id="850d5-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="850d5-141">Na obrázku když uživatel spustí pořadí, aktivuje událost domény OrderStarted vytvoření objektu kupujících v řazení mikroslužbu, založené na původní informace o uživateli z mikroslužbu identity (pomocí informací uvedených v příkazu CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="850d5-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="850d5-142">Událost domény je generován agregace pořadí při vytvoření na prvním místě.</span><span class="sxs-lookup"><span data-stu-id="850d5-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="850d5-143">Alternativně můžete mít kořenu agregační předplatné pro události vyvolané službou členy jeho agregace (podřízených entit).</span><span class="sxs-lookup"><span data-stu-id="850d5-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="850d5-144">Každá entita podřízené OrderItem pro instanci může vyvolat událost, když cena zboží je vyšší než určitou velikostí, nebo když množství položek produktu je příliš vysoká.</span><span class="sxs-lookup"><span data-stu-id="850d5-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="850d5-145">Agregační kořenové můžete přijímat tyto události a provádět globální výpočtu nebo agregace.</span><span class="sxs-lookup"><span data-stu-id="850d5-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="850d5-146">Je důležité si uvědomit, že tato komunikace na základě událostí není implementována přímo v rámci agregace; je nutné implementovat domény obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="850d5-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="850d5-147">Zpracování událostí domény je aplikace.</span><span class="sxs-lookup"><span data-stu-id="850d5-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="850d5-148">Vrstva modelu domény měli jenom zaměřit na logiku domény – věcí, které by pochopit odborník z domény, ne aplikace infrastruktury, jako jsou obslužné rutiny a vedlejším účinkem trvalost akce s použitím úložiště.</span><span class="sxs-lookup"><span data-stu-id="850d5-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="850d5-149">Úroveň vrstvy aplikace je proto, kde byste měli mít spuštění akce při domény událost se vyvolá, obslužné rutiny událostí domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="850d5-150">Události domény lze také použít k aktivaci libovolného počtu akcí aplikace a co je důležitější, musí být otevřený a odpojeného způsobem zvýšit počet v budoucnu.</span><span class="sxs-lookup"><span data-stu-id="850d5-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="850d5-151">Například při spuštění pořadí, můžete chtít publikování domény událostí k šíření této informací o jiné agregace nebo i pro vyvolání akce aplikace jako oznámení.</span><span class="sxs-lookup"><span data-stu-id="850d5-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="850d5-152">Klíče bod je otevřené počet akce má být proveden při výskytu události domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="850d5-153">Nakonec se zvýší akce a pravidla v doméně a aplikace.</span><span class="sxs-lookup"><span data-stu-id="850d5-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="850d5-154">Složitost nebo počet vedlejším účinkem akcí, když se stane něco se zvýší, ale pokud se váš kód kombinaci s "spojovací" (který je právě vytváření instancí objektů s new – klíčové slovo v jazyce C\#), pokaždé, když je potřeba přidat novou akci je nutné, aby Původní kód změňte.</span><span class="sxs-lookup"><span data-stu-id="850d5-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="850d5-155">Výsledkem by mohlo nové chyby, protože se každý nový požadavek by potřebujete změnit původní toku kódu.</span><span class="sxs-lookup"><span data-stu-id="850d5-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="850d5-156">To má význam proti [otevřete/uzavřeno Princip](https://en.wikipedia.org/wiki/Open/closed_principle) z [plnou](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="850d5-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="850d5-157">Ne, pouze to, že, původní třídu, která byla Orchestrace operace by růst a růst, která přejde na [jedné zásadě odpovědnost (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="850d5-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="850d5-158">Na druhé straně Pokud používáte události domény, můžete vytvořit podrobné a odpojeného implementace oddělováním odpovědnosti použití tohoto přístupu:</span><span class="sxs-lookup"><span data-stu-id="850d5-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="850d5-159">Odeslání příkazu (například CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="850d5-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="850d5-160">Zobrazí příkaz v obslužná rutina příkazu.</span><span class="sxs-lookup"><span data-stu-id="850d5-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="850d5-161">Spusťte jeden agregace transakce.</span><span class="sxs-lookup"><span data-stu-id="850d5-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="850d5-162">(Volitelné) Vyvolávání událostí domény pro vedlejší efekty (například OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="850d5-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
1.  <span data-ttu-id="850d5-163">Zpracování událostí domény (v rámci aktuální proces), které budou spuštěny otevřete počet vedlejší účinky v několika agregace nebo se akce aplikace.</span><span class="sxs-lookup"><span data-stu-id="850d5-163">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="850d5-164">Příklad:</span><span class="sxs-lookup"><span data-stu-id="850d5-164">For example:</span></span>
    -   <span data-ttu-id="850d5-165">Ověřte nebo vytvořte kupujících a způsobu platby.</span><span class="sxs-lookup"><span data-stu-id="850d5-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="850d5-166">Vytvoření a odeslání událostí související integrace ke sběrnici událostí k rozšíří stavy na mikroslužeb nebo aktivační událost externí akcí jako odběratel odesílání e-mailu.</span><span class="sxs-lookup"><span data-stu-id="850d5-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="850d5-167">Zpracujte jiné vedlejší účinky.</span><span class="sxs-lookup"><span data-stu-id="850d5-167">Handle other side effects.</span></span>

<span data-ttu-id="850d5-168">Jak znázorňuje obrázek 9 – 15, od stejné domény události, může zpracovávat několik akcí souvisejících s jiné agregace v doméně nebo akce další aplikace, které je potřeba provést přes připojení s integrace události a události sběrnice mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="850d5-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="850d5-169">**Obrázek 9 až 15**.</span><span class="sxs-lookup"><span data-stu-id="850d5-169">**Figure 9-15**.</span></span> <span data-ttu-id="850d5-170">Zpracování více akcí v každé doméně</span><span class="sxs-lookup"><span data-stu-id="850d5-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="850d5-171">Obslužné rutiny událostí jsou obvykle v aplikační vrstvě, protože objektů infrastruktury, jako jsou úložiště nebo rozhraní API aplikace bude používat mikroslužbu chování.</span><span class="sxs-lookup"><span data-stu-id="850d5-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="850d5-172">V tomto smysl jsou podobné obslužné rutiny příkazů, obslužné rutiny událostí, tak jak jsou součástí aplikační vrstvu.</span><span class="sxs-lookup"><span data-stu-id="850d5-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="850d5-173">Důležitý rozdíl je, že příkaz má být zpracován pouze jednou.</span><span class="sxs-lookup"><span data-stu-id="850d5-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="850d5-174">Událost domény může být zpracována nula nebo *n* krát, protože ho lze přijímat pomocí několika příjemci nebo obslužných rutin událostí pomocí k jinému účelu pro každou obslužnou rutinu.</span><span class="sxs-lookup"><span data-stu-id="850d5-174">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="850d5-175">Možnost Otevřít počet obslužných rutin na událost domény umožňuje přidat mnoho další pravidla domény bez dopadu na váš aktuální kód.</span><span class="sxs-lookup"><span data-stu-id="850d5-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="850d5-176">Implementace následující obchodní pravidlo, které se má provést vpravo po konkrétní události, například může být stejně snadná jako přidávání několik obslužné rutiny událostí (nebo i pouze jeden):</span><span class="sxs-lookup"><span data-stu-id="850d5-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="850d5-177">Pokud celková velikost koupili zákazníka v úložišti, napříč jakékoli číslo objednávky, překročí $6000, platí pro všechny nové pořadí 10 % vypnout slevu a upozorňovat zákazník s e-mailu o tomto slevy pro budoucí objednávky.</span><span class="sxs-lookup"><span data-stu-id="850d5-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="850d5-178">Implementace události domény</span><span class="sxs-lookup"><span data-stu-id="850d5-178">Implementing domain events</span></span>

<span data-ttu-id="850d5-179">V jazyce C# domény událostí je jednoduše data za ruku struktura nebo třídy, jako je DTO, všechny informace související s co se právě stalo v doméně, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="850d5-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="850d5-180">Toto je v podstatě třídu, která obsahuje všechna data související s OrderStarted události.</span><span class="sxs-lookup"><span data-stu-id="850d5-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="850d5-181">Z hlediska všudypřítomný jazyka domény vzhledem k tomu, že událost je něco, co se stalo v minulosti, název třídy události by měl být reprezentován jako minulost operace, jako je OrderStartedDomainEvent nebo OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="850d5-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="850d5-182">To je, jak je implementovaná událost domény v řazení mikroslužbu v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="850d5-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="850d5-183">Jak již bylo uvedeno dříve, důležitou vlastností událostí je, že vzhledem k tomu, že událost je něco, co se stalo v minulosti, neměli měnit.</span><span class="sxs-lookup"><span data-stu-id="850d5-183">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="850d5-184">Proto musí být třídu neměnné.</span><span class="sxs-lookup"><span data-stu-id="850d5-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="850d5-185">Zobrazí se v předchozí kód, který vlastnosti jsou jen pro čtení z mimo objekt.</span><span class="sxs-lookup"><span data-stu-id="850d5-185">You can see in the previous code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="850d5-186">Jediný způsob, jak aktualizovat objekt je pomocí konstruktoru, při vytváření objektu události.</span><span class="sxs-lookup"><span data-stu-id="850d5-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="850d5-187">Vyvolání událostí domény</span><span class="sxs-lookup"><span data-stu-id="850d5-187">Raising domain events</span></span>

<span data-ttu-id="850d5-188">Další otázka se vyvolat událost domény, takže se dosáhne jeho obslužné rutiny událostí související postupy.</span><span class="sxs-lookup"><span data-stu-id="850d5-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="850d5-189">Můžete použít několik přístupů.</span><span class="sxs-lookup"><span data-stu-id="850d5-189">You can use multiple approaches.</span></span>

<span data-ttu-id="850d5-190">Původně navrhované UDI Dahan (například v několika související s příspěvky, jako například [události domény – trvat 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) pomocí statická třída pro správu a vyvolávání událostí.</span><span class="sxs-lookup"><span data-stu-id="850d5-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="850d5-191">To může zahrnovat statické třídy s názvem DomainEvents, který by vyvolávání událostí domény okamžitě, když je volána, pomocí syntaxe jako DomainEvents.Raise (MyEvent má mít událostí).</span><span class="sxs-lookup"><span data-stu-id="850d5-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="850d5-192">Jimmy Bogard napsali blogový příspěvek ([posílení vaší domény: domény události](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)), doporučuje podobný postup.</span><span class="sxs-lookup"><span data-stu-id="850d5-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="850d5-193">Ale když statické třídy události domény se také odešle do obslužné rutiny okamžitě.</span><span class="sxs-lookup"><span data-stu-id="850d5-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="850d5-194">Díky testování a ladění obtížnější, protože obslužných rutin událostí pomocí logiky vedlejší účinky jsou vykonány ihned po vyvolání události.</span><span class="sxs-lookup"><span data-stu-id="850d5-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="850d5-195">Když jsou testování a ladění, chcete zaměřit na to, a stejně, co se děje v aktuální agregační třídy; nechcete náhle přesměrovat na ostatních obslužných rutin událostí pro vedlejší účinky související do jiných agregací nebo aplikační logiku.</span><span class="sxs-lookup"><span data-stu-id="850d5-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="850d5-196">Z tohoto důvodu vyvinuly jiné postupy, jak je popsáno v následující části.</span><span class="sxs-lookup"><span data-stu-id="850d5-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="850d5-197">Odložené přístup pro vyvolání a odeslání události</span><span class="sxs-lookup"><span data-stu-id="850d5-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="850d5-198">Místo odeslání na obslužnou rutinu události domény okamžitě, je lepší způsob přidání události domény do kolekce a potom k odesílání událostí tyto domény *bezprostředně před* nebo *správné*  *Po* potvrzení transakce (stejně jako u SaveChanges v EF).</span><span class="sxs-lookup"><span data-stu-id="850d5-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="850d5-199">(Tento přístup byl Jimmy Bogard popsaného v tomto blogu [lepší vzor události domény](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="850d5-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="850d5-200">Při rozhodování o tom, pokud je odeslat události domény hned před nebo správné za potvrzení transakce je důležité, protože určuje, zda bude obsahovat vedlejší účinky v rámci stejné transakci nebo jinou transakcí.</span><span class="sxs-lookup"><span data-stu-id="850d5-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="850d5-201">V takovém případě budete muset řešit případné konzistence napříč více agregace.</span><span class="sxs-lookup"><span data-stu-id="850d5-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="850d5-202">Toto téma je popsané v další části.</span><span class="sxs-lookup"><span data-stu-id="850d5-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="850d5-203">Odložené přístup je, jaké eShopOnContainers používá.</span><span class="sxs-lookup"><span data-stu-id="850d5-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="850d5-204">Nejprve přidejte události děje ve vašem entity do kolekce nebo seznamu událostí za entity.</span><span class="sxs-lookup"><span data-stu-id="850d5-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="850d5-205">Tento seznam musí být součástí objektu entity, nebo i lépe součástí třídy základní entitu, jak je znázorněno v následujícím příkladu základní třídy Entity:</span><span class="sxs-lookup"><span data-stu-id="850d5-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //... 
    private List<INotification> _domainEvents;
    public List<INotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<INotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(INotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="850d5-206">Když chcete vyvolat událost, stačí ho přidáte do kolekce událostí z kódu v jakékoli metody objektu entity agregace root.</span><span class="sxs-lookup"><span data-stu-id="850d5-206">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="850d5-207">Následující kód, součástí [pořadí agregate-root na eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), ukazuje příklad:</span><span class="sxs-lookup"><span data-stu-id="850d5-207">The following code, part of the [Order agregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="850d5-208">Všimněte si, že je jediné, co dělají metodu AddDomainEvent přidání události do seznamu.</span><span class="sxs-lookup"><span data-stu-id="850d5-208">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="850d5-209">Žádná událost je odeslána ještě a ještě volána žádná obslužná rutina události.</span><span class="sxs-lookup"><span data-stu-id="850d5-209">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="850d5-210">Chcete skutečně později na odeslání události při potvrzení transakce do databáze.</span><span class="sxs-lookup"><span data-stu-id="850d5-210">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="850d5-211">Pokud používáte Entity Framework Core, znamená to v metodě SaveChanges vaší EF DbContext, jako v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="850d5-211">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.        
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="850d5-212">S tímto kódem odeslání události entity k svým obslužným příslušné události.</span><span class="sxs-lookup"><span data-stu-id="850d5-212">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="850d5-213">Celkové výsledkem je, že budete mít odpojené vyvolání události domény (jednoduchou přidat do seznamu v paměti) od odeslání do obslužné rutiny události.</span><span class="sxs-lookup"><span data-stu-id="850d5-213">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="850d5-214">Kromě toho v závislosti na tom, jaký druh dispečera používáte, může odeslat události synchronně nebo asynchronně.</span><span class="sxs-lookup"><span data-stu-id="850d5-214">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="850d5-215">Mějte na paměti zde přehrání transakční hranice začalo významné.</span><span class="sxs-lookup"><span data-stu-id="850d5-215">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="850d5-216">Pokud je vaše jednotka práce a transakce může mít rozsah více než jeden agregace (stejně jako při používání jádra EF a relační databáze), to může fungovat správně.</span><span class="sxs-lookup"><span data-stu-id="850d5-216">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="850d5-217">Ale pokud transakce nelze span agregace, jako je například při použití databáze NoSQL, jako je Azure DocumentDB, je nutné implementovat další kroky k zajištění konzistence.</span><span class="sxs-lookup"><span data-stu-id="850d5-217">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="850d5-218">To je další důvod, proč trvalost které není universal; To závisí na systému úložiště, které používáte.</span><span class="sxs-lookup"><span data-stu-id="850d5-218">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="850d5-219">Jediné transakce napříč agregace versus konzistence typu případné napříč agregace</span><span class="sxs-lookup"><span data-stu-id="850d5-219">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="850d5-220">Dotaz, zda provést jediné transakce napříč agregace versus spoléhat na konzistence typu případné mezi tyto agregace je sporná.</span><span class="sxs-lookup"><span data-stu-id="850d5-220">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="850d5-221">Mnoho DDD autoři jako zařízení Evans Erica a Vaughn Vernon doporučují pravidlo této jednu transakci = jeden agregace a proto uvádějí pro konzistence typu případné napříč agregace.</span><span class="sxs-lookup"><span data-stu-id="850d5-221">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="850d5-222">Například v jeho kniha *Domain-Driven návrhu*, zařízení Erica Evans uvádí toto:</span><span class="sxs-lookup"><span data-stu-id="850d5-222">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="850d5-223">Jakékoli pravidlo, které zahrnuje agregace nebude možné očekává aktuální za všech okolností.</span><span class="sxs-lookup"><span data-stu-id="850d5-223">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="850d5-224">Prostřednictvím zpracování událostí, dávkové zpracování nebo jiných mechanismů aktualizace může být další závislosti vyřešen v určité chvíli.</span><span class="sxs-lookup"><span data-stu-id="850d5-224">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="850d5-225">(stránka 128)</span><span class="sxs-lookup"><span data-stu-id="850d5-225">(page 128)</span></span>

<span data-ttu-id="850d5-226">Vaughn Vernon uvádí následující [efektivní návrh agregace. Část II: Provádění agreguje pracovní společně](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="850d5-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="850d5-227">Proto pokud spouštění příkazu na jednom agregační instance vyžaduje, že další obchodní pravidla spustit na jeden nebo více agregace, použijte konzistence typu případné \[...\] Je praktický způsob, jak podporovat konzistence typu případné ve DDD model.</span><span class="sxs-lookup"><span data-stu-id="850d5-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="850d5-228">Agregační metoda publikuje domény událost, která je v čase se doručí na jeden nebo více asynchronní odběratele.</span><span class="sxs-lookup"><span data-stu-id="850d5-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="850d5-229">Tato odůvodnění je založena na přijetí podrobných transakce místo transakce mnoho agregace nebo entity.</span><span class="sxs-lookup"><span data-stu-id="850d5-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="850d5-230">Cílem je, že v druhém případě počtu uzamčení databáze bude výrazně v aplikace ve velkém měřítku s vysokou škálovatelnost požadavky.</span><span class="sxs-lookup"><span data-stu-id="850d5-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="850d5-231">Přijetí skutečnost, že vysoce škálovatelné aplikace potřebují nemá rychlých transakční konzistence mezi více agregace pomáhá s přijetím koncept konzistence typu případné.</span><span class="sxs-lookup"><span data-stu-id="850d5-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="850d5-232">Atomic firmy často není potřebné změny, a je v žádném případě odpovědnost domény odborníků. Tím vyjádříte, jestli konkrétní operace musí jednotlivé transakce, nebo ne.</span><span class="sxs-lookup"><span data-stu-id="850d5-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="850d5-233">Pokud operace vždy potřebuje transakcích mezi více agregace, může požádat, jestli vaše agregace musí být větší nebo nebyl navržen správně.</span><span class="sxs-lookup"><span data-stu-id="850d5-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="850d5-234">Ostatní vývojáři a architektům jako Jimmy Bogard jsou však nevadí pokrývání uzlů jediné transakce napříč několika agregace – ale jenom, když jsou tyto další agregace relaci k vedlejší účinky pro stejný původní příkaz.</span><span class="sxs-lookup"><span data-stu-id="850d5-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="850d5-235">Například v [lepší vzor události domény](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard uvádí toto:</span><span class="sxs-lookup"><span data-stu-id="850d5-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="850d5-236">Obvykle chci vedlejší účinky domény události dochází v rámci stejné logické transakci, ale nemusí nutně jít ve stejném oboru z vyvolá událost domény \[...\] Těsně před jsme potvrzení naše transakce, jsme dispatch naše události na jejich odpovídající obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="850d5-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="850d5-237">Pokud dispatch právo události domény *před* potvrzování původní transakce, je to proto, chcete-li vedlejší účinky těchto událostí, které mají být zahrnuty ve stejné transakci.</span><span class="sxs-lookup"><span data-stu-id="850d5-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="850d5-238">Například pokud metoda EF DbContext SaveChanges selže, transakce se vrátit zpět všechny změny, včetně výsledek žádné vedlejším účinkem operace implementované obslužné rutiny událostí související domény.</span><span class="sxs-lookup"><span data-stu-id="850d5-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="850d5-239">To je protože oboru životnosti DbContext je ve výchozím nastavení definovaný jako "vymezen."</span><span class="sxs-lookup"><span data-stu-id="850d5-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="850d5-240">Proto je objekt DbContext sdílet mezi více objektů úložiště vytváření instancí v rámci stejného oboru nebo grafu objektu.</span><span class="sxs-lookup"><span data-stu-id="850d5-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="850d5-241">To se shoduje s oboru požadavku HTTP při vývoji aplikace webového rozhraní API nebo MVC.</span><span class="sxs-lookup"><span data-stu-id="850d5-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="850d5-242">Ve skutečnosti může být správné obou přístupů (jedné atomic transakce a konzistence typu případné).</span><span class="sxs-lookup"><span data-stu-id="850d5-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="850d5-243">Ve skutečnosti závisí na vaší domény nebo organizační požadavky a co se odborníka domény zjistíte.</span><span class="sxs-lookup"><span data-stu-id="850d5-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="850d5-244">Také závisí na tom, jak škálovatelné musí až bude služba (podrobnější transakce mají menší dopad s ohledem na uzamčení databáze).</span><span class="sxs-lookup"><span data-stu-id="850d5-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="850d5-245">A závisí na tom, kolik investice jste ochotni proveďte v kódu, protože konzistence typu případné vyžaduje složitější kód zjistit možné nekonzistence mezi agregace a není nutné k implementaci vyrovnávací akce.</span><span class="sxs-lookup"><span data-stu-id="850d5-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="850d5-246">Vezměte v úvahu, že pokud provedete změny původní agregace a později, když jsou události distribuovanou, nastane problém a obslužné rutiny událostí nelze potvrdit jejich vedlejší účinky, budete mít nekonzistence mezi agregace.</span><span class="sxs-lookup"><span data-stu-id="850d5-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="850d5-247">Způsob, jak povolit vyrovnávací akce by k uložení událostí domény v tabulkách další databáze, aby mohly být součástí původní transakce.</span><span class="sxs-lookup"><span data-stu-id="850d5-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="850d5-248">Později může mít batch proces, který zjistí nekonzistence a spustí vyrovnávací akce tak, že porovnáte seznam událostí s aktuálním stavem agregací.</span><span class="sxs-lookup"><span data-stu-id="850d5-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="850d5-249">Vyrovnávací akce, které jsou součástí komplexní téma, které bude vyžadovat hloubkovou analýzu z vaší strany, včetně diskuse s business uživatelů a domény odborníky.</span><span class="sxs-lookup"><span data-stu-id="850d5-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="850d5-250">V každém případě můžete přístupů, které potřebujete.</span><span class="sxs-lookup"><span data-stu-id="850d5-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="850d5-251">Počáteční odložení přístup, ale – vyvolání události před potvrzením, takže můžete použít jen jednu transakci – je nejjednodušším přístupem při použití EF jádra a relační databáze.</span><span class="sxs-lookup"><span data-stu-id="850d5-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="850d5-252">Je usnadnil a v mnoha případech firmy.</span><span class="sxs-lookup"><span data-stu-id="850d5-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="850d5-253">Je také metoda používaná v řazení mikroslužbu v eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="850d5-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="850d5-254">Ale jak je ve skutečnosti odeslání události, k jejich obslužné rutiny událostí odpovídajících?</span><span class="sxs-lookup"><span data-stu-id="850d5-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="850d5-255">Co je \_zprostředkovatel objekt, který se zobrazí v předchozím příkladu?</span><span class="sxs-lookup"><span data-stu-id="850d5-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="850d5-256">Který má dělat s technik a artefaktů, které můžete použít pro mapování mezi událostí a jejich obslužných rutin.</span><span class="sxs-lookup"><span data-stu-id="850d5-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="850d5-257">Dispečer událostí domény: mapování z událostí na obslužné rutiny událostí</span><span class="sxs-lookup"><span data-stu-id="850d5-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="850d5-258">Jakmile budete moct odeslat nebo publikovat události, je nutné nějaký druh artefaktů, která bude publikovat události, tak, aby každý související rutiny můžete ho získat a zpracovat vedlejší účinky na základě této události.</span><span class="sxs-lookup"><span data-stu-id="850d5-258">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="850d5-259">Jeden z přístupů je skutečně zasílání zpráv systému nebo i událostí sběrnici, případně založená na služby service bus a události v paměti.</span><span class="sxs-lookup"><span data-stu-id="850d5-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="850d5-260">Pro první případ skutečných zasílání zpráv by však bylo přehnaně pro zpracování události domény, protože stačí ke zpracování těchto událostí v rámci stejného procesu (to znamená, v rámci stejné vrstvě domény a aplikace).</span><span class="sxs-lookup"><span data-stu-id="850d5-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="850d5-261">Dalším způsobem se mapují události do více obslužných rutin událostí je prostřednictvím registrace typy v kontejner IoC, takže můžete dynamicky odvození kde odeslání události.</span><span class="sxs-lookup"><span data-stu-id="850d5-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="850d5-262">Jinými slovy budete muset vědět, jaké obslužné rutiny událostí je potřeba získat konkrétní události.</span><span class="sxs-lookup"><span data-stu-id="850d5-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="850d5-263">Obrázek 9 až 16 ukazuje zjednodušený přístup k této.</span><span class="sxs-lookup"><span data-stu-id="850d5-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="850d5-264">**Obrázek 9 až 16**.</span><span class="sxs-lookup"><span data-stu-id="850d5-264">**Figure 9-16**.</span></span> <span data-ttu-id="850d5-265">Dispečer událostí domény pomocí technologie IoC</span><span class="sxs-lookup"><span data-stu-id="850d5-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="850d5-266">Můžete vytvořit všechny vložení a artefaktů k implementaci tohoto přístupu podle sami.</span><span class="sxs-lookup"><span data-stu-id="850d5-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="850d5-267">Však můžete použít také k dispozici knihovny jako [MediatR](https://github.com/jbogard/MediatR), který pod pozadí používá vaše kontejner IoC.</span><span class="sxs-lookup"><span data-stu-id="850d5-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoC container.</span></span> <span data-ttu-id="850d5-268">Proto přímo můžete vytvořit předdefinované rozhraní a metody publikování nebo odeslání objekt zprostředkovatel.</span><span class="sxs-lookup"><span data-stu-id="850d5-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="850d5-269">V kódu, je nutné nejprve zaregistrovat typy obslužných rutin událostí v vaší kontejner IoC, jak je znázorněno v následujícím příkladu v [eShopOnContainers řazení mikroslužbu](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="850d5-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="850d5-270">Kód nejprve identifikuje sestavení, které obsahuje obslužné rutiny událostí domény tím, že je sestavení, které obsahuje všechny obslužné rutiny (pomocí typeof(ValidateOrAddBuyerAggregateWhenXxxx), ale by vybrány žádné jiné obslužné rutiny události k nalezení sestavení).</span><span class="sxs-lookup"><span data-stu-id="850d5-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="850d5-271">Vzhledem k tomu, že všechny obslužné rutiny událostí implementovat rozhraní IAsyncNotificationHandler, kód pak vyhledá jenom ty typy a zaregistruje všechny obslužné rutiny událostí.</span><span class="sxs-lookup"><span data-stu-id="850d5-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="850d5-272">Tom, jak se přihlásit k odběru událostí domény</span><span class="sxs-lookup"><span data-stu-id="850d5-272">How to subscribe to domain events</span></span>

<span data-ttu-id="850d5-273">Při použití MediatR každý obslužné rutiny události musí používat typ události, který je k dispozici na obecný parametr INotificationHandler rozhraní, jak můžete vidět v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="850d5-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="850d5-274">Na základě vztahu mezi událostí a obslužná rutina události, která lze považovat za předplatné, artefaktů MediatR zjistit všechny obslužné rutiny události pro všechny události a aktivuje každý z těchto obslužných rutin událostí.</span><span class="sxs-lookup"><span data-stu-id="850d5-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="850d5-275">Postupy: zpracování události domény</span><span class="sxs-lookup"><span data-stu-id="850d5-275">How to handle domain events</span></span>

<span data-ttu-id="850d5-276">Nakonec obslužné rutiny události obvykle implementuje aplikační vrstvy kód, který používá infrastrukturu úložiště získat požadovaná další agregace a provést logiku domény vedlejším účinkem.</span><span class="sxs-lookup"><span data-stu-id="850d5-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="850d5-277">Následující [domény kód obslužné rutiny událostí v eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), ukazuje příklad implementace.</span><span class="sxs-lookup"><span data-stu-id="850d5-277">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;        
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) 
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="850d5-278">Předchozí kód obslužné rutiny událostí domény považuje za vrstvy kódu aplikace protože ji používá infrastrukturu úložiště, jak je vysvětleno v další části na vrstvě infrastruktury trvalost.</span><span class="sxs-lookup"><span data-stu-id="850d5-278">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="850d5-279">Obslužné rutiny událostí může také použít další součásti infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="850d5-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="850d5-280">Události domény může generovat události integrace publikována mimo hranice mikroslužbu</span><span class="sxs-lookup"><span data-stu-id="850d5-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="850d5-281">Nakonec je důležité zmínili, může někdy chcete rozšíří události na více mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="850d5-281">Finally, it is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="850d5-282">Který považuje za událost integrace a může být publikován přes sběrnici událostí z obslužné rutiny události žádné konkrétní doméně.</span><span class="sxs-lookup"><span data-stu-id="850d5-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="850d5-283">Závěrů na události domény</span><span class="sxs-lookup"><span data-stu-id="850d5-283">Conclusions on domain events</span></span>

<span data-ttu-id="850d5-284">Jak jsme uvedli, pomocí události domény explicitní implementace vedlejší účinky změn ve vaší doméně.</span><span class="sxs-lookup"><span data-stu-id="850d5-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="850d5-285">Terminologie DDD, použití události domény explicitně implementovat vedlejší účinky přes jeden nebo více agregace.</span><span class="sxs-lookup"><span data-stu-id="850d5-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="850d5-286">Kromě toho a lepší škálovatelnost a menší dopad na uzamčení databáze použijte konzistence typu případné mezi agregace ve stejné doméně.</span><span class="sxs-lookup"><span data-stu-id="850d5-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="850d5-287">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="850d5-287">Additional resources</span></span>

-   <span data-ttu-id="850d5-288">**Gregu Young. Co je událost domény?**
    [*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="850d5-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="850d5-289">**Jan Stenberg. Události domény a konzistence typu případné**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="850d5-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="850d5-290">**Jimmy Bogard. Lepší vzor události domény**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="850d5-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="850d5-291">**Vaughn Vernon. Efektivní agregační návrhu část II: Provedení agregace pracovní společně**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_články/Vernon\_2011\_2. pdf*](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="850d5-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="850d5-292">**Jimmy Bogard. Posílení vaší domény: domény události**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span><span class="sxs-lookup"><span data-stu-id="850d5-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="850d5-293">**ADAM Truong. Příklad vzoru události domény**
    [*https://www.tonytruong.net/domain-events-pattern-example/*](https://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="850d5-293">**Tony Truong. Domain Events Pattern Example**
[*https://www.tonytruong.net/domain-events-pattern-example/*](https://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="850d5-294">**Udi Dahan. Postup vytvoření plně zapouzdřené domény modely**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="850d5-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="850d5-295">**Udi Dahan. Události domény – trvat 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="850d5-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="850d5-296">**Udi Dahan. Události domény – Salvation**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="850d5-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="850d5-297">**Jan Kronquist. Nemáte publikovat události domény, obnoví v nich!**
    [*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="850d5-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="850d5-298">**Cesaru členka Torre. Domény události vs. Integrace události v případě architektur se DDD a mikroslužeb**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="850d5-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="850d5-299">[Předchozí] (klient straně validation.md) [Další] (infrastruktury trvalost layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="850d5-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
