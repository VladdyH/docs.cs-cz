---
title: "Seskupovací konstrukce v regulárních výrazech"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
caps.latest.revision: "33"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 37428cf96bbe36a55e88edeb5ec56e09895be994
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/21/2017
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="d1a51-102">Seskupovací konstrukce v regulárních výrazech</span><span class="sxs-lookup"><span data-stu-id="d1a51-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="d1a51-103">Seskupovací konstrukce vymezují podvýrazy regulární výraz a zachycení podřetězce vstupní řetězce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="d1a51-104">Seskupovací konstrukce můžete provést následující akce:</span><span class="sxs-lookup"><span data-stu-id="d1a51-104">You can use grouping constructs to do the following:</span></span>  
  
-   <span data-ttu-id="d1a51-105">Odpovídat dílčím výrazu, který se opakuje ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-105">Match a subexpression that is repeated in the input string.</span></span>  
  
-   <span data-ttu-id="d1a51-106">Použití kvantifikátoru na dílčím výrazu, který má více prvků jazyka regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="d1a51-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="d1a51-107">Další informace o kvantifikátory najdete v tématu [kvantifikátory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d1a51-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="d1a51-108">Zahrnout dílčím výrazu řetězec, který je vrácený <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> a <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="d1a51-109">Načíst jednotlivé podvýrazy z <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> vlastnost a zpracovat je odděleně od odpovídajícího textu jako celek.</span><span class="sxs-lookup"><span data-stu-id="d1a51-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="d1a51-110">Následující tabulka uvádí seskupovací konstrukce nepodporuje modul regulárních výrazů .NET a určuje, zda jsou zaznamenání nebo jiných zachycení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="d1a51-111">Seskupovací konstrukce</span><span class="sxs-lookup"><span data-stu-id="d1a51-111">Grouping construct</span></span>|<span data-ttu-id="d1a51-112">Zaznamenávání nebo bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="d1a51-113">Podvýrazy</span><span class="sxs-lookup"><span data-stu-id="d1a51-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="d1a51-114">Zaznamenání</span><span class="sxs-lookup"><span data-stu-id="d1a51-114">Capturing</span></span>|  
|[<span data-ttu-id="d1a51-115">S názvem podvýrazy</span><span class="sxs-lookup"><span data-stu-id="d1a51-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="d1a51-116">Zaznamenání</span><span class="sxs-lookup"><span data-stu-id="d1a51-116">Capturing</span></span>|  
|[<span data-ttu-id="d1a51-117">Vyrovnávání definice skupin</span><span class="sxs-lookup"><span data-stu-id="d1a51-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="d1a51-118">Zaznamenání</span><span class="sxs-lookup"><span data-stu-id="d1a51-118">Capturing</span></span>|  
|[<span data-ttu-id="d1a51-119">Skupiny bez zachytávání</span><span class="sxs-lookup"><span data-stu-id="d1a51-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="d1a51-120">Bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-120">Noncapturing</span></span>|  
|[<span data-ttu-id="d1a51-121">Možnosti pro skupiny</span><span class="sxs-lookup"><span data-stu-id="d1a51-121">Group options</span></span>](#group_options)|<span data-ttu-id="d1a51-122">Bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-122">Noncapturing</span></span>|  
|[<span data-ttu-id="d1a51-123">Kontrolní výrazy s nulovou šířkou kladné dopředným vyhledáváním</span><span class="sxs-lookup"><span data-stu-id="d1a51-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="d1a51-124">Bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-124">Noncapturing</span></span>|  
|[<span data-ttu-id="d1a51-125">Kontrolní výrazy s nulovou šířkou záporné dopředným vyhledáváním</span><span class="sxs-lookup"><span data-stu-id="d1a51-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="d1a51-126">Bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-126">Noncapturing</span></span>|  
|[<span data-ttu-id="d1a51-127">Kontrolní výrazy kladné zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="d1a51-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="d1a51-128">Bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-128">Noncapturing</span></span>|  
|[<span data-ttu-id="d1a51-129">Kontrolní výrazy negativního zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="d1a51-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="d1a51-130">Bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-130">Noncapturing</span></span>|  
|[<span data-ttu-id="d1a51-131">Bez mechanismu navrácení podvýrazy</span><span class="sxs-lookup"><span data-stu-id="d1a51-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="d1a51-132">Bez zachycení</span><span class="sxs-lookup"><span data-stu-id="d1a51-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="d1a51-133">Informace o skupinách a model objektu regulárního výrazu, najdete v části [seskupovací konstrukce a objekty regulární výraz](#Objects).</span><span class="sxs-lookup"><span data-stu-id="d1a51-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="d1a51-134">Podvýrazy</span><span class="sxs-lookup"><span data-stu-id="d1a51-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="d1a51-135">Následující seskupovací konstrukce zaznamená odpovídající dílčím výrazu:</span><span class="sxs-lookup"><span data-stu-id="d1a51-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="d1a51-136">`(`*dílčím výrazu*`)`</span><span class="sxs-lookup"><span data-stu-id="d1a51-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="d1a51-137">kde *dílčím výrazu* je libovolný vzor platný regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="d1a51-138">Zaznamená, že používají závorky jsou automaticky číslována zleva doprava na základě pořadí počáteční závorky v regulárním výrazu, od jednoho.</span><span class="sxs-lookup"><span data-stu-id="d1a51-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="d1a51-139">Zachycení, které je číslem nula je text odpovídající celý regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d1a51-140">Ve výchozím nastavení `(` *dílčím výrazu* `)` jazyk element zaznamená odpovídající dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="d1a51-141">Avšak v tom případě <xref:System.Text.RegularExpressions.RegexOptions> parametr vzor regulárního výrazu odpovídající metoda obsahuje <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> příznak, nebo, pokud `n` pro tento dílčím výrazu použije možnost (najdete v části [skupiny možnosti](#group_options) dál v tomto tématu), není zaznamenaná odpovídající dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="d1a51-142">Můžete získat přístup k zaznamenané skupinám čtyři způsoby:</span><span class="sxs-lookup"><span data-stu-id="d1a51-142">You can access captured groups in four ways:</span></span>  
  
-   <span data-ttu-id="d1a51-143">Pomocí zpětných odkazů vytvořte v rámci regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="d1a51-144">Odpovídající dílčím výrazu je odkazován ve stejném regulárního výrazu pomocí syntaxe `\` *číslo*, kde *číslo* je řadová číslovka zaznamenané dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="d1a51-145">Pomocí pojmenovaného zpětných odkazů vytvořte v rámci regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="d1a51-146">Odpovídající dílčím výrazu je odkazován ve stejném regulárního výrazu pomocí syntaxe `\k<` *název*`>`, kde *název* je název zachycené skupiny, nebo `\k<` *číslo*`>`, kde *číslo* je řadová číslovka zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="d1a51-147">Zaznamenávání skupina má výchozí název, který je stejný jako jeho řadová číslovka.</span><span class="sxs-lookup"><span data-stu-id="d1a51-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="d1a51-148">Další informace najdete v tématu [pojmenované odpovídající podvýrazy](#named_matched_subexpression) dál v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
-   <span data-ttu-id="d1a51-149">Pomocí `$` *číslo* nahrazení pořadí v <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> nebo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> volání metody, kde *číslo* je řadová číslovka zaznamenané dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="d1a51-150">Programově pomocí <xref:System.Text.RegularExpressions.GroupCollection> objekt vrácený <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d1a51-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d1a51-151">Člen na pozici nula v kolekci představuje celý regulární výraz text.</span><span class="sxs-lookup"><span data-stu-id="d1a51-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="d1a51-152">Každý následující člen představuje odpovídající dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="d1a51-153">Další informace najdete v tématu [vytvoří seskupení a regulární výraz objekty](#Objects) části.</span><span class="sxs-lookup"><span data-stu-id="d1a51-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="d1a51-154">Následující příklad ukazuje regulární výraz, který identifikuje duplicitní slova v textu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="d1a51-155">Vzor regulárního výrazu dvě zaznamenávání skupiny představují dvě instance duplicitní slovo.</span><span class="sxs-lookup"><span data-stu-id="d1a51-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="d1a51-156">Druhou instanci se zaznamená do sestavy jeho počáteční pozice ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="d1a51-157">Regulární výraz je následující:</span><span class="sxs-lookup"><span data-stu-id="d1a51-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="d1a51-158">Následující tabulka ukazuje, jak interpretovat regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="d1a51-159">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-159">Pattern</span></span>|<span data-ttu-id="d1a51-160">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="d1a51-161">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-161">Match one or more word characters.</span></span> <span data-ttu-id="d1a51-162">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="d1a51-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="d1a51-163">Porovná prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="d1a51-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="d1a51-164">Porovná řetězec v první zaznamenané skupinu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-164">Match the string in the first captured group.</span></span> <span data-ttu-id="d1a51-165">Toto je druhá zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="d1a51-165">This is the second capturing group.</span></span> <span data-ttu-id="d1a51-166">Příklad přiřadí ji k zaznamenané skupiny tak, aby počáteční pozici duplicitní aplikace word se dá načíst z `Match.Index` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d1a51-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="d1a51-167">Porovná znak aplikace word, včetně mezer a interpunkce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="d1a51-168">Regulární výraz zabrání odpovídající aplikace word, který začíná slovem z první zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="d1a51-169">S názvem podvýrazy</span><span class="sxs-lookup"><span data-stu-id="d1a51-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="d1a51-170">Následující seskupovací konstrukce zaznamená odpovídající dílčím výrazu a umožňuje přístup pomocí názvu nebo podle čísla:</span><span class="sxs-lookup"><span data-stu-id="d1a51-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="d1a51-171">nebo:</span><span class="sxs-lookup"><span data-stu-id="d1a51-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="d1a51-172">kde *název* je název skupiny platný, a *dílčím výrazu* je libovolný vzor platný regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="d1a51-173">*název* nesmí obsahovat znaky interpunkce a nesmí začínat číslem.</span><span class="sxs-lookup"><span data-stu-id="d1a51-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d1a51-174">Pokud <xref:System.Text.RegularExpressions.RegexOptions> parametr vzor regulárního výrazu odpovídající metoda zahrnuje <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> příznak, nebo pokud `n` pro tento dílčím výrazu použije možnost (najdete v části [skupiny možnosti](#group_options) dál v tomto tématu), jediný způsob, jak zachytit dílčím výrazu je explicitně název skupiny zachycení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="d1a51-175">Pojmenované zachycené skupiny se můžete dostat následujícími způsoby:</span><span class="sxs-lookup"><span data-stu-id="d1a51-175">You can access named captured groups in the following ways:</span></span>  
  
-   <span data-ttu-id="d1a51-176">Pomocí pojmenovaného zpětných odkazů vytvořte v rámci regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="d1a51-177">Odpovídající dílčím výrazu je odkazován ve stejném regulárního výrazu pomocí syntaxe `\k<` *název*`>`, kde *název* je název zaznamenané dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="d1a51-178">Pomocí zpětných odkazů vytvořte v rámci regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="d1a51-179">Odpovídající dílčím výrazu je odkazován ve stejném regulárního výrazu pomocí syntaxe `\` *číslo*, kde *číslo* je řadová číslovka zaznamenané dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="d1a51-180">Pojmenované podvýrazy jsou číslována za sebou zleva doprava po podvýrazy.</span><span class="sxs-lookup"><span data-stu-id="d1a51-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
-   <span data-ttu-id="d1a51-181">Pomocí `${` *název* `}` nahrazení pořadí v <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> nebo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> volání metody, kde *název* je název zaznamenané dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="d1a51-182">Pomocí `$` *číslo* nahrazení pořadí v <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> nebo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> volání metody, kde *číslo* je řadová číslovka zaznamenané dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="d1a51-183">Programově pomocí <xref:System.Text.RegularExpressions.GroupCollection> objekt vrácený <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d1a51-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d1a51-184">Člen na pozici nula v kolekci představuje celý regulární výraz text.</span><span class="sxs-lookup"><span data-stu-id="d1a51-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="d1a51-185">Každý následující člen představuje odpovídající dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="d1a51-186">Pojmenované zachycené skupiny jsou uloženy v kolekci po číslovaných zachycených skupinách.</span><span class="sxs-lookup"><span data-stu-id="d1a51-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
-   <span data-ttu-id="d1a51-187">Prostřednictvím kódu programu, tím, že poskytuje název dílčím výrazu, který má <xref:System.Text.RegularExpressions.GroupCollection> indexeru objektu (v jazyku C#) nebo jeho <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> vlastnost (v jazyce Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d1a51-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="d1a51-188">Jednoduché regulárního výrazu ukazuje, jak číslované (bez názvu) a s názvem skupiny může být odkazováno buď programově, nebo pomocí syntaxe jazyka regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="d1a51-189">Regulární výraz `((?<One>abc)\d+)?(?<Two>xyz)(.*)` vytváří následující zaznamenávání seskupeny podle čísla a podle názvu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="d1a51-190">První vždy zaznamenávání skupiny (číslo 0) odkazuje na celý vzor.</span><span class="sxs-lookup"><span data-stu-id="d1a51-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="d1a51-191">Číslo</span><span class="sxs-lookup"><span data-stu-id="d1a51-191">Number</span></span>|<span data-ttu-id="d1a51-192">Název</span><span class="sxs-lookup"><span data-stu-id="d1a51-192">Name</span></span>|<span data-ttu-id="d1a51-193">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="d1a51-194">0</span><span class="sxs-lookup"><span data-stu-id="d1a51-194">0</span></span>|<span data-ttu-id="d1a51-195">0 (výchozí název)</span><span class="sxs-lookup"><span data-stu-id="d1a51-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="d1a51-196">1</span><span class="sxs-lookup"><span data-stu-id="d1a51-196">1</span></span>|<span data-ttu-id="d1a51-197">1 (výchozí název)</span><span class="sxs-lookup"><span data-stu-id="d1a51-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="d1a51-198">2</span><span class="sxs-lookup"><span data-stu-id="d1a51-198">2</span></span>|<span data-ttu-id="d1a51-199">2 (výchozí název)</span><span class="sxs-lookup"><span data-stu-id="d1a51-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="d1a51-200">3</span><span class="sxs-lookup"><span data-stu-id="d1a51-200">3</span></span>|<span data-ttu-id="d1a51-201">Jeden</span><span class="sxs-lookup"><span data-stu-id="d1a51-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="d1a51-202">4</span><span class="sxs-lookup"><span data-stu-id="d1a51-202">4</span></span>|<span data-ttu-id="d1a51-203">dvě</span><span class="sxs-lookup"><span data-stu-id="d1a51-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="d1a51-204">Následující příklad ukazuje regulární výraz, který identifikuje duplicitní slova a Wordu, který následuje jednotlivých slov duplicitní.</span><span class="sxs-lookup"><span data-stu-id="d1a51-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="d1a51-205">Regulární výraz definuje dva pojmenované podvýrazy: `duplicateWord`, která představuje duplicitní slovo; a `nextWord`, která představuje slovo následující duplicitní slovo.</span><span class="sxs-lookup"><span data-stu-id="d1a51-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="d1a51-206">Regulární výraz je následující:</span><span class="sxs-lookup"><span data-stu-id="d1a51-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="d1a51-207">Následující tabulka ukazuje, jak interpretovat regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="d1a51-208">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-208">Pattern</span></span>|<span data-ttu-id="d1a51-209">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="d1a51-210">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-210">Match one or more word characters.</span></span> <span data-ttu-id="d1a51-211">Název této skupiny zaznamenávání `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="d1a51-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="d1a51-212">Porovná prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="d1a51-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="d1a51-213">Shoda s řetězcem z zaznamenané skupiny, který je pojmenován `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="d1a51-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="d1a51-214">Porovná znak aplikace word, včetně mezer a interpunkce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="d1a51-215">Regulární výraz zabrání odpovídající aplikace word, který začíná slovem z první zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="d1a51-216">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-216">Match one or more word characters.</span></span> <span data-ttu-id="d1a51-217">Název této skupiny zaznamenávání `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="d1a51-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="d1a51-218">Všimněte si, že název skupiny můžete opakovat v regulárním výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="d1a51-219">Například je možné pro více než jednu skupinu s názvem `digit`, jak ukazuje následující příklad.</span><span class="sxs-lookup"><span data-stu-id="d1a51-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="d1a51-220">V případě duplicitní názvy, hodnota <xref:System.Text.RegularExpressions.Group> objektu je dáno poslední úspěšné zachycení ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="d1a51-221">Kromě toho <xref:System.Text.RegularExpressions.CaptureCollection> se zobrazí informace o jednotlivých zachycení v stejně, jako by bylo, pokud nebyla duplicitní název skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="d1a51-222">V následujícím příkladu, regulární výraz `\D+(?<digit>\d+)\D+(?<digit>\d+)?` obsahuje dva výskyty skupinu s názvem `digit`.</span><span class="sxs-lookup"><span data-stu-id="d1a51-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="d1a51-223">První `digit` s názvem skupiny zachycení jeden nebo více znaků, číslic.</span><span class="sxs-lookup"><span data-stu-id="d1a51-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="d1a51-224">Druhý `digit` pojmenovanou skupinu zaznamená buď nula nebo jeden výskyt jeden nebo více znaků, číslic.</span><span class="sxs-lookup"><span data-stu-id="d1a51-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="d1a51-225">Jako výstup ukazuje příklad, pokud druhý zaznamenávání skupiny úspěšně odpovídá textu, hodnota tohoto textu definuje hodnotu <xref:System.Text.RegularExpressions.Group> objektu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="d1a51-226">Pokud nelze druhé zachytávající skupině neodpovídá vstupní řetězec, hodnota poslední úspěšné shodě definuje hodnotu <xref:System.Text.RegularExpressions.Group> objektu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="d1a51-227">Následující tabulka ukazuje, jak interpretovat regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="d1a51-228">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-228">Pattern</span></span>|<span data-ttu-id="d1a51-229">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="d1a51-230">Porovná jeden nebo více znaků není desítková číslice.</span><span class="sxs-lookup"><span data-stu-id="d1a51-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="d1a51-231">Porovná jeden nebo více znaků desítková číslice.</span><span class="sxs-lookup"><span data-stu-id="d1a51-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="d1a51-232">Shoda pro přiřazení `digit` s názvem skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-232">Assign the match to the `digit` named group.</span></span>|  
|<span data-ttu-id="d1a51-233">\D+</span><span class="sxs-lookup"><span data-stu-id="d1a51-233">\D+</span></span>|<span data-ttu-id="d1a51-234">Porovná jeden nebo více znaků není desítková číslice.</span><span class="sxs-lookup"><span data-stu-id="d1a51-234">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="d1a51-235">Porovná nula nebo jeden výskyt jeden nebo více znaků desítková číslice.</span><span class="sxs-lookup"><span data-stu-id="d1a51-235">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="d1a51-236">Shoda pro přiřazení `digit` s názvem skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-236">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="d1a51-237">Vyrovnávání definice skupin</span><span class="sxs-lookup"><span data-stu-id="d1a51-237">Balancing Group Definitions</span></span>  
 <span data-ttu-id="d1a51-238">Vyrovnávání definice skupiny odstraní definici dříve definované skupiny a úložiště v aktuální skupině, interval mezi dříve definované skupiny a aktuální skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-238">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="d1a51-239">Tato seskupovací konstrukce má následující formát:</span><span class="sxs-lookup"><span data-stu-id="d1a51-239">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="d1a51-240">nebo:</span><span class="sxs-lookup"><span data-stu-id="d1a51-240">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="d1a51-241">kde *name1* je daná skupina (volitelné), *name2* je dříve definovaný skupina, a *dílčím výrazu* je libovolný vzor platný regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-241">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="d1a51-242">Seskupovací definice odstraní definici *name2* a uloží interval mezi *name2* a *name1* v *name1*.</span><span class="sxs-lookup"><span data-stu-id="d1a51-242">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="d1a51-243">Pokud žádné *name2* skupina je definována, provede krok zpět na shodu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-243">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="d1a51-244">Protože odstranění poslední definice *name2* ukáže předchozí definici *name2*, tato konstrukce umožňuje použití zásobníku zachycení pro skupinu *name2* jako Čítač pro udržování přehledu o vnořené konstruktory, jako jsou závorky nebo levé a pravé závorky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-244">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="d1a51-245">Seskupovací definice používá *name2* jako zásobník.</span><span class="sxs-lookup"><span data-stu-id="d1a51-245">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="d1a51-246">Počáteční znak jednotlivých vnořených konstrukcí je umístěn ve skupině a v jeho <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-246">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="d1a51-247">Pokud je nalezena shoda ukončovací znak, jeho odpovídající počáteční znak je odebrán ze skupiny a <xref:System.Text.RegularExpressions.Group.Captures%2A> kolekce je snížila o jednu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-247">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="d1a51-248">Po počátečních a koncových znaků všech vnořených konstrukcí, *name1* je prázdný.</span><span class="sxs-lookup"><span data-stu-id="d1a51-248">After the opening and closing characters of all nested constructs have been matched, *name1* is empty.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d1a51-249">Po úpravě regulárnímu výrazu v následujícím příkladu k použití vhodného počátečního a koncového znaku vnořené konstrukce, můžete ji použít pro zpracování nejvíce vnořené konstrukce, jako je například matematické výrazy nebo řádky kódu programu, které obsahují více vnořených volání metod.</span><span class="sxs-lookup"><span data-stu-id="d1a51-249">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="d1a51-250">Následující příklad používá vyrovnávání definice skupiny tak, aby odpovídaly v levém horním a pravém úhlu závorky (<>) ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-250">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="d1a51-251">V příkladu jsou definovány dvě skupiny s názvem `Open` a `Close`, které se používají jako zásobníky pro sledování odpovídající dvojice ostrých závorek.</span><span class="sxs-lookup"><span data-stu-id="d1a51-251">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="d1a51-252">Každý zaznamenané levou hranatou závorku je vložena do kolekce zachycení `Open` skupiny a každý zaznamenané pravém úhlu závorka je vložena do kolekce zachycení `Close` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-252">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="d1a51-253">Seskupovací definice zajišťuje, že odpovídající práva lomená závorka pro každou levou hranatou závorku.</span><span class="sxs-lookup"><span data-stu-id="d1a51-253">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="d1a51-254">Pokud není k dispozici, konečný dílčí vzor `(?(Open)(?!))`, vyhodnotí pouze v případě `Open` není prázdná (a tedy bylo ukončeno Pokud všechny vnořené konstrukce).</span><span class="sxs-lookup"><span data-stu-id="d1a51-254">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="d1a51-255">Pokud vyhodnotí konečný dílčí vzor shody selže, protože `(?!)` dílčí vzor je negativního nulovou šířkou dopředného vyhledávání, který vždycky selže.</span><span class="sxs-lookup"><span data-stu-id="d1a51-255">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="d1a51-256">Regulární výraz je:</span><span class="sxs-lookup"><span data-stu-id="d1a51-256">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="d1a51-257">Regulární výraz je interpretována takto:</span><span class="sxs-lookup"><span data-stu-id="d1a51-257">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="d1a51-258">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-258">Pattern</span></span>|<span data-ttu-id="d1a51-259">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-259">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="d1a51-260">Začít na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-260">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="d1a51-261">Odpovídat nula nebo více znaků, které nejsou doleva nebo doprava úhel závorky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-261">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="d1a51-262">Odpovídající levou hranatou závorku a přiřaďte ho do skupiny s názvem `Open`.</span><span class="sxs-lookup"><span data-stu-id="d1a51-262">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="d1a51-263">Odpovídat nula nebo více znaků, které nejsou doleva nebo doprava úhel závorky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-263">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*) +`|<span data-ttu-id="d1a51-264">Porovná jeden nebo více výskytů levou hranatou závorku následované nula nebo více znaků, které nejsou doleva nebo doprava úhel závorky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-264">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="d1a51-265">Toto je druhá zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="d1a51-265">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="d1a51-266">Shodují pravé ostré závorky, přiřadí podřetězec mezi `Open` skupinu a na aktuální skupinu `Close` skupiny a odstranit definici `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-266">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="d1a51-267">Porovná nula nebo více výskytů libovolný znak, který není pravé ostré závorky ani levé straně.</span><span class="sxs-lookup"><span data-stu-id="d1a51-267">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="d1a51-268">Porovná jeden nebo více výskytů pravé ostré závorky, za nímž následuje nula nebo více výskytů libovolný znak, který není levou ani vpravo lomená závorka.</span><span class="sxs-lookup"><span data-stu-id="d1a51-268">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="d1a51-269">Při porovnání pravé ostré závorky, přiřadí podřetězec mezi `Open` skupinu a na aktuální skupinu `Close` skupiny a odstranit definici `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-269">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="d1a51-270">Toto je třetí zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="d1a51-270">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="d1a51-271">Porovná nula nebo více výskytů následující vzor: jeden nebo více výskytů levou hranatou závorku, za nímž následuje nula nebo více znaků lomená závorka, za nímž následuje jeden nebo více výskytů pravé ostré závorky, za nímž následuje nula nebo více výskytů není lomené závorky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-271">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="d1a51-272">Při porovnání pravé ostré závorky, odstranit definici `Open` a přiřadí podřetězec mezi `Open` skupinu a na aktuální skupinu `Close` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-272">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="d1a51-273">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="d1a51-273">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="d1a51-274">Pokud `Open` skupina existuje, zrušte shody, pokud je možné přiřadit prázdný řetězec, ale není posunutí pozice modul regulárních výrazů v řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-274">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="d1a51-275">Toto je nulovou šířkou záporné dopředného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-275">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="d1a51-276">Protože prázdný řetězec se vždy implicitně nachází ve vstupní řetězec, toto porovnání se vždy nezdaří.</span><span class="sxs-lookup"><span data-stu-id="d1a51-276">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="d1a51-277">Selhání této odpovídal naznačuje, že ostré závorky nejsou spárovány.</span><span class="sxs-lookup"><span data-stu-id="d1a51-277">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="d1a51-278">Porovná konec vstupního řetězce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-278">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="d1a51-279">Poslední dílčím výrazu, `(?(Open)(?!))`, označuje, zda jsou vnořené konstrukce v vstupní řetězec správně rozloženy (například zda každý levou hranatou závorku má odpovídající práva ostré závorky).</span><span class="sxs-lookup"><span data-stu-id="d1a51-279">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="d1a51-280">Pomocí podmíněného porovnávání na základě platný zaznamenané skupiny; Další informace najdete v tématu [konstrukce alternace](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d1a51-280">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="d1a51-281">Pokud `Open` skupina je definována, modul regulárních výrazů se pokusí o porovnání dílčí výraz `(?!)` ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-281">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="d1a51-282">`Open` Skupiny by měl být definován, pouze v případě, že jsou vnořené konstrukce nevyrovnané.</span><span class="sxs-lookup"><span data-stu-id="d1a51-282">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="d1a51-283">Vzor pro porovnání ve vstupním řetězci proto musí být ten, který vždy způsobí selhání porovnávání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-283">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="d1a51-284">V takovém případě `(?!)` je nulovou šířkou záporné dopředného vyhledávání to vždy selže, protože prázdný řetězec se vždy implicitně nachází na další pozici ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-284">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="d1a51-285">V příkladu modul regulárních výrazů vyhodnotí vstupní řetězec "\<abc >< mno\<xyz >>" jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-285">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-286">Krok</span><span class="sxs-lookup"><span data-stu-id="d1a51-286">Step</span></span>|<span data-ttu-id="d1a51-287">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-287">Pattern</span></span>|<span data-ttu-id="d1a51-288">Výsledek</span><span class="sxs-lookup"><span data-stu-id="d1a51-288">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="d1a51-289">1</span><span class="sxs-lookup"><span data-stu-id="d1a51-289">1</span></span>|`^`|<span data-ttu-id="d1a51-290">Spustí na shodu na začátku vstupní řetězec</span><span class="sxs-lookup"><span data-stu-id="d1a51-290">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="d1a51-291">2</span><span class="sxs-lookup"><span data-stu-id="d1a51-291">2</span></span>|`[^<>]*`|<span data-ttu-id="d1a51-292">Vyhledá lomená závorka znaků před levou hranatou závorku; vyhledá žádné odpovídající položky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-292">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="d1a51-293">3</span><span class="sxs-lookup"><span data-stu-id="d1a51-293">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="d1a51-294">Odpovídá levé ostré závorky v "\<abc >" a přiřadí ji k `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-294">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="d1a51-295">4</span><span class="sxs-lookup"><span data-stu-id="d1a51-295">4</span></span>|`[^<>]*`|<span data-ttu-id="d1a51-296">Odpovídá "abc".</span><span class="sxs-lookup"><span data-stu-id="d1a51-296">Matches "abc".</span></span>|  
|<span data-ttu-id="d1a51-297">5</span><span class="sxs-lookup"><span data-stu-id="d1a51-297">5</span></span>|`)+`|<span data-ttu-id="d1a51-298">"< abc" je hodnota druhý zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-298">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="d1a51-299">Další znak ve vstupním řetězci není levou hranatou závorku, takže modul regulárních výrazů neskočí zpět `(?'Open'<)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-299">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-300">6</span><span class="sxs-lookup"><span data-stu-id="d1a51-300">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="d1a51-301">Odpovídá pravé ostré závorky v "\<abc >", přiřadí "abc", která je dílčí řetězec mezi `Open` skupiny a pravém úhlu závorka k `Close` skupiny a odstraní aktuální hodnotu ("<") z `Open` skupiny, ponechat prázdné.</span><span class="sxs-lookup"><span data-stu-id="d1a51-301">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="d1a51-302">7</span><span class="sxs-lookup"><span data-stu-id="d1a51-302">7</span></span>|`[^<>]*`|<span data-ttu-id="d1a51-303">Vyhledá lomená závorka znaků po pravé ostré závorky; Vyhledá žádné odpovídající položky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-303">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="d1a51-304">8</span><span class="sxs-lookup"><span data-stu-id="d1a51-304">8</span></span>|`)+`|<span data-ttu-id="d1a51-305">Hodnota třetí zaznamenané skupiny je ">".</span><span class="sxs-lookup"><span data-stu-id="d1a51-305">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="d1a51-306">Další znak ve vstupním řetězci není pravé ostré závorky, takže modul regulárních výrazů neskočí zpět `((?'Close-Open'>)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-306">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-307">9</span><span class="sxs-lookup"><span data-stu-id="d1a51-307">9</span></span>|`)*`|<span data-ttu-id="d1a51-308">Hodnota první zaznamenané skupinu je "\<abc >".</span><span class="sxs-lookup"><span data-stu-id="d1a51-308">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="d1a51-309">Další znak ve vstupním řetězci je levou hranatou závorku, takže modul regulárních výrazů v cyklu zpět `(((?'Open'<)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-309">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-310">10</span><span class="sxs-lookup"><span data-stu-id="d1a51-310">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="d1a51-311">Odpovídá levé ostré závorky v "\<mno >" a přiřadí ji k `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-311">Matches the left angle bracket in "\<mno>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="d1a51-312">Jeho <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> kolekce nyní obsahuje jednu hodnotu, "<".</span><span class="sxs-lookup"><span data-stu-id="d1a51-312">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="d1a51-313">11</span><span class="sxs-lookup"><span data-stu-id="d1a51-313">11</span></span>|`[^<>]*`|<span data-ttu-id="d1a51-314">Porovná "mno".</span><span class="sxs-lookup"><span data-stu-id="d1a51-314">Matches "mno".</span></span>|  
|<span data-ttu-id="d1a51-315">12</span><span class="sxs-lookup"><span data-stu-id="d1a51-315">12</span></span>|`)+`|<span data-ttu-id="d1a51-316">"< mno" je hodnota druhý zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-316">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="d1a51-317">Následující znak ve vstupním řetězci je levou hranatou závorku, takže modul regulárních výrazů v cyklu zpět `(?'Open'<)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-317">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-318">13</span><span class="sxs-lookup"><span data-stu-id="d1a51-318">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="d1a51-319">Odpovídá levé ostré závorky v "\<xyz >" a přiřadí ji k `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-319">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="d1a51-320"><xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> Kolekce `Open` skupiny teď obsahuje dvě zachycení: levou hranatou závorku z "\<mno >" a levou hranatou závorku z "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="d1a51-320">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno>", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="d1a51-321">14</span><span class="sxs-lookup"><span data-stu-id="d1a51-321">14</span></span>|`[^<>]*`|<span data-ttu-id="d1a51-322">Porovná "xyz".</span><span class="sxs-lookup"><span data-stu-id="d1a51-322">Matches "xyz".</span></span>|  
|<span data-ttu-id="d1a51-323">15</span><span class="sxs-lookup"><span data-stu-id="d1a51-323">15</span></span>|`)+`|<span data-ttu-id="d1a51-324">"< xyz" je hodnota druhý zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-324">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="d1a51-325">Další znak ve vstupním řetězci není levou hranatou závorku, takže modul regulárních výrazů neskočí zpět `(?'Open'<)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-325">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-326">16</span><span class="sxs-lookup"><span data-stu-id="d1a51-326">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="d1a51-327">Odpovídá pravé ostré závorky v "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="d1a51-327">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="d1a51-328">"xyz", přiřadí podřetězec mezi `Open` skupiny a pravém úhlu závorka k `Close` skupiny a odstraní aktuální hodnota `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-328">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="d1a51-329">Hodnota předchozího zachycení (levé ostré závorky v "\<mno >") se změní na aktuální hodnota `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-329">The value of the previous capture (the left angle bracket in "\<mno>") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="d1a51-330"><xref:System.Text.RegularExpressions.Group.Captures%2A> Kolekce `Open` skupiny nyní obsahuje jediné zachycení, levou hranatou závorku z "\<xyz >".</span><span class="sxs-lookup"><span data-stu-id="d1a51-330">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="d1a51-331">17</span><span class="sxs-lookup"><span data-stu-id="d1a51-331">17</span></span>|`[^<>]*`|<span data-ttu-id="d1a51-332">Vyhledá lomená závorka znaků; Vyhledá žádné odpovídající položky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-332">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="d1a51-333">18</span><span class="sxs-lookup"><span data-stu-id="d1a51-333">18</span></span>|`)+`|<span data-ttu-id="d1a51-334">Hodnota třetí zaznamenané skupiny je ">".</span><span class="sxs-lookup"><span data-stu-id="d1a51-334">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="d1a51-335">Následující znak ve vstupním řetězci je pravé ostré závorky, takže modul regulárních výrazů v cyklu zpět `((?'Close-Open'>)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-335">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-336">19</span><span class="sxs-lookup"><span data-stu-id="d1a51-336">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="d1a51-337">Odpovídá posledním pravé ostré závorky v "xyz >>", přiřadí "mno\<xyz >" (podřetězec mezi `Open` skupiny a pravé ostré závorky) k `Close` skupiny a odstraní aktuální hodnota `Open` skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-337">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="d1a51-338">`Open` Skupina je teď prázdná.</span><span class="sxs-lookup"><span data-stu-id="d1a51-338">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="d1a51-339">20</span><span class="sxs-lookup"><span data-stu-id="d1a51-339">20</span></span>|`[^<>]*`|<span data-ttu-id="d1a51-340">Vyhledá lomená závorka znaků; Vyhledá žádné odpovídající položky.</span><span class="sxs-lookup"><span data-stu-id="d1a51-340">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="d1a51-341">21</span><span class="sxs-lookup"><span data-stu-id="d1a51-341">21</span></span>|`)+`|<span data-ttu-id="d1a51-342">Hodnota třetí zaznamenané skupiny je ">".</span><span class="sxs-lookup"><span data-stu-id="d1a51-342">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="d1a51-343">Další znak ve vstupním řetězci není pravé ostré závorky, takže modul regulárních výrazů neskočí zpět `((?'Close-Open'>)[^<>]*)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-343">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-344">22</span><span class="sxs-lookup"><span data-stu-id="d1a51-344">22</span></span>|`)*`|<span data-ttu-id="d1a51-345">Hodnotu první zaznamenané skupinu "< mno\<xyz >>".</span><span class="sxs-lookup"><span data-stu-id="d1a51-345">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="d1a51-346">Další znak ve vstupním řetězci není levou hranatou závorku, takže modul regulárních výrazů neskočí zpět `(((?'Open'<)` dílčího vzoru.</span><span class="sxs-lookup"><span data-stu-id="d1a51-346">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="d1a51-347">23</span><span class="sxs-lookup"><span data-stu-id="d1a51-347">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="d1a51-348">`Open` Skupiny není definována, takže dojde k pokusu o žádná shoda.</span><span class="sxs-lookup"><span data-stu-id="d1a51-348">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="d1a51-349">24</span><span class="sxs-lookup"><span data-stu-id="d1a51-349">24</span></span>|`$`|<span data-ttu-id="d1a51-350">Odpovídá konci vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="d1a51-350">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="d1a51-351">Skupiny bez zachytávání</span><span class="sxs-lookup"><span data-stu-id="d1a51-351">Noncapturing Groups</span></span>  
 <span data-ttu-id="d1a51-352">Následující seskupovací konstrukce nezachytává dílčí řetězec, který má odpovídající dílčím výrazu:</span><span class="sxs-lookup"><span data-stu-id="d1a51-352">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="d1a51-353">kde *dílčím výrazu* je libovolný vzor platný regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-353">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="d1a51-354">Seskupovací konstrukce se obvykle používá, když kvantifikátoru do skupiny, ale jsou podřetězce zachycené skupinou nejsou důležité.</span><span class="sxs-lookup"><span data-stu-id="d1a51-354">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d1a51-355">Obsahuje-li regulární výraz vnořené seskupovací konstrukce, vnější seskupovací konstrukce se nevztahuje na vnořené seskupovací konstrukce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-355">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="d1a51-356">Následující příklad ukazuje regulární výraz, který obsahuje skupiny bez zachytávání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-356">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="d1a51-357">Všimněte si, že výstup neobsahuje žádné zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-357">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="d1a51-358">Regulární výraz `(?:\b(?:\w+)\W*)+\.` odpovídá větě, která je ukončen tečkou.</span><span class="sxs-lookup"><span data-stu-id="d1a51-358">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="d1a51-359">Protože regulární výraz se zaměřuje na věty, nikoli na jednotlivých slov, seskupovací konstrukce jsou používány výhradně jako kvantifikátory.</span><span class="sxs-lookup"><span data-stu-id="d1a51-359">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="d1a51-360">Regulární výraz interpretována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-360">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-361">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-361">Pattern</span></span>|<span data-ttu-id="d1a51-362">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-362">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d1a51-363">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-363">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="d1a51-364">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-364">Match one or more word characters.</span></span> <span data-ttu-id="d1a51-365">Nepřiřazujte odpovídající text do zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-365">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="d1a51-366">Porovná nula nebo více znaků aplikace word.</span><span class="sxs-lookup"><span data-stu-id="d1a51-366">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="d1a51-367">Odpovídat vzor jeden nebo více znaků slova začínající na hranici slova, za nímž následuje nula nebo více znaků aplikace word, jeden či více krát.</span><span class="sxs-lookup"><span data-stu-id="d1a51-367">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="d1a51-368">Nepřiřazujte odpovídající text do zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-368">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="d1a51-369">Porovná tečku.</span><span class="sxs-lookup"><span data-stu-id="d1a51-369">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="d1a51-370">Možnosti pro skupiny</span><span class="sxs-lookup"><span data-stu-id="d1a51-370">Group Options</span></span>  
 <span data-ttu-id="d1a51-371">Následující seskupovací konstrukce použije nebo zakáže zadané možnosti v rámci dílčím výrazu:</span><span class="sxs-lookup"><span data-stu-id="d1a51-371">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="d1a51-372">`(?imnsx-imnsx:`*dílčím výrazu*`)`</span><span class="sxs-lookup"><span data-stu-id="d1a51-372">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="d1a51-373">kde *dílčím výrazu* je libovolný vzor platný regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-373">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="d1a51-374">Například `(?i-s:)` zapne nerozlišování a zakáže režim jeden řádek.</span><span class="sxs-lookup"><span data-stu-id="d1a51-374">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="d1a51-375">Další informace o vložených možností můžete určit, najdete v části [možnosti regulárních výrazů](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="d1a51-375">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d1a51-376">Můžete zadat možnosti, které platí pro celý regulární výraz, nikoli dílčím výrazu pomocí <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> konstruktoru nebo statické metody třídy.</span><span class="sxs-lookup"><span data-stu-id="d1a51-376">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="d1a51-377">Můžete také určit vnitřní možnosti, které platí po určitém bodě v regulárním výrazu pomocí `(?imnsx-imnsx)` konstrukce jazyka.</span><span class="sxs-lookup"><span data-stu-id="d1a51-377">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="d1a51-378">Konstrukce možnosti skupiny není skupinu zachycení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-378">The group options construct is not a capturing group.</span></span> <span data-ttu-id="d1a51-379">To znamená i když jakékoli její části řetězec, který je zachycen *dílčím výrazu* se dodává se shodují, není zahrnuta ve skupině zaznamenané ani používaných k naplnění <xref:System.Text.RegularExpressions.GroupCollection> objektu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-379">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="d1a51-380">Například regulární výraz `\b(?ix: d \w+)\s` v následujícím příkladu používá vložených možností v seskupovací konstrukce k povolení porovnávání a Ignorovat prázdné vzor při identifikaci všech slov, která začínají znakem "d".</span><span class="sxs-lookup"><span data-stu-id="d1a51-380">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="d1a51-381">Regulární výraz je definována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-381">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-382">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-382">Pattern</span></span>|<span data-ttu-id="d1a51-383">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-383">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d1a51-384">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-384">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="d1a51-385">Pomocí velká a malá písmena a ignorování mezer v tomto vzoru, shodovat s "d" následuje jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-385">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="d1a51-386">Porovná prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="d1a51-386">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="d1a51-387">Kontrolní výrazy s nulovou šířkou kladné dopředným vyhledáváním</span><span class="sxs-lookup"><span data-stu-id="d1a51-387">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="d1a51-388">Následující seskupovací konstrukce definuje nulovou šířkou kladné dopředného vyhledávání:</span><span class="sxs-lookup"><span data-stu-id="d1a51-388">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="d1a51-389">`(?=`*dílčím výrazu*`)`</span><span class="sxs-lookup"><span data-stu-id="d1a51-389">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="d1a51-390">kde *dílčím výrazu* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-390">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="d1a51-391">Pro úspěšné porovnání, vstupní řetězec musí odpovídat vzor regulárního výrazu v *dílčím výrazu*, i když odpovídající podřetězec není zahrnut ve výsledku porovnání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-391">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="d1a51-392">Nulovou šířkou kladné dopředného vyhledávání není zpětný krok.</span><span class="sxs-lookup"><span data-stu-id="d1a51-392">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="d1a51-393">Nulovou šířkou kladné dopředného vyhledávání se obvykle nachází na konci vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-393">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="d1a51-394">Definuje dílčí řetězec, který musí být nalezen na konci řetězce pro porovnání dojít, ale které by neměly být obsažené v shody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-394">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="d1a51-395">Je také užitečné brání nadměrné zpětné navracení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-395">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="d1a51-396">Nulovou šířkou kladné dopředného vyhledávání můžete použít k zajištění, že do určité skupiny zaznamenané začíná text, který odpovídá podmnožinu vzoru definované pro tuto skupinu zaznamenané.</span><span class="sxs-lookup"><span data-stu-id="d1a51-396">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="d1a51-397">Například pokud skupinu zachycení odpovídá znaků po sobě jdoucí slova, můžete nulovou šířkou kladné dopředného vyhledávání vyžadují, aby první znak abecední velké písmeno.</span><span class="sxs-lookup"><span data-stu-id="d1a51-397">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="d1a51-398">Následující příklad používá nulovou šířkou kladné dopředného vyhledávání tak, aby odpovídaly slovo, které předchází příkaz "je" ve vstupním řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-398">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="d1a51-399">Regulární výraz `\b\w+(?=\sis\b)` interpretována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-399">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-400">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-400">Pattern</span></span>|<span data-ttu-id="d1a51-401">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-401">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d1a51-402">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-402">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="d1a51-403">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-403">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="d1a51-404">Určete, jestli znaků slova jsou následuje prázdné znaky a řetězce "je", který končí na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-404">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="d1a51-405">Pokud ano, je úspěšný shody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-405">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="d1a51-406">Kontrolní výrazy s nulovou šířkou záporné dopředným vyhledáváním</span><span class="sxs-lookup"><span data-stu-id="d1a51-406">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="d1a51-407">Následující seskupovací konstrukce definuje výraz negativního dopředného vyhledávání s nulovou šířkou:</span><span class="sxs-lookup"><span data-stu-id="d1a51-407">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="d1a51-408">`(?!`*dílčím výrazu*`)`</span><span class="sxs-lookup"><span data-stu-id="d1a51-408">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="d1a51-409">kde *dílčím výrazu* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-409">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="d1a51-410">Pro úspěšné porovnání vstupní řetězec nesmí odpovídat vzor regulárního výrazu v *dílčím výrazu*, i když odpovídající řetězec není součástí výsledku porovnání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-410">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="d1a51-411">Nulovou šířkou záporné dopředného vyhledávání se obvykle používá na začátku nebo na konci regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-411">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="d1a51-412">Na začátku regulární výraz se může definovat konkrétní vzor, který by neměly odpovídat při začátku regulární výraz definuje podobně jako u ale obecnější vzor pro porovnání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-412">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="d1a51-413">V takovém případě se často používá k omezení zpětné navracení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-413">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="d1a51-414">Na konci regulární výraz se může definovat dílčím výrazu, který se nemůže vyskytovat na konci shody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-414">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="d1a51-415">V následujícím příkladu definuje regulární výraz, který používá dopředného vyhledávání nulovou šířkou na začátku regulárního výrazu tak, aby odpovídaly slova, která nemají na začátku "zrušení".</span><span class="sxs-lookup"><span data-stu-id="d1a51-415">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="d1a51-416">Regulární výraz `\b(?!un)\w+\b` interpretována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-416">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-417">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-417">Pattern</span></span>|<span data-ttu-id="d1a51-418">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-418">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d1a51-419">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-419">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="d1a51-420">Určení, zda jsou následující dva znaky "zrušení".</span><span class="sxs-lookup"><span data-stu-id="d1a51-420">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="d1a51-421">Pokud tomu tak není, je možné shody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-421">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="d1a51-422">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-422">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="d1a51-423">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-423">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="d1a51-424">V následujícím příkladu definuje regulární výraz, který používá dopředného vyhledávání nulovou šířkou na konci regulární výraz k přiřazení slova, která na konci interpunkční znaménko.</span><span class="sxs-lookup"><span data-stu-id="d1a51-424">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="d1a51-425">Regulární výraz `\b\w+\b(?!\p{P})` interpretována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-425">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-426">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-426">Pattern</span></span>|<span data-ttu-id="d1a51-427">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-427">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d1a51-428">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-428">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="d1a51-429">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-429">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="d1a51-430">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-430">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="d1a51-431">Pokud další znak není interpunkční symbol (například období nebo čárkou), bude úspěšná shody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-431">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="d1a51-432">Kontrolní výrazy kladné zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="d1a51-432">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="d1a51-433">Následující seskupovací konstrukce definuje výraz kladné zpětného vyhledávání s nulovou šířkou:</span><span class="sxs-lookup"><span data-stu-id="d1a51-433">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="d1a51-434">`(?<=`*dílčím výrazu*`)`</span><span class="sxs-lookup"><span data-stu-id="d1a51-434">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="d1a51-435">kde *dílčím výrazu* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-435">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="d1a51-436">Pro úspěšné, porovnání *dílčím výrazu* musí objevit ve vstupním řetězci nalevo od aktuální pozice, přestože `subexpression` není zahrnut ve výsledku porovnání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-436">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="d1a51-437">Kladné zpětného vyhledávání s nulovou šířkou kontrolní mechanismus navrácení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-437">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="d1a51-438">Kontrolní výrazy kladné zpětného vyhledávání s nulovou šířkou jsou obvykle používány na začátku regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="d1a51-438">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="d1a51-439">Vzor, který definují je předpokladem pro shodu, i když není součástí výsledku porovnání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-439">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="d1a51-440">Například v následujícím příkladu odpovídá poslední dvě číslice roku pro 21 dvacet (to znamená, že číslice "20" předcházet odpovídající řetězec).</span><span class="sxs-lookup"><span data-stu-id="d1a51-440">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="d1a51-441">Regulární výraz `(?<=\b20)\d{2}\b` interpretována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-441">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-442">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-442">Pattern</span></span>|<span data-ttu-id="d1a51-443">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-443">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="d1a51-444">Porovná dvě desítková číslice.</span><span class="sxs-lookup"><span data-stu-id="d1a51-444">Match two decimal digits.</span></span>|  
|`{?<=\b20)`|<span data-ttu-id="d1a51-445">Pokračujte shody, pokud dva desetinných míst předchází desetinných míst "20" na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-445">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="d1a51-446">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-446">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="d1a51-447">Kontrolní výrazy kladné zpětného vyhledávání s nulovou šířkou se taky používají k omezení zpětné navracení při poslední znak nebo znaky ve skupině zaznamenané musí být podmnožinou znaky, které odpovídají vzor regulárního výrazu této skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-447">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="d1a51-448">Například pokud skupinu zaznamená všechny aplikace word po sobě jdoucí znaky, můžete výraz kladné zpětného vyhledávání s nulovou šířkou vyžadují, aby jeho poslední znak abecední.</span><span class="sxs-lookup"><span data-stu-id="d1a51-448">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="d1a51-449">Kontrolní výrazy negativního zpětného vyhledávání s nulovou šířkou</span><span class="sxs-lookup"><span data-stu-id="d1a51-449">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="d1a51-450">Následující seskupovací konstrukce definuje výraz negativního zpětného vyhledávání s nulovou šířkou:</span><span class="sxs-lookup"><span data-stu-id="d1a51-450">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="d1a51-451">`(?<!`*dílčím výrazu*`)`</span><span class="sxs-lookup"><span data-stu-id="d1a51-451">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="d1a51-452">kde *dílčím výrazu* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-452">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="d1a51-453">Pro úspěšné, porovnání *dílčím výrazu* nesmí vyskytovat ve vstupním řetězci nalevo od aktuální pozici.</span><span class="sxs-lookup"><span data-stu-id="d1a51-453">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="d1a51-454">Ale jakýkoli podřetězec, který neodpovídá `subexpression` není zahrnut ve výsledku porovnání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-454">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="d1a51-455">Kontrolní výrazy negativního zpětného vyhledávání s nulovou šířkou jsou obvykle používány na začátku regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="d1a51-455">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="d1a51-456">Vzor, který definují vylučuje porovnávání řetězce, který následuje.</span><span class="sxs-lookup"><span data-stu-id="d1a51-456">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="d1a51-457">Používají se také omezit zpětné navracení při poslední znak nebo znaky ve skupině zaznamenané nesmí být jeden nebo více znaků, které odpovídají vzor regulárního výrazu této skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-457">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="d1a51-458">Například pokud skupinu zaznamená všechny aplikace word po sobě jdoucí znaky, můžete výraz kladné zpětného vyhledávání s nulovou šířkou vyžadují, aby jeho poslední znak není podtržítko (_).</span><span class="sxs-lookup"><span data-stu-id="d1a51-458">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</span></span>  
  
 <span data-ttu-id="d1a51-459">Následující příklad odpovídá datum pro všechny den v týdnu, který není víkendu (to znamená, že je sobota ani neděle).</span><span class="sxs-lookup"><span data-stu-id="d1a51-459">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="d1a51-460">Regulární výraz `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` interpretována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-460">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-461">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-461">Pattern</span></span>|<span data-ttu-id="d1a51-462">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-462">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d1a51-463">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-463">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="d1a51-464">Porovná jeden nebo více znaků slova, za nímž následuje prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="d1a51-464">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="d1a51-465">Odpovídat jedna nebo dvě desetinných míst následovaný prázdným znakem a čárkou.</span><span class="sxs-lookup"><span data-stu-id="d1a51-465">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="d1a51-466">Odpovídající čtyři desetinných míst a ukončí porovnávání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-466">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|`(?<!(Saturday&#124;Sunday) )`|<span data-ttu-id="d1a51-467">Pokud je shoda předchází něco jiného než řetězce "Sobota" nebo "Neděle" následované mezerou, porovnávání je úspěšné.</span><span class="sxs-lookup"><span data-stu-id="d1a51-467">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="d1a51-468">Bez mechanismu navrácení podvýrazy</span><span class="sxs-lookup"><span data-stu-id="d1a51-468">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="d1a51-469">Následující seskupovací konstrukce představuje podvýraz (také označované jako "chamtivého" dílčím výrazu):</span><span class="sxs-lookup"><span data-stu-id="d1a51-469">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="d1a51-470">`(?>`*dílčím výrazu*`)`</span><span class="sxs-lookup"><span data-stu-id="d1a51-470">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="d1a51-471">kde *dílčím výrazu* je libovolný vzor regulárního výrazu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-471">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="d1a51-472">Normálně Pokud regulární výraz zahrnuje volitelný nebo alternativní odpovídající vzorek a porovnávání neproběhne úspěšně, můžete v několika směrech tak, aby odpovídaly vstupní řetězec pomocí vzoru větev modul regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="d1a51-472">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="d1a51-473">Pokud není nalezena shoda při přepínání první větve, můžete modul regulárních výrazů zálohovat nebo navrátit do místa, kde došlo na první shodu a pokus shody pomocí druhé větve.</span><span class="sxs-lookup"><span data-stu-id="d1a51-473">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="d1a51-474">Tento proces může pokračovat, dokud všechny větve mají nebyl proveden pokus o.</span><span class="sxs-lookup"><span data-stu-id="d1a51-474">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="d1a51-475">`(?>` *Dílčím výrazu* `)` jazyková konstrukce zakáže mechanismus navrácení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-475">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="d1a51-476">Modul regulárních výrazů bude odpovídat tolik znaků ve vstupním řetězci, jak je to možné.</span><span class="sxs-lookup"><span data-stu-id="d1a51-476">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="d1a51-477">Pokud žádné další shody je možné, nebude zpětný krok k pokusu o alternativní vzor shody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-477">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="d1a51-478">(To znamená, dílčí výraz odpovídá pouze řetězce, které by odpovídat samostatně dílčím výrazu, se nebude pokoušet o porovnání řetězce na základě dílčí výraz a všechny podvýrazy, které následují ji.)</span><span class="sxs-lookup"><span data-stu-id="d1a51-478">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="d1a51-479">Tato možnost se doporučuje, když víte, že zpětné navracení se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="d1a51-479">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="d1a51-480">Modul regulárních výrazů brání v provádění zbytečného hledání zvyšuje výkon.</span><span class="sxs-lookup"><span data-stu-id="d1a51-480">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="d1a51-481">Následující příklad ilustruje, jak podvýraz upraví výsledky vzor shody.</span><span class="sxs-lookup"><span data-stu-id="d1a51-481">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="d1a51-482">Navrácení regulární výraz úspěšně odpovídá řadu opakovaných znaky následované více výskytů stejného znaku na hranici slova, ale nemá bez mechanismu navrácení regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="d1a51-482">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="d1a51-483">Bez mechanismu navrácení regulární výraz `(?>(\w)\1+).\b` je definovaný jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-483">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-484">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-484">Pattern</span></span>|<span data-ttu-id="d1a51-485">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-485">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="d1a51-486">Porovná znak jednoho slova a přiřaďte ho ke skupině první zaznamenávání.</span><span class="sxs-lookup"><span data-stu-id="d1a51-486">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="d1a51-487">Odpovídají hodnotě první zachycený podřetězec jeden či více krát.</span><span class="sxs-lookup"><span data-stu-id="d1a51-487">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="d1a51-488">Porovná libovolný znak.</span><span class="sxs-lookup"><span data-stu-id="d1a51-488">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="d1a51-489">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-489">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="d1a51-490">Porovná jeden nebo více výskytů znak duplicitní slova, ale nevrací se tak, aby odpovídala poslední znak na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-490">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="d1a51-491">Seskupovací konstrukce a objekty regulární výraz</span><span class="sxs-lookup"><span data-stu-id="d1a51-491">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="d1a51-492">Podřetězce, které jsou porovnávány regulárním výrazem zaznamenávání skupiny jsou reprezentované pomocí <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objekty, které můžete získat z <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> objekt, který je vrácený <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d1a51-492">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d1a51-493"><xref:System.Text.RegularExpressions.GroupCollection> Objektu je naplněn takto:</span><span class="sxs-lookup"><span data-stu-id="d1a51-493">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
-   <span data-ttu-id="d1a51-494">První <xref:System.Text.RegularExpressions.Group> objekt v kolekci (objekt v indexu nula) představuje celou shodu.</span><span class="sxs-lookup"><span data-stu-id="d1a51-494">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
-   <span data-ttu-id="d1a51-495">Další sada <xref:System.Text.RegularExpressions.Group> objekty představuje nepojmenované (číslované) zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-495">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="d1a51-496">Zobrazí se v pořadí, ve kterém jsou definovány v regulárním výrazu zleva doprava.</span><span class="sxs-lookup"><span data-stu-id="d1a51-496">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="d1a51-497">Index hodnoty těchto skupin rozsahu od 1 do počet nepojmenované zaznamenání skupin v kolekci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-497">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="d1a51-498">(Index určité skupiny je ekvivalentní k jeho číslem zpětných odkazů.</span><span class="sxs-lookup"><span data-stu-id="d1a51-498">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="d1a51-499">Zpětné odkazy na další informace najdete v tématu [konstrukce zpětných odkazů](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="d1a51-499">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
-   <span data-ttu-id="d1a51-500">Konečné sada <xref:System.Text.RegularExpressions.Group> objekty představuje pojmenované zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-500">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="d1a51-501">Zobrazí se v pořadí, ve kterém jsou definovány v regulárním výrazu zleva doprava.</span><span class="sxs-lookup"><span data-stu-id="d1a51-501">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="d1a51-502">Hodnota indexu první pojmenované zachytávající skupiny je větší než index poslední nepojmenované zachytávající skupiny.</span><span class="sxs-lookup"><span data-stu-id="d1a51-502">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="d1a51-503">Pokud neexistují žádné nepojmenované zachytávající skupiny v regulárním výrazu, je hodnota indexu první pojmenované zachytávající skupiny jeden.</span><span class="sxs-lookup"><span data-stu-id="d1a51-503">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="d1a51-504">Pokud použijete kvantifikátor zachycené skupiny, odpovídající <xref:System.Text.RegularExpressions.Group> objektu <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, a <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> vlastnosti vyjadřují poslední podřetězec zachycenou skupinu zachycení.</span><span class="sxs-lookup"><span data-stu-id="d1a51-504">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="d1a51-505">Můžete načíst kompletní sadu dílčích řetězců, které jsou zachyceny skupiny, které mají kvantifikátory z <xref:System.Text.RegularExpressions.CaptureCollection> objekt, který je vrácený <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d1a51-505">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="d1a51-506">Následující příklad vysvětluje vztah mezi <xref:System.Text.RegularExpressions.Group> a <xref:System.Text.RegularExpressions.Capture> objekty.</span><span class="sxs-lookup"><span data-stu-id="d1a51-506">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="d1a51-507">Regulární výraz `\b(\w+)\W+)+` extrahuje jednotlivých slov v řetězci.</span><span class="sxs-lookup"><span data-stu-id="d1a51-507">The regular expression pattern `\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="d1a51-508">Je definován tak, jak je uvedeno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="d1a51-508">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d1a51-509">Vzor</span><span class="sxs-lookup"><span data-stu-id="d1a51-509">Pattern</span></span>|<span data-ttu-id="d1a51-510">Popis</span><span class="sxs-lookup"><span data-stu-id="d1a51-510">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d1a51-511">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-511">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="d1a51-512">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="d1a51-512">Match one or more word characters.</span></span> <span data-ttu-id="d1a51-513">Tyto znaky společně tvoří slovo.</span><span class="sxs-lookup"><span data-stu-id="d1a51-513">Together, these characters form a word.</span></span> <span data-ttu-id="d1a51-514">Toto je druhá zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="d1a51-514">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="d1a51-515">Odpovídat jeden nebo více znaků aplikace word.</span><span class="sxs-lookup"><span data-stu-id="d1a51-515">Match one or more non-word characters.</span></span>|  
|`(\w+)\W+)+`|<span data-ttu-id="d1a51-516">Shodují se vzorem jeden nebo více znaků slova následuje jeden nebo více mimo slovo znaků jeden či více krát.</span><span class="sxs-lookup"><span data-stu-id="d1a51-516">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="d1a51-517">Toto je první zachytávající skupina.</span><span class="sxs-lookup"><span data-stu-id="d1a51-517">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="d1a51-518">První skupinu zaznamenávání odpovídá jednotlivých slov věty.</span><span class="sxs-lookup"><span data-stu-id="d1a51-518">The first capturing group matches each word of the sentence.</span></span> <span data-ttu-id="d1a51-519">Druhá zachytávající skupina odpovídá jednotlivých slov spolu s interpunkce a prázdné znaky, které budou následovat slovo.</span><span class="sxs-lookup"><span data-stu-id="d1a51-519">The second capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="d1a51-520"><xref:System.Text.RegularExpressions.Group> Objekt, jehož index je 2 poskytuje informace o text odpovídající druhé zachytávající skupině.</span><span class="sxs-lookup"><span data-stu-id="d1a51-520">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="d1a51-521">Kompletní sadu slov zachycených zachytávající skupině jsou k dispozici na <xref:System.Text.RegularExpressions.CaptureCollection> objekt vrácený <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> vlastnost.</span><span class="sxs-lookup"><span data-stu-id="d1a51-521">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d1a51-522">Viz také</span><span class="sxs-lookup"><span data-stu-id="d1a51-522">See Also</span></span>  
 [<span data-ttu-id="d1a51-523">Jazyk regulárních výrazů – Stručná referenční příručka</span><span class="sxs-lookup"><span data-stu-id="d1a51-523">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="d1a51-524">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="d1a51-524">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
