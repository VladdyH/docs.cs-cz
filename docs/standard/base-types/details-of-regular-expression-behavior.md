---
title: "Podrobnosti k chování regulárních výrazů"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 5b471cd8e934880fc8095fbad68b460174ec338c
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/27/2018
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="e0397-102">Podrobnosti k chování regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="e0397-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="e0397-103">Modul regulárního výrazu rozhraní .NET Framework je navrácení regulární výraz objekt přiřazení vzorce která zahrnuje modul tradiční Nedeterministická konečné Automaton (NFA) jako je například použité Perl, Python, Emacs a Tcl.</span><span class="sxs-lookup"><span data-stu-id="e0397-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="e0397-104">To je odlišné z rychlejší, ale omezenější, čistý regulární výraz moduly deterministický konečné Automaton (DFA) jako aplikace awk, egrep nebo lex.</span><span class="sxs-lookup"><span data-stu-id="e0397-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="e0397-105">To je také odlišné od standardizované, ale pomalejší, k zařízení NFAs POSIX.</span><span class="sxs-lookup"><span data-stu-id="e0397-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="e0397-106">Následující část popisuje tři typy modulů regulární výraz a vysvětluje, proč jsou regulární výrazy v rozhraní .NET Framework implementovaná pomocí modul tradiční NFA.</span><span class="sxs-lookup"><span data-stu-id="e0397-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="e0397-107">Výhody modulu NFA</span><span class="sxs-lookup"><span data-stu-id="e0397-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="e0397-108">Pokud moduly DFA provést porovnávání vzorů, jejich pořadí zpracování doprovází vstupní řetězec.</span><span class="sxs-lookup"><span data-stu-id="e0397-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="e0397-109">Modul začne od začátku vstupní řetězec a pokračuje postupně k určení, zda další znak odpovídá regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="e0397-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="e0397-110">Se může zaručit tak, aby odpovídala nejdelší řetězec, který je možné.</span><span class="sxs-lookup"><span data-stu-id="e0397-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="e0397-111">Vzhledem k tomu, že se nikdy otestovat ve stejném dvakrát, nepodporují DFA moduly zpětné navracení.</span><span class="sxs-lookup"><span data-stu-id="e0397-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="e0397-112">Ale protože modul DFA obsahuje pouze konečný stav, nesmí se shodovat vzor s zpětné odkazy a protože není ji vytvořit explicitní rozšíření, nelze zachytit podvýrazy.</span><span class="sxs-lookup"><span data-stu-id="e0397-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="e0397-113">Na rozdíl od DFA weby když tradiční moduly NFA provést porovnávání vzorů jejich pořadí zpracování doprovází regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="e0397-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="e0397-114">Během zpracování elementu konkrétní jazyk, modul používá typu greedy odpovídající; To znamená odpovídá co nejvíc vstupní řetězec jako pravděpodobně můžete.</span><span class="sxs-lookup"><span data-stu-id="e0397-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="e0397-115">Můžete ale také uloží stav po úspěšně odpovídající dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="e0397-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="e0397-116">Pokud odpovídající nakonec selže, modul, pokusí se použít další odpovídá vrátit do uloženého stavu.</span><span class="sxs-lookup"><span data-stu-id="e0397-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="e0397-117">Zrušení úspěšné dílčím výrazu shody, aby souhlasila novější jazykové elementy v regulárním výrazu můžete také tento proces se označuje jako *zpětné navracení*.</span><span class="sxs-lookup"><span data-stu-id="e0397-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="e0397-118">NFA moduly využívají zpětné navracení otestovat všechny možné rozšíření regulárního výrazu v určitém pořadí a přijmout na první shodu.</span><span class="sxs-lookup"><span data-stu-id="e0397-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="e0397-119">Vzhledem k tomu, že modul tradiční NFA vytvoří konkrétní rozšíření regulárního výrazu shody úspěšné, můžete zaznamenat, odpovídá dílčím výrazu a odpovídající zpětné odkazy.</span><span class="sxs-lookup"><span data-stu-id="e0397-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="e0397-120">Ale protože tradiční NFA provede krok zpět, je navštívit stejného stavu více než jednou. Pokud dorazí stav přes různé cesty.</span><span class="sxs-lookup"><span data-stu-id="e0397-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="e0397-121">V důsledku toho může probíhat exponenciálnímu pomalu v nejhorším případě.</span><span class="sxs-lookup"><span data-stu-id="e0397-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="e0397-122">Vzhledem k tomu, že modul tradiční NFA přijme první odpovídat ho najde, můžete také ponechat jiné (pravděpodobně delší) odpovídá nezjištěné.</span><span class="sxs-lookup"><span data-stu-id="e0397-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="e0397-123">POSIX NFA moduly jsou jako tradiční NFA moduly, s výjimkou toho, aby nadále zpětný krok, dokud se může zaručit, že jejich našli nejdelší shody možné.</span><span class="sxs-lookup"><span data-stu-id="e0397-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="e0397-124">V důsledku toho modul POSIX NFA je nižší než tradiční modul NFA a pokud používáte modul POSIX NFA, nelze upřednostnit kratší shoda přes delší jeden změnou pořadí navrácení hledání.</span><span class="sxs-lookup"><span data-stu-id="e0397-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="e0397-125">Tradiční NFA moduly jsou podporuje programátory, protože nabízejí větší kontrolu nad řetězec odpovídající než DFA nebo POSIX NFA moduly.</span><span class="sxs-lookup"><span data-stu-id="e0397-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="e0397-126">I když v nejhorším případě mohou spouštět pomalu, můžete řídit, je nalezení shody v čase lineární nebo polynomické pomocí vzorů, které snížit nejednoznačnosti a omezit zpětné navracení.</span><span class="sxs-lookup"><span data-stu-id="e0397-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="e0397-127">Jinými slovy i když NFA moduly obchodu výkonu pro výkon a flexibilitu ve většině případů, které nabízejí pustit do přijatelný výkon, pokud regulární výraz je kvalitně a zabraňuje případy, kdy zpětné navracení snižuje výkon exponenciálně.</span><span class="sxs-lookup"><span data-stu-id="e0397-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e0397-128">Informace o snížení výkonu kvůli nadměrné zpětné navracení a způsoby, jak vytvořit regulární výraz je obejít najdete v tématu [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="e0397-129">Možnosti modulu .NET framework</span><span class="sxs-lookup"><span data-stu-id="e0397-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="e0397-130">Abyste mohli využívat výhod modul tradiční NFA, zahrnuje modul regulárního výrazu rozhraní .NET Framework kompletní sadu konstrukty, které umožňují řídit modul navrácení programátory v jazyce.</span><span class="sxs-lookup"><span data-stu-id="e0397-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="e0397-131">Tyto konstrukce lze použít k vyhledání shody rychlejší nebo upřednostnit konkrétní rozšíření přes jiné.</span><span class="sxs-lookup"><span data-stu-id="e0397-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="e0397-132">Další funkce modulu regulárního výrazu rozhraní .NET Framework zahrnují následující:</span><span class="sxs-lookup"><span data-stu-id="e0397-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
-   <span data-ttu-id="e0397-133">Líné kvantifikátory: `??`, `*?`, `+?`, `{`  *n*  `,` *m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="e0397-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="e0397-134">Tyto konstrukce řekněte modul navrácení nejprve hledání minimální počet opakování.</span><span class="sxs-lookup"><span data-stu-id="e0397-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="e0397-135">Naproti tomu obyčejnou typu greedy kvantifikátory pokusit nejprve porovnat maximální počet opakování.</span><span class="sxs-lookup"><span data-stu-id="e0397-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="e0397-136">Následující příklad ukazuje rozdíl mezi nimi.</span><span class="sxs-lookup"><span data-stu-id="e0397-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="e0397-137">Regulární výraz odpovídá věty, které končí číslem a zaznamenávání skupiny slouží k extrakci toto číslo.</span><span class="sxs-lookup"><span data-stu-id="e0397-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="e0397-138">Regulární výraz `.+(\d+)\.` zahrnuje typu greedy kvantifikátoru `.+`, což způsobí, že modul regulárních výrazů k zachycení pouze poslední číslice čísla.</span><span class="sxs-lookup"><span data-stu-id="e0397-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="e0397-139">Naproti tomu regulární výraz `.+?(\d+)\.` zahrnuje opožděné kvantifikátoru `.+?`, což způsobí, že modul regulárních výrazů k zachycení celé číslo.</span><span class="sxs-lookup"><span data-stu-id="e0397-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="e0397-140">Verze typu greedy a opožděné tento regulární výraz jsou definovány, jak je znázorněno v následující tabulce. "</span><span class="sxs-lookup"><span data-stu-id="e0397-140">The greedy and lazy versions of this regular expression are defined as shown in the following table.\`</span></span>  
  
    |<span data-ttu-id="e0397-141">Vzor</span><span class="sxs-lookup"><span data-stu-id="e0397-141">Pattern</span></span>|<span data-ttu-id="e0397-142">Popis</span><span class="sxs-lookup"><span data-stu-id="e0397-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="e0397-143">`.+` (typu greedy kvantifikátoru)</span><span class="sxs-lookup"><span data-stu-id="e0397-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="e0397-144">Porovná alespoň jeden výskyt libovolného znaku.</span><span class="sxs-lookup"><span data-stu-id="e0397-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="e0397-145">To způsobí, že modul regulárních výrazů tak, aby odpovídaly celý řetězec a pak zpětný krok jako potřeby tak, aby odpovídaly zbytek vzoru.</span><span class="sxs-lookup"><span data-stu-id="e0397-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="e0397-146">`.+?` (opožděné kvantifikátoru)</span><span class="sxs-lookup"><span data-stu-id="e0397-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="e0397-147">Porovná alespoň jeden výskyt libovolný znak, ale odpovídat co nejméně.</span><span class="sxs-lookup"><span data-stu-id="e0397-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="e0397-148">Odpovídají alespoň jeden znak číselné a přiřaďte ho ke skupině první zaznamenávání.</span><span class="sxs-lookup"><span data-stu-id="e0397-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="e0397-149">Porovná tečku.</span><span class="sxs-lookup"><span data-stu-id="e0397-149">Match a period.</span></span>|  
  
     <span data-ttu-id="e0397-150">Další informace o líné kvantifikátory najdete v tématu [kvantifikátory](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="e0397-151">Kladné s dopředným vyhledáváním: `(?=` *dílčím výrazu*`)`.</span><span class="sxs-lookup"><span data-stu-id="e0397-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="e0397-152">Tato funkce umožňuje modul navrácení se vraťte do stejné pozici v textu po porovnávání dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="e0397-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="e0397-153">Je užitečné pro vyhledávání v celém textu kontrolou více vzorů, které začínají stejnou pozici.</span><span class="sxs-lookup"><span data-stu-id="e0397-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="e0397-154">Také umožňuje, aby modul ověřte, zda je dílčí řetězec nachází na konci shody bez zahrnutí dílčí řetězec v odpovídající text.</span><span class="sxs-lookup"><span data-stu-id="e0397-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="e0397-155">Následující příklad používá kladné s dopředným vyhledáváním pro extrahování slova ve větě, která nejsou následuje interpunkčních znamének.</span><span class="sxs-lookup"><span data-stu-id="e0397-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="e0397-156">Regulární výraz `\b[A-Z]+\b(?=\P{P})` je definovaný jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="e0397-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="e0397-157">Vzor</span><span class="sxs-lookup"><span data-stu-id="e0397-157">Pattern</span></span>|<span data-ttu-id="e0397-158">Popis</span><span class="sxs-lookup"><span data-stu-id="e0397-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="e0397-159">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="e0397-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="e0397-160">Porovná libovolný znak abecedy jeden či více krát.</span><span class="sxs-lookup"><span data-stu-id="e0397-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="e0397-161">Protože <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metoda je volána s <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> možnost, porovnání nerozlišuje.</span><span class="sxs-lookup"><span data-stu-id="e0397-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="e0397-162">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="e0397-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="e0397-163">Hledat k určení, zda další znak je symbol interpunkce.</span><span class="sxs-lookup"><span data-stu-id="e0397-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="e0397-164">Pokud není, bude úspěšná shody.</span><span class="sxs-lookup"><span data-stu-id="e0397-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="e0397-165">Další informace o kontrolní výrazy s dopředným vyhledáváním kladné najdete v tématu [seskupení vytvoří](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="e0397-166">Záporné s dopředným vyhledáváním: `(?!` *dílčím výrazu*`)`.</span><span class="sxs-lookup"><span data-stu-id="e0397-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="e0397-167">Tato funkce přidává možnost tak, aby odpovídaly výrazu, pouze pokud selže dílčím výrazu tak, aby odpovídaly.</span><span class="sxs-lookup"><span data-stu-id="e0397-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="e0397-168">To je zvláště efektivní pro vyřazování hledání, protože je často jednodušší zajistit výrazu pro případ, který by měly být odstraněny než výrazu v případech, kdy musí být zahrnut.</span><span class="sxs-lookup"><span data-stu-id="e0397-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="e0397-169">Například je obtížné zápisu výrazu pro slova, která nemají na začátku "jiné".</span><span class="sxs-lookup"><span data-stu-id="e0397-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="e0397-170">Následující příklad používá záporné s dopředným vyhledáváním z nich vyloučit.</span><span class="sxs-lookup"><span data-stu-id="e0397-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="e0397-171">Regulární výraz `\b(?!non)\w+\b` je definovaný jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="e0397-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="e0397-172">Vzor</span><span class="sxs-lookup"><span data-stu-id="e0397-172">Pattern</span></span>|<span data-ttu-id="e0397-173">Popis</span><span class="sxs-lookup"><span data-stu-id="e0397-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="e0397-174">Začne porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="e0397-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="e0397-175">Hledat zajistit, aby aktuálního řetězce nezačíná "jiné".</span><span class="sxs-lookup"><span data-stu-id="e0397-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="e0397-176">Pokud ano, porovnání se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="e0397-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="e0397-177">Porovná jeden nebo více znaků slova.</span><span class="sxs-lookup"><span data-stu-id="e0397-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="e0397-178">Ukončí porovnání na hranici slova.</span><span class="sxs-lookup"><span data-stu-id="e0397-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="e0397-179">Další informace o kontrolní výrazy s dopředným vyhledáváním záporné najdete v tématu [seskupení vytvoří](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="e0397-180">Podmíněné vyhodnocení: `(?(` *výraz*`)`*Ano*`|`*žádné* `)` a `(?(` *název*`)`*Ano*`|`*žádné*`)`, kde *výraz* je dílčím výrazu tak, aby odpovídaly, *název* je název zachycené skupiny, *Ano* je řetězec, který má splněno, pokud *výraz* je nalezena shoda nebo *název* je platný, neprázdný zaznamenané skupiny, a *žádné* dílčím výrazu pro porovnání, pokud je *výraz* neodpovídá nebo *název* není platné, prázdný zaznamenané skupiny.</span><span class="sxs-lookup"><span data-stu-id="e0397-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="e0397-181">Tato funkce umožňuje modul pro vyhledávání pomocí více než jeden alternativní vzorek, v závislosti na výsledek předchozí shodě dílčím výrazu nebo výsledek assertion nulovou šířkou.</span><span class="sxs-lookup"><span data-stu-id="e0397-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="e0397-182">To umožňuje výkonnější formu zpětných odkazů, která umožňuje například odpovídající dílčím výrazu založené na tom, jestli byl shodná předchozí dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="e0397-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="e0397-183">Odpovídá regulárnímu výrazu v následujícím příkladu odstavců, které jsou určeny pro veřejný i interní použití.</span><span class="sxs-lookup"><span data-stu-id="e0397-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="e0397-184">Začínat odstavců určena pouze pro interní použití `<PRIVATE>` značky.</span><span class="sxs-lookup"><span data-stu-id="e0397-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="e0397-185">Regulární výraz `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` používá podmíněného vyhodnocení přiřadit obsah odstavců určený pro veřejné a pro interní použití jednotlivé skupiny zachycení.</span><span class="sxs-lookup"><span data-stu-id="e0397-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="e0397-186">Tyto odstavců můžete poté zpracovány jinak.</span><span class="sxs-lookup"><span data-stu-id="e0397-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="e0397-187">Regulární výraz je definována, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="e0397-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="e0397-188">Vzor</span><span class="sxs-lookup"><span data-stu-id="e0397-188">Pattern</span></span>|<span data-ttu-id="e0397-189">Popis</span><span class="sxs-lookup"><span data-stu-id="e0397-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="e0397-190">Začne porovnávání na začátku řádku.</span><span class="sxs-lookup"><span data-stu-id="e0397-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="e0397-191">Porovná nula nebo jeden výskyt řetězec `<PRIVATE>` následuje prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="e0397-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="e0397-192">Přiřadit shody zachycující skupiny s názvem `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="e0397-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="e0397-193">Pokud `Pvt` zaznamenávání skupina existuje, porovná jeden nebo více výskytů jeden nebo více znaků slova následuje žádnou nebo jednu oddělovače interpunkce následuje prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="e0397-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="e0397-194">Dílčí řetězec přiřadíte ke skupině první zaznamenávání.</span><span class="sxs-lookup"><span data-stu-id="e0397-194">Assign the substring to the first capturing group.</span></span>|  
    |<code>&#124;((\w+\p{P}?\s)+))<code>|<span data-ttu-id="e0397-195">Pokud `Pvt` zachycující skupina neexistuje, shodovat s jedním nebo více výskytů jeden nebo více znaků slova následuje žádnou nebo jednu oddělovače interpunkce následuje prázdný znak.</span><span class="sxs-lookup"><span data-stu-id="e0397-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="e0397-196">Dílčí řetězec přiřadíte ke skupině třetí zaznamenávání.</span><span class="sxs-lookup"><span data-stu-id="e0397-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="e0397-197">Odpovídat konci řádku nebo konci řetězce.</span><span class="sxs-lookup"><span data-stu-id="e0397-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="e0397-198">Další informace o vyhodnocení podmíněného najdete v tématu [konstrukce alternace](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="e0397-199">Definice skupin vyrovnávání: `(?<` *name1*`-`*name2* `>` *dílčím výrazu*`)`.</span><span class="sxs-lookup"><span data-stu-id="e0397-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="e0397-200">Tato funkce umožňuje modul regulárních výrazů ke sledování vnořené konstruktory, jako jsou závorky nebo levé a pravé závorky.</span><span class="sxs-lookup"><span data-stu-id="e0397-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="e0397-201">Příklad, naleznete v části [seskupení vytvoří](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="e0397-202">Bez mechanismu navrácení podvýrazy (také označované jako typu greedy podvýrazy): `(?>` *dílčím výrazu*`)`.</span><span class="sxs-lookup"><span data-stu-id="e0397-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="e0397-203">Tato funkce umožňuje, aby navrácení modul zaručit, že dílčím výrazu odpovídá pouze na první shodu nalezeno pro tento dílčím výrazu, jako by byla spuštěna nezávislé jejího výrazu obsahujícího výraz.</span><span class="sxs-lookup"><span data-stu-id="e0397-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="e0397-204">Pokud nepoužijete tento konstrukce, navrácení vyhledávání z větší výrazu můžete změnit chování dílčím výrazu.</span><span class="sxs-lookup"><span data-stu-id="e0397-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="e0397-205">Například regulární výraz `(a+)\w` odpovídá jeden nebo více znaků "a, společně s word znak, který odpovídá pořadí znaků"a"a přiřadí posloupnost znaků"a"první zachycující skupiny, ale" pokud posledním znakem vstupní řetězec je také "a", it má odpovídající `\w` element jazyk, který není zahrnut ve skupině zaznamenané.</span><span class="sxs-lookup"><span data-stu-id="e0397-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="e0397-206">Regulární výraz `((?>a+))\w` brání toto chování.</span><span class="sxs-lookup"><span data-stu-id="e0397-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="e0397-207">Protože všechny po sobě jdoucích znaků "a" se splní bez zpětné navracení, první zaznamenávání skupina zahrnuje všechny po sobě jdoucích znaků "a".</span><span class="sxs-lookup"><span data-stu-id="e0397-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="e0397-208">Pokud znaků "a" nejsou následuje nejméně jeden znak více než "a", shody se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="e0397-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="e0397-209">Další informace o bez mechanismu navrácení podvýrazy najdete v tématu [seskupení vytvoří](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="e0397-210">Doleva párování, který je určený zadáním <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> možnost k <xref:System.Text.RegularExpressions.Regex> konstruktoru třídy nebo statické odpovídající metodu instance.</span><span class="sxs-lookup"><span data-stu-id="e0397-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="e0397-211">Tato funkce je užitečná při hledání zprava doleva místo zleva doprava nebo v případech, kdy je efektivnější zahájíte porovnávání na pravou část vzoru místo doleva.</span><span class="sxs-lookup"><span data-stu-id="e0397-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="e0397-212">Jak ukazuje následující příklad, porovnáváním zprava doleva můžete změnit chování typu greedy kvantifikátory.</span><span class="sxs-lookup"><span data-stu-id="e0397-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="e0397-213">V příkladu provede dvě vyhledá věty, které končí číslem.</span><span class="sxs-lookup"><span data-stu-id="e0397-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="e0397-214">Vyhledávání zleva doprava, který používá typu greedy kvantifikátoru `+` odpovídá jednomu z šesti číslic ve větě, zatímco hledání zprava doleva odpovídá všech šest číslic.</span><span class="sxs-lookup"><span data-stu-id="e0397-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="e0397-215">Popis regulární výraz podívejte se na příklad, který znázorňuje líné kvantifikátory dříve v této části.</span><span class="sxs-lookup"><span data-stu-id="e0397-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="e0397-216">Další informace o hledání shody zprava doleva najdete v tématu [možnosti regulárních výrazů](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
-   <span data-ttu-id="e0397-217">Kladné a záporné zpětného vyhledávání: `(?<=` *dílčím výrazu* `)` pro pozitivní zpětného vyhledávání, a `(?<!` *dílčím výrazu* `)` pro negativního zpětného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="e0397-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="e0397-218">Tato funkce je podobná dopředného vyhledávání, která je popsána dříve v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="e0397-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="e0397-219">Vzhledem k tomu, že modul regulárních výrazů umožňuje dokončení odpovídající zprava doleva, regulární výrazy Povolit neomezené konstrukce lookbehind.</span><span class="sxs-lookup"><span data-stu-id="e0397-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="e0397-220">Abyste se vyhnuli vnoření kvantifikátory při vnořené dílčím výrazu je nadmnožinou vnější výrazu se lze také kladné a záporné zpětného vyhledávání.</span><span class="sxs-lookup"><span data-stu-id="e0397-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="e0397-221">Regulární výrazy se takový vnořené kvantifikátory často nabízejí snížený výkon.</span><span class="sxs-lookup"><span data-stu-id="e0397-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="e0397-222">Například v následujícím příkladu ověřuje, že řetězec zahájení a ukončení alfanumerickým znakem a že další znak v řetězci je jednou z podmnožinu větší.</span><span class="sxs-lookup"><span data-stu-id="e0397-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="e0397-223">Tvoří část regulární výraz používaný k ověření e-mailové adresy; Další informace najdete v tématu [postup: Ověřte, zda jsou řetězce v platném formátu e-mailu](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="e0397-224">Regulární výraz `^[A-Z0-9]([-!#$%&'.*+/=?^`{} | ~ \w])* (? < = [A-Z0-9]) $"je definován, jak je znázorněno v následující tabulce.</span><span class="sxs-lookup"><span data-stu-id="e0397-224">The regular expression `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])\*(?<=[A-Z0-9])$\` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="e0397-225">Vzor</span><span class="sxs-lookup"><span data-stu-id="e0397-225">Pattern</span></span>|<span data-ttu-id="e0397-226">Popis</span><span class="sxs-lookup"><span data-stu-id="e0397-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="e0397-227">Začne porovnávání na začátku řetězce.</span><span class="sxs-lookup"><span data-stu-id="e0397-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="e0397-228">Porovná libovolný znak číselné nebo alfanumerické znaky.</span><span class="sxs-lookup"><span data-stu-id="e0397-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="e0397-229">(Porovnání se velká a malá písmena.)</span><span class="sxs-lookup"><span data-stu-id="e0397-229">(The comparison is case-insensitive.)</span></span>|  
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])*<code>|<span data-ttu-id="e0397-230">Porovná nula nebo více výskytů libovolný znak, nebo libovolná z následujících znaků:-,!, #, $, % &,:,., \*, +, /, =,?, ^, \`, {,}, &#124; nebo ~.</span><span class="sxs-lookup"><span data-stu-id="e0397-230">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, \`, {, }, &#124;, or ~.</span></span>|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="e0397-231">Vyhledejte za předchozí znak, který musí být číselné nebo alfanumerické znaky.</span><span class="sxs-lookup"><span data-stu-id="e0397-231">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="e0397-232">(Porovnání se velká a malá písmena.)</span><span class="sxs-lookup"><span data-stu-id="e0397-232">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="e0397-233">Ukončí porovnávání na konci řetězce.</span><span class="sxs-lookup"><span data-stu-id="e0397-233">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="e0397-234">Další informace o kladné a záporné zpětného vyhledávání najdete v tématu [seskupení vytvoří](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e0397-234">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="e0397-235">Související témata</span><span class="sxs-lookup"><span data-stu-id="e0397-235">Related Topics</span></span>  
  
|<span data-ttu-id="e0397-236">Název</span><span class="sxs-lookup"><span data-stu-id="e0397-236">Title</span></span>|<span data-ttu-id="e0397-237">Popis</span><span class="sxs-lookup"><span data-stu-id="e0397-237">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="e0397-238">Zpětné navracení</span><span class="sxs-lookup"><span data-stu-id="e0397-238">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="e0397-239">Poskytuje informace o tom, jak regulární výraz zpětné navracení větví najít alternativní shody.</span><span class="sxs-lookup"><span data-stu-id="e0397-239">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="e0397-240">Kompilace a opětovné používání</span><span class="sxs-lookup"><span data-stu-id="e0397-240">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="e0397-241">Poskytuje informace o kompilace a opětovné použití regulárních výrazů pro zvýšení výkonu.</span><span class="sxs-lookup"><span data-stu-id="e0397-241">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="e0397-242">Bezpečnost vlákna</span><span class="sxs-lookup"><span data-stu-id="e0397-242">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="e0397-243">Poskytuje informace o zabezpečení vlákna regulární výraz a vysvětluje, kdy bude třeba synchronizovat přístup k objektům regulární výraz.</span><span class="sxs-lookup"><span data-stu-id="e0397-243">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="e0397-244">Regulární výrazy rozhraní .NET framework</span><span class="sxs-lookup"><span data-stu-id="e0397-244">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="e0397-245">Poskytuje přehled programovací jazyk aspektů regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="e0397-245">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="e0397-246">Model objektu regulárního výrazu</span><span class="sxs-lookup"><span data-stu-id="e0397-246">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="e0397-247">Poskytuje informace a příklady kódu znázorňující způsob použití třídy regulárních výrazů.</span><span class="sxs-lookup"><span data-stu-id="e0397-247">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="e0397-248">Příklady regulárních výrazů</span><span class="sxs-lookup"><span data-stu-id="e0397-248">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="e0397-249">Obsahuje příklady kódu, které ilustrují použití regulárních výrazů v běžné aplikace.</span><span class="sxs-lookup"><span data-stu-id="e0397-249">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="e0397-250">Jazyk regulárních výrazů – stručná referenční dokumentace</span><span class="sxs-lookup"><span data-stu-id="e0397-250">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="e0397-251">Poskytuje informace o sadě znaků, operátory a konstrukce, které můžete použít k definování regulární výrazy.</span><span class="sxs-lookup"><span data-stu-id="e0397-251">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="e0397-252">Odkaz</span><span class="sxs-lookup"><span data-stu-id="e0397-252">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
