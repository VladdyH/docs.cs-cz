---
title: "Asynchronní volání synchronních metod"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- asynchronous programming, delegates
- asynchronous delegates
- AsyncWaitHandle property
- callback methods
- calling synchronous methods in asynchronous manner
- WaitHandle class, code examples
- asynchronous programming, status polling
- polling asynchronous operation status
- delegates [.NET Framework], asynchronous
- synchronous calling in asynchronous manner
- waiting for asynchronous calls
- status information [.NET Framework], asynchronous operations
ms.assetid: 41972034-92ed-450a-9664-ab93fcc6f1fb
caps.latest.revision: "24"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 965e5928c03ae573eacba98a7596f55b56aaba26
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/21/2017
---
# <a name="calling-synchronous-methods-asynchronously"></a><span data-ttu-id="f9b6f-102">Asynchronní volání synchronních metod</span><span class="sxs-lookup"><span data-stu-id="f9b6f-102">Calling Synchronous Methods Asynchronously</span></span>
<span data-ttu-id="f9b6f-103">Rozhraní .NET Framework umožňuje libovolné metody asynchronní volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-103">The .NET Framework enables you to call any method asynchronously.</span></span> <span data-ttu-id="f9b6f-104">K tomu můžete definovat delegáta se stejným podpisem jako metodu, kterou chcete volat; modul common language runtime automaticky definuje `BeginInvoke` a `EndInvoke` metody pro tento delegát s odpovídajícími podpisy.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-104">To do this you define a delegate with the same signature as the method you want to call; the common language runtime automatically defines `BeginInvoke` and `EndInvoke` methods for this delegate, with the appropriate signatures.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f9b6f-105">Volá asynchronní delegáta, konkrétně `BeginInvoke` a `EndInvoke` metody, nejsou podporovány v rozhraní .NET Compact Framework.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-105">Asynchronous delegate calls, specifically the `BeginInvoke` and `EndInvoke` methods, are not supported in the .NET Compact Framework.</span></span>  
  
 <span data-ttu-id="f9b6f-106">`BeginInvoke` Metoda iniciuje asynchronní volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-106">The `BeginInvoke` method initiates the asynchronous call.</span></span> <span data-ttu-id="f9b6f-107">Má stejné parametry jako metodu, kterou chcete provést asynchronně plus dva další volitelné parametry.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-107">It has the same parameters as the method that you want to execute asynchronously, plus two additional optional parameters.</span></span> <span data-ttu-id="f9b6f-108">První parametr je <xref:System.AsyncCallback> delegáta, který odkazuje na metodu, která se má volat po dokončení asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-108">The first parameter is an <xref:System.AsyncCallback> delegate that references a method to be called when the asynchronous call completes.</span></span> <span data-ttu-id="f9b6f-109">Druhý parametr je objekt definovaný uživatelem, který předává informace do metoda zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-109">The second parameter is a user-defined object that passes information into the callback method.</span></span> <span data-ttu-id="f9b6f-110">`BeginInvoke`Vrátí okamžitě a nečeká na dokončení asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-110">`BeginInvoke` returns immediately and does not wait for the asynchronous call to complete.</span></span> <span data-ttu-id="f9b6f-111">`BeginInvoke`Vrátí <xref:System.IAsyncResult>, které lze použít pro monitorování průběhu asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-111">`BeginInvoke` returns an <xref:System.IAsyncResult>, which can be used to monitor the progress of the asynchronous call.</span></span>  
  
 <span data-ttu-id="f9b6f-112">`EndInvoke` Metoda načítá výsledek asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-112">The `EndInvoke` method retrieves the results of the asynchronous call.</span></span> <span data-ttu-id="f9b6f-113">Může být volána kdykoli po `BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-113">It can be called any time after `BeginInvoke`.</span></span> <span data-ttu-id="f9b6f-114">Pokud asynchronního volání nebyla dokončena, `EndInvoke` blokuje volající vlákno, dokud nebude dokončena.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-114">If the asynchronous call has not completed, `EndInvoke` blocks the calling thread until it completes.</span></span> <span data-ttu-id="f9b6f-115">Parametry `EndInvoke` zahrnují `out` a `ref` parametry (`<Out>` `ByRef` a `ByRef` v jazyce Visual Basic) metody, která se má provést asynchronně, a <xref:System.IAsyncResult> vrácený `BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-115">The parameters of `EndInvoke` include the `out` and `ref` parameters (`<Out>` `ByRef` and `ByRef` in Visual Basic) of the method that you want to execute asynchronously, plus the <xref:System.IAsyncResult> returned by `BeginInvoke`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f9b6f-116">Funkci IntelliSense v [!INCLUDE[vsprvslong](../../../includes/vsprvslong-md.md)] zobrazí parametry `BeginInvoke` a `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-116">The IntelliSense feature in [!INCLUDE[vsprvslong](../../../includes/vsprvslong-md.md)] displays the parameters of `BeginInvoke` and `EndInvoke`.</span></span> <span data-ttu-id="f9b6f-117">Pokud nepoužíváte Visual Studio nebo podobného nástroje, nebo pokud používáte C# s použitím [!INCLUDE[vsprvslong](../../../includes/vsprvslong-md.md)], najdete v části [asynchronní programování modelu (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) popis parametrů definovaných pro tyto metody.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-117">If you are not using Visual Studio or a similar tool, or if you are using C# with [!INCLUDE[vsprvslong](../../../includes/vsprvslong-md.md)], see [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) for a description of the parameters defined for these methods.</span></span>  
  
 <span data-ttu-id="f9b6f-118">Příklady kódu v tomto tématu ukazují čtyři běžné způsoby použití `BeginInvoke` a `EndInvoke` asynchronní volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-118">The code examples in this topic demonstrate four common ways to use `BeginInvoke` and `EndInvoke` to make asynchronous calls.</span></span> <span data-ttu-id="f9b6f-119">Po volání `BeginInvoke` můžete provést následující:</span><span class="sxs-lookup"><span data-stu-id="f9b6f-119">After calling `BeginInvoke` you can do the following:</span></span>  
  
-   <span data-ttu-id="f9b6f-120">Provést některé fungovat a pak zavolají `EndInvoke` blok, dokud se nedokončí volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-120">Do some work and then call `EndInvoke` to block until the call completes.</span></span>  
  
-   <span data-ttu-id="f9b6f-121">Získat <xref:System.Threading.WaitHandle> pomocí <xref:System.IAsyncResult.AsyncWaitHandle%2A?displayProperty=nameWithType> vlastnosti, použijte jeho <xref:System.Threading.WaitHandle.WaitOne%2A> metoda spouštění bloku až <xref:System.Threading.WaitHandle> signalizace a pak zavolají `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-121">Obtain a <xref:System.Threading.WaitHandle> using the <xref:System.IAsyncResult.AsyncWaitHandle%2A?displayProperty=nameWithType> property, use its <xref:System.Threading.WaitHandle.WaitOne%2A> method to block execution until the <xref:System.Threading.WaitHandle> is signaled, and then call `EndInvoke`.</span></span>  
  
-   <span data-ttu-id="f9b6f-122">Dotazování <xref:System.IAsyncResult> vrácený `BeginInvoke` určete po dokončení asynchronního volání a pak zavolají `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-122">Poll the <xref:System.IAsyncResult> returned by `BeginInvoke` to determine when the asynchronous call has completed, and then call `EndInvoke`.</span></span>  
  
-   <span data-ttu-id="f9b6f-123">Předání delegáta pro metody zpětného volání k `BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-123">Pass a delegate for a callback method to `BeginInvoke`.</span></span> <span data-ttu-id="f9b6f-124">Tuto metodu je spustit na <xref:System.Threading.ThreadPool> vláken po dokončení asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-124">The method is executed on a <xref:System.Threading.ThreadPool> thread when the asynchronous call completes.</span></span> <span data-ttu-id="f9b6f-125">Volání metody zpětného volání `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-125">The callback method calls `EndInvoke`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f9b6f-126">Bez ohledu na to, jaké metody můžete použít, vždy volat `EndInvoke` na dokončení asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-126">No matter which technique you use, always call `EndInvoke` to complete your asynchronous call.</span></span>  
  
## <a name="defining-the-test-method-and-asynchronous-delegate"></a><span data-ttu-id="f9b6f-127">Definování testovací metoda a asynchronní delegáta</span><span class="sxs-lookup"><span data-stu-id="f9b6f-127">Defining the Test Method and Asynchronous Delegate</span></span>  
 <span data-ttu-id="f9b6f-128">Příklady kódu ukazují různých způsobů volání stejnou metodu dlouho běžící `TestMethod`, asynchronně.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-128">The code examples that follow demonstrate various ways of calling the same long-running method, `TestMethod`, asynchronously.</span></span> <span data-ttu-id="f9b6f-129">`TestMethod` Metoda zobrazí zprávu konzoly pro zobrazení, zahájení zpracování, v režimu spánku několik sekund a pak ukončí.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-129">The `TestMethod` method displays a console message to show that it has begun processing, sleeps for a few seconds, and then ends.</span></span> <span data-ttu-id="f9b6f-130">`TestMethod`má `out` parametr k předvedení způsobu, jakým tyto parametry jsou přidány do signatur `BeginInvoke` a `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-130">`TestMethod` has an `out` parameter to demonstrate the way such parameters are added to the signatures of `BeginInvoke` and `EndInvoke`.</span></span> <span data-ttu-id="f9b6f-131">Dokáže zpracovat `ref` parametry podobně.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-131">You can handle `ref` parameters similarly.</span></span>  
  
 <span data-ttu-id="f9b6f-132">Následující příklad kódu ukazuje definici `TestMethod` a delegáta s názvem `AsyncMethodCaller` který lze použít k volání `TestMethod` asynchronně.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-132">The following code example shows the definition of `TestMethod` and the delegate named `AsyncMethodCaller` that can be used to call `TestMethod` asynchronously.</span></span> <span data-ttu-id="f9b6f-133">Kompilace ukázky kódu, musí obsahovat definice pro `TestMethod` a `AsyncMethodCaller` delegovat.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-133">To compile the code examples, you must include the definitions for `TestMethod` and the `AsyncMethodCaller` delegate.</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#1](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
  
## <a name="waiting-for-an-asynchronous-call-with-endinvoke"></a><span data-ttu-id="f9b6f-134">Čekání na asynchronní volání s EndInvoke –</span><span class="sxs-lookup"><span data-stu-id="f9b6f-134">Waiting for an Asynchronous Call with EndInvoke</span></span>  
 <span data-ttu-id="f9b6f-135">Nejjednodušší způsob, jak provedení metody asynchronně je spustit provedení metody voláním delegáta `BeginInvoke` metoda, některé pracovat na hlavní vlákno a pak zavolají delegáta `EndInvoke` metoda.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-135">The simplest way to execute a method asynchronously is to start executing the method by calling the delegate's `BeginInvoke` method, do some work on the main thread, and then call the delegate's `EndInvoke` method.</span></span> <span data-ttu-id="f9b6f-136">`EndInvoke`volající vlákno mohou blokovat, protože nevrací až po dokončení asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-136">`EndInvoke` might block the calling thread because it does not return until the asynchronous call completes.</span></span> <span data-ttu-id="f9b6f-137">To je dobrý technika pro použití s soubor nebo síťové operace.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-137">This is a good technique to use with file or network operations.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f9b6f-138">Protože `EndInvoke` mohou blokovat, můžete by měly nikdy volat z vlákna, které služeb uživatelské rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-138">Because `EndInvoke` might block, you should never call it from threads that service the user interface.</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#2](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/EndInvoke.cpp#2)]
 [!code-csharp[AsyncDelegateExamples#2](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/EndInvoke.cs#2)]
 [!code-vb[AsyncDelegateExamples#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/EndInvoke.vb#2)]  
  
## <a name="waiting-for-an-asynchronous-call-with-waithandle"></a><span data-ttu-id="f9b6f-139">Čekání na asynchronní volání s WaitHandle</span><span class="sxs-lookup"><span data-stu-id="f9b6f-139">Waiting for an Asynchronous Call with WaitHandle</span></span>  
 <span data-ttu-id="f9b6f-140">Můžete získat <xref:System.Threading.WaitHandle> pomocí <xref:System.IAsyncResult.AsyncWaitHandle%2A> vlastnost <xref:System.IAsyncResult> vrácený `BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-140">You can obtain a <xref:System.Threading.WaitHandle> by using the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> returned by `BeginInvoke`.</span></span> <span data-ttu-id="f9b6f-141"><xref:System.Threading.WaitHandle> Signalizace při dokončení asynchronní volání a počkejte, až ho voláním <xref:System.Threading.WaitHandle.WaitOne%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-141">The <xref:System.Threading.WaitHandle> is signaled when the asynchronous call completes, and you can wait for it by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="f9b6f-142">Pokud používáte <xref:System.Threading.WaitHandle>, můžete provést další zpracování před nebo po dokončení asynchronního volání, ale před voláním `EndInvoke` načíst výsledky.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-142">If you use a <xref:System.Threading.WaitHandle>, you can perform additional processing before or after the asynchronous call completes, but before calling `EndInvoke` to retrieve the results.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f9b6f-143">Popisovač čekání není uzavřený automaticky při volání `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-143">The wait handle is not closed automatically when you call `EndInvoke`.</span></span> <span data-ttu-id="f9b6f-144">Pokud je uvolnit všechny odkazy na popisovač čekání, systémové prostředky jsou uvolněny při uvolňování paměti získá popisovač čekání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-144">If you release all references to the wait handle, system resources are freed when garbage collection reclaims the wait handle.</span></span> <span data-ttu-id="f9b6f-145">Uvolnit systémové prostředky, jakmile budete hotovi, pomocí popisovač čekání, dispose to voláním <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-145">To free the system resources as soon as you are finished using the wait handle, dispose of it by calling the <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f9b6f-146">Uvolňování paměti funguje efektivněji, když na jedno použití objekty jsou explicitně zlikvidován.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-146">Garbage collection works more efficiently when disposable objects are explicitly disposed.</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#3](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
 [!code-csharp[AsyncDelegateExamples#3](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
 [!code-vb[AsyncDelegateExamples#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
## <a name="polling-for-asynchronous-call-completion"></a><span data-ttu-id="f9b6f-147">Dotazování na dokončení asynchronního volání</span><span class="sxs-lookup"><span data-stu-id="f9b6f-147">Polling for Asynchronous Call Completion</span></span>  
 <span data-ttu-id="f9b6f-148">Můžete použít <xref:System.IAsyncResult.IsCompleted%2A> vlastnost <xref:System.IAsyncResult> vrácený `BeginInvoke` pro zjišťování po dokončení asynchronního volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-148">You can use the <xref:System.IAsyncResult.IsCompleted%2A> property of the <xref:System.IAsyncResult> returned by `BeginInvoke` to discover when the asynchronous call completes.</span></span> <span data-ttu-id="f9b6f-149">Můžete to třeba udělat při provádění asynchronní volání z vlákna, které služby uživatelské rozhraní.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-149">You might do this when making the asynchronous call from a thread that services the user interface.</span></span> <span data-ttu-id="f9b6f-150">Dotazování pro dokončení umožňuje volající vlákno chcete pokračovat v provádění během asynchronního volání provede na <xref:System.Threading.ThreadPool> přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-150">Polling for completion allows the calling thread to continue executing while the asynchronous call executes on a <xref:System.Threading.ThreadPool> thread.</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#4](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/polling.cpp#4)]
 [!code-csharp[AsyncDelegateExamples#4](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/polling.cs#4)]
 [!code-vb[AsyncDelegateExamples#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/polling.vb#4)]  
  
## <a name="executing-a-callback-method-when-an-asynchronous-call-completes"></a><span data-ttu-id="f9b6f-151">Provádění metody zpětného volání při dokončení asynchronní volání</span><span class="sxs-lookup"><span data-stu-id="f9b6f-151">Executing a Callback Method When an Asynchronous Call Completes</span></span>  
 <span data-ttu-id="f9b6f-152">Pokud podproces, který iniciuje asynchronní volání nemusí být podproces, který zpracuje výsledky, je možné spustit metody zpětného volání při dokončení volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-152">If the thread that initiates the asynchronous call does not need to be the thread that processes the results, you can execute a callback method when the call completes.</span></span> <span data-ttu-id="f9b6f-153">Metoda zpětného volání, které se spouští na <xref:System.Threading.ThreadPool> přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-153">The callback method is executed on a <xref:System.Threading.ThreadPool> thread.</span></span>  
  
 <span data-ttu-id="f9b6f-154">Chcete-li použít metody zpětného volání, musíte zadat `BeginInvoke` <xref:System.AsyncCallback> delegáta, který představuje metoda zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-154">To use a callback method, you must pass `BeginInvoke` an <xref:System.AsyncCallback> delegate that represents the callback method.</span></span> <span data-ttu-id="f9b6f-155">Také můžete předat objekt, který obsahuje informace, které použije metoda zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-155">You can also pass an object that contains information to be used by the callback method.</span></span> <span data-ttu-id="f9b6f-156">Metoda zpětného volání, můžete převést <xref:System.IAsyncResult>, na které je jediný parametr metody zpětného volání <xref:System.Runtime.Remoting.Messaging.AsyncResult> objektu.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-156">In the callback method, you can cast the <xref:System.IAsyncResult>, which is the only parameter of the callback method, to an <xref:System.Runtime.Remoting.Messaging.AsyncResult> object.</span></span> <span data-ttu-id="f9b6f-157">Pak můžete použít <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A?displayProperty=nameWithType> vlastnost k získání delegáta, který byl použit k iniciujte hovor, takže můžete volat `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-157">You can then use the <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A?displayProperty=nameWithType> property to get the delegate that was used to initiate the call so that you can call `EndInvoke`.</span></span>  
  
 <span data-ttu-id="f9b6f-158">Poznámky na příkladu:</span><span class="sxs-lookup"><span data-stu-id="f9b6f-158">Notes on the example:</span></span>  
  
-   <span data-ttu-id="f9b6f-159">`threadId` Parametr `TestMethod` je `out` parametr ([`<Out>` `ByRef` v jazyce Visual Basic), takže jeho vstupní hodnota je používán nikdy `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-159">The `threadId` parameter of `TestMethod` is an `out` parameter ([`<Out>` `ByRef` in Visual Basic), so its input value is never used by `TestMethod`.</span></span> <span data-ttu-id="f9b6f-160">Předaný fiktivní proměnné `BeginInvoke` volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-160">A dummy variable is passed to the `BeginInvoke` call.</span></span> <span data-ttu-id="f9b6f-161">Pokud `threadId` měla parametr `ref` parametr (`ByRef` v jazyce Visual Basic), proměnná by mohl být na úrovni pole tak, aby ho může být předat do obou `BeginInvoke` a `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-161">If the `threadId` parameter were a `ref` parameter (`ByRef` in Visual Basic), the variable would have to be a class-level field so that it could be passed to both `BeginInvoke` and `EndInvoke`.</span></span>  
  
-   <span data-ttu-id="f9b6f-162">Informace o stavu, který je předán `BeginInvoke` je formátovací řetězec, který používá metoda zpětného volání k formátování zprávu výstup.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-162">The state information that is passed to `BeginInvoke` is a format string, which the callback method uses to format an output message.</span></span> <span data-ttu-id="f9b6f-163">Protože je předána jako typ <xref:System.Object>, informace o stavu musí před použitím přetypovat na typ správné.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-163">Because it is passed as type <xref:System.Object>, the state information must be cast to its proper type before it can be used.</span></span>  
  
-   <span data-ttu-id="f9b6f-164">Zpětné volání se provádí na <xref:System.Threading.ThreadPool> přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-164">The callback is made on a <xref:System.Threading.ThreadPool> thread.</span></span> <span data-ttu-id="f9b6f-165"><xref:System.Threading.ThreadPool>vlákna jsou vlákna na pozadí, které by neměly být aplikace spuštěna pokud hlavní vlákno skončí, takže hlavní vlákno v příkladu má do režimu spánku dostatečně dlouhou dobu na dokončení zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="f9b6f-165"><xref:System.Threading.ThreadPool> threads are background threads, which do not keep the application running if the main thread ends, so the main thread of the example has to sleep long enough for the callback to finish.</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#5](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
 [!code-csharp[AsyncDelegateExamples#5](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
 [!code-vb[AsyncDelegateExamples#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
## <a name="see-also"></a><span data-ttu-id="f9b6f-166">Viz také</span><span class="sxs-lookup"><span data-stu-id="f9b6f-166">See Also</span></span>  
 <xref:System.Delegate>  
 [<span data-ttu-id="f9b6f-167">Asynchronní vzor založený na událostech (EAP)</span><span class="sxs-lookup"><span data-stu-id="f9b6f-167">Event-based Asynchronous Pattern (EAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)
