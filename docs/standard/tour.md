---
title: "Přehled používání rozhraní .NET"
description: "Průvodce pomocí některé z hlavní funkce .NET."
keywords: "Rozhraní .NET, .NET core prohlídka, bezpečnost typů jazyky, nebezpečné, správa paměti, asynchronní programování"
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.openlocfilehash: 809f0eaddf298b0d6a57e217c2bcf5450675c3e9
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/18/2017
---
# <a name="tour-of-net"></a><span data-ttu-id="aac4e-104">Přehled používání rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="aac4e-104">Tour of .NET</span></span>

<span data-ttu-id="aac4e-105">Rozhraní .NET je platforma pro vývoj pro obecné účely.</span><span class="sxs-lookup"><span data-stu-id="aac4e-105">.NET is a general purpose development platform.</span></span> <span data-ttu-id="aac4e-106">Má několik klíčových funkcí, jako je podpora pro více programovacích jazyků, asynchronní a souběžných programovací modely a nativní interoperabilita umožňující širokou škálu scénářů napříč různými platformami.</span><span class="sxs-lookup"><span data-stu-id="aac4e-106">It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</span></span>

<span data-ttu-id="aac4e-107">Tento článek nabízí průvodce prostřednictvím některé klíčové funkce .NET.</span><span class="sxs-lookup"><span data-stu-id="aac4e-107">This article offers a guided tour through some of the key features of the .NET.</span></span> <span data-ttu-id="aac4e-108">Najdete v článku [součástí architektury .NET](components.md) tématu, dozvíte se o architektury součásti rozhraní .NET a co se používají pro.</span><span class="sxs-lookup"><span data-stu-id="aac4e-108">See the [.NET Architectural Components](components.md) topic to learn about the architectural pieces of .NET and what they're used for.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="aac4e-109">Postup spuštění ukázky kódu</span><span class="sxs-lookup"><span data-stu-id="aac4e-109">How to run the code samples</span></span>

<span data-ttu-id="aac4e-110">Zjistěte, jak nastavit vývojové prostředí pro spouštění ukázky kódu, najdete v článku [Začínáme](get-started.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-110">To learn how to set up a development environment to run the code samples, see the [Getting Started](get-started.md) topic.</span></span> <span data-ttu-id="aac4e-111">Zkopírujte a vložte do vašeho prostředí je spuštění ukázky kódu z této stránky.</span><span class="sxs-lookup"><span data-stu-id="aac4e-111">Copy and paste code samples from this page into your environment to execute them.</span></span> 

## <a name="programming-languages"></a><span data-ttu-id="aac4e-112">Programovací jazyky</span><span class="sxs-lookup"><span data-stu-id="aac4e-112">Programming languages</span></span>

<span data-ttu-id="aac4e-113">Rozhraní .NET podporuje více programovacích jazyků.</span><span class="sxs-lookup"><span data-stu-id="aac4e-113">.NET supports multiple programming languages.</span></span> <span data-ttu-id="aac4e-114">Implementace rozhraní .NET implementovat [společné jazykové infrastruktury (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), která kromě jiných věcí určuje nezávislé na jazyku runtime a jazyk interoperability.</span><span class="sxs-lookup"><span data-stu-id="aac4e-114">The .NET implementations implement the [Common Language Infrastructure (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), which among other things specifies a language-independent runtime and language interoperability.</span></span> <span data-ttu-id="aac4e-115">To znamená, že zvolíte kterémkoli jazyce platformy .NET k vytváření aplikací a služeb na rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="aac4e-115">This means that you choose any .NET language to build apps and services on .NET.</span></span>

<span data-ttu-id="aac4e-116">Microsoft aktivně vyvíjí a podporuje tři jazyky rozhraní .NET: C#, F # a Visual Basic (VB).</span><span class="sxs-lookup"><span data-stu-id="aac4e-116">Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic (VB).</span></span> 

* <span data-ttu-id="aac4e-117">C# je jednoduché, výkonné, bezpečnost typů a objektově orientované, a přitom zachovat expressiveness a eleganci jazyků C-style.</span><span class="sxs-lookup"><span data-stu-id="aac4e-117">C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</span></span> <span data-ttu-id="aac4e-118">Každý, kdo obeznámeni s podobnou jazyky C a vyhledá několik problémy s přizpůsobením jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="aac4e-118">Anyone familiar with C and similar languages finds few problems in adapting to C#.</span></span> <span data-ttu-id="aac4e-119">Podívejte se [průvodce v C#](../csharp/index.md) Další informace o C#.</span><span class="sxs-lookup"><span data-stu-id="aac4e-119">Check out the [C# Guide](../csharp/index.md) to learn more about C#.</span></span>

* <span data-ttu-id="aac4e-120">F # je napříč platformami, funkční programovací jazyk, který taky podporuje tradiční objektově orientované a imperativní programování.</span><span class="sxs-lookup"><span data-stu-id="aac4e-120">F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</span></span> <span data-ttu-id="aac4e-121">Podívejte se [Průvodce F #](../fsharp/index.md) Další informace o F #.</span><span class="sxs-lookup"><span data-stu-id="aac4e-121">Check out the [F# Guide](../fsharp/index.md) to learn more about F#.</span></span>

* <span data-ttu-id="aac4e-122">Visual Basic je snadno jazyk informace, že použijete k sestavení celou řadu aplikací, které běží na rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="aac4e-122">Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</span></span> <span data-ttu-id="aac4e-123">Mezi jazyky rozhraní .NET je nejblíže k obyčejnou lidského jazyk často usnadnit pro osoby pro vývoj softwaru nové syntaxe jazyka Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="aac4e-123">Among the .NET languages, the syntax of VB is the closest to ordinary human language, often making it easier for people new to software development.</span></span>

## <a name="automatic-memory-management"></a><span data-ttu-id="aac4e-124">Automatická správa paměti</span><span class="sxs-lookup"><span data-stu-id="aac4e-124">Automatic memory management</span></span>

<span data-ttu-id="aac4e-125">Používá rozhraní .NET [uvolňování paměti (GC)](garbagecollection/index.md) zajistit Automatická správa paměti pro programy.</span><span class="sxs-lookup"><span data-stu-id="aac4e-125">.NET uses [garbage collection (GC)](garbagecollection/index.md) to provide automatic memory management for programs.</span></span> <span data-ttu-id="aac4e-126">Globální Katalog funguje na opožděné přístup ke správě, paměti, upřednostňují propustnost aplikace ke kolekci okamžitou paměti.</span><span class="sxs-lookup"><span data-stu-id="aac4e-126">The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</span></span> <span data-ttu-id="aac4e-127">Další informace o .NET GC, podívejte se na [základy uvolnění paměti (GC)](garbagecollection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="aac4e-127">To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md).</span></span>

<span data-ttu-id="aac4e-128">Následující dva řádky obou přidělit paměť:</span><span class="sxs-lookup"><span data-stu-id="aac4e-128">The following two lines both allocate memory:</span></span>

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]

<span data-ttu-id="aac4e-129">Neexistuje žádné podobá – klíčové slovo zrušte přidělit paměť, protože deaktivace přidělení dojde automaticky při uvolňování paměti získá paměti prostřednictvím její naplánované spuštění.</span><span class="sxs-lookup"><span data-stu-id="aac4e-129">There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</span></span>

<span data-ttu-id="aac4e-130">Uvolňování paměti je jedna ze služeb, které pomůžou zajistit *bezpečnost paměti*.</span><span class="sxs-lookup"><span data-stu-id="aac4e-130">The garbage collector is one of the services that help ensure *memory safety*.</span></span> <span data-ttu-id="aac4e-131">Program je bezpečné, pokud přistupuje k paměti pouze přidělené paměti.</span><span class="sxs-lookup"><span data-stu-id="aac4e-131">A program is memory safe if it accesses only allocated memory.</span></span> <span data-ttu-id="aac4e-132">Modul runtime pro instanci zajišťuje, aby aplikace nemá přístup k volné paměti za hranice pole.</span><span class="sxs-lookup"><span data-stu-id="aac4e-132">For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</span></span>

<span data-ttu-id="aac4e-133">V následujícím příkladu, modul runtime vyvolá `InvalidIndexException` výjimka vynutit zabezpečení paměti:</span><span class="sxs-lookup"><span data-stu-id="aac4e-133">In the following example, the runtime throws an `InvalidIndexException` exception to enforce memory safety:</span></span>

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]

## <a name="working-with-unmanaged-resources"></a><span data-ttu-id="aac4e-134">Práce s nespravovaných prostředků</span><span class="sxs-lookup"><span data-stu-id="aac4e-134">Working with unmanaged resources</span></span>

<span data-ttu-id="aac4e-135">Některé objekty odkaz *nespravovaných prostředků*.</span><span class="sxs-lookup"><span data-stu-id="aac4e-135">Some objects reference *unmanaged resources*.</span></span> <span data-ttu-id="aac4e-136">Nespravované prostředky jsou prostředky, které nejsou spravovány automaticky modulem runtime rozhraní .NET.</span><span class="sxs-lookup"><span data-stu-id="aac4e-136">Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</span></span> <span data-ttu-id="aac4e-137">Popisovač souboru je například nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="aac4e-137">For example, a file handle is an unmanaged resource.</span></span> <span data-ttu-id="aac4e-138">A <xref:System.IO.FileStream> spravovaných objektů, ale odkazuje na popisovače souboru, který nebude spravován.</span><span class="sxs-lookup"><span data-stu-id="aac4e-138">A <xref:System.IO.FileStream> object is a managed object, but it references a file handle, which is unmanaged.</span></span> <span data-ttu-id="aac4e-139">Po dokončení pomocí <xref:System.IO.FileStream>, budete potřebovat uvolnit popisovač souboru.</span><span class="sxs-lookup"><span data-stu-id="aac4e-139">When you're done using the <xref:System.IO.FileStream>, you need to release the file handle.</span></span>

<span data-ttu-id="aac4e-140">V rozhraní .NET, objekty, které odkazují na nespravované prostředky implementovat <xref:System.IDisposable> rozhraní.</span><span class="sxs-lookup"><span data-stu-id="aac4e-140">In .NET, objects that reference unmanaged resources implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="aac4e-141">Po dokončení pomocí objektu, volání objektu <xref:System.IDisposable.Dispose> metodu, která je zodpovědná za uvolnění jakýchkoli nespravovaných prostředků.</span><span class="sxs-lookup"><span data-stu-id="aac4e-141">When you're done using the object, you call the object's <xref:System.IDisposable.Dispose> method, which is responsible for releasing any unmanaged resources.</span></span> <span data-ttu-id="aac4e-142">Zadejte jazyky rozhraní .NET pohodlnou `using` syntaxe pro objekty, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="aac4e-142">.NET languages provide a convenient `using` syntax for such objects, as shown in the following example:</span></span>

[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]

<span data-ttu-id="aac4e-143">Jednou `using` blok dokončení, modul runtime rozhraní .NET automaticky vyvolá `stream` objektu <xref:System.IDisposable.Dispose> metodu, která uvolní popisovač souboru.</span><span class="sxs-lookup"><span data-stu-id="aac4e-143">Once the `using` block completes, the .NET runtime automatically calls the `stream` object's <xref:System.IDisposable.Dispose> method, which releases the file handle.</span></span> <span data-ttu-id="aac4e-144">Modul runtime také tomu Pokud ovládací prvek chcete nechat bloku způsobí výjimku.</span><span class="sxs-lookup"><span data-stu-id="aac4e-144">The runtime also does this if an exception causes control to leave the block.</span></span>

<span data-ttu-id="aac4e-145">Další podrobnosti naleznete v následujících tématech:</span><span class="sxs-lookup"><span data-stu-id="aac4e-145">For more details, see the following topics:</span></span>

* <span data-ttu-id="aac4e-146">Pro jazyk C#, najdete v článku [using – příkaz (referenční dokumentace jazyka C#)](../csharp/language-reference/keywords/using-statement.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-146">For C#, see the [using Statement (C# Reference)](../csharp/language-reference/keywords/using-statement.md) topic.</span></span>
* <span data-ttu-id="aac4e-147">F #, najdete v části [Správa prostředků: klíčové slovo use](../fsharp/language-reference/resource-management-the-use-keyword.md).</span><span class="sxs-lookup"><span data-stu-id="aac4e-147">For F#, see [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md).</span></span>
* <span data-ttu-id="aac4e-148">VB, najdete v článku [pomocí – příkaz (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-148">For VB, see the [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) topic.</span></span>

## <a name="type-safety"></a><span data-ttu-id="aac4e-149">Zabezpečení typů</span><span class="sxs-lookup"><span data-stu-id="aac4e-149">Type safety</span></span>

<span data-ttu-id="aac4e-150">Objekt je instance určitého typu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-150">An object is an instance of a specific type.</span></span> <span data-ttu-id="aac4e-151">Jenom operace, které jsou povolené pro daný objekt se jeho typu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-151">The only operations allowed for a given object are those of its type.</span></span> <span data-ttu-id="aac4e-152">A `Dog` může mít typ `Jump` a `WagTail` metody ale ne `SumTotal` metoda.</span><span class="sxs-lookup"><span data-stu-id="aac4e-152">A `Dog` type may have `Jump` and `WagTail` methods but not a `SumTotal` method.</span></span> <span data-ttu-id="aac4e-153">Program pouze volá metody, které patří do daného typu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-153">A program only calls the methods belonging to a given type.</span></span> <span data-ttu-id="aac4e-154">Jiná volání za následek chyby kompilace nebo výjimka běhu (v případě použití dynamické funkcí nebo `object`).</span><span class="sxs-lookup"><span data-stu-id="aac4e-154">All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or `object`).</span></span>

<span data-ttu-id="aac4e-155">Jazyky rozhraní .NET jsou objektově orientované s hierarchií základní a odvozené třídy.</span><span class="sxs-lookup"><span data-stu-id="aac4e-155">.NET languages are object-oriented with hierarchies of base and derived classes.</span></span> <span data-ttu-id="aac4e-156">Modul runtime rozhraní .NET umožňuje pouze objekt přetypování a volání, které zarovnané s hierarchie objektů.</span><span class="sxs-lookup"><span data-stu-id="aac4e-156">The .NET runtime only allows object casts and calls that align with the object hierarchy.</span></span> <span data-ttu-id="aac4e-157">Mějte na paměti, každý typ definované v kterémkoli jazyce platformy .NET, pochází z základní <xref:System.Object> typu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-157">Remember that every type defined in any .NET language derives from the base <xref:System.Object> type.</span></span>

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L19-L23)]

<span data-ttu-id="aac4e-158">Zabezpečení typů se také používá tak, aby vynutitelné zapouzdření podle zaručit přesnost klíčová slova přistupujícího objektu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-158">Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</span></span> <span data-ttu-id="aac4e-159">Klíčová slova přistupujícího objektu se o artefakty, které řízení přístupu ke členům daného typu jiným kódem.</span><span class="sxs-lookup"><span data-stu-id="aac4e-159">Accessor keywords are artifacts which control access to members of a given type by other code.</span></span> <span data-ttu-id="aac4e-160">Ty se obvykle používají pro různé typy dat v rámci typu, která se používají ke správě své chování.</span><span class="sxs-lookup"><span data-stu-id="aac4e-160">These are usually used for various kinds of data within a type that are used to manage its behavior.</span></span>

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]

<span data-ttu-id="aac4e-161">C#, VB a F # podpora místní *odvození typu*.</span><span class="sxs-lookup"><span data-stu-id="aac4e-161">C#, VB, and F# support local *type inference*.</span></span> <span data-ttu-id="aac4e-162">Odvození typu znamená, že kompilátor deduces typ výraz na levé straně z výrazu na pravé straně.</span><span class="sxs-lookup"><span data-stu-id="aac4e-162">Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</span></span> <span data-ttu-id="aac4e-163">To neznamená, že je poškozený nebo vyhnout bezpečnost typů.</span><span class="sxs-lookup"><span data-stu-id="aac4e-163">This doesn't mean that the type safety is broken or avoided.</span></span> <span data-ttu-id="aac4e-164">Výsledný typ mít s všechno silné typ, který znamená.</span><span class="sxs-lookup"><span data-stu-id="aac4e-164">The resulting type does have a strong type with everything that implies.</span></span> <span data-ttu-id="aac4e-165">Z předchozího příkladu `dog` a `cat` jsou přepsaná zavádět odvození typu a zbytek v příkladu se neliší:</span><span class="sxs-lookup"><span data-stu-id="aac4e-165">From the previous example, `dog` and `cat` are rewritten to introduce type inference, and the remainder of the example is unchanged:</span></span>

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]

<span data-ttu-id="aac4e-166">F # má i další možnosti odvození typu než odvození typu metoda místní nalezených v C# a VB.</span><span class="sxs-lookup"><span data-stu-id="aac4e-166">F# has even further type inference capabilities than the method-local type inference found in C# and VB.</span></span> <span data-ttu-id="aac4e-167">Další informace najdete v tématu [odvození typu](../fsharp/language-reference/type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="aac4e-167">To learn more, see [Type Inference](../fsharp/language-reference/type-inference.md).</span></span>

## <a name="delegates-and-lambdas"></a><span data-ttu-id="aac4e-168">Delegáti a lambdas</span><span class="sxs-lookup"><span data-stu-id="aac4e-168">Delegates and lambdas</span></span>

<span data-ttu-id="aac4e-169">Delegát je reprezentována podpis metody.</span><span class="sxs-lookup"><span data-stu-id="aac4e-169">A delegate is represented by a method signature.</span></span> <span data-ttu-id="aac4e-170">Jakékoli metody této podpisem lze přiřadit k delegát a je proveden při vyvolání delegáta.</span><span class="sxs-lookup"><span data-stu-id="aac4e-170">Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</span></span>

<span data-ttu-id="aac4e-171">Delegáti jsou jako ukazatelů na funkce C++ s tím rozdílem, že jsou bezpečné typu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-171">Delegates are like C++ function pointers except that they're type safe.</span></span> <span data-ttu-id="aac4e-172">Jsou druh odpojené metoda v rámci systému typu CLR.</span><span class="sxs-lookup"><span data-stu-id="aac4e-172">They're a kind of disconnected method within the CLR type system.</span></span> <span data-ttu-id="aac4e-173">Běžné metody jsou připojené k třídu a jsou pouze přímo volány prostřednictvím statické nebo volání instance konvence.</span><span class="sxs-lookup"><span data-stu-id="aac4e-173">Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</span></span>

<span data-ttu-id="aac4e-174">V rozhraní .NET delegáti běžně se používají v obslužné rutiny událostí, definování asynchronních operací a v lambda – výrazy, které jsou kamenem LINQ.</span><span class="sxs-lookup"><span data-stu-id="aac4e-174">In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</span></span> <span data-ttu-id="aac4e-175">Další informace v [Delegáti a lambdas](delegates-lambdas.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-175">Learn more in the [Delegates and lambdas](delegates-lambdas.md) topic.</span></span>

## <a name="generics"></a><span data-ttu-id="aac4e-176">Obecné typy</span><span class="sxs-lookup"><span data-stu-id="aac4e-176">Generics</span></span>

<span data-ttu-id="aac4e-177">Obecné typy povolit programátorů zavádět *parametr typu* při navrhování jejich tříd, které umožňuje určit typ přesný používejte místo parametr typu kód klienta (uživatelé typu).</span><span class="sxs-lookup"><span data-stu-id="aac4e-177">Generics allow the programmer to introduce a *type parameter* when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</span></span>

<span data-ttu-id="aac4e-178">Obecné typy byla přidána k programátory implementovat obecné datové struktury.</span><span class="sxs-lookup"><span data-stu-id="aac4e-178">Generics were added to help programmers implement generic data structures.</span></span> <span data-ttu-id="aac4e-179">Před jejich přijetí v pořadí pro typ, jako `List` typ, který má být obecný, by musel pracovat s prvky, které byly typu `object`.</span><span class="sxs-lookup"><span data-stu-id="aac4e-179">Before their arrival in order for a type such as the `List` type to be generic, it would have to work with elements that were of type `object`.</span></span> <span data-ttu-id="aac4e-180">To mělo různé výkonu a sémantické problémy, společně s chyby možné jemně za běhu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-180">This had various performance and semantic problems, along with possible subtle runtime errors.</span></span> <span data-ttu-id="aac4e-181">Většina notorious z k tomu je datová struktura obsahuje například celá čísla i řetězce a `InvalidCastException` je vyvolána o práci se členy v seznamu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-181">The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an `InvalidCastException` is thrown on working with the list's members.</span></span>

<span data-ttu-id="aac4e-182">Následující příklad ukazuje základní program spuštěný pomocí instance <xref:System.Collections.Generic.List%601> typy:</span><span class="sxs-lookup"><span data-stu-id="aac4e-182">The following sample shows a basic program running using an instance of <xref:System.Collections.Generic.List%601> types:</span></span>

[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]

<span data-ttu-id="aac4e-183">Další informace najdete v tématu [obecné typy (Obecné) – přehled](generics.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-183">For more information, see the [Generic types (Generics) overview](generics.md) topic.</span></span>

## <a name="async-programming"></a><span data-ttu-id="aac4e-184">Asynchronní programování</span><span class="sxs-lookup"><span data-stu-id="aac4e-184">Async programming</span></span>

<span data-ttu-id="aac4e-185">Asynchronní programování je první třídy koncept v rámci .NET asynchronní podpora v modulu runtime knihoven, a vytvoří jazyce platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="aac4e-185">Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</span></span> <span data-ttu-id="aac4e-186">Interně založených na objekty (například `Task`), který využít výhod operačního systému na co možná nejefektivnější provádět I/čítači úlohy.</span><span class="sxs-lookup"><span data-stu-id="aac4e-186">Internally, they're based on objects (such as `Task`), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</span></span>

<span data-ttu-id="aac4e-187">Další informace o asynchronní programování v rozhraní .NET, začínat [přehled asynchronních](async.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-187">To learn more about async programming in .NET, start with the [Async overview](async.md) topic.</span></span>

## <a name="language-integrated-query-linq"></a><span data-ttu-id="aac4e-188">Jazyk integrovaného dotazu (LINQ)</span><span class="sxs-lookup"><span data-stu-id="aac4e-188">Language Integrated Query (LINQ)</span></span>

<span data-ttu-id="aac4e-189">LINQ je výkonnou sadu funkcí pro C# a VB, které vám umožní napsat jednoduchý a deklarativní kód pro provoz na data.</span><span class="sxs-lookup"><span data-stu-id="aac4e-189">LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</span></span> <span data-ttu-id="aac4e-190">Data mohou být v mnoha formulářích (například objekty v paměti, databázi SQL nebo dokument XML), ale není zdrojem dat liší LINQ kód, který obvykle napíšete.</span><span class="sxs-lookup"><span data-stu-id="aac4e-190">The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</span></span>

<span data-ttu-id="aac4e-191">Další informace a zobrazit některé ukázky, najdete v článku [LINQ (Language integrovaného dotazu)](using-linq.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-191">To learn more and see some samples, see the [LINQ (Language Integrated Query)](using-linq.md) topic.</span></span>

## <a name="native-interoperability"></a><span data-ttu-id="aac4e-192">Nativní interoperabilita</span><span class="sxs-lookup"><span data-stu-id="aac4e-192">Native interoperability</span></span>

<span data-ttu-id="aac4e-193">Každý operační systém, zahrnuje programovací rozhraní aplikace (API), která poskytuje systémových služeb.</span><span class="sxs-lookup"><span data-stu-id="aac4e-193">Every operating system includes an application programming interface (API) that provides system services.</span></span> <span data-ttu-id="aac4e-194">Rozhraní .NET poskytuje několik způsobů, jak volat těchto rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="aac4e-194">.NET provides several ways to call those APIs.</span></span>

<span data-ttu-id="aac4e-195">Hlavní způsob k provedení nativní Interoperabilita je prostřednictvím "vyvolání platformy" nebo P/Invoke pro zkrácení, která je podporována mezi platformami, Linux a Windows.</span><span class="sxs-lookup"><span data-stu-id="aac4e-195">The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</span></span> <span data-ttu-id="aac4e-196">Pouze pro systém Windows způsob, jakým způsobem nativní interoperabilita se označuje jako "COM interoperabilita", který se používá pro práci s [COM – součásti](https://msdn.microsoft.com/library/bwa2bx93.aspx) ve spravovaném kódu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-196">A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code.</span></span> <span data-ttu-id="aac4e-197">Je postavená na infrastruktuře P/Invoke, ale funguje trochu různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="aac4e-197">It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</span></span>

<span data-ttu-id="aac4e-198">Většina na Mono (a proto je Xamarin) podpory interoperability Java a jazyka Objective-C jsou vytvořeny podobně, to znamená, že použít stejné zásady.</span><span class="sxs-lookup"><span data-stu-id="aac4e-198">Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</span></span>

<span data-ttu-id="aac4e-199">Další informace o nativní interoperabilita v [nativní interoperabilita](native-interop.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-199">Read more about it native interoperability in the [Native interoperability](native-interop.md) topic.</span></span>

## <a name="unsafe-code"></a><span data-ttu-id="aac4e-200">Nezabezpečený kód</span><span class="sxs-lookup"><span data-stu-id="aac4e-200">Unsafe code</span></span>

<span data-ttu-id="aac4e-201">V závislosti na podpoře jazyka modulu CLR vám umožní přístup k paměti nativní a provést aritmetika ukazatele prostřednictvím `unsafe` kódu.</span><span class="sxs-lookup"><span data-stu-id="aac4e-201">Depending on language support, the CLR lets you access native memory and do pointer arithmetic via `unsafe` code.</span></span> <span data-ttu-id="aac4e-202">Tyto operace jsou potřebné pro určité algoritmů a interoperability systému.</span><span class="sxs-lookup"><span data-stu-id="aac4e-202">These operations are needed for certain algorithms and system interoperability.</span></span> <span data-ttu-id="aac4e-203">I když výkonné, použití nezabezpečený kód se nedoporučuje, pokud je potřeba Interoperabilita s rozhraní API systému nebo implementovat algoritmus maximální efektivitou.</span><span class="sxs-lookup"><span data-stu-id="aac4e-203">Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</span></span> <span data-ttu-id="aac4e-204">Nezabezpečený kód nemusí spustit stejným způsobem jako v různých prostředích a také ztratí výhody systém uvolňování paměti a bezpečnost typů.</span><span class="sxs-lookup"><span data-stu-id="aac4e-204">Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</span></span> <span data-ttu-id="aac4e-205">Se doporučuje omezit a centralizovat co nejvíce nezabezpečený kód a důkladně otestovat tento kód.</span><span class="sxs-lookup"><span data-stu-id="aac4e-205">It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</span></span>

<span data-ttu-id="aac4e-206">Následující příklad je upravenou verzi `ToString()` metoda z `StringBuilder` třídy.</span><span class="sxs-lookup"><span data-stu-id="aac4e-206">The following example is a modified version of the `ToString()` method from the `StringBuilder` class.</span></span> <span data-ttu-id="aac4e-207">Ukazuje, jak pomocí `unsafe` kódu můžete efektivně implementovat algoritmus přímo přesunutím kolem bloky paměti:</span><span class="sxs-lookup"><span data-stu-id="aac4e-207">It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:</span></span>

[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]

## <a name="next-steps"></a><span data-ttu-id="aac4e-208">Další kroky</span><span class="sxs-lookup"><span data-stu-id="aac4e-208">Next steps</span></span>

<span data-ttu-id="aac4e-209">Pokud vás zajímá prohlídku funkcí jazyka C#, podívejte se na [prohlídka z jazyka C#](../csharp/tour-of-csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="aac4e-209">If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).</span></span>

<span data-ttu-id="aac4e-210">Pokud vás zajímá prohlídku funkcí F #, přečtěte si téma [prohlídka z F #](../fsharp/tour.md).</span><span class="sxs-lookup"><span data-stu-id="aac4e-210">If you're interested in a tour of F# features, see [Tour of F#](../fsharp/tour.md).</span></span>

<span data-ttu-id="aac4e-211">Pokud chcete začít vytvářet kód vlastní, navštivte [Začínáme](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="aac4e-211">If you want to get started with writing code of your own, visit [Getting Started](get-started.md).</span></span>

<span data-ttu-id="aac4e-212">Další informace o důležité součásti rozhraní .NET, podívejte se na [součástí architektury .NET](components.md).</span><span class="sxs-lookup"><span data-stu-id="aac4e-212">To learn about important components of .NET, check out [.NET Architectural Components](components.md).</span></span>
