---
title: "Společné architektury webové aplikace"
description: "Architektury moderních webových aplikací pomocí ASP.NET Core a Microsoft Azure | společné architektury webové aplikace"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: dc5580d38ac29a5e923a4b7d84f9d7e077d5cdb2
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/23/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="2eef4-103">Společné architektury webové aplikace</span><span class="sxs-lookup"><span data-stu-id="2eef4-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="2eef4-104">"Pokud se domníváte, že je dobré architektura náročná, zkuste architektura chybné."</span><span class="sxs-lookup"><span data-stu-id="2eef4-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="2eef4-105">_-Brian zápatí a Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="2eef4-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="2eef4-106">Souhrn</span><span class="sxs-lookup"><span data-stu-id="2eef4-106">Summary</span></span>

<span data-ttu-id="2eef4-107">Většina tradičních aplikací .NET jsou nasazeny jako jedné jednotky odpovídající spustitelný soubor nebo jedné webové aplikace běžící v rámci jedné domény aplikace služby IIS.</span><span class="sxs-lookup"><span data-stu-id="2eef4-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="2eef4-108">Toto je nejjednodušší model nasazení a velmi dobře slouží mnoho interních a veřejných menší aplikací.</span><span class="sxs-lookup"><span data-stu-id="2eef4-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="2eef4-109">Ale i zadána tato jedné jednotky nasazení nejvíce netriviální obchodních aplikací těžit z některé logického oddělení do několika vrstev.</span><span class="sxs-lookup"><span data-stu-id="2eef4-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="2eef4-110">Co je monolitický aplikace?</span><span class="sxs-lookup"><span data-stu-id="2eef4-110">What is a monolithic application?</span></span>

<span data-ttu-id="2eef4-111">Monolitický aplikace je ten, který je zcela samostatné, z hlediska své chování.</span><span class="sxs-lookup"><span data-stu-id="2eef4-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="2eef4-112">Může komunikovat s další služby nebo datové úložiště v průběhu provádění jeho operací, ale základní své chování běží v rámci vlastní proces a bude celá aplikace se obvykle nasazují jako na jednu jednotku.</span><span class="sxs-lookup"><span data-stu-id="2eef4-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="2eef4-113">Pokud je takové aplikace je potřeba škálovat horizontálně, obvykle v celé aplikaci duplicitní mezi více serverů nebo virtuální počítače.</span><span class="sxs-lookup"><span data-stu-id="2eef4-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="2eef4-114">Aplikace: 1</span><span class="sxs-lookup"><span data-stu-id="2eef4-114">All-in-One applications</span></span>

<span data-ttu-id="2eef4-115">Nejmenší možný počet projekty pro architekturu aplikace je jedna.</span><span class="sxs-lookup"><span data-stu-id="2eef4-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="2eef4-116">V této architektuře celý logiku aplikace obsažené v jednom projektu, zkompilovány do jednoho sestavení a nasadit jako na jednu jednotku.</span><span class="sxs-lookup"><span data-stu-id="2eef4-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="2eef4-117">Nový projekt ASP.NET Core, vytvořené v sadě Visual Studio nebo z příkazového řádku, spustí jako jednoduchý monolitu "vše v jednom".</span><span class="sxs-lookup"><span data-stu-id="2eef4-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="2eef4-118">Obsahuje všechny chování aplikace, včetně přístupu logiku prezentační, obchodní a data.</span><span class="sxs-lookup"><span data-stu-id="2eef4-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="2eef4-119">Obrázek 5-1 zobrazuje strukturu souborů jednoprojektové aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="2eef4-120">**Obrázek 5-1.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-120">**Figure 5-1.**</span></span> <span data-ttu-id="2eef4-121">Jeden projektu aplikace ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="2eef4-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="2eef4-122">V případě jedné projektu oddělené oblasti zájmu se dosahuje prostřednictvím složky.</span><span class="sxs-lookup"><span data-stu-id="2eef4-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="2eef4-123">Výchozí šablony obsahuje samostatné složky pro odpovědnosti vzor MVC modely, zobrazení, a řadiče, a také další složky pro Data a služby.</span><span class="sxs-lookup"><span data-stu-id="2eef4-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="2eef4-124">V tomto případě prezentace podrobnosti by měl být omezeny co nejvíce do složky, zobrazení a podrobnosti implementace přístup data by měla být omezená na třídy zachovány ve složce Data.</span><span class="sxs-lookup"><span data-stu-id="2eef4-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="2eef4-125">Obchodní logika by měl být umístěn v služeb a tříd v rámci složku modely.</span><span class="sxs-lookup"><span data-stu-id="2eef4-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="2eef4-126">I když je jednoduchý, má monolitický řešení jednoprojektové některé nevýhody.</span><span class="sxs-lookup"><span data-stu-id="2eef4-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="2eef4-127">S růstem velikost a složitost projektu pořád roste s tím také počet souborů a složek.</span><span class="sxs-lookup"><span data-stu-id="2eef4-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="2eef4-128">Otázky uživatelského rozhraní (modely, zobrazení, řadiče) jsou umístěny ve více složkách, které nejsou seskupeny podle abecedy.</span><span class="sxs-lookup"><span data-stu-id="2eef4-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="2eef4-129">Tento problém jenom získá zhoršení, když další konstruktory úrovni uživatelského rozhraní, jako jsou filtry nebo ModelBinders, se přidají do vlastních složek.</span><span class="sxs-lookup"><span data-stu-id="2eef4-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="2eef4-130">Obchodní logika je různých mezi složkami modely a služby, a není není jasný náznak, které by měl třídy v složky, které závisí na které jiné.</span><span class="sxs-lookup"><span data-stu-id="2eef4-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="2eef4-131">Kvůli chybějící organizace na úrovni projektu často vede k [špagety kód](http://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="2eef4-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="2eef4-132">Aby bylo možné tyto problémy řeší aplikace často momentální do řešení vícenásobného projektu, kde se každý projekt, považuje se nacházejí v konkrétní *vrstvy* aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="2eef4-133">Jaké jsou vrstvy?</span><span class="sxs-lookup"><span data-stu-id="2eef4-133">What are layers?</span></span>

<span data-ttu-id="2eef4-134">Jelikož aplikace v složitost, jeden způsob, jak spravovat této složitost je rozdělit aplikace podle jeho odpovědnosti nebo připomínky.</span><span class="sxs-lookup"><span data-stu-id="2eef4-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="2eef4-135">To odpovídá oddělení Princip otázky a pomoct chránit rostoucí codebase uspořádaná tak, aby vývojáři mohli snadno najít, kde je implementováno určité funkce.</span><span class="sxs-lookup"><span data-stu-id="2eef4-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="2eef4-136">Vrstvená architektura nabízí řadu výhod nad rámec právě kód organizaci, ale.</span><span class="sxs-lookup"><span data-stu-id="2eef4-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="2eef4-137">Podle uspořádání kódu do vrstvy, můžete znovu použít běžné funkce nízké úrovně v celé aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="2eef4-138">Vzhledem k tomu, znamená to, že méně kódu potřeba zapsat a můžou aplikace pro standardizaci na jediná implementace, podle SUCHÝCH zásady, je vhodné tuto opakované použití.</span><span class="sxs-lookup"><span data-stu-id="2eef4-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="2eef4-139">S Vrstvená architektura aplikace můžete vynutit omezení, na kterých vrstvy může komunikovat s jiných vrstev.</span><span class="sxs-lookup"><span data-stu-id="2eef4-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="2eef4-140">To pomáhá zajistit zapouzdření.</span><span class="sxs-lookup"><span data-stu-id="2eef4-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="2eef4-141">Když vrstvu změní nebo nahradit, by měl mít vliv pouze vrstvy, které s ním pracovat.</span><span class="sxs-lookup"><span data-stu-id="2eef4-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="2eef4-142">Omezením, které závisí vrstvy, na kterých lze zmírnit jiných vrstev dopad změny, aby jediné změny nebude mít vliv na celou aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="2eef4-143">Vrstvy (a zapouzdření) bylo mnohem snazší nahradit funkcionalitu v rámci aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="2eef4-144">Například aplikace může původně trvalosti použít svou vlastní databázi systému SQL Server, ale později může zvolit strategie trvalost založené na cloudu, nebo jeden za webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2eef4-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="2eef4-145">Pokud aplikace má správně zapouzdřené jeho implementace trvalost v rámci logické vrstvy, může být nahrazen novou implementace stejné veřejné rozhraní této konkrétní vrstvy systému SQL Server.</span><span class="sxs-lookup"><span data-stu-id="2eef4-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="2eef4-146">Kromě potenciálně záměnu implementace v reakci na budoucí změny v požadavcích vrstvy aplikace můžete taky usnadňují vyměnit implementace pro účely testování.</span><span class="sxs-lookup"><span data-stu-id="2eef4-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="2eef4-147">Místo nutnosti psaní testy, které provozují proti skutečná data vrstvy nebo uživatelského rozhraní aplikace, tyto vrstvy můžou nahradit během testu falešných implementace, které poskytují známé odpovědí na požadavky.</span><span class="sxs-lookup"><span data-stu-id="2eef4-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="2eef4-148">Testy díky obvykle mnohem snazší k zápisu a mnohem rychlejší spusťte ve srovnání s spuštěná testy znovu skutečné infrastruktury aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="2eef4-149">Logické rozvrstvení je běžný postup pro zlepšení organizace kódu v podnikových aplikacích softwaru a existuje několik způsobů, ve kterých mohou být uspořádány kód do vrstvy.</span><span class="sxs-lookup"><span data-stu-id="2eef4-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="2eef4-150">*Vrstvy* představují logického oddělení v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="2eef4-151">V případě, že logiku aplikace je fyzicky distribuován do samostatné servery nebo procesy, tyto cíle samostatné fyzické nasazení se označují jako *vrstev*.</span><span class="sxs-lookup"><span data-stu-id="2eef4-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="2eef4-152">Je možné a celkem běžné tak, aby měl N-Layer aplikaci, která je nasazena na jedné vrstvě.</span><span class="sxs-lookup"><span data-stu-id="2eef4-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="2eef4-153">Tradiční "N-Layer" Architektura aplikace</span><span class="sxs-lookup"><span data-stu-id="2eef4-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="2eef4-154">Nejběžnější organizace aplikace logiky do vrstvách je znázorněno na obrázku 5-2.</span><span class="sxs-lookup"><span data-stu-id="2eef4-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="2eef4-155">**Obrázek 5-2.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-155">**Figure 5-2.**</span></span> <span data-ttu-id="2eef4-156">Typická aplikace vrstvy.</span><span class="sxs-lookup"><span data-stu-id="2eef4-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="2eef4-157">Tyto vrstvy jsou často se používá zkratka jako uživatelského rozhraní, BLL (vrstvu obchodní logiky) a DAL (Data Access Layer).</span><span class="sxs-lookup"><span data-stu-id="2eef4-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="2eef4-158">Pomocí této architektury, uživatelé provádět požadavky prostřednictvím uživatelského rozhraní vrstvy, která komunikuje jenom s BLL.</span><span class="sxs-lookup"><span data-stu-id="2eef4-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="2eef4-159">BLL, pak můžete volat DAL data žádosti o přístup.</span><span class="sxs-lookup"><span data-stu-id="2eef4-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="2eef4-160">Vrstva uživatelského rozhraní neměli provádět všechny požadavky vrstvy DAL přímo, ani musí komunikovat s trvalost přímo přes jiným způsobem.</span><span class="sxs-lookup"><span data-stu-id="2eef4-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="2eef4-161">Podobně BLL by měla pouze pracovat s trvalost projít DAL.</span><span class="sxs-lookup"><span data-stu-id="2eef4-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="2eef4-162">Tímto způsobem každé vrstvě má vlastní dobře známé zodpovědnost.</span><span class="sxs-lookup"><span data-stu-id="2eef4-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="2eef4-163">Jednou z nevýhod tohoto přístupu tradiční rozvrstvení je, že kompilaci závislosti shora dolů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="2eef4-164">To znamená vrstvě uživatelského rozhraní závisí na BLL, což závisí na DAL.</span><span class="sxs-lookup"><span data-stu-id="2eef4-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="2eef4-165">To znamená, že BLL, což obvykle obsahuje nejdůležitější logiku v aplikaci, je závislá na podrobnosti implementace přístup dat (a často na existenci databáze).</span><span class="sxs-lookup"><span data-stu-id="2eef4-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="2eef4-166">Testování obchodní logiku v takové architekturu je často složité, vyžadování testovací databáze.</span><span class="sxs-lookup"><span data-stu-id="2eef4-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="2eef4-167">Princip inverzi závislosti lze použít a tento problém vyřešit, jak uvidíte v další části.</span><span class="sxs-lookup"><span data-stu-id="2eef4-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="2eef4-168">Obrázek 5-3 ukazuje řešení s příklad nejnovější aplikace do tří projektů odpovědnost (nebo layer).</span><span class="sxs-lookup"><span data-stu-id="2eef4-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="2eef4-169">**Obrázek 5-3.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-169">**Figure 5-3.**</span></span> <span data-ttu-id="2eef4-170">Jednoduché monolitický aplikace pomocí tří projektů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="2eef4-171">I když tato aplikace používá několik projektů pro účely organizace, je stále nasazen jako na jednu jednotku a jeho klienty bude pracovat s ním jako jednu webovou aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="2eef4-172">To umožňuje velmi jednoduché nasazení procesu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="2eef4-173">Obrázek 5-4 ukazuje, jak může být taková aplikace hostované pomocí služby Windows Azure.</span><span class="sxs-lookup"><span data-stu-id="2eef4-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="2eef4-174">**Obrázek 5 – 4.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-174">**Figure 5-4.**</span></span> <span data-ttu-id="2eef4-175">Jednoduché nasazení webové aplikace Azure</span><span class="sxs-lookup"><span data-stu-id="2eef4-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="2eef4-176">Jak aplikace potřebuje, růst, mohou být vyžadovány komplexní a robustní řešení nasazení.</span><span class="sxs-lookup"><span data-stu-id="2eef4-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="2eef4-177">Obrázek 5-5 ukazuje příklad složitější plán nasazení, který podporuje další funkce.</span><span class="sxs-lookup"><span data-stu-id="2eef4-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="2eef4-178">**Obrázek 5-5.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-178">**Figure 5-5.**</span></span> <span data-ttu-id="2eef4-179">Nasazení webové aplikace do Azure App Service</span><span class="sxs-lookup"><span data-stu-id="2eef4-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="2eef4-180">Tento projekt organizace do více projektů podle odpovědnost interně, zlepšuje udržovatelnosti aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="2eef4-181">Tato jednotka je možné rozšířit nebo horizontálně navýšit kapacitu Pokud chcete využít výhod cloudových škálovatelnost na vyžádání.</span><span class="sxs-lookup"><span data-stu-id="2eef4-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="2eef4-182">Rozšiřování prostředků znamená přidávání dalších procesoru, paměti, místa na disku nebo jiným prostředkům na server(y) hostování vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="2eef4-183">Škálování znamená, přidávání dalších instancí těchto serverů, zda se jedná o fyzických serverech nebo virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="2eef4-184">Pokud je vaše aplikace hostované ve více instancích, nástroj pro vyrovnávání zatížení se používá k požadavky přiřadit instance jednotlivých aplikací.</span><span class="sxs-lookup"><span data-stu-id="2eef4-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="2eef4-185">Nejjednodušším přístupem při škálování webové aplikace v Azure je nakonfigurovat ručně škálování v plánu služby aplikace App Service.</span><span class="sxs-lookup"><span data-stu-id="2eef4-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="2eef4-186">Obrázek 5 a 6 zobrazit obrazovce odpovídající řídicí panel Azure nakonfigurovat, kolik instancí slouží k aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="2eef4-187">**Obrázek 5 a 6.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-187">**Figure 5-6.**</span></span> <span data-ttu-id="2eef4-188">Plán služby App Service škálování v Azure.</span><span class="sxs-lookup"><span data-stu-id="2eef4-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="2eef4-189">Vyčištění architektura</span><span class="sxs-lookup"><span data-stu-id="2eef4-189">Clean architecture</span></span>

<span data-ttu-id="2eef4-190">Aplikace, které následují v inverzi Princip závislostí, jakož i Principy návrhu Domain-Driven (DDD) zpravidla přicházejí na podobnou architekturu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="2eef4-191">Tato architektura se příliš mnoho názvy průběhu let.</span><span class="sxs-lookup"><span data-stu-id="2eef4-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="2eef4-192">Jeden ze zadaných názvů první byl šestiúhelníkový architekturu, za nímž následuje adaptéry a porty.</span><span class="sxs-lookup"><span data-stu-id="2eef4-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="2eef4-193">Nedávno, je byla citovalo jako [průsvitek architektura](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) nebo [čisté architektura](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="2eef4-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="2eef4-194">Je tento poslední název čistou architektura, která slouží jako základ pro popis architektury v této příručce e.</span><span class="sxs-lookup"><span data-stu-id="2eef4-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="2eef4-195">Termín čistou architektura lze použít k aplikacím, které jsou vytvořené pomocí také zásady DDD, ty, které nejsou sestavené pomocí DDD.</span><span class="sxs-lookup"><span data-stu-id="2eef4-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="2eef4-196">V případě dřívějším, může být tato kombinace označovány jako "Čistou DDD architektura".</span><span class="sxs-lookup"><span data-stu-id="2eef4-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="2eef4-197">Vyčištění architektura převádí model obchodní logiky a aplikace v centru aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="2eef4-198">Místo nutnosti obchodní logiky, závisí na přístup k datům nebo jiných příčin infrastruktury, je obrácený tuto závislost: Podrobnosti o infrastruktury a implementace závisí na základní aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="2eef4-199">Toho dosáhnete tak, že definujete abstrakce nebo rozhraní, klíčové aplikace, které jsou pak implementované pro typy definované v vrstvě infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2eef4-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="2eef4-200">Běžný způsob vizualizace této architektury je použití řadu soustředných kroužky, podobně jako průsvitek.</span><span class="sxs-lookup"><span data-stu-id="2eef4-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="2eef4-201">Obrázek 5 X ukazuje příklad tento styl architektury reprezentace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="2eef4-202">**Obrázek 5 – 7.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-202">**Figure 5-7.**</span></span> <span data-ttu-id="2eef4-203">Vyčištění architektura; zobrazení průsvitek</span><span class="sxs-lookup"><span data-stu-id="2eef4-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="2eef4-204">V tomto diagramu toku závislostí směrem k nejvnitřnější kruhu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="2eef4-205">Proto se zobrazí, že základní aplikace (která má svůj název od pozice základem této diagramu) nemá žádné závislosti na jiných vrstev aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="2eef4-206">V centru velmi jsou entity a rozhraní aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="2eef4-207">Právě mimo, ale stále v základní aplikace jsou služby domény, obvykle implementující rozhraní definované v informacích o vnitřní kruh.</span><span class="sxs-lookup"><span data-stu-id="2eef4-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="2eef4-208">Mimo aplikaci základní uživatelské rozhraní a infrastruktura vrstvy, které závisí na základní aplikaci, ale není na sebe navzájem (nutně).</span><span class="sxs-lookup"><span data-stu-id="2eef4-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="2eef4-209">Obrázek 5 X znázorňuje tradičnější diagram vodorovné vrstev, který lépe závislosti mezi uživatelského rozhraní a jiných vrstev.</span><span class="sxs-lookup"><span data-stu-id="2eef4-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="2eef4-210">**Obrázek 5-8.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-210">**Figure 5-8.**</span></span> <span data-ttu-id="2eef4-211">Vyčištění architektura; zobrazení vodorovné vrstvy</span><span class="sxs-lookup"><span data-stu-id="2eef4-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="2eef4-212">Všimněte si, že plnou šipky představují kompilaci závislosti, zatímco přerušovanou šipku představuje závislost pouze modul runtime.</span><span class="sxs-lookup"><span data-stu-id="2eef4-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="2eef4-213">Pomocí architektuře čistého, vrstvě uživatelského rozhraní funguje s rozhraními definované v základní aplikace v době kompilace a v ideálním případě by neměl mít žádnou znalost typy implementace definované v vrstvě infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2eef4-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="2eef4-214">Za běhu ale tyto typy implementace se bude vyžadovat pro aplikaci spustit, tak budou muset být přítomna a drátové až rozhraní základní aplikace pomocí vkládání závislostí.</span><span class="sxs-lookup"><span data-stu-id="2eef4-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="2eef4-215">Obrázek 5-9 ukazuje podrobnější pohled na architekturu aplikace ASP.NET Core při sestavení následující tato doporučení.</span><span class="sxs-lookup"><span data-stu-id="2eef4-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Architektura jádra ASPNET](./media/image5-9.png)

<span data-ttu-id="2eef4-217">**Obrázek 5-9.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-217">**Figure 5-9.**</span></span> <span data-ttu-id="2eef4-218">Diagram architektury ASP.NET Core následující čistou architektura.</span><span class="sxs-lookup"><span data-stu-id="2eef4-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="2eef4-219">Protože základní aplikace nezávisí na infrastrukturu, je velmi snadné zápis testů částí automatizované pro tuto vrstvu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="2eef4-220">Následující obrázky 5 až 10 a 5 11 ukazují, jak testy nevejde se do této architektury.</span><span class="sxs-lookup"><span data-stu-id="2eef4-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="2eef4-222">**Obrázek 5-10.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-222">**Figure 5-10.**</span></span> <span data-ttu-id="2eef4-223">Testování aplikací jádra v izolaci částí.</span><span class="sxs-lookup"><span data-stu-id="2eef4-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="2eef4-225">**Obrázek 5-11.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-225">**Figure 5-11.**</span></span> <span data-ttu-id="2eef4-226">Integrace testování implementace infrastruktury s externími závislostmi.</span><span class="sxs-lookup"><span data-stu-id="2eef4-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="2eef4-227">Vzhledem k tomu, že vrstva uživatelského rozhraní neobsahuje žádné přímé závislost na typy definované v projektu infrastruktury, je rovněž velmi snadné odkládacího souboru se implementace, buď usnadňuje testování nebo v reakci na měnící se požadavky na aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="2eef4-228">Předdefinované použití a podpora pro vkládání závislostí ASP.NET Core díky této architektury za nejvhodnější způsob, jak struktura netriviální monolitický aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="2eef4-229">Pro monolitický aplikace jsou všechny projekty základní aplikaci, infrastruktury a uživatelské rozhraní spustit jako jednu aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="2eef4-230">Architektura modulu runtime aplikace může vypadat jako obrázek 5-12.</span><span class="sxs-lookup"><span data-stu-id="2eef4-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![Architektura jádra ASPNET 2](./media/image5-12.png)

<span data-ttu-id="2eef4-232">**Obrázek 5-12.**</span><span class="sxs-lookup"><span data-stu-id="2eef4-232">**Figure 5-12.**</span></span> <span data-ttu-id="2eef4-233">Architektura aplikace ukázka ASP.NET Core runtime.</span><span class="sxs-lookup"><span data-stu-id="2eef4-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="2eef4-234">Uspořádání kódu v architektuře čistého</span><span class="sxs-lookup"><span data-stu-id="2eef4-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="2eef4-235">V čisté Architektura řešení každý projekt má zrušte odpovědnosti.</span><span class="sxs-lookup"><span data-stu-id="2eef4-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="2eef4-236">Jako takový bude určité typy patří do každého projektu a často zjistíte složky odpovídající tyto typy v příslušné projektu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="2eef4-237">Základní aplikace obsahuje obchodní model, který obsahuje entity, služeb a rozhraní.</span><span class="sxs-lookup"><span data-stu-id="2eef4-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="2eef4-238">Tato rozhraní zahrnují abstrakce pro operace, které bude možné provést pomocí infrastruktury, například přístup k datům, přístupu k systému souborů, volání sítě atd. Pro práci s nonentity typy, které nemají žádné závislosti na uživatelského rozhraní nebo infrastruktury nutné někdy služby nebo rozhraní definované v této vrstvě.</span><span class="sxs-lookup"><span data-stu-id="2eef4-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="2eef4-239">To může být definováno jako jednoduché objekty Data Transfer (DTOs).</span><span class="sxs-lookup"><span data-stu-id="2eef4-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="2eef4-240">Základní typy aplikací</span><span class="sxs-lookup"><span data-stu-id="2eef4-240">Application Core Types</span></span>
> -   <span data-ttu-id="2eef4-241">Entity (obchodní model třídy, které jsou nastavené jako trvalé)</span><span class="sxs-lookup"><span data-stu-id="2eef4-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="2eef4-242">Rozhraní</span><span class="sxs-lookup"><span data-stu-id="2eef4-242">Interfaces</span></span>
> -   <span data-ttu-id="2eef4-243">Služby</span><span class="sxs-lookup"><span data-stu-id="2eef4-243">Services</span></span>
> -   <span data-ttu-id="2eef4-244">DTOs</span><span class="sxs-lookup"><span data-stu-id="2eef4-244">DTOs</span></span>

<span data-ttu-id="2eef4-245">Projekt infrastruktury by měl obvykle zahrnovat implementace přístup data.</span><span class="sxs-lookup"><span data-stu-id="2eef4-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="2eef4-246">V typické webové aplikace ASP.NET Core to bude zahrnovat data přístup implementace třídy Entity Framework DbContext, všechny migrace EF jádra, které byly definovány a.</span><span class="sxs-lookup"><span data-stu-id="2eef4-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="2eef4-247">Nejběžnější způsob abstraktní data přístup implementace kód je prostřednictvím [vzor návrhu úložiště](http://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="2eef4-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="2eef4-248">Kromě dat implementace přístup musí obsahovat projektu OMI implementace služeb, které musí spolupracovat s riziko z hlediska infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="2eef4-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="2eef4-249">Tyto služby musí implementovat rozhraní definované v základní aplikace, a proto infrastruktury by měl mít odkaz na projekt aplikace jádra.</span><span class="sxs-lookup"><span data-stu-id="2eef4-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="2eef4-250">Typy infrastruktury</span><span class="sxs-lookup"><span data-stu-id="2eef4-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="2eef4-251">Základní typy EF (DbContext, migrace)</span><span class="sxs-lookup"><span data-stu-id="2eef4-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="2eef4-252">Přístup k datům implementace typů (úložiště)</span><span class="sxs-lookup"><span data-stu-id="2eef4-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="2eef4-253">Specifické pro infrastrukturu služby (FileLogger, SmtpNotifier atd.)</span><span class="sxs-lookup"><span data-stu-id="2eef4-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="2eef4-254">V aplikaci ASP.NET MVC základní uživatelské rozhraní vrstvě bude vstupní bod pro aplikaci a bude projektu aplikace ASP.NET MVC jádra.</span><span class="sxs-lookup"><span data-stu-id="2eef4-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="2eef4-255">Tento projekt by měl odkazovat projektu základní aplikace a typy jejího musí komunikovat s infrastrukturou výhradně prostřednictvím rozhraní definované v základní aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="2eef4-256">Žádné přímé vytváření instancí (nebo statické volání) musí být povolené typy vrstvy infrastruktury ve vrstvě uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="2eef4-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="2eef4-257">Typy vrstvy uživatelského rozhraní</span><span class="sxs-lookup"><span data-stu-id="2eef4-257">UI Layer Types</span></span>
> -   <span data-ttu-id="2eef4-258">Kontrolery</span><span class="sxs-lookup"><span data-stu-id="2eef4-258">Controllers</span></span>
> -   <span data-ttu-id="2eef4-259">Filtry</span><span class="sxs-lookup"><span data-stu-id="2eef4-259">Filters</span></span>
> -   <span data-ttu-id="2eef4-260">zobrazení</span><span class="sxs-lookup"><span data-stu-id="2eef4-260">Views</span></span>
> -   <span data-ttu-id="2eef4-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="2eef4-261">ViewModels</span></span>
> -   <span data-ttu-id="2eef4-262">Spuštění</span><span class="sxs-lookup"><span data-stu-id="2eef4-262">Startup</span></span>

<span data-ttu-id="2eef4-263">Třída při spuštění je zodpovědný pro konfiguraci aplikace a kabeláž typů implementace rozhraní, což vkládání závislostí v době běhu správně fungovat.</span><span class="sxs-lookup"><span data-stu-id="2eef4-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="2eef4-264">Aby bylo možné propojit až vkládání závislostí v ConfigureServices v souboru Startup.cs projektu uživatelského rozhraní, možná muset projektu odkazovat projektu OMI.</span><span class="sxs-lookup"><span data-stu-id="2eef4-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="2eef4-265">Tuto závislost jde je eliminovat snadno pomocí vlastní DI kontejner.</span><span class="sxs-lookup"><span data-stu-id="2eef4-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="2eef4-266">Pro účely tohoto příkladu je nejjednodušší je umožnit uživatelského rozhraní projekt, který má odkazovat na projektu OMI.</span><span class="sxs-lookup"><span data-stu-id="2eef4-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="2eef4-267">Monolitický aplikace a kontejnery</span><span class="sxs-lookup"><span data-stu-id="2eef4-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="2eef4-268">Můžete sestavit jeden a monolitický nasazení založené na webové aplikace nebo služby a nasaďte ho jako kontejner.</span><span class="sxs-lookup"><span data-stu-id="2eef4-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="2eef4-269">V aplikaci nemusí být monolitický ale uspořádány do několika knihovny, komponenty nebo vrstvy.</span><span class="sxs-lookup"><span data-stu-id="2eef4-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="2eef4-270">Externě je jediný kontejner jako jeden proces, jednu webovou aplikaci nebo jedné služby.</span><span class="sxs-lookup"><span data-stu-id="2eef4-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="2eef4-271">Ke správě tohoto modelu, můžete nasadit jediný kontejner k reprezentaci aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="2eef4-272">Pokud chcete použít škálování, stačí přidáte další kopie pro vyrovnávání zatížení vpředu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="2eef4-273">Jednoduchost pochází z Správa jedno nasazení v jedné kontejneru nebo virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="2eef4-274">Můžete zahrnout více součásti nebo knihovny nebo interní vrstvy v rámci každý kontejner, jak je znázorněno na obrázku 5-X.</span><span class="sxs-lookup"><span data-stu-id="2eef4-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="2eef4-275">Objekt zabezpečení kontejneru, ale následující *"kontejner nepodporuje jednou z věcí a nemá v jednom procesu*", monolitický vzor může dojít ke konfliktu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="2eef4-276">Nevýhodou tohoto přístupu dodává Pokud/při zvětšování aplikace vyžadující ji škálovat.</span><span class="sxs-lookup"><span data-stu-id="2eef4-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="2eef4-277">Pokud bude celá aplikace škálovat, není skutečně problém.</span><span class="sxs-lookup"><span data-stu-id="2eef4-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="2eef4-278">Ve většině případů několik součástí aplikace jsou však, že body potlačení nutnosti škálování, zatímco ostatní součásti jsou používá menší.</span><span class="sxs-lookup"><span data-stu-id="2eef4-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="2eef4-279">Pomocí příklad typické elektronické obchodování; Co je pravděpodobně potřeba škálování je součást informace o produktu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="2eef4-280">Mnoho zákazníků další Procházet produkty než jejich zakoupení.</span><span class="sxs-lookup"><span data-stu-id="2eef4-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="2eef4-281">Další zákazníci využívat nákupního košíku než použití kanálu platba.</span><span class="sxs-lookup"><span data-stu-id="2eef4-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="2eef4-282">Méně zákazníky přidání komentářů nebo zobrazit historii jejich nákupu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="2eef4-283">A pravděpodobně pouze existuje více zaměstnancům, najdete v jedné oblasti, která potřebují spravovat obsah a marketingových kampaní.</span><span class="sxs-lookup"><span data-stu-id="2eef4-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="2eef4-284">Pomocí příjmu monolitický návrhu, všechny kód nasazen vícekrát.</span><span class="sxs-lookup"><span data-stu-id="2eef4-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="2eef4-285">Kromě měřítka všechno, co problém, změny jedinou komponentu vyžadují opětovném dokončení testování v celé aplikaci a dokončení opětovného nasazení všech instancí.</span><span class="sxs-lookup"><span data-stu-id="2eef4-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="2eef4-286">Monolitický přístup je běžné a mnoha organizacích jsou vývoj s tímto přístupem architektury.</span><span class="sxs-lookup"><span data-stu-id="2eef4-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="2eef4-287">Mnoho mají s vhodné dostatek výsledky, zatímco ostatní nedosáhli limitů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="2eef4-288">Mnoho určená svých aplikací v tomto modelu, protože nástroje a infrastruktura byly příliš složité sestavení architektury služby zaměřené na konkrétní (SOA) a nebylo uvidí potřeba – dokud vzrostla aplikace.</span><span class="sxs-lookup"><span data-stu-id="2eef4-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="2eef4-289">Pokud zjistíte, že jste nedosáhli limitů monolitický přístupu, může být rozdělení aplikace k tomu, aby lépe využít kontejnery a mikroslužeb logické dál.</span><span class="sxs-lookup"><span data-stu-id="2eef4-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="2eef4-290">Nasazení monolitický aplikací v Microsoft Azure se dá dosáhnout pomocí vyhrazených virtuálních počítačích pro každou instanci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="2eef4-291">Pomocí [škálovatelné sady virtuálních počítačů Azure](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), je možné snadno škálovat virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="2eef4-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) můžete spouštět monolitický aplikace a snadno škálovat instance bez nutnosti ke správě virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="2eef4-293">Azure App Services můžete spustit jedné instance Docker kontejnery také, což výrazně zjednodušuje nasazení.</span><span class="sxs-lookup"><span data-stu-id="2eef4-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="2eef4-294">Pomocí Docker, můžete nasadit jeden virtuální počítač jako hostitele Docker a spustit víc instancí.</span><span class="sxs-lookup"><span data-stu-id="2eef4-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="2eef4-295">Pomocí nástroje pro vyrovnávání Azure, jak je znázorněno v obrázku 5-14, můžete spravovat škálování.</span><span class="sxs-lookup"><span data-stu-id="2eef4-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="2eef4-296">Nasazení do různých hostitelů lze spravovat pomocí techniky tradiční nasazení.</span><span class="sxs-lookup"><span data-stu-id="2eef4-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="2eef4-297">Hostitelů Docker lze spravovat pomocí příkazů jako **docker spustit** provést ručně, nebo prostřednictvím automatizace, jako je nepřetržitá doručení (CD) kanálů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="2eef4-298">Monolitický aplikace nasazena jako kontejner</span><span class="sxs-lookup"><span data-stu-id="2eef4-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="2eef4-299">Existují výhody použití kontejnerů ke správě nasazení monolitický aplikací.</span><span class="sxs-lookup"><span data-stu-id="2eef4-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="2eef4-300">Změna velikosti instancí kontejnerů je mnohem rychlejší a snadnější než nasazení dalších virtuálních počítačů.</span><span class="sxs-lookup"><span data-stu-id="2eef4-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="2eef4-301">I když se používá škálovatelné sady virtuálních počítačů škálování virtuálních počítačů, jejich trvat dobu k instanci.</span><span class="sxs-lookup"><span data-stu-id="2eef4-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="2eef4-302">Při nasazení jako instance aplikace, je konfigurace aplikace spravované v rámci virtuálního počítače.</span><span class="sxs-lookup"><span data-stu-id="2eef4-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="2eef4-303">Nasazení aktualizací, jako je mnohem rychlejší imagí Dockeru a efektivní sítě.</span><span class="sxs-lookup"><span data-stu-id="2eef4-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="2eef4-304">Imagí dockeru obvykle spuštění v sekundách, rychlosti zavedení uživatelům.</span><span class="sxs-lookup"><span data-stu-id="2eef4-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="2eef4-305">Zrušení Docker instance je stejně snadná jako vystavování **docker zastavení** příkazu, obvykle dokončení menší než za sekundu.</span><span class="sxs-lookup"><span data-stu-id="2eef4-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="2eef4-306">Jako kontejnery jsou ze své podstaty neměnné záměrné, nikdy musíte si dělat starosti poškozená virtuálních počítačích, zatímco skriptů pro aktualizaci zapomněl účet pro některé specifické konfigurace nebo vlevo soubor na disku.</span><span class="sxs-lookup"><span data-stu-id="2eef4-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="2eef4-307">Při monolitický aplikace využívat Docker, rozdělení monolitický aplikaci do dílčí systémy, které je možné rozšířit, vyvíjí a nasadit samostatně může být vašim vstupním bodem do sféru mikroslužeb.</span><span class="sxs-lookup"><span data-stu-id="2eef4-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="2eef4-308">Odkazy – společné architektury webové</span><span class="sxs-lookup"><span data-stu-id="2eef4-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="2eef4-309">**Vyčištění architektura**</span><span class="sxs-lookup"><span data-stu-id="2eef4-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="2eef4-310"><https://8thlight.com/blog/Uncle-Bob/2012/08/13/the-Clean-Architecture.HTML></span><span class="sxs-lookup"><span data-stu-id="2eef4-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="2eef4-311">**Architektura průsvitek**</span><span class="sxs-lookup"><span data-stu-id="2eef4-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="2eef4-312"><http://jeffreypalermo.com/blog/the-onion-Architecture-Part-1/></span><span class="sxs-lookup"><span data-stu-id="2eef4-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="2eef4-313">**Vzor úložiště**</span><span class="sxs-lookup"><span data-stu-id="2eef4-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="2eef4-314"><http://deviq.com/Repository-Pattern/></span><span class="sxs-lookup"><span data-stu-id="2eef4-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="2eef4-315">**Vyčištění ukázkové architektury řešení**</span><span class="sxs-lookup"><span data-stu-id="2eef4-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="2eef4-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="2eef4-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="2eef4-317">**Architektury elektronická kniha Mikroslužeb** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="2eef4-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="2eef4-318">[Předchozí] (architectural-principles.md) [Další] (common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="2eef4-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>
