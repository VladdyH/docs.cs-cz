---
title: Pokyny pro kolekce
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 09a2a075e21de6968989575385db07ab39eb627f
ms.sourcegitcommit: c3957fdb990060559d73cca44ab3e2c7b4d049c0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/05/2018
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="a36a8-102">Pokyny pro kolekce</span><span class="sxs-lookup"><span data-stu-id="a36a8-102">Guidelines for Collections</span></span>
<span data-ttu-id="a36a8-103">Jakýkoli typ navrženo konkrétně k manipulaci s pro skupinu objektů, že některé běžné vlastnosti lze považovat za kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="a36a8-104">Je téměř vždy vhodné pro tyto typy pro implementaci <xref:System.Collections.IEnumerable> nebo <xref:System.Collections.Generic.IEnumerable%601>, takže v této části jsme pouze na nabídnuté typy implementace jednoho nebo obou těchto rozhraní jako kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>  
  
 <span data-ttu-id="a36a8-105">**X nesmí** slabě typovaná kolekce použít veřejné rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="a36a8-105">**X DO NOT** use weakly typed collections in public APIs.</span></span>  
  
 <span data-ttu-id="a36a8-106">Typ všechny návratové hodnoty a parametry položky kolekce představující musí být typ položky přesně, nikoli jakákoliv z jeho základních typů (to se týká pouze veřejné členy kolekce).</span><span class="sxs-lookup"><span data-stu-id="a36a8-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>  
  
 <span data-ttu-id="a36a8-107">**X nesmí** použít <xref:System.Collections.ArrayList> nebo <xref:System.Collections.Generic.List%601> veřejné rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="a36a8-107">**X DO NOT** use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>  
  
 <span data-ttu-id="a36a8-108">Tyto typy jsou datové struktury, které jsou určeny k použití v interní implementaci není v veřejná rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="a36a8-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="a36a8-109">`List<T>` je optimalizován pro výkon a výkon za cenu čistotu rozhraní API a flexibility.</span><span class="sxs-lookup"><span data-stu-id="a36a8-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="a36a8-110">Například, pokud vrátíte `List<T>`, někdy nebudete moci přijímat upozornění, když kód klienta upraví kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="a36a8-111">Navíc `List<T>` zpřístupní mnoho členů, jako například <xref:System.Collections.Generic.List%601.BinarySearch%2A>, které nejsou užitečné nebo v mnoha scénářích není platná.</span><span class="sxs-lookup"><span data-stu-id="a36a8-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="a36a8-112">Následující dvě části popisují typy (abstrakce) určený speciálně pro použití v veřejná rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="a36a8-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>  
  
 <span data-ttu-id="a36a8-113">**X nesmí** použít `Hashtable` nebo `Dictionary<TKey,TValue>` veřejné rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="a36a8-113">**X DO NOT** use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>  
  
 <span data-ttu-id="a36a8-114">Tyto typy jsou určeny k použití v interní implementaci datové struktury.</span><span class="sxs-lookup"><span data-stu-id="a36a8-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="a36a8-115">Veřejná rozhraní API by měl používat <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, nebo vlastní typ implementace jedno nebo obě rozhraní.</span><span class="sxs-lookup"><span data-stu-id="a36a8-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>  
  
 <span data-ttu-id="a36a8-116">**X nesmí** použít <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, nebo jakýkoli jiný typ, který implementuje kterékoli z těchto rozhraní, s výjimkou jako návratový typ `GetEnumerator` metoda.</span><span class="sxs-lookup"><span data-stu-id="a36a8-116">**X DO NOT** use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>  
  
 <span data-ttu-id="a36a8-117">Typy vrácení výčty z metody jiné než `GetEnumerator` nelze použít s `foreach` příkaz.</span><span class="sxs-lookup"><span data-stu-id="a36a8-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>  
  
 <span data-ttu-id="a36a8-118">**X nesmí** implementovat obě `IEnumerator<T>` a `IEnumerable<T>` na stejného typu.</span><span class="sxs-lookup"><span data-stu-id="a36a8-118">**X DO NOT** implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="a36a8-119">Totéž platí i pro rozhraní neobecné `IEnumerator` a `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>  
  
## <a name="collection-parameters"></a><span data-ttu-id="a36a8-120">Kolekce parametrů</span><span class="sxs-lookup"><span data-stu-id="a36a8-120">Collection Parameters</span></span>  
 <span data-ttu-id="a36a8-121">**PROVEĎTE ✓** typ specializuje nejmenší možné použít jako typ parametru.</span><span class="sxs-lookup"><span data-stu-id="a36a8-121">**✓ DO** use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="a36a8-122">Většina členy trvá kolekce jako parametry použijte `IEnumerable<T>` rozhraní.</span><span class="sxs-lookup"><span data-stu-id="a36a8-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>  
  
 <span data-ttu-id="a36a8-123">**X nepoužívejte** pomocí <xref:System.Collections.Generic.ICollection%601> nebo <xref:System.Collections.ICollection> jako parametr pouze pro přístup `Count` vlastnost.</span><span class="sxs-lookup"><span data-stu-id="a36a8-123">**X AVOID** using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>  
  
 <span data-ttu-id="a36a8-124">Místo toho zvažte použití `IEnumerable<T>` nebo `IEnumerable` a dynamicky kontrola, zda objekt implementuje `ICollection<T>` nebo `ICollection`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>  
  
## <a name="collection-properties-and-return-values"></a><span data-ttu-id="a36a8-125">Kolekce vlastností a návratové hodnoty</span><span class="sxs-lookup"><span data-stu-id="a36a8-125">Collection Properties and Return Values</span></span>  
 <span data-ttu-id="a36a8-126">**X nesmí** zadejte vlastnosti nastavit kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-126">**X DO NOT** provide settable collection properties.</span></span>  
  
 <span data-ttu-id="a36a8-127">Uživatele můžete nahradit obsah kolekce nejprve vymazání kolekce a potom přidat nový obsah.</span><span class="sxs-lookup"><span data-stu-id="a36a8-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="a36a8-128">Pokud nahrazení celé kolekce je běžný scénář, zvažte možnost poskytování `AddRange` metoda v kolekci.</span><span class="sxs-lookup"><span data-stu-id="a36a8-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>  
  
 <span data-ttu-id="a36a8-129">**PROVEĎTE ✓** použít `Collection<T>` nebo podtřídou třídy `Collection<T>` pro vlastnosti nebo return hodnoty představující kolekce pro čtení a zápis.</span><span class="sxs-lookup"><span data-stu-id="a36a8-129">**✓ DO** use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>  
  
 <span data-ttu-id="a36a8-130">Pokud `Collection<T>` nesplňuje některé požadavky (například nesmí kolekce implementovat <xref:System.Collections.IList>), používat vlastní kolekce implementací `IEnumerable<T>`, `ICollection<T>`, nebo <xref:System.Collections.Generic.IList%601>.</span><span class="sxs-lookup"><span data-stu-id="a36a8-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>  
  
 <span data-ttu-id="a36a8-131">**PROVEĎTE ✓** použít <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, podtřídou třídy `ReadOnlyCollection<T>`, nebo ve výjimečných případech `IEnumerable<T>` pro vlastnosti nebo return hodnoty představující kolekce jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a36a8-131">**✓ DO** use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>  
  
 <span data-ttu-id="a36a8-132">Obecně platí, raději `ReadOnlyCollection<T>`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="a36a8-133">Pokud nesplňuje požadavek na některé (například nesmí kolekce implementovat `IList`), používat vlastní kolekce implementací `IEnumerable<T>`, `ICollection<T>`, nebo `IList<T>`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="a36a8-134">Pokud budete implementovat vlastní kolekce jen pro čtení, implementujte `ICollection<T>.IsReadOnly` vrátit `true`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-134">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>  
  
 <span data-ttu-id="a36a8-135">V případech, kdy jste si jisti, že jediný scénář, se někdy budete chtít podporu je dopředné iterace, můžete jednoduše použít `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>  
  
 <span data-ttu-id="a36a8-136">**✓ ZVAŽTE** pomocí podtřídy obecné základní kolekce místo použití kolekce přímo.</span><span class="sxs-lookup"><span data-stu-id="a36a8-136">**✓ CONSIDER** using subclasses of generic base collections instead of using the collections directly.</span></span>  
  
 <span data-ttu-id="a36a8-137">To umožňuje lepší názvu a pro přidávání členů pomocné rutiny, které se nenacházejí na typy základní kolekcí.</span><span class="sxs-lookup"><span data-stu-id="a36a8-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="a36a8-138">Používá se především pro vysoké úrovně rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="a36a8-138">This is especially applicable to high-level APIs.</span></span>  
  
 <span data-ttu-id="a36a8-139">**✓ ZVAŽTE** vrácení podtřídou třídy `Collection<T>` nebo `ReadOnlyCollection<T>` velmi běžně používaných metod a vlastností.</span><span class="sxs-lookup"><span data-stu-id="a36a8-139">**✓ CONSIDER** returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>  
  
 <span data-ttu-id="a36a8-140">To znamená, že vám umožní přidat pomocné metody nebo změňte implementaci kolekce v budoucnu.</span><span class="sxs-lookup"><span data-stu-id="a36a8-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>  
  
 <span data-ttu-id="a36a8-141">**✓ ZVAŽTE** pomocí kolekci s klíčem, je-li mít jedinečné klíče položky uložené v kolekci (názvy, ID, atd.).</span><span class="sxs-lookup"><span data-stu-id="a36a8-141">**✓ CONSIDER** using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="a36a8-142">Kolekce s klíči jsou kolekce, které může indexovat pomocí celé číslo a klíč a jsou obvykle implementované dědění z `KeyedCollection<TKey,TItem>`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>  
  
 <span data-ttu-id="a36a8-143">Kolekce s klíči obvykle mají větší paměti pracovníkům a by se neměla používat, pokud nároky na paměť převáží o výhodách klíče.</span><span class="sxs-lookup"><span data-stu-id="a36a8-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>  
  
 <span data-ttu-id="a36a8-144">**X nesmí** vrátit hodnotu null. hodnoty z vlastnosti kolekce nebo z metody, které vrací kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-144">**X DO NOT** return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="a36a8-145">Místo toho vrátí prázdnou kolekci nebo prázdné pole.</span><span class="sxs-lookup"><span data-stu-id="a36a8-145">Return an empty collection or an empty array instead.</span></span>  
  
 <span data-ttu-id="a36a8-146">Obecně platí, že by měla být hodnota null a prázdný kolekcí (0 položek) nebo pole chovají stejně.</span><span class="sxs-lookup"><span data-stu-id="a36a8-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>  
  
### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="a36a8-147">Snímky a za provozu kolekce</span><span class="sxs-lookup"><span data-stu-id="a36a8-147">Snapshots Versus Live Collections</span></span>  
 <span data-ttu-id="a36a8-148">Kolekce představující stav v určitém okamžiku v čase se označují jako snímek kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="a36a8-149">Kolekce obsahující řádků vrácená z dotazu databáze by být například snímek.</span><span class="sxs-lookup"><span data-stu-id="a36a8-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="a36a8-150">Kolekce, které vždy představují aktuální stav, se nazývají za provozu kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="a36a8-151">Například kolekce `ComboBox` položky je soubor za provozu.</span><span class="sxs-lookup"><span data-stu-id="a36a8-151">For example, a collection of `ComboBox` items is a live collection.</span></span>  
  
 <span data-ttu-id="a36a8-152">**X nesmí** vracejí snímek kolekce z vlastností.</span><span class="sxs-lookup"><span data-stu-id="a36a8-152">**X DO NOT** return snapshot collections from properties.</span></span> <span data-ttu-id="a36a8-153">Vlastnosti by měl vrátit za provozu kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-153">Properties should return live collections.</span></span>  
  
 <span data-ttu-id="a36a8-154">Mechanismy získání vlastnost by měla být velmi jednoduché operace.</span><span class="sxs-lookup"><span data-stu-id="a36a8-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="a36a8-155">Vrácení snímek vyžaduje vytvoření kopie vnitřní kolekce v O(n) operace.</span><span class="sxs-lookup"><span data-stu-id="a36a8-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>  
  
 <span data-ttu-id="a36a8-156">**PROVEĎTE ✓** použít kolekci snímku nebo živé `IEnumerable<T>` (nebo jeho dílčí) představují kolekce, které jsou volatile (tj, který můžete změnit bez explicitně úpravy kolekce).</span><span class="sxs-lookup"><span data-stu-id="a36a8-156">**✓ DO** use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>  
  
 <span data-ttu-id="a36a8-157">Všechny kolekce představující sdíleného prostředku (například soubory v adresáři) jsou obecně volatile.</span><span class="sxs-lookup"><span data-stu-id="a36a8-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="a36a8-158">Tyto kolekce jsou velmi obtížné nebo dokonce znemožňují implementovat jako kolekce za provozu, pokud jeho implementace je jednoduše dopředné enumerátor.</span><span class="sxs-lookup"><span data-stu-id="a36a8-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>  
  
## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="a36a8-159">Volba mezi pole a kolekce</span><span class="sxs-lookup"><span data-stu-id="a36a8-159">Choosing Between Arrays and Collections</span></span>  
 <span data-ttu-id="a36a8-160">**PROVEĎTE ✓** upřednostnit kolekce přes pole.</span><span class="sxs-lookup"><span data-stu-id="a36a8-160">**✓ DO** prefer collections over arrays.</span></span>  
  
 <span data-ttu-id="a36a8-161">Kolekce poskytuje větší kontrolu nad obsah, můžete v průběhu času vyvíjejí a jsou více použitelné.</span><span class="sxs-lookup"><span data-stu-id="a36a8-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="a36a8-162">Kromě toho použití polí pro scénáře jen pro čtení se nedoporučuje. protože je cenově náklady klonování pole.</span><span class="sxs-lookup"><span data-stu-id="a36a8-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="a36a8-163">Použitelnost studií vyplývá, že někteří vývojáři bez obav více pomocí rozhraní API založené na kolekcích.</span><span class="sxs-lookup"><span data-stu-id="a36a8-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>  
  
 <span data-ttu-id="a36a8-164">Ale pokud vyvíjíte nízké úrovně rozhraní API, může být vhodnější použít pole pro scénáře pro čtení a zápis.</span><span class="sxs-lookup"><span data-stu-id="a36a8-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="a36a8-165">Pole mít menší nároky paměti, která pomáhá snižovat pracovní sady, a přístup k prvků v poli je rychlejší, protože je optimalizována modulem runtime.</span><span class="sxs-lookup"><span data-stu-id="a36a8-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>  
  
 <span data-ttu-id="a36a8-166">**✓ ZVAŽTE** použití polí v nižší úrovně rozhraní API minimalizovat využití paměti a maximalizovat výkon.</span><span class="sxs-lookup"><span data-stu-id="a36a8-166">**✓ CONSIDER** using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>  
  
 <span data-ttu-id="a36a8-167">**PROVEĎTE ✓** pomocí bajtových polí místo kolekcí bajtů.</span><span class="sxs-lookup"><span data-stu-id="a36a8-167">**✓ DO** use byte arrays instead of collections of bytes.</span></span>  
  
 <span data-ttu-id="a36a8-168">**X nesmí** použít pole pro vlastnosti, pokud by pak bylo vlastnost vrací nové pole (například kopii interní pole) pokaždé, když je volána metoda getter vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="a36a8-168">**X DO NOT** use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>  
  
## <a name="implementing-custom-collections"></a><span data-ttu-id="a36a8-169">Implementace vlastních kolekcí</span><span class="sxs-lookup"><span data-stu-id="a36a8-169">Implementing Custom Collections</span></span>  
 <span data-ttu-id="a36a8-170">**✓ ZVAŽTE** dědění z `Collection<T>`, `ReadOnlyCollection<T>`, nebo `KeyedCollection<TKey,TItem>` při návrhu nové kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-170">**✓ CONSIDER** inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>  
  
 <span data-ttu-id="a36a8-171">**PROVEĎTE ✓** implementovat `IEnumerable<T>` při návrhu nové kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-171">**✓ DO** implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="a36a8-172">Zvažte implementaci `ICollection<T>` nebo i `IList<T>` kde má smysl.</span><span class="sxs-lookup"><span data-stu-id="a36a8-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>  
  
 <span data-ttu-id="a36a8-173">Při implementaci těchto vlastní kolekce, postupujte podle vzoru rozhraní API vymezenému `Collection<T>` a `ReadOnlyCollection<T>` co nejblíže.</span><span class="sxs-lookup"><span data-stu-id="a36a8-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="a36a8-174">To znamená implementovat stejné členy explicitně, název parametry, jako jsou tyto dvě kolekce název je a tak dále.</span><span class="sxs-lookup"><span data-stu-id="a36a8-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>  
  
 <span data-ttu-id="a36a8-175">**✓ ZVAŽTE** implementace rozhraní neobecné kolekce (`IList` a `ICollection`) Pokud kolekce se často předá rozhraní API trvá tato rozhraní jako vstup.</span><span class="sxs-lookup"><span data-stu-id="a36a8-175">**✓ CONSIDER** implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>  
  
 <span data-ttu-id="a36a8-176">**X nepoužívejte** implementace rozhraní pro kolekce na typy s komplexní rozhraní API koncept kolekce, které nejsou.</span><span class="sxs-lookup"><span data-stu-id="a36a8-176">**X AVOID** implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>  
  
 <span data-ttu-id="a36a8-177">**X nesmí** dědit z neobecného základní kolekcí, jako `CollectionBase`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-177">**X DO NOT** inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="a36a8-178">Použití `Collection<T>`, `ReadOnlyCollection<T>`, a `KeyedCollection<TKey,TItem>` místo.</span><span class="sxs-lookup"><span data-stu-id="a36a8-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>  
  
### <a name="naming-custom-collections"></a><span data-ttu-id="a36a8-179">Názvy vlastních kolekcí</span><span class="sxs-lookup"><span data-stu-id="a36a8-179">Naming Custom Collections</span></span>  
 <span data-ttu-id="a36a8-180">Kolekce (typy, které implementují `IEnumerable`) jsou vytvořeny především dvou důvodů: (1) Chcete-li vytvořit novou strukturu dat s operacích specifických struktura a často různé výkonové charakteristiky než existující datové struktury (například <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>) a (2) Chcete-li vytvořit kolekci specializované pro uložení konkrétní sadu položek (například <xref:System.Collections.Specialized.StringCollection>).</span><span class="sxs-lookup"><span data-stu-id="a36a8-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="a36a8-181">Datové struktury se nejčastěji používají k implementaci interní aplikace a knihovny.</span><span class="sxs-lookup"><span data-stu-id="a36a8-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="a36a8-182">Specializované kolekce jsou především mají být exponovány v rozhraní API (jako vlastnost a parametr typy).</span><span class="sxs-lookup"><span data-stu-id="a36a8-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>  
  
 <span data-ttu-id="a36a8-183">**PROVEĎTE ✓** používat příponu "Slovník" v názvech abstrakce implementace `IDictionary` nebo `IDictionary<TKey,TValue>`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-183">**✓ DO** use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>  
  
 <span data-ttu-id="a36a8-184">**PROVEĎTE ✓** používat příponu "Kolekce" v názvech typů implementace `IEnumerable` (nebo některého z jejich potomků) a představuje seznam položek.</span><span class="sxs-lookup"><span data-stu-id="a36a8-184">**✓ DO** use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>  
  
 <span data-ttu-id="a36a8-185">**PROVEĎTE ✓** použijte název struktura příslušná data pro vlastní datové struktury.</span><span class="sxs-lookup"><span data-stu-id="a36a8-185">**✓ DO** use the appropriate data structure name for custom data structures.</span></span>  
  
 <span data-ttu-id="a36a8-186">**X nepoužívejte** pomocí libovolné přípony zdání konkrétní implementace, jako je například "LinkedList" nebo "Zatřiďovací tabulky," v názvech abstrakce kolekce.</span><span class="sxs-lookup"><span data-stu-id="a36a8-186">**X AVOID** using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>  
  
 <span data-ttu-id="a36a8-187">**✓ ZVAŽTE** prefixu názvy kolekci s názvem typu položky.</span><span class="sxs-lookup"><span data-stu-id="a36a8-187">**✓ CONSIDER** prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="a36a8-188">Například kolekce ukládání položky typu `Address` (implementace `IEnumerable<Address>`) by měla mít název `AddressCollection`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="a36a8-189">Pokud typ položky je rozhraní, "I" předpony položky lze vynechat typu.</span><span class="sxs-lookup"><span data-stu-id="a36a8-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="a36a8-190">Proto kolekci <xref:System.IDisposable> položky lze volat `DisposableCollection`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>  
  
 <span data-ttu-id="a36a8-191">**✓ ZVAŽTE** pomocí předpony "Jen pro čtení" v názvech kolekcí jen pro čtení, pokud odpovídající kolekci lze zapisovat, mohou být přidány nebo již existuje v rámci.</span><span class="sxs-lookup"><span data-stu-id="a36a8-191">**✓ CONSIDER** using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>  
  
 <span data-ttu-id="a36a8-192">Například by měla být volána jen pro čtení kolekci řetězců `ReadOnlyStringCollection`.</span><span class="sxs-lookup"><span data-stu-id="a36a8-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>  
  
 <span data-ttu-id="a36a8-193">*Portions © 2005, 2009 Microsoft Corporation. Všechna práva vyhrazena.*</span><span class="sxs-lookup"><span data-stu-id="a36a8-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="a36a8-194">*Provedení podle oprávnění Pearson Education, Inc. z [pokynů pro návrh Framework: konvence, Idioms a vzory pro jedno použití knihovny .NET, 2. vydání](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina a Abrams Brada publikovaná 22 Oct 2008 pomocí Designing Effective jako součást vývoj řady Microsoft Windows.*</span><span class="sxs-lookup"><span data-stu-id="a36a8-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a36a8-195">Viz také</span><span class="sxs-lookup"><span data-stu-id="a36a8-195">See Also</span></span>  
 [<span data-ttu-id="a36a8-196">Pokyny k návrhu architektury</span><span class="sxs-lookup"><span data-stu-id="a36a8-196">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)  
 [<span data-ttu-id="a36a8-197">Pokyny k používání</span><span class="sxs-lookup"><span data-stu-id="a36a8-197">Usage Guidelines</span></span>](../../../docs/standard/design-guidelines/usage-guidelines.md)
