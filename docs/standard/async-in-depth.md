---
title: "Asynchronní podrobněji"
description: "Zjistěte, jak zápis I/čítači a vázané na procesor asynchronní kódu je přehledné pomocí modelu .NET Task-based asynchronní."
keywords: "Rozhraní .NET, rozhraní .NET core, Standard rozhraní .NET"
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: b23a90de991b31005ba5a07a959c717c24869ffb
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/23/2017
---
# <a name="async-in-depth"></a><span data-ttu-id="6da61-104">Asynchronní podrobněji</span><span class="sxs-lookup"><span data-stu-id="6da61-104">Async in depth</span></span>

<span data-ttu-id="6da61-105">Zápis vázané na vstupně-výstupních operací a procesor asynchronní kód je přehledné pomocí modelu .NET Task-based asynchronní.</span><span class="sxs-lookup"><span data-stu-id="6da61-105">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="6da61-106">Model je zveřejněný prostřednictvím `Task` a `Task<T>` typy a `async` a `await` klíčová slova v C# a Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6da61-106">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="6da61-107">(Prostředky pro konkrétní jazyky, které se nacházejí v [viz také](#see-also) části.) Tento článek vysvětluje, jak použít asynchronní rozhraní .NET a poskytuje vhled do rozhraní asynchronní použít v pozadí.</span><span class="sxs-lookup"><span data-stu-id="6da61-107">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-tasklttgt"></a><span data-ttu-id="6da61-108">Úlohy a úkolů&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="6da61-108">Task and Task&lt;T&gt;</span></span>

<span data-ttu-id="6da61-109">Úlohy jsou konstrukce používané k implementaci, která se označuje jako [Promise modelu Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="6da61-109">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="6da61-110">Stručně řečeno nabízejí můžete "příslib" které pracují se dokončit později, umožňují koordinaci s promise s čistou rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="6da61-110">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

*   <span data-ttu-id="6da61-111">`Task`představuje jednu operaci, která nevrátí hodnotu.</span><span class="sxs-lookup"><span data-stu-id="6da61-111">`Task` represents a single operation which does not return a value.</span></span>
*   <span data-ttu-id="6da61-112">`Task<T>`představuje jednu operaci, která vrátí hodnotu typu `T`.</span><span class="sxs-lookup"><span data-stu-id="6da61-112">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="6da61-113">Je důležité důvod o úlohách jako abstrakce pracovní děje asynchronně, a *není* abstrakci přes dělení na vlákna.</span><span class="sxs-lookup"><span data-stu-id="6da61-113">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="6da61-114">Ve výchozím nastavení úlohy spustit na aktuální pracovní vlákno a delegovat do operačního systému, podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="6da61-114">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="6da61-115">Volitelně můžete úlohy můžete explicitně požadovanou ke spuštění na samostatné vlákno prostřednictvím `Task.Run` rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="6da61-115">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="6da61-116">Úlohy vystavit protokol rozhraní API pro monitorování, čeká na a přístup k hodnotě výsledek (u `Task<T>`) úlohy.</span><span class="sxs-lookup"><span data-stu-id="6da61-116">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="6da61-117">Integrace jazyka s `await` – klíčové slovo, poskytuje vyšší úrovni abstrakce pro používání úlohy.</span><span class="sxs-lookup"><span data-stu-id="6da61-117">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span> 

<span data-ttu-id="6da61-118">Pomocí `await` umožňuje provádět užitečné práci, zatímco úloha běží je ovládací prvek jeho volajícího, dokud se provádí úloha vaše aplikace nebo služba.</span><span class="sxs-lookup"><span data-stu-id="6da61-118">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="6da61-119">Váš kód není nutné spoléhají na zpětná volání nebo události pro pokračování v provádění po dokončení úlohy.</span><span class="sxs-lookup"><span data-stu-id="6da61-119">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="6da61-120">Jazyk a úloh integrace rozhraní API nepodporuje který pro vás.</span><span class="sxs-lookup"><span data-stu-id="6da61-120">The language and task API integration does that for you.</span></span> <span data-ttu-id="6da61-121">Pokud používáte `Task<T>`, `await` – klíčové slovo bude kromě "rozbalení" hodnota vrácená po dokončení úlohy.</span><span class="sxs-lookup"><span data-stu-id="6da61-121">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="6da61-122">Podrobnosti o tom, jak to funguje jsou vysvětleny níže.</span><span class="sxs-lookup"><span data-stu-id="6da61-122">The details of how this works are explained further below.</span></span>

<span data-ttu-id="6da61-123">Další informace o úlohách a různé způsoby, jak pracovat s nimi v [založený na úlohách asynchronní vzor (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) tématu.</span><span class="sxs-lookup"><span data-stu-id="6da61-123">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="6da61-124">Podrobnější prohlídku do úlohy I/čítači operace</span><span class="sxs-lookup"><span data-stu-id="6da61-124">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="6da61-125">Následující část popisuje, co se stane s typické asynchronní vstupně-výstupních operací volání 10 000 stopy zobrazení.</span><span class="sxs-lookup"><span data-stu-id="6da61-125">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="6da61-126">Začněme několik příkladů.</span><span class="sxs-lookup"><span data-stu-id="6da61-126">Let's start with a couple examples.</span></span>

<span data-ttu-id="6da61-127">V prvním příkladu volá asynchronní metody a vrátí aktivní úkol, pravděpodobně ještě dokončit.</span><span class="sxs-lookup"><span data-stu-id="6da61-127">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();
    
    return client.GetStringAsync("http://www.dotnetfoundation.org");
}
```

<span data-ttu-id="6da61-128">V druhém příkladu přidá použití `async` a `await` klíčová slova pracovat v úloze.</span><span class="sxs-lookup"><span data-stu-id="6da61-128">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();
    
    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("http://www.dotnetfoundation.org");
    
    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.
    
    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="6da61-129">Volání `GetStringAsync()` volání nižší úrovně knihovny .NET (například volání jiných asynchronní metody) dokud dosáhne P/Invoke spolupráce volání do nativního síťové knihovny.</span><span class="sxs-lookup"><span data-stu-id="6da61-129">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="6da61-130">Nativní knihovny může následně volání do volání rozhraní API systému (například `write()` na soket v systému Linux).</span><span class="sxs-lookup"><span data-stu-id="6da61-130">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="6da61-131">Objekt úlohy se vytvoří v nativní nebo spravovaný hranic, které by mohly mít pomocí [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="6da61-131">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="6da61-132">Objekt úlohy budou předána vrstvy, pravděpodobně zpracovat nebo přímo vrátil, nakonec vrátí počáteční volajícího.</span><span class="sxs-lookup"><span data-stu-id="6da61-132">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span> 

<span data-ttu-id="6da61-133">V druhém příkladu výše `Task<T>` objekt se vrátil z `GetStringAsync`.</span><span class="sxs-lookup"><span data-stu-id="6da61-133">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="6da61-134">Použití `await` – klíčové slovo způsobí, že metoda vrátí objekt nově vytvořená úloha.</span><span class="sxs-lookup"><span data-stu-id="6da61-134">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="6da61-135">Vrátí ovládací prvek na volajícího z tohoto umístění v `GetFirstCharactersCountAsync` metoda.</span><span class="sxs-lookup"><span data-stu-id="6da61-135">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="6da61-136">Metody a vlastnosti [úloh&lt;T&gt; ](xref:System.Threading.Tasks.Task%601) objektu volajícím povolit pro monitorování průběhu úlohy, která se dokončí po zbývající kód v GetFirstCharactersCountAsync má provedení.</span><span class="sxs-lookup"><span data-stu-id="6da61-136">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="6da61-137">Po volání rozhraní API systému požadavku je nyní v prostoru jádra zajistit jeho způsob, jak síťového podsystému operačního systému (například `/net` Linux jádra systému).</span><span class="sxs-lookup"><span data-stu-id="6da61-137">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="6da61-138">Zde operačního systému sítě požadavek zpracuje *asynchronně*.</span><span class="sxs-lookup"><span data-stu-id="6da61-138">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="6da61-139">Podrobnosti se může lišit v závislosti na operačního systému používá (volání ovladače zařízení může být naplánovaná jako signál odeslána zpět do modulu runtime, nebo může být provedeno volání ovladačů zařízení a *pak* signál k odeslání zpět), ale nakonec budou informováni modul runtime aby sítě žádost je zpracovávána.</span><span class="sxs-lookup"><span data-stu-id="6da61-139">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="6da61-140">V tomto okamžiku pracovní ovladače zařízení budou buď být naplánované, probíhá nebo již bylo dokončeno, (požadavek je již na "přenášených v síti") – ale protože je to všechny děje asynchronně, ovladače zařízení je schopna okamžitě zpracovávat něco jiného!</span><span class="sxs-lookup"><span data-stu-id="6da61-140">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="6da61-141">V systému Windows operační systém například vlákno zavolá k ovladači zařízení sítě a požádá ji k provedení operace sítě prostřednictvím přerušení požadavku paketů (IRP), která představuje operaci.</span><span class="sxs-lookup"><span data-stu-id="6da61-141">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="6da61-142">Ovladače zařízení obdrží kontrolní, provede volání k síti, označí IRP jako "čekající na vyřízení" a vrátí zpět do operačního systému.</span><span class="sxs-lookup"><span data-stu-id="6da61-142">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="6da61-143">Vzhledem k tomu, že vlákno operačního systému teď ví, že je kontrolní "čekající", nemá žádné další práci udělat pro tuto úlohu a "vrátí" tak, aby ho lze provádět jinou práci.</span><span class="sxs-lookup"><span data-stu-id="6da61-143">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="6da61-144">Při splnění požadavku na a data zpátky prostřednictvím ovladače zařízení, upozorní procesoru nová data obdržel prostřednictvím přerušení.</span><span class="sxs-lookup"><span data-stu-id="6da61-144">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="6da61-145">Získá zpracování této přerušení se liší podle operačního systému, ale nakonec data budou předány prostřednictvím operačního systému dokud nedosáhne spolupráce volání systému (třeba v systému Linux obslužné rutiny přerušení se naplánuje dolní polovinu požadavku přerušení na předání dat operačního systému  asynchronně).</span><span class="sxs-lookup"><span data-stu-id="6da61-145">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="6da61-146">Poznámka: Tento to *také* probíhá asynchronně!</span><span class="sxs-lookup"><span data-stu-id="6da61-146">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="6da61-147">Výsledkem je ve frontě, dokud další vlákno k dispozici je možné provést asynchronní metody a "rozbalení" výsledek dokončené úlohy.</span><span class="sxs-lookup"><span data-stu-id="6da61-147">The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="6da61-148">V rámci celého tohoto procesu klíče takeaway je, že **žádný přístup z více vláken je vyhrazen pro spuštění úlohy**.</span><span class="sxs-lookup"><span data-stu-id="6da61-148">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="6da61-149">I když pracovní se spouštějí v kontextu některé (to znamená, operačního systému nutné předat data do ovladač zařízení a reagovat na přerušení), žádný přístup z více vláken je vyhrazený pro *čekání* pro data z požadavku opět online.</span><span class="sxs-lookup"><span data-stu-id="6da61-149">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="6da61-150">To umožňuje systému pro zpracování mnohem větší objem práce místo čekání volání některé vstupně-výstupních operací na dokončení.</span><span class="sxs-lookup"><span data-stu-id="6da61-150">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="6da61-151">Výše se mohou jevit jako hodně práce má být provedena, když měří podle skutečný čas, sice miniscule ve srovnání s čas potřebný k vykonávají samotnou práci vstupně-výstupní operace.</span><span class="sxs-lookup"><span data-stu-id="6da61-151">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="6da61-152">I když nejsou vůbec přesné potenciální časovou osu pro volání bude vypadat takto:</span><span class="sxs-lookup"><span data-stu-id="6da61-152">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="6da61-153">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="6da61-153">0-1————————————————————————————————————————————————–2-3</span></span>

*   <span data-ttu-id="6da61-154">Čas strávený z bodů `0` k `1` je všechno, dokud asynchronní metody vypočítá ovládacího prvku do jeho volajícího.</span><span class="sxs-lookup"><span data-stu-id="6da61-154">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
*   <span data-ttu-id="6da61-155">Čas strávený z bodů `1` k `2` časem stráveným na vstupně-výstupních operací s žádné procesoru náklady.</span><span class="sxs-lookup"><span data-stu-id="6da61-155">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
*   <span data-ttu-id="6da61-156">Nakonec čas strávený z bodů `2` k `3` je předávání řízení zpět (a potenciálně hodnotu) do asynchronní metody, které okamžiku je znovu prováděna.</span><span class="sxs-lookup"><span data-stu-id="6da61-156">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="6da61-157">Co to znamená pro scénář serveru?</span><span class="sxs-lookup"><span data-stu-id="6da61-157">What does this mean for a server scenario?</span></span>

<span data-ttu-id="6da61-158">Tento model funguje dobře u zatížení scénář typické serveru.</span><span class="sxs-lookup"><span data-stu-id="6da61-158">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="6da61-159">Protože nejsou k dispozici nejsou žádná vlákna vyhrazený pro blokování nedokončené úloh, můžete server fondu služby mnohem vyšší objem webových žádostí.</span><span class="sxs-lookup"><span data-stu-id="6da61-159">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="6da61-160">Vezměte v úvahu dva servery: ten, který spouští asynchronní kód a ten, který neexistuje.</span><span class="sxs-lookup"><span data-stu-id="6da61-160">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="6da61-161">Pro účely tohoto příkladu má každý server jenom 5 vláken, které jsou k dispozici pro žádosti o služby.</span><span class="sxs-lookup"><span data-stu-id="6da61-161">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="6da61-162">Všimněte si, že tato čísla jsou imaginarily malé a sloužit pouze v kontextu demonstrative.</span><span class="sxs-lookup"><span data-stu-id="6da61-162">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="6da61-163">Předpokládejme, že oba servery přijímat 6 souběžných požadavků.</span><span class="sxs-lookup"><span data-stu-id="6da61-163">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="6da61-164">Každý požadavek provede vstupně-výstupní operace.</span><span class="sxs-lookup"><span data-stu-id="6da61-164">Each request performs an I/O operation.</span></span>  <span data-ttu-id="6da61-165">Server *bez* asynchronní kódu má do fronty až 6. žádost, dokud jeden z 5 vláken dokončení práce I/čítači a zapsán odpovědi.</span><span class="sxs-lookup"><span data-stu-id="6da61-165">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="6da61-166">V místě, které 20 požadavek odeslán může server spustit zpomalit, protože fronta je získávání příliš dlouhý.</span><span class="sxs-lookup"><span data-stu-id="6da61-166">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="6da61-167">Server *s* asynchronní kód spuštěný na něm stále fronty až 6. požadavek, ale protože používá `async` a `await`, každý z jeho vláken jsou uvolněna, když se spustí I/čítači pracovní místo po dokončení.</span><span class="sxs-lookup"><span data-stu-id="6da61-167">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="6da61-168">V čase 20 žádost pochází ve frontě příchozích požadavků bude mnohem menší (pokud ho neobsahuje nic vůbec), a nebude zpomalit serveru.</span><span class="sxs-lookup"><span data-stu-id="6da61-168">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="6da61-169">Přestože je toto contrived příklad, funguje velmi podobně jako ochrana v reálném světě.</span><span class="sxs-lookup"><span data-stu-id="6da61-169">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="6da61-170">Ve skutečnosti můžete očekávat, že server moct zpracovávat další požadavky pomocí řádově `async` a `await` než pokud ho byly vyhradit vlákno pro každý požadavek obdrží.</span><span class="sxs-lookup"><span data-stu-id="6da61-170">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="6da61-171">Co to znamená pro scénář klienta?</span><span class="sxs-lookup"><span data-stu-id="6da61-171">What does this mean for client scenario?</span></span>

<span data-ttu-id="6da61-172">Největších nárůst pro používání `async` a `await` pro klienta aplikace je zvýšení odezvy.</span><span class="sxs-lookup"><span data-stu-id="6da61-172">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="6da61-173">I když reaguje aplikace můžete vytvořit pomocí při vytváření kopie vlákna ručně, v rámci při vytváření kopie vlákna je náročná operace relativně k jenom pomocí `async` a `await`.</span><span class="sxs-lookup"><span data-stu-id="6da61-173">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="6da61-174">Hlavně pro něco jako mobilní hry je velmi důležitý co nejméně vlákna uživatelského rozhraní kde problémem vstupně-výstupních operací, které mají vliv.</span><span class="sxs-lookup"><span data-stu-id="6da61-174">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="6da61-175">Je důležité protože pracovní I/čítači stráví prakticky žádný čas na procesoru, vyhradit celé vlákno procesoru provádět sotva jakékoli užitečné práce by špatné využití prostředků.</span><span class="sxs-lookup"><span data-stu-id="6da61-175">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="6da61-176">Kromě toho odeslání pracovní vlákno uživatelského rozhraní (například aktualizace uživatelského rozhraní) je velmi jednoduchý s `async` metody a nevyžaduje další práci (jako například volání delegáta vláken).</span><span class="sxs-lookup"><span data-stu-id="6da61-176">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="6da61-177">Podrobnější prohlídku do úloh a úloh<T> operace vázané na procesor</span><span class="sxs-lookup"><span data-stu-id="6da61-177">Deeper Dive into Task and Task<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="6da61-178">Vázané na procesor `async` kód je trochu jiná než I/čítači `async` kódu.</span><span class="sxs-lookup"><span data-stu-id="6da61-178">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="6da61-179">Protože práci na procesoru, neexistuje žádný způsob, jak získat kolem vyhradit vlákno pro výpočet.</span><span class="sxs-lookup"><span data-stu-id="6da61-179">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="6da61-180">Použití `async` a `await` poskytuje můžete s čistou způsob, jak pracovat s pozadí vláken a ponechat volající asynchronní metody reaguje.</span><span class="sxs-lookup"><span data-stu-id="6da61-180">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="6da61-181">Všimněte si, že to neposkytuje ochranu pro sdílená data.</span><span class="sxs-lookup"><span data-stu-id="6da61-181">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="6da61-182">Pokud používáte sdílená data, musíte pořád vztahují příslušné synchronizace strategie.</span><span class="sxs-lookup"><span data-stu-id="6da61-182">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="6da61-183">Tady je 10 000 stopy zobrazení asynchronního volání vázané na procesor:</span><span class="sxs-lookup"><span data-stu-id="6da61-183">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));
    
    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!
    
    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;
    
    return result;
}
```

<span data-ttu-id="6da61-184">`CalculateResult()`provede ve vlákně na byla volána.</span><span class="sxs-lookup"><span data-stu-id="6da61-184">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="6da61-185">Při volání `Task.Run`, se zařadí do fronty náročná operace vázané na procesor, `DoExpensiveCalculation()`, ve fondu vláken a přijímá `Task<int>` zpracování.</span><span class="sxs-lookup"><span data-stu-id="6da61-185">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="6da61-186">`DoExpensiveCalculation()`Nakonec běží souběžně na další dostupný vlákno, pravděpodobně na jiné jádro procesoru.</span><span class="sxs-lookup"><span data-stu-id="6da61-186">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="6da61-187">Je možné souběžných práci při `DoExpensiveCalculation()` je zaneprázdněn na jiné vlákno, protože vláken, který označuje `CalculateResult()` stále probíhá.</span><span class="sxs-lookup"><span data-stu-id="6da61-187">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="6da61-188">Jednou `await` bez provedení `CalculateResult()` jeho volajícího, povolení dalších práce s aktuálním vláknem při, je vhodné `DoExpensiveCalculation()` je produkování výsledku.</span><span class="sxs-lookup"><span data-stu-id="6da61-188">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="6da61-189">Po dokončení, výsledek je zařadit do fronty ke spuštění na hlavní vlákno.</span><span class="sxs-lookup"><span data-stu-id="6da61-189">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="6da61-190">Nakonec se vrátí hlavního vlákna pro provádění `CalculateResult()`, na bod, který bude mít výsledek `DoExpensiveCalculation()`.</span><span class="sxs-lookup"><span data-stu-id="6da61-190">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="6da61-191">Proč asynchronní pomáhá tady?</span><span class="sxs-lookup"><span data-stu-id="6da61-191">Why does async help here?</span></span>

<span data-ttu-id="6da61-192">`async`a `await` jsou nejlepší praxi Správa pracovních vázané na procesor, když potřebujete odezvy.</span><span class="sxs-lookup"><span data-stu-id="6da61-192">`async` and `await` are the best practice managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="6da61-193">Existuje více vzory pro použití modifikátoru async s pracovní vázané na procesor.</span><span class="sxs-lookup"><span data-stu-id="6da61-193">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="6da61-194">Je důležité si uvědomit, že je malé náklady na použití modifikátoru async a není doporučeno pro úzkou smyčky.</span><span class="sxs-lookup"><span data-stu-id="6da61-194">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="6da61-195">Je to na určit, jak psát kód kolem této nové funkci.</span><span class="sxs-lookup"><span data-stu-id="6da61-195">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="6da61-196">Viz také</span><span class="sxs-lookup"><span data-stu-id="6da61-196">See also</span></span>

<span data-ttu-id="6da61-197">[Asynchronní programování v jazyce C#](~/docs/csharp/async.md) </span><span class="sxs-lookup"><span data-stu-id="6da61-197">[Asynchronous programming in C#](~/docs/csharp/async.md) </span></span>  
<span data-ttu-id="6da61-198">[Asynchronní programování v F #](~/docs/fsharp/tutorials/asynchronous-and-concurrent-programming/async.md) </span><span class="sxs-lookup"><span data-stu-id="6da61-198">[Async Programming in F#](~/docs/fsharp/tutorials/asynchronous-and-concurrent-programming/async.md) </span></span>  
[<span data-ttu-id="6da61-199">Asynchronní programování pomocí modifikátoru Async a operátoru Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="6da61-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](~/docs/visual-basic/programming-guide/concepts/async/index.md)
