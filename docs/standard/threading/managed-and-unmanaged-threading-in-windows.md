---
title: "Spravovaná a nespravovaná vlákna ve Windows"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
caps.latest.revision: "17"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 2ce17ef15a5b582a9df0f16d7e0ac82df626579d
ms.sourcegitcommit: c0dd436f6f8f44dc80dc43b07f6841a00b74b23f
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/19/2018
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="9f742-102">Spravovaná a nespravovaná vlákna ve Windows</span><span class="sxs-lookup"><span data-stu-id="9f742-102">Managed and Unmanaged Threading in Windows</span></span>
<span data-ttu-id="9f742-103">Správa všechna vlákna se provádí prostřednictvím <xref:System.Threading.Thread> třídy, včetně vláken vytvořený modul common language runtime a ty mimo modul runtime, který zadejte spravované prostředí ke spouštění kódu.</span><span class="sxs-lookup"><span data-stu-id="9f742-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="9f742-104">Modul runtime monitoruje všechna vlákna zpracování, které někdy provedli kódu v rámci spravovaného spouštění prostředí.</span><span class="sxs-lookup"><span data-stu-id="9f742-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="9f742-105">Žádné další podprocesy sledovat.</span><span class="sxs-lookup"><span data-stu-id="9f742-105">It does not track any other threads.</span></span> <span data-ttu-id="9f742-106">Vláken můžete zadat spravovaného spouštění prostředí pomocí zprostředkovatele komunikace s objekty COM (protože modul runtime zpřístupní spravované objekty jako objekty COM nespravované World), modelu COM [DllGetClassObject](https://msdn.microsoft.com/library/ms680760.aspx) funkce a vyvolání platformy.</span><span class="sxs-lookup"><span data-stu-id="9f742-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](https://msdn.microsoft.com/library/ms680760.aspx) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="9f742-107">Nespravovaná vlákna zadá runtime prostřednictvím, například obálka volatelná aplikacemi COM, systém kontroluje, zda místní úložiště daném vláknu se podívat interní spravované <xref:System.Threading.Thread> objektu.</span><span class="sxs-lookup"><span data-stu-id="9f742-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="9f742-108">Pokud je takový nalezen, je již vědět tohoto podprocesu modulu runtime.</span><span class="sxs-lookup"><span data-stu-id="9f742-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="9f742-109">Pokud nelze najít jednu, vytvoří novou však modulu runtime <xref:System.Threading.Thread> objektu a nainstaluje v místním úložišti tento přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="9f742-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="9f742-110">V dělení na spravovaná vlákna, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> je identifikace stabilní spravovaných vláken.</span><span class="sxs-lookup"><span data-stu-id="9f742-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="9f742-111">Po dobu jeho existence váš přístup z více vláken nebude kolidují s hodnotou z jiné vlákno, bez ohledu na doménu aplikace, ze kterého můžete získat tuto hodnotu.</span><span class="sxs-lookup"><span data-stu-id="9f742-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9f742-112">Spouštění operačního systému **ID podprocesu** nemá žádný pevné vztah k spravované vlákno, protože nespravované hostitele můžete řídit vztah mezi spravovanými a nespravovanými vláken.</span><span class="sxs-lookup"><span data-stu-id="9f742-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="9f742-113">Konkrétně sofistikované hostitele můžete použít rozhraní API Fiber, naplánovat mnoho spravovaných vláknech na stejném vlákně, v operačním systému nebo přesunout spravované vlákno mezi vláken jiného operačního systému.</span><span class="sxs-lookup"><span data-stu-id="9f742-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="9f742-114">Mapování z vlákna Win32 pro dělení na spravovaná vlákna</span><span class="sxs-lookup"><span data-stu-id="9f742-114">Mapping from Win32 Threading to Managed Threading</span></span>  
 <span data-ttu-id="9f742-115">Následující tabulka mapuje vláken elementy Win32 jejich přibližnou runtime ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="9f742-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="9f742-116">Všimněte si, že toto mapování nepředstavuje identické funkce.</span><span class="sxs-lookup"><span data-stu-id="9f742-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="9f742-117">Například **TerminateThread** nepracuje **nakonec** klauzule nebo uvolní prostředky a nelze zabránit.</span><span class="sxs-lookup"><span data-stu-id="9f742-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="9f742-118">Ale <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> provede všech vašich kódech vrácení zpět, získá všechny prostředky a může být odepřen pomocí <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="9f742-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="9f742-119">Nezapomeňte si přečíst v dokumentaci těsně před odhad funkce.</span><span class="sxs-lookup"><span data-stu-id="9f742-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="9f742-120">V systému Win32</span><span class="sxs-lookup"><span data-stu-id="9f742-120">In Win32</span></span>|<span data-ttu-id="9f742-121">V modulu common language runtime</span><span class="sxs-lookup"><span data-stu-id="9f742-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="9f742-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="9f742-122">**CreateThread**</span></span>|<span data-ttu-id="9f742-123">Kombinace **vláken** a<xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="9f742-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="9f742-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="9f742-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="9f742-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="9f742-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-127">**Přejít do režimu spánku**</span><span class="sxs-lookup"><span data-stu-id="9f742-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-128">**WaitForSingleObject** na popisovač podprocesu</span><span class="sxs-lookup"><span data-stu-id="9f742-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="9f742-129">**ExitThread**</span></span>|<span data-ttu-id="9f742-130">Žádný ekvivalent</span><span class="sxs-lookup"><span data-stu-id="9f742-130">No equivalent</span></span>|  
|<span data-ttu-id="9f742-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="9f742-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="9f742-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-133">Žádný ekvivalent</span><span class="sxs-lookup"><span data-stu-id="9f742-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-134">Žádný ekvivalent</span><span class="sxs-lookup"><span data-stu-id="9f742-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="9f742-135">Zavřete na **CoInitializeEx** (OLE32. KNIHOVNY DLL)</span><span class="sxs-lookup"><span data-stu-id="9f742-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="9f742-136">Spravovaných vláknech a Apartment COM</span><span class="sxs-lookup"><span data-stu-id="9f742-136">Managed Threads and COM Apartments</span></span>  
 <span data-ttu-id="9f742-137">Spravované vlákno, může být označen k označení, že bude hostitelem [jednovláknové](http://msdn.microsoft.com/library/windows/desktop/ms680112.aspx) nebo [vícevláknové](http://msdn.microsoft.com/library/windows/desktop/ms693421.aspx) typu apartment.</span><span class="sxs-lookup"><span data-stu-id="9f742-137">A managed thread can be marked to indicate that it will host a [single-threaded](http://msdn.microsoft.com/library/windows/desktop/ms680112.aspx) or [multithreaded](http://msdn.microsoft.com/library/windows/desktop/ms693421.aspx) apartment.</span></span> <span data-ttu-id="9f742-138">(Další informace o modelu COM dělení na vlákna architektuře, najdete v části [procesy, vláken a Apartment](http://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, A <xref:System.Threading.Thread.TrySetApartmentState%2A> metody <xref:System.Threading.Thread> třídy vrátit a přiřaďte stav objektu apartment vlákna.</span><span class="sxs-lookup"><span data-stu-id="9f742-138">(For more information on the COM threading architecture, see [Processes, threads, and Apartments](http://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="9f742-139">Pokud stav není nastaven, <xref:System.Threading.Thread.GetApartmentState%2A> vrátí <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f742-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9f742-140">Vlastnost lze nastavit pouze v případě, že se <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stavu; ho lze nastavit pouze jednou vlákna.</span><span class="sxs-lookup"><span data-stu-id="9f742-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="9f742-141">Pokud stav objektu apartment není nastavena, před zahájením vlákno, vlákno je inicializován jako více vláken typu apartment (MTA).</span><span class="sxs-lookup"><span data-stu-id="9f742-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="9f742-142">Vlákno finalizační metodu a všechna vlákna řízené <xref:System.Threading.ThreadPool> jsou modelu MTA.</span><span class="sxs-lookup"><span data-stu-id="9f742-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9f742-143">Pro spuštění kódu aplikace, je jediným způsobem, jak řídit stav objektu apartment použít <xref:System.MTAThreadAttribute> nebo <xref:System.STAThreadAttribute> položek bodu postupu.</span><span class="sxs-lookup"><span data-stu-id="9f742-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="9f742-144">V rozhraní .NET Framework 1.0 a 1.1 <xref:System.Threading.Thread.ApartmentState%2A> vlastnost lze nastavit jako první řádek kódu.</span><span class="sxs-lookup"><span data-stu-id="9f742-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="9f742-145">To není povoleno v rozhraní .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="9f742-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="9f742-146">Spravované objekty, které jsou zpřístupněny COM chovat, jako by se měl agregovat volné zařazování vláken.</span><span class="sxs-lookup"><span data-stu-id="9f742-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="9f742-147">Jinými slovy bylo možné volat z jakékoli COM apartment způsobem podprocesy.</span><span class="sxs-lookup"><span data-stu-id="9f742-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="9f742-148">Jenom spravované objekty, které nedojde toto chování podprocesy jsou tyto objekty, které jsou odvozeny od <xref:System.EnterpriseServices.ServicedComponent> nebo <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="9f742-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="9f742-149">Ve spravovaném světě, neexistuje žádná podpora pro <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> Pokud nechcete použít kontexty a spravované instance kontextu vazby.</span><span class="sxs-lookup"><span data-stu-id="9f742-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="9f742-150">Pokud používáte podnikové služby, pak objektu musí být odvozeny od <xref:System.EnterpriseServices.ServicedComponent> (který je sám odvozen z <xref:System.ContextBoundObject>).</span><span class="sxs-lookup"><span data-stu-id="9f742-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="9f742-151">Když spravovaný kód zavolá objekty modelu COM, vždy následuje COM pravidla.</span><span class="sxs-lookup"><span data-stu-id="9f742-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="9f742-152">Jinými slovy zavolá prostřednictvím proxy apartment COM a kontext obálky COM + 1.0 stanovená OLE32.</span><span class="sxs-lookup"><span data-stu-id="9f742-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="9f742-153">Problémy s blokováním</span><span class="sxs-lookup"><span data-stu-id="9f742-153">Blocking Issues</span></span>  
 <span data-ttu-id="9f742-154">Pokud vlákno provede volání nespravovaného do operačního systému, který má blokovaný vlákno v nespravovaném kódu, modul runtime nebude převzít kontrolu nad pro <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> nebo <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f742-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9f742-155">U <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, modul runtime označí vlákno pro **Abort** a provede kontrolu nad ho, když ho znovu vstupuje do spravovaného kódu.</span><span class="sxs-lookup"><span data-stu-id="9f742-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="9f742-156">Je vhodnější pro použití spravovaných blokování místo nespravované blokování.</span><span class="sxs-lookup"><span data-stu-id="9f742-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="9f742-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>a tak dále jsou všechny reaguje na <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> a <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f742-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9f742-158">Navíc pokud váš přístup z více vláken ve single-threaded apartment, všechny tyto spravované blokování operace bude správně čerpadla zprávy ve vašem apartment při vaší vlákno je blokované.</span><span class="sxs-lookup"><span data-stu-id="9f742-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9f742-159">Viz také</span><span class="sxs-lookup"><span data-stu-id="9f742-159">See Also</span></span>  
 <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>  
 <xref:System.Threading.ThreadState>  
 <xref:System.EnterpriseServices.ServicedComponent>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.Monitor>
