---
title: Přehled primitiv synchronizace
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 37abcb6b3a8fdf4ef91d5e946a97db7ca1428ce8
ms.sourcegitcommit: dfb2a100cfb4d3902c042f17b3204f49bc7635e7
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/20/2018
ms.locfileid: "46493084"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="f2a2f-102">Přehled primitiv synchronizace</span><span class="sxs-lookup"><span data-stu-id="f2a2f-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="f2a2f-103">Rozhraní .NET Framework poskytuje celou řadu primitiv synchronizace pro řízení interakce vláken a jak se vyhnout konfliktům časování.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="f2a2f-104">Ty je možné zhruba rozdělit do tří kategorií: zamykání, signalizační a propojené operace.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="f2a2f-105">Kategorie nejsou uklizený ani jasně definované: Některé mechanismy synchronizace mají charakteristiky v několika kategoriích; události, které verze jedním vláknem a současně jsou funkčně jako zámky; verze žádný zámek si lze představit jako signál; a propojené operace lze použít k sestavení kompletních zámky.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="f2a2f-106">Kategorie jsou však stále užitečná.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="f2a2f-107">Je dobré si uvědomit, že je kooperativní synchronizaci vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="f2a2f-108">Pokud ani jedno vlákno obchází synchronizační mechanismus a přistupuje k chráněnému prostředku přímo, tento synchronizační mechanismus nemůže být účinné.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="f2a2f-109">Tento přehled obsahuje následující části:</span><span class="sxs-lookup"><span data-stu-id="f2a2f-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="f2a2f-110">Uzamčení</span><span class="sxs-lookup"><span data-stu-id="f2a2f-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="f2a2f-111">Signalizace</span><span class="sxs-lookup"><span data-stu-id="f2a2f-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="f2a2f-112">Typy zjednodušené synchronizace</span><span class="sxs-lookup"><span data-stu-id="f2a2f-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="f2a2f-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="f2a2f-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="f2a2f-114">Propojené operace</span><span class="sxs-lookup"><span data-stu-id="f2a2f-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="f2a2f-115">Uzamčení</span><span class="sxs-lookup"><span data-stu-id="f2a2f-115">Locking</span></span>  
 <span data-ttu-id="f2a2f-116">Zámky poskytují kontrolu prostředku na jedno vlákno najednou, nebo zadaný počet vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="f2a2f-117">Vlákna, která vyžaduje výhradní zámek při zámek je používán bloky dokud nebude k dispozici zámek.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="f2a2f-118">Výhradní zámků</span><span class="sxs-lookup"><span data-stu-id="f2a2f-118">Exclusive Locks</span></span>  
 <span data-ttu-id="f2a2f-119">Nejjednodušší forma uzamčení se `lock` příkaz v jazyce C# a `SyncLock` v sadě Visual Studio, které řídí přístup k bloku kódu.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="f2a2f-120">Takové bloku se často označuje jako kritickou sekci.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="f2a2f-121">`lock` Příkazu je implementovaný s využitím <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> a <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody a používá `try…finally` blok k Ujistěte se, že zámek je uvolněn.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="f2a2f-122">Obecně platí, pomocí `lock` nebo `SyncLock` příkaz k ochraně malé bloky kódu, nikdy pokrývající více než jedné metody, je nejlepší způsob, jak používat <xref:System.Threading.Monitor> třídy.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="f2a2f-123">I když výkonné, <xref:System.Threading.Monitor> třídy je náchylný na zámků osamocené a zablokování.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="f2a2f-124">Monitor – třída</span><span class="sxs-lookup"><span data-stu-id="f2a2f-124">Monitor Class</span></span>  
 <span data-ttu-id="f2a2f-125"><xref:System.Threading.Monitor> Třída poskytuje další funkce, které lze použít ve spojení s `lock` – příkaz:</span><span class="sxs-lookup"><span data-stu-id="f2a2f-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="f2a2f-126"><xref:System.Threading.Monitor.TryEnter%2A> Metoda umožňuje podproces, který je blokovaný čekání na prostředek, který chcete vzdát po uplynutí zadaného intervalu.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="f2a2f-127">Vrátí logickou hodnotu udávající úspěch nebo selhání, který slouží ke zjišťování a zabránilo potenciální zablokování.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="f2a2f-128"><xref:System.Threading.Monitor.Wait%2A> Metoda je volána vláknem v kritický oddíl.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="f2a2f-129">Nabízí řízení prostředků a bloky, dokud prostředek je opět k dispozici.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="f2a2f-130"><xref:System.Threading.Monitor.Pulse%2A> a <xref:System.Threading.Monitor.PulseAll%2A> povolit vlákno, které chcete uvolnit zámek nebo volání metody <xref:System.Threading.Monitor.Wait%2A> umístit jeden nebo více vláken do fronty, připravené tak, aby jejich získání zámku.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="f2a2f-131">Časové limity u <xref:System.Threading.Monitor.Wait%2A> přetížení metody umožňují čekajících vláken k návratu do fronty připravené.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="f2a2f-132"><xref:System.Threading.Monitor> Třída může poskytnout uzamčení v víc aplikačních doménách, pokud objekt použitý pro zámek je odvozena z <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="f2a2f-133"><xref:System.Threading.Monitor> má spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="f2a2f-134">To znamená, vlákna, které zadaný monitor ukončíte zavoláním <xref:System.Threading.Monitor.Exit%2A> nebo <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="f2a2f-135"><xref:System.Threading.Monitor> Třída není instantiable.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="f2a2f-136">Její metody jsou statické (`Shared` v jazyce Visual Basic), dokážete na základě instantiable zámek objektu.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="f2a2f-137">Koncepční přehled najdete v tématu [monitorování](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="f2a2f-138">Mutex – třída</span><span class="sxs-lookup"><span data-stu-id="f2a2f-138">Mutex Class</span></span>  
 <span data-ttu-id="f2a2f-139">Požadavek vlákna <xref:System.Threading.Mutex> voláním přetížení jeho <xref:System.Threading.WaitHandle.WaitOne%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f2a2f-140">Přetížení s vypršení časového limitu jsou k dispozici, aby vlákna uvolňovat čekání.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="f2a2f-141">Na rozdíl od <xref:System.Threading.Monitor> třídě mutex může být místní nebo globální.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="f2a2f-142">Globální objekty mutex, také nazývané objekty pojmenované mutex, jsou viditelné v celém operačním systému a slouží k synchronizaci vláken ve více doménách aplikace nebo procesy.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="f2a2f-143">Místní mutexů odvozovat <xref:System.MarshalByRefObject>a můžete použít přes hranice aplikačních domén.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f2a2f-144">Kromě toho <xref:System.Threading.Mutex> je odvozena z <xref:System.Threading.WaitHandle>, což znamená, že lze použít s signalizační mechanismy poskytované <xref:System.Threading.WaitHandle>, například <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, a <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="f2a2f-145">Stejně jako <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> má spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="f2a2f-146">Na rozdíl od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> je instantiable objekt.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="f2a2f-147">Koncepční přehled najdete v tématu [mutexů](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="f2a2f-148">Třída struktuře SpinLock</span><span class="sxs-lookup"><span data-stu-id="f2a2f-148">SpinLock Class</span></span>  
 <span data-ttu-id="f2a2f-149">Počínaje [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], můžete použít <xref:System.Threading.SpinLock> třídy, pokud to vyžaduje režii <xref:System.Threading.Monitor> snižuje výkon.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="f2a2f-150">Když <xref:System.Threading.SpinLock> zaznamená uzamčené kritický oddíl, ho jednoduše přede ve smyčce dokud nebude k dispozici zámek.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="f2a2f-151">Pokud je pro velmi krátké době zámek, pokryjte může poskytovat lepší výkon než blokování.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="f2a2f-152">Nicméně, pokud je zámek je uložena pro více než několik desítek cykly, <xref:System.Threading.SpinLock> provádí stejně, jako <xref:System.Threading.Monitor>, ale bude používat další Procesorové cykly a proto může snížit výkon jiných vláknech či procesy.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="f2a2f-153">Další zámky</span><span class="sxs-lookup"><span data-stu-id="f2a2f-153">Other Locks</span></span>  
 <span data-ttu-id="f2a2f-154">Zámky nemusí být exkluzivní.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-154">Locks need not be exclusive.</span></span> <span data-ttu-id="f2a2f-155">Často je užitečné umožnit omezenému počtu vláken souběžný přístup k prostředku.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="f2a2f-156">Semaforů a zámky pro čtení a zápis jsou určeny k řízení tento druh přístupu k prostředkům ve fondu.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="f2a2f-157">ReaderWriterLock – třída</span><span class="sxs-lookup"><span data-stu-id="f2a2f-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="f2a2f-158"><xref:System.Threading.ReaderWriterLockSlim> Třídy řeší případ, kdy vlákno, které mění data, modul pro zápis musí exkluzivní přístup k prostředku.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="f2a2f-159">Pokud modul pro zápis není aktivní, můžete libovolný počet čtenářů přístup k prostředku (například voláním <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metoda).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="f2a2f-160">Pokud vlákno vyžaduje výhradní přístup (například voláním <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metoda), následné čtečky požadavky bloku, dokud všechny existující čtenáři odpojili zámek a zapisovač, který má zadaný a byla ukončena, zámek.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="f2a2f-161"><xref:System.Threading.ReaderWriterLockSlim> má spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="f2a2f-162">Koncepční přehled najdete v tématu [čtení a zápis uzamkne](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="f2a2f-163">Semaphore – třída</span><span class="sxs-lookup"><span data-stu-id="f2a2f-163">Semaphore Class</span></span>  
 <span data-ttu-id="f2a2f-164"><xref:System.Threading.Semaphore> Třída umožňuje zadaný počet vláken pro přístup k prostředku.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="f2a2f-165">Žádosti o prostředku bloku, dokud vlákno uvolní semafor další vlákna.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="f2a2f-166">Podobně jako <xref:System.Threading.Mutex> třídy <xref:System.Threading.Semaphore> je odvozena z <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f2a2f-167">Také jako <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> může být místní nebo globální.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="f2a2f-168">Je možné přes hranice aplikačních domén.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f2a2f-169">Na rozdíl od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, a <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> nemá spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="f2a2f-170">To znamená, že je možné použít v situacích, kdy jedno vlákno získává semafor a jiné verze.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="f2a2f-171">Koncepční přehled najdete v tématu [Semaphore a SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="f2a2f-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> je zjednodušené semafor pro synchronizaci v rámci jednoho procesu hranice.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="f2a2f-173">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="f2a2f-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="f2a2f-174">Signálů</span><span class="sxs-lookup"><span data-stu-id="f2a2f-174">Signaling</span></span>  
 <span data-ttu-id="f2a2f-175">Nejjednodušší způsob, jak čekání na signál z jiného vlákna je zavolat <xref:System.Threading.Thread.Join%2A> metodu, která blokuje, dokud se nedokončí jiného podprocesu.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="f2a2f-176"><xref:System.Threading.Thread.Join%2A> má dvě přetížení, které umožňují zablokování vlákna, aby čekání po uplynutí zadaného intervalu.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="f2a2f-177">Obslužné rutiny čekání poskytují mnohem širší nabídku sad signalizace možnosti a čekání.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="f2a2f-178">Obslužné rutiny čekání</span><span class="sxs-lookup"><span data-stu-id="f2a2f-178">Wait Handles</span></span>  
 <span data-ttu-id="f2a2f-179">Obslužné rutiny čekání odvozovat <xref:System.Threading.WaitHandle> třídu, která je dále odvozeno z <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="f2a2f-180">Díky tomu se obslužné rutiny čekání slouží k synchronizaci činností vlákna přes hranice aplikačních domén.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f2a2f-181">Blokování vlákna na čekací zpracovává zavoláním metody instance <xref:System.Threading.WaitHandle.WaitOne%2A> nebo statických metod <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, nebo <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="f2a2f-182">Jak se vydávají závisí na byla volána metoda a na druhu obslužné rutiny čekání.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="f2a2f-183">Koncepční přehled najdete v tématu [počkejte zpracovává](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="f2a2f-184">Událost obslužné rutiny čekání</span><span class="sxs-lookup"><span data-stu-id="f2a2f-184">Event Wait Handles</span></span>  
 <span data-ttu-id="f2a2f-185">Zahrnout události obslužné rutiny čekání <xref:System.Threading.EventWaitHandle> třída a odvozené třídy, <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="f2a2f-186">Vlákna se vydávají z popisovače čekání události při popisovač čekání události signalizován voláním jeho <xref:System.Threading.EventWaitHandle.Set%2A> metody nebo pomocí <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="f2a2f-187">Událost obslužné rutiny, buď resetovat sami automaticky, jako je Turniket, který umožňuje pouze jedno vlákno prostřednictvím pokaždé, když je signalizována, nebo musí být v továrním ručně, jako je brána je zavřít, dokud není signalizována a pak otevřete, dokud uživatel nezavře čekání.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="f2a2f-188">Jak naznačují jejich názvy <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent> představují bývalého a druhá možnost, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="f2a2f-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> je zjednodušené událost synchronizace v rámci jednoho procesu hranice.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="f2a2f-190"><xref:System.Threading.EventWaitHandle> Může představovat buď typ události a může být místní nebo globální.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="f2a2f-191">Odvozené třídy <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent> jsou vždy místní.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="f2a2f-192">Obslužné rutiny události čekání nemají spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="f2a2f-193">Jakékoli vlákno může signalizuje, že popisovač čekání událost.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="f2a2f-194">Koncepční přehled najdete v tématu [eventwaithandle –, autoresetevent –, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="f2a2f-195">Vzájemně vyloučený přístup a třídy Semaphore</span><span class="sxs-lookup"><span data-stu-id="f2a2f-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="f2a2f-196">Vzhledem k tomu, <xref:System.Threading.Mutex> a <xref:System.Threading.Semaphore> třídy odvozovat z <xref:System.Threading.WaitHandle>, je možné pomocí statické metody z <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f2a2f-197">Například můžete použít vlákno <xref:System.Threading.WaitHandle.WaitAll%2A> metoda počkat, dokud jsou splněny všechny tři z následujících akcí: <xref:System.Threading.EventWaitHandle> signalizován, <xref:System.Threading.Mutex> vydání a <xref:System.Threading.Semaphore> vydání.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="f2a2f-198">Podobně můžete použít vlákno <xref:System.Threading.WaitHandle.WaitAny%2A> metoda počkat, až některou z těchto podmínek má hodnotu true.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="f2a2f-199">Pro <xref:System.Threading.Mutex> nebo <xref:System.Threading.Semaphore>, probíhá signalizován znamená, že se vydávají.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="f2a2f-200">Pokud se buď typ používá jako první argument <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda, se uvolní.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="f2a2f-201">V případě třídy <xref:System.Threading.Mutex>, který obsahuje spřažení vláken, je vyvolána výjimka, pokud volající vlákno nevlastní mutex.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="f2a2f-202">Jak bylo uvedeno dříve, nemají semafory spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="f2a2f-203">Bariéra</span><span class="sxs-lookup"><span data-stu-id="f2a2f-203">Barrier</span></span>  
 <span data-ttu-id="f2a2f-204"><xref:System.Threading.Barrier> Třída poskytuje způsob, jak cyklicky synchronizovat více vláken, aby se všechny blok na stejný bod a počkat na všechna vlákna, k dokončení.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="f2a2f-205">Bariéra je užitečné, když jeden nebo více vláken vyžadují výsledky z jiného vlákna než budete pokračovat v další fázi algoritmus.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="f2a2f-206">Další informace najdete v tématu [bariéry](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="f2a2f-207">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="f2a2f-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="f2a2f-208">Typy zjednodušené synchronizace</span><span class="sxs-lookup"><span data-stu-id="f2a2f-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="f2a2f-209">Počínaje [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], můžete použít primitiv synchronizace, které poskytují rychlý výkon zabráněním nákladné závislost na Win32 jádra objekty, jako je obslužné rutiny, kdykoli je to možné čekání.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="f2a2f-210">Obecně platí abyste používali tyto typy po krátkou dobu čekání a pouze v případě, že původní typy synchronizace jste se pokusili a vyhodnocený jako nevyhovující.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="f2a2f-211">Jednoduché typy nelze používat ve scénářích, které vyžadují komunikace mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="f2a2f-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> je Odlehčená verze <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f2a2f-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> je Odlehčená verze <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f2a2f-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> představuje událost, která se stane signalizováno při její vlastnosti count je nula.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="f2a2f-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> umožňuje více vláken, k synchronizaci mezi sebou bez použití ovládacího prvku hlavní vlákno.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="f2a2f-216">Bariéry brání každé vlákno pokračovat, dokud všechna vlákna dosáhli Zadaný bod.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="f2a2f-217">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="f2a2f-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="f2a2f-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="f2a2f-218">SpinWait</span></span>  
 <span data-ttu-id="f2a2f-219">Počínaje [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], můžete použít <xref:System.Threading.SpinWait?displayProperty=nameWithType> struktury, pokud vlákno obsahuje čekání na událost má být signalizován nebo podmínku splnit, ale v případě, že skutečné čekací doba má být menší než doba čekání pomocí popisovač čekání nebo otherwi se blokuje aktuální vlákno.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="f2a2f-220">S použitím <xref:System.Threading.SpinWait>, můžete zadat krátké doby k aktivaci při čekání a potom yield (třeba podle čekání nebo v režimu spánku) pouze v případě, že nebyla splněna podmínka v určený čas.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="f2a2f-221">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="f2a2f-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="f2a2f-222">Propojené operace</span><span class="sxs-lookup"><span data-stu-id="f2a2f-222">Interlocked Operations</span></span>  
 <span data-ttu-id="f2a2f-223">Propojené operace jsou jednoduché atomické operace provedené na umístění v paměti pomocí statických metod <xref:System.Threading.Interlocked> třídy.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="f2a2f-224">Atomických operací zahrnují přidání, zvýšení a snížení, exchange, podmíněné exchange v závislosti na tom, porovnání a operace čtení pro hodnoty 64-bit na 32bitových platformách.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f2a2f-225">Zárukou atomicitu je omezená na jednotlivé operace; Když jako jednotka se musí provádět více operací, musí být použita více hrubých synchronizační mechanismus.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="f2a2f-226">I když žádné z těchto operací se zámky nebo signály, můžete použít k sestavení kompletních zámky a signálů.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="f2a2f-227">Protože jde o nativního pro operační systém Windows, propojené operace jsou velmi rychlé.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="f2a2f-228">Propojené operace lze s volatile paměti záruky pro psaní aplikací, které vykazují výkonné neblokující souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="f2a2f-229">Ale vyžadují sofistikované, nízké úrovně programování, tak pro většinu účelů jsou jednoduché zámky lepší volbou.</span><span class="sxs-lookup"><span data-stu-id="f2a2f-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="f2a2f-230">Koncepční přehled najdete v tématu [propojené operace](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="f2a2f-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f2a2f-231">Viz také:</span><span class="sxs-lookup"><span data-stu-id="f2a2f-231">See also</span></span>

- [<span data-ttu-id="f2a2f-232">Synchronizace dat pro vícevláknové zpracování</span><span class="sxs-lookup"><span data-stu-id="f2a2f-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="f2a2f-233">Monitorování</span><span class="sxs-lookup"><span data-stu-id="f2a2f-233">Monitors</span></span>](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
- [<span data-ttu-id="f2a2f-234">Mutex – třídy</span><span class="sxs-lookup"><span data-stu-id="f2a2f-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
- [<span data-ttu-id="f2a2f-235">Semaphore a SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="f2a2f-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
- [<span data-ttu-id="f2a2f-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="f2a2f-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
- [<span data-ttu-id="f2a2f-237">Obslužné rutiny čekání</span><span class="sxs-lookup"><span data-stu-id="f2a2f-237">Wait Handles</span></span>](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
- [<span data-ttu-id="f2a2f-238">Propojené operace</span><span class="sxs-lookup"><span data-stu-id="f2a2f-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
- [<span data-ttu-id="f2a2f-239">Zámky modulů pro čtení a zápis</span><span class="sxs-lookup"><span data-stu-id="f2a2f-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
- [<span data-ttu-id="f2a2f-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="f2a2f-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
- [<span data-ttu-id="f2a2f-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="f2a2f-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
- [<span data-ttu-id="f2a2f-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="f2a2f-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
