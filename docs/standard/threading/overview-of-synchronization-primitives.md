---
title: "Přehled primitiv synchronizace"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
caps.latest.revision: "17"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 79d6e384458e289c4da8587eae66486a054aad08
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/23/2017
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="c3306-102">Přehled primitiv synchronizace</span><span class="sxs-lookup"><span data-stu-id="c3306-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a><span data-ttu-id="c3306-103">Rozhraní .NET Framework poskytuje celou řadu synchronizace primitiv pro řízení interakce vláken a vyloučení časování.</span><span class="sxs-lookup"><span data-stu-id="c3306-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="c3306-104">To je možné zhruba rozdělit do tří kategorií: zamykání, signalizační a interlocked operace.</span><span class="sxs-lookup"><span data-stu-id="c3306-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="c3306-105">Kategorie nejsou přehledně ani jasně definované: Některé mechanismy synchronizace mají charakteristické vlastnosti třídy více kategorií; události, které verze jedním vláknem a současně jsou funkčně jako zámky; verze všech zámku lze považovat za signál; a propojené operace lze použít k vytvoření zámky.</span><span class="sxs-lookup"><span data-stu-id="c3306-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="c3306-106">Kategorie jsou však stále užitečné.</span><span class="sxs-lookup"><span data-stu-id="c3306-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="c3306-107">Je důležité si pamatovat, že je synchronizace vláken spolupráci.</span><span class="sxs-lookup"><span data-stu-id="c3306-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="c3306-108">Pokud ani jedno vlákno obchází synchronizační mechanismus a přistupuje k chráněnému prostředku přímo, nelze tento synchronizační mechanismus efektivní.</span><span class="sxs-lookup"><span data-stu-id="c3306-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="c3306-109">Tento přehled obsahuje následující části:</span><span class="sxs-lookup"><span data-stu-id="c3306-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="c3306-110">Zamykání</span><span class="sxs-lookup"><span data-stu-id="c3306-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="c3306-111">Signalizace</span><span class="sxs-lookup"><span data-stu-id="c3306-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="c3306-112">Typy zjednodušené synchronizace</span><span class="sxs-lookup"><span data-stu-id="c3306-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="c3306-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="c3306-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="c3306-114">Propojené operace</span><span class="sxs-lookup"><span data-stu-id="c3306-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="c3306-115">Zamykání</span><span class="sxs-lookup"><span data-stu-id="c3306-115">Locking</span></span>  
 <span data-ttu-id="c3306-116">Zámky poskytnou kontrolu prostředku jedno vlákno najednou, nebo určený počet vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="c3306-117">Vlákno, které žádá o výhradní zámek Pokud zámek je používán bloky dokud nebude k dispozici zámek.</span><span class="sxs-lookup"><span data-stu-id="c3306-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="c3306-118">Výhradní zámky.</span><span class="sxs-lookup"><span data-stu-id="c3306-118">Exclusive Locks</span></span>  
 <span data-ttu-id="c3306-119">Je nejjednodušší forma uzamčení `lock` příkaz v jazyce C# a `SyncLock` v jazyce Visual Basic, který určuje přístup do bloku kódu.</span><span class="sxs-lookup"><span data-stu-id="c3306-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="c3306-120">Takové blok se často označuje jako důležitý oddíl.</span><span class="sxs-lookup"><span data-stu-id="c3306-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="c3306-121">`lock` Příkaz je implementována pomocí <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> a <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody a používá `try…catch…finally` blok k zajištění toho, že je vydán zámek.</span><span class="sxs-lookup"><span data-stu-id="c3306-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses `try…catch…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="c3306-122">Obecně platí, pomocí `lock` nebo `SyncLock` příkaz k ochraně malé bloky kódu, nikdy pokrývání uzlů více než jedné metody, je nejlepší způsob, jak používat <xref:System.Threading.Monitor> – třída.</span><span class="sxs-lookup"><span data-stu-id="c3306-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="c3306-123">I když výkonné, <xref:System.Threading.Monitor> třídy jsou náchylné na bez synchronní kopie zámků a blokování.</span><span class="sxs-lookup"><span data-stu-id="c3306-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="c3306-124">Monitor – třída</span><span class="sxs-lookup"><span data-stu-id="c3306-124">Monitor Class</span></span>  
 <span data-ttu-id="c3306-125"><xref:System.Threading.Monitor> Třída poskytuje další funkce, který můžete použít ve spojení s `lock` příkaz:</span><span class="sxs-lookup"><span data-stu-id="c3306-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="c3306-126"><xref:System.Threading.Monitor.TryEnter%2A> Metoda umožňuje vlákno, které se zablokuje čekáním na prostředek, který uvolňovat po určité době.</span><span class="sxs-lookup"><span data-stu-id="c3306-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="c3306-127">Vrátí logickou hodnotu udávající úspěch nebo selhání, který můžete použít ke zjištění a vyhnout potenciální zablokování.</span><span class="sxs-lookup"><span data-stu-id="c3306-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="c3306-128"><xref:System.Threading.Monitor.Wait%2A> Metoda je volána metodou vlákna v kritická sekce.</span><span class="sxs-lookup"><span data-stu-id="c3306-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="c3306-129">Umožňuje až řízení prostředků a bloky, dokud daný prostředek k dispozici znovu.</span><span class="sxs-lookup"><span data-stu-id="c3306-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="c3306-130"><xref:System.Threading.Monitor.Pulse%2A> a <xref:System.Threading.Monitor.PulseAll%2A> povolit vlákno, které chcete uvolnit zámek, nebo k volání metody <xref:System.Threading.Monitor.Wait%2A> uvést jednu nebo více podprocesů do připravené fronty, tak, aby se můžete získat zámek.</span><span class="sxs-lookup"><span data-stu-id="c3306-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="c3306-131">Časové limity na <xref:System.Threading.Monitor.Wait%2A> přetížení metody povolit čekání vláken, abyste se vyhnuli do připravené fronty.</span><span class="sxs-lookup"><span data-stu-id="c3306-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="c3306-132"><xref:System.Threading.Monitor> Třída může poskytnout zamykání ve více doménách aplikace, pokud je objekt použitý pro zámek odvozena z <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="c3306-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="c3306-133"><xref:System.Threading.Monitor>má spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="c3306-134">To znamená, musí ukončit vlákno, které zadali monitorování voláním <xref:System.Threading.Monitor.Exit%2A> nebo <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3306-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="c3306-135"><xref:System.Threading.Monitor> Třída není instantiable.</span><span class="sxs-lookup"><span data-stu-id="c3306-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="c3306-136">Její metody jsou statické (`Shared` v jazyce Visual Basic) a provádění akcí na instantiable zámek objektu.</span><span class="sxs-lookup"><span data-stu-id="c3306-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="c3306-137">Koncepční přehled, najdete v části [monitorování](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="c3306-137">For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="c3306-138">Mutex – třída</span><span class="sxs-lookup"><span data-stu-id="c3306-138">Mutex Class</span></span>  
 <span data-ttu-id="c3306-139">Žádost o vláken <xref:System.Threading.Mutex> voláním přetížení jeho <xref:System.Threading.WaitHandle.WaitOne%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="c3306-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="c3306-140">Přetížení s časové limity jsou uvedeny umožňující vláken uvolňovat čekání.</span><span class="sxs-lookup"><span data-stu-id="c3306-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="c3306-141">Na rozdíl od <xref:System.Threading.Monitor> třída, mutex může být buď místní nebo globální.</span><span class="sxs-lookup"><span data-stu-id="c3306-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="c3306-142">Globální mutex – třídy, označované taky jako s názvem mutex – třídy, jsou viditelné v rámci operačního systému a slouží k synchronizaci vláken ve více domén aplikací nebo procesů.</span><span class="sxs-lookup"><span data-stu-id="c3306-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="c3306-143">Místní mutex – třídy odvozovat od <xref:System.MarshalByRefObject>a lze použít v rámci hranice domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3306-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="c3306-144">Kromě toho <xref:System.Threading.Mutex> je odvozena z <xref:System.Threading.WaitHandle>, což znamená, že lze použít s signalizační mechanismy poskytované <xref:System.Threading.WaitHandle>, jako <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, a <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c3306-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="c3306-145">Jako <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> má spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="c3306-146">Na rozdíl od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> je instantiable objektem.</span><span class="sxs-lookup"><span data-stu-id="c3306-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="c3306-147">Koncepční přehled, najdete v části [mutex – třídy](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="c3306-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="c3306-148">SpinLock – třída</span><span class="sxs-lookup"><span data-stu-id="c3306-148">SpinLock Class</span></span>  
 <span data-ttu-id="c3306-149">Od verze [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], můžete použít <xref:System.Threading.SpinLock> třídy, pokud to vyžaduje nároky na <xref:System.Threading.Monitor> snižuje výkon.</span><span class="sxs-lookup"><span data-stu-id="c3306-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="c3306-150">Když <xref:System.Threading.SpinLock> zaznamená uzamčeném kritická sekce ho jednoduše otáčí ve smyčce dokud nebude k dispozici zámek.</span><span class="sxs-lookup"><span data-stu-id="c3306-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="c3306-151">Pokud pro velmi krátké době je blokován zámek, roztočený může poskytovat lepší výkon než blokování.</span><span class="sxs-lookup"><span data-stu-id="c3306-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="c3306-152">Ale v případě, že je blokován zámek pro víc než několik desítkami cykly, <xref:System.Threading.SpinLock> provede stejně dobře jako <xref:System.Threading.Monitor>, ale budou používat další cyklů procesoru a proto může snížit výkon jiných vláken nebo procesy.</span><span class="sxs-lookup"><span data-stu-id="c3306-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="c3306-153">Další zámky.</span><span class="sxs-lookup"><span data-stu-id="c3306-153">Other Locks</span></span>  
 <span data-ttu-id="c3306-154">Zámky nemusí být výhradní.</span><span class="sxs-lookup"><span data-stu-id="c3306-154">Locks need not be exclusive.</span></span> <span data-ttu-id="c3306-155">Je často užitečné povolit omezený počet vláken souběžný přístup k prostředku.</span><span class="sxs-lookup"><span data-stu-id="c3306-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="c3306-156">Semaforů a čtení a zápis zámky slouží k řízení tento druh přístupu k prostředkům ve fondu.</span><span class="sxs-lookup"><span data-stu-id="c3306-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="c3306-157">ReaderWriterLock – třída</span><span class="sxs-lookup"><span data-stu-id="c3306-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="c3306-158"><xref:System.Threading.ReaderWriterLockSlim> Třída řeší tento případ, kdy vlákno, které mění data, modul pro zápis, musí mít výhradní přístup k prostředku.</span><span class="sxs-lookup"><span data-stu-id="c3306-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="c3306-159">Když v modulu pro zápis není aktivní, libovolný počet čtenářů má přístup k prostředku (například voláním <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metoda).</span><span class="sxs-lookup"><span data-stu-id="c3306-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="c3306-160">Pokud vlákno vyžaduje výhradní přístup (například voláním <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metoda), následné čtečky požadavky bloku, dokud všechny existující čtečky se odpojili zámek a zapisovač zadal a byl ukončen zámek.</span><span class="sxs-lookup"><span data-stu-id="c3306-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="c3306-161"><xref:System.Threading.ReaderWriterLockSlim>má spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="c3306-162">Koncepční přehled, najdete v části [zamkne čtení a zápis](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="c3306-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="c3306-163">Semaphore – třída</span><span class="sxs-lookup"><span data-stu-id="c3306-163">Semaphore Class</span></span>  
 <span data-ttu-id="c3306-164"><xref:System.Threading.Semaphore> Třída umožňuje zadaný počet vláken pro přístup k prostředkům.</span><span class="sxs-lookup"><span data-stu-id="c3306-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="c3306-165">Požaduje bloku prostředků, dokud vlákno uvolní semaforu další vlákna.</span><span class="sxs-lookup"><span data-stu-id="c3306-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="c3306-166">Podobně jako <xref:System.Threading.Mutex> třídy, <xref:System.Threading.Semaphore> je odvozena z <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c3306-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c3306-167">Také jako <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> může být místní nebo globální.</span><span class="sxs-lookup"><span data-stu-id="c3306-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="c3306-168">Lze přes hranice domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3306-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="c3306-169">Na rozdíl od <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, a <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> nemá spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="c3306-170">To znamená, že je možné ve scénářích, kde jedno vlákno získá semafor a jiné uvolněním.</span><span class="sxs-lookup"><span data-stu-id="c3306-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="c3306-171">Koncepční přehled, najdete v části [semafor a SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="c3306-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="c3306-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>je lightweight semafor pro synchronizaci v jednom procesu hranici.</span><span class="sxs-lookup"><span data-stu-id="c3306-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="c3306-173">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="c3306-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="c3306-174">Signálů</span><span class="sxs-lookup"><span data-stu-id="c3306-174">Signaling</span></span>  
 <span data-ttu-id="c3306-175">Nejjednodušší způsob, jak Počkejte, než je signál z jiné vlákno k volání <xref:System.Threading.Thread.Join%2A> metoda, která blokuje až do dokončení jiné vlákno.</span><span class="sxs-lookup"><span data-stu-id="c3306-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="c3306-176"><xref:System.Threading.Thread.Join%2A>má dva přetížení, která umožňují blokované vlákno pro přerušení mimo dobu, po uplynutí zadaného intervalu.</span><span class="sxs-lookup"><span data-stu-id="c3306-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="c3306-177">Obslužné rutiny čekání poskytují mnohem širší čekání a možnosti signalizace.</span><span class="sxs-lookup"><span data-stu-id="c3306-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="c3306-178">Obslužné rutiny čekání</span><span class="sxs-lookup"><span data-stu-id="c3306-178">Wait Handles</span></span>  
 <span data-ttu-id="c3306-179">Obslužné rutiny čekání odvozena od <xref:System.Threading.WaitHandle> třída, která naopak je odvozena z <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="c3306-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="c3306-180">Proto obslužné rutiny čekání slouží k synchronizaci aktivity vláken napříč hranicemi domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="c3306-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="c3306-181">Blokování vlákna na čekání zpracovává voláním metody instance <xref:System.Threading.WaitHandle.WaitOne%2A> nebo jeden z statických metod <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, nebo <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3306-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="c3306-182">Jak jsou vydávány závisí na volala se metoda, která a na druhu obslužné rutiny čekání.</span><span class="sxs-lookup"><span data-stu-id="c3306-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="c3306-183">Koncepční přehled, najdete v části [počkejte zpracovává](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="c3306-183">For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="c3306-184">Obslužné rutiny čekání na události</span><span class="sxs-lookup"><span data-stu-id="c3306-184">Event Wait Handles</span></span>  
 <span data-ttu-id="c3306-185">Obslužné rutiny čekání na událost zahrnují <xref:System.Threading.EventWaitHandle> třída a odvozené třídy, <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="c3306-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="c3306-186">Vláken vydávají z popisovač čekání událost signalizace událostí popisovač čekání voláním jeho <xref:System.Threading.EventWaitHandle.Set%2A> metoda nebo pomocí <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="c3306-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="c3306-187">Obslužné rutiny buď sami automaticky resetovat, jako je Turniket, který umožňuje pouze jedno vlákno prostřednictvím pokaždé, když signalizace, nebo musí být ručně, obnovit jako bránu je uzavřen, dokud signál a pak otevřete, dokud ho někdo nezavře čekání událostí.</span><span class="sxs-lookup"><span data-stu-id="c3306-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="c3306-188">Jak je určeno, jejich názvy, <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent> představují bývalé a druhé, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="c3306-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="c3306-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>je lightweight událost pro synchronizaci v jednom procesu hranici.</span><span class="sxs-lookup"><span data-stu-id="c3306-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="c3306-190"><xref:System.Threading.EventWaitHandle> Může představovat buď typ události a může být místní nebo globální.</span><span class="sxs-lookup"><span data-stu-id="c3306-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="c3306-191">Odvozené třídy <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent> jsou vždy místní.</span><span class="sxs-lookup"><span data-stu-id="c3306-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="c3306-192">Obslužné rutiny čekání na událost nemají spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="c3306-193">Jakékoli vlákno mohou signalizovat čekání popisovač události.</span><span class="sxs-lookup"><span data-stu-id="c3306-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="c3306-194">Koncepční přehled, najdete v části [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="c3306-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="c3306-195">Semafor třídy a mutex</span><span class="sxs-lookup"><span data-stu-id="c3306-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="c3306-196">Protože <xref:System.Threading.Mutex> a <xref:System.Threading.Semaphore> třídy jsou odvozeny od <xref:System.Threading.WaitHandle>, lze pomocí statických metod <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c3306-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c3306-197">Například můžete použít vlákna <xref:System.Threading.WaitHandle.WaitAll%2A> metoda počkat, dokud jsou splněny všechny tři z následujících akcí: <xref:System.Threading.EventWaitHandle> signalizace, <xref:System.Threading.Mutex> vydání a <xref:System.Threading.Semaphore> vydání.</span><span class="sxs-lookup"><span data-stu-id="c3306-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="c3306-198">Podobně můžete použít vlákna <xref:System.Threading.WaitHandle.WaitAny%2A> metoda počkat, dokud platí jedna z těchto podmínek.</span><span class="sxs-lookup"><span data-stu-id="c3306-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="c3306-199">Pro <xref:System.Threading.Mutex> nebo <xref:System.Threading.Semaphore>, probíhá signál znamená vydán.</span><span class="sxs-lookup"><span data-stu-id="c3306-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="c3306-200">Pokud buď typ se používá jako první argument funkce <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda, jeho vydání.</span><span class="sxs-lookup"><span data-stu-id="c3306-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="c3306-201">U <xref:System.Threading.Mutex>, který má spřažení vláken, je vyvolána výjimka, pokud objekt mutex není vlastníkem volající vlákno.</span><span class="sxs-lookup"><span data-stu-id="c3306-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="c3306-202">Jak je uvedeno dříve, nemají semaforů spřažení vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="c3306-203">Bariéra</span><span class="sxs-lookup"><span data-stu-id="c3306-203">Barrier</span></span>  
 <span data-ttu-id="c3306-204"><xref:System.Threading.Barrier> Třída poskytuje způsob, jak cyklicky synchronizovat více vláken, tak, aby se všechny bloku zároveň bodu a počkat na všechna vlákna k dokončení.</span><span class="sxs-lookup"><span data-stu-id="c3306-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="c3306-205">Bariéry je užitečné, pokud jeden nebo více podprocesů vyžadují výsledky jiné vlákno před pokračováním do další fáze algoritmu.</span><span class="sxs-lookup"><span data-stu-id="c3306-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="c3306-206">Další informace najdete v tématu [Barrier](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="c3306-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="c3306-207">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="c3306-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="c3306-208">Typy zjednodušené synchronizace</span><span class="sxs-lookup"><span data-stu-id="c3306-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="c3306-209">Od verze [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], můžete použít primitiv synchronizace, které poskytují vysoký výkon vyhnout nákladné spoléhat na Win32 jádra objekty, například obslužné rutiny, kdykoli je to možné čekání.</span><span class="sxs-lookup"><span data-stu-id="c3306-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="c3306-210">Obecně platí měli byste použít tyto typy po krátkou dobu čekání a jenom v případě, že jste se pokusili a nevyhovující původní typy synchronizace.</span><span class="sxs-lookup"><span data-stu-id="c3306-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="c3306-211">Prosté typů nelze použít ve scénářích, které vyžadují komunikaci mezi procesy.</span><span class="sxs-lookup"><span data-stu-id="c3306-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="c3306-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>je Odlehčená verze <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c3306-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c3306-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>je Odlehčená verze <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c3306-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c3306-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType>představuje událost, která se změní na signál, když jeho počtu nula.</span><span class="sxs-lookup"><span data-stu-id="c3306-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="c3306-215"><xref:System.Threading.Barrier?displayProperty=nameWithType>Umožňuje synchronizovat sebou bez použití ovládacího prvku hlavní vlákno více vláken.</span><span class="sxs-lookup"><span data-stu-id="c3306-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="c3306-216">Bariéry brání každé vlákno z budete pokračovat, dokud všechna vlákna dosáhli Zadaný bod.</span><span class="sxs-lookup"><span data-stu-id="c3306-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="c3306-217">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="c3306-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="c3306-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="c3306-218">SpinWait</span></span>  
 <span data-ttu-id="c3306-219">Od verze [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], můžete použít <xref:System.Threading.SpinWait?displayProperty=nameWithType> struktury vlákno musí čekat signál události nebo podmínky, které musí být splněné, ale když skutečné čekací doba musí být menší než doba čekání požadované pomocí popisovač čekání nebo otherwi se blokování aktuální vlákno.</span><span class="sxs-lookup"><span data-stu-id="c3306-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="c3306-220">Pomocí <xref:System.Threading.SpinWait>, můžete zadat krátké době číselníku při čekání, a pak yield (například podle čekání nebo režimu spánku) pouze v případě, že nebyla splněna podmínka v určeném čase.</span><span class="sxs-lookup"><span data-stu-id="c3306-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="c3306-221">Zpět na začátek</span><span class="sxs-lookup"><span data-stu-id="c3306-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="c3306-222">Propojené operace</span><span class="sxs-lookup"><span data-stu-id="c3306-222">Interlocked Operations</span></span>  
 <span data-ttu-id="c3306-223">Propojené operace jsou jednoduché atomické operací provádí statických metod v umístění v paměti <xref:System.Threading.Interlocked> třídy.</span><span class="sxs-lookup"><span data-stu-id="c3306-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="c3306-224">Tyto atomická operace zahrnují přidání, zvýšit a snížení, exchange, v závislosti na porovnání, podmíněného exchange a čtení operací pro 64bitové hodnoty na 32bitové platformy.</span><span class="sxs-lookup"><span data-stu-id="c3306-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c3306-225">Zárukou toho nedělitelnost je omezený na jednotlivé operace; Při více operací se musí provádět jako jednotku, se musí použít více hrubý synchronizační mechanismus.</span><span class="sxs-lookup"><span data-stu-id="c3306-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="c3306-226">I když žádný z těchto operací jsou zámky nebo signály, jejich lze vytvořit zámků a signály.</span><span class="sxs-lookup"><span data-stu-id="c3306-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="c3306-227">Protože jsou nativní pro operační systém Windows, jsou velmi rychlé propojené operace.</span><span class="sxs-lookup"><span data-stu-id="c3306-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="c3306-228">Propojené operace lze použít s záruky volatile paměti pro psaní aplikací, které vykazují výkonné neblokující souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="c3306-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="c3306-229">Ale vyžadují sofistikované, nízké úrovně programování, tak pro většinu účelů jsou jednoduché zámky lepší volbou.</span><span class="sxs-lookup"><span data-stu-id="c3306-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="c3306-230">Koncepční přehled, najdete v části [propojený Operations](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="c3306-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c3306-231">Viz také</span><span class="sxs-lookup"><span data-stu-id="c3306-231">See Also</span></span>  
 [<span data-ttu-id="c3306-232">Synchronizace dat pro vícevláknové zpracování</span><span class="sxs-lookup"><span data-stu-id="c3306-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="c3306-233">Monitorování</span><span class="sxs-lookup"><span data-stu-id="c3306-233">Monitors</span></span>](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="c3306-234">Mutex – třídy</span><span class="sxs-lookup"><span data-stu-id="c3306-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="c3306-235">Semaphore a SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="c3306-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="c3306-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="c3306-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="c3306-237">Obslužné rutiny čekání</span><span class="sxs-lookup"><span data-stu-id="c3306-237">Wait Handles</span></span>](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="c3306-238">Propojené operace</span><span class="sxs-lookup"><span data-stu-id="c3306-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="c3306-239">Zámky modulů pro čtení a zápis</span><span class="sxs-lookup"><span data-stu-id="c3306-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="c3306-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="c3306-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="c3306-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="c3306-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="c3306-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="c3306-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
