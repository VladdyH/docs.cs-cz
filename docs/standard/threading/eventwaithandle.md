---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 665676a25aea48388ba01b8028af00049b113f2b
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/23/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="e20d7-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="e20d7-102">EventWaitHandle</span></span>
<span data-ttu-id="e20d7-103"><xref:System.Threading.EventWaitHandle> Třída umožňuje vláken pro komunikaci mezi sebou signalizace a čekání signály.</span><span class="sxs-lookup"><span data-stu-id="e20d7-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="e20d7-104">Obslužné rutiny událostí čekání (také označované jako události jednoduše) jsou popisovače čekání, které můžete signál, aby verze jeden nebo více podprocesů čekání.</span><span class="sxs-lookup"><span data-stu-id="e20d7-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="e20d7-105">Po to bylo signalizováno, popisovač čekání událostí je obnovit ručně nebo automaticky.</span><span class="sxs-lookup"><span data-stu-id="e20d7-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="e20d7-106"><xref:System.Threading.EventWaitHandle> Třída může představovat buď místní události popisovač čekání (místní události) nebo s názvem systémové události počkejte popisovač (s názvem události nebo událostí systému, viditelné pro všechny procesy).</span><span class="sxs-lookup"><span data-stu-id="e20d7-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e20d7-107">Obslužné rutiny čekání na událost nejsou události v tom smyslu, obvykle určená pomocí této aplikace word v rozhraní .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="e20d7-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="e20d7-108">Neexistují žádné delegáti nebo obslužné rutiny událostí související se situací.</span><span class="sxs-lookup"><span data-stu-id="e20d7-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="e20d7-109">Slova "událost" slouží k popisu je vzhledem k tomu, že budou mít tradičně se označuje jako událostí operačního systému, a vzhledem k tomu, že v rámci signalizace popisovač čekání označuje k čekání vláken, došlo k události.</span><span class="sxs-lookup"><span data-stu-id="e20d7-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="e20d7-110">Obslužné rutiny čekání oba pojmenované a místní událostí pomocí systému synchronizačními objekty, které jsou chráněny <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> obálky zajistit uvolnění prostředků.</span><span class="sxs-lookup"><span data-stu-id="e20d7-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="e20d7-111">Můžete použít <xref:System.Threading.WaitHandle.Dispose%2A> metodu pro uvolnění prostředků hned po dokončení pomocí objektu.</span><span class="sxs-lookup"><span data-stu-id="e20d7-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="e20d7-112">Obslužné rutiny čekání událostí, které automaticky resetovat</span><span class="sxs-lookup"><span data-stu-id="e20d7-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="e20d7-113">Vytvoření událostí automatický reset zadáním <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> při vytváření <xref:System.Threading.EventWaitHandle> objektu.</span><span class="sxs-lookup"><span data-stu-id="e20d7-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="e20d7-114">Jak již název napovídá, tato událost synchronizace obnoví automaticky při signál po vydání jedním vláknem a čekání.</span><span class="sxs-lookup"><span data-stu-id="e20d7-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="e20d7-115">Signál události voláním jeho <xref:System.Threading.EventWaitHandle.Set%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="e20d7-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="e20d7-116">Automatické vynulování události se obvykle používají zajistit výhradní přístup k prostředku pro jedno vlákno najednou.</span><span class="sxs-lookup"><span data-stu-id="e20d7-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="e20d7-117">Vlákno požadavek na prostředek voláním <xref:System.Threading.WaitHandle.WaitOne%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="e20d7-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="e20d7-118">Pokud žádné jiné vlákno drží popisovač čekání, vrátí metoda `true` a volající vlákno má ovládací prvek prostředku.</span><span class="sxs-lookup"><span data-stu-id="e20d7-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e20d7-119">Stejně jako u všech mechanismů synchronizace, je nutné zajistit, že všechny cesty kódu čekání na popisovač odpovídající čekání před přístupem k chráněnému prostředku.</span><span class="sxs-lookup"><span data-stu-id="e20d7-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="e20d7-120">Synchronizace vláken je spolupráci.</span><span class="sxs-lookup"><span data-stu-id="e20d7-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="e20d7-121">Pokud událost automatický reset signalizace při žádné vláken čekají, zůstane signalizovaného, dokud vlákno pokusí čekat na něm.</span><span class="sxs-lookup"><span data-stu-id="e20d7-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="e20d7-122">Událost uvolní vlákno a okamžitě resetuje blokování následné vláken.</span><span class="sxs-lookup"><span data-stu-id="e20d7-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="e20d7-123">Obslužné rutiny čekání událostí, které ručně obnovit</span><span class="sxs-lookup"><span data-stu-id="e20d7-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="e20d7-124">Vytvořte Ruční vynulování události zadáním <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> při vytváření <xref:System.Threading.EventWaitHandle> objektu.</span><span class="sxs-lookup"><span data-stu-id="e20d7-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="e20d7-125">Jak již název napovídá, tato událost synchronizace, musí se obnovit ručně po jeho nesignalizuje.</span><span class="sxs-lookup"><span data-stu-id="e20d7-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="e20d7-126">Dokud se resetuje voláním jeho <xref:System.Threading.EventWaitHandle.Reset%2A> metoda, vláken, která čekání na popisovač události prakticky hned pokračovat bez blokování.</span><span class="sxs-lookup"><span data-stu-id="e20d7-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="e20d7-127">Ruční obnovení úkony událostí jako pro bránu corral.</span><span class="sxs-lookup"><span data-stu-id="e20d7-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="e20d7-128">Pokud není signál události, vláken, která čekat na něm blokovat jako koně v corral.</span><span class="sxs-lookup"><span data-stu-id="e20d7-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="e20d7-129">Když signalizace události voláním jeho <xref:System.Threading.EventWaitHandle.Set%2A> metoda, všechna vlákna čekání jsou zdarma pokračovat.</span><span class="sxs-lookup"><span data-stu-id="e20d7-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="e20d7-130">Událost zůstane signalizovaného dokud jeho <xref:System.Threading.EventWaitHandle.Reset%2A> metoda je volána.</span><span class="sxs-lookup"><span data-stu-id="e20d7-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="e20d7-131">Díky tomu Ruční vynulování události nevhodnější způsob pojmout až vláken, které je potřeba čekat, až jedno vlákno dokončí úlohu.</span><span class="sxs-lookup"><span data-stu-id="e20d7-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="e20d7-132">Jako koně ponechat corral jak dlouho trvá dobu vydaná vláken naplánovat podle operačního systému a pokračovat v provádění.</span><span class="sxs-lookup"><span data-stu-id="e20d7-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="e20d7-133">Pokud <xref:System.Threading.EventWaitHandle.Reset%2A> metoda je volána před všechna vlákna mít obnovil provádění, zbývající vláken znovu blokovat.</span><span class="sxs-lookup"><span data-stu-id="e20d7-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="e20d7-134">Které obnovení vláken a které blokování vláken závisí na náhodných faktorech, jako je zatížení systému, počet vláken čekání pro Plánovač a tak dále.</span><span class="sxs-lookup"><span data-stu-id="e20d7-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="e20d7-135">To není problém, pokud vlákno, které signály události končí po signalizace, což je nejběžnější vzor používání.</span><span class="sxs-lookup"><span data-stu-id="e20d7-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="e20d7-136">Pokud chcete, aby vlákno, které signalizace událostí zahájíte nové úlohy po všech čekání, které se mají obnovit vláken, musíte zablokovat až do mají obnovit všechna vlákna čekání.</span><span class="sxs-lookup"><span data-stu-id="e20d7-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="e20d7-137">Jinak máte časování a nepředvídatelné chování kódu.</span><span class="sxs-lookup"><span data-stu-id="e20d7-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="e20d7-138">Běžné funkce automatického nebo ručního události</span><span class="sxs-lookup"><span data-stu-id="e20d7-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="e20d7-139">Obvykle jeden nebo více podprocesů blokovat na <xref:System.Threading.EventWaitHandle> dokud odblokuje vlákno volá <xref:System.Threading.EventWaitHandle.Set%2A> metodu, která uvolní jeden vláken čekání (v případě událostí automatický reset) nebo všechny z nich (v případě ručního resetovat událostí).</span><span class="sxs-lookup"><span data-stu-id="e20d7-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="e20d7-140">Vlákno můžete signál <xref:System.Threading.EventWaitHandle> a pak blokovat, jako atomickou operaci, voláním statické <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="e20d7-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e20d7-141"><xref:System.Threading.EventWaitHandle>objekty lze použít s statických <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> a <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="e20d7-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="e20d7-142">Protože <xref:System.Threading.EventWaitHandle> a <xref:System.Threading.Mutex> třídy obě jsou odvozeny od <xref:System.Threading.WaitHandle>, můžete použít obě třídy pomocí těchto metod.</span><span class="sxs-lookup"><span data-stu-id="e20d7-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="e20d7-143">Pojmenované události</span><span class="sxs-lookup"><span data-stu-id="e20d7-143">Named Events</span></span>  
 <span data-ttu-id="e20d7-144">Operační systém Windows umožňuje obslužné rutiny čekání na událost názvy.</span><span class="sxs-lookup"><span data-stu-id="e20d7-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="e20d7-145">Pojmenované událost je celého systému.</span><span class="sxs-lookup"><span data-stu-id="e20d7-145">A named event is system wide.</span></span> <span data-ttu-id="e20d7-146">To znamená že po vytvoření pojmenovaného událostí je viditelná pro všechny vláken ve všech procesů.</span><span class="sxs-lookup"><span data-stu-id="e20d7-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="e20d7-147">Proto s názvem události slouží k synchronizaci aktivity procesy a také vláken.</span><span class="sxs-lookup"><span data-stu-id="e20d7-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="e20d7-148">Můžete vytvořit <xref:System.Threading.EventWaitHandle> objekt, který reprezentuje událostí s názvem systému pomocí jedné z konstruktorů, které určuje název události.</span><span class="sxs-lookup"><span data-stu-id="e20d7-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e20d7-149">Vzhledem k pojmenované události jsou celého systému, je možné, že více <xref:System.Threading.EventWaitHandle> objekty, které představují stejné s názvem událostí.</span><span class="sxs-lookup"><span data-stu-id="e20d7-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="e20d7-150">Při každém volání konstruktoru, nebo <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metoda, nový <xref:System.Threading.EventWaitHandle> je vytvořen objekt.</span><span class="sxs-lookup"><span data-stu-id="e20d7-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="e20d7-151">Zadat stejný název opakovaně vytvoří více objektů, které představují stejnou událost s názvem.</span><span class="sxs-lookup"><span data-stu-id="e20d7-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="e20d7-152">Upozornění se doporučuje při použití s názvem události.</span><span class="sxs-lookup"><span data-stu-id="e20d7-152">Caution is advised in using named events.</span></span> <span data-ttu-id="e20d7-153">Protože jsou celého systému, může jiný proces, který používá stejný název neočekávaně blokovat vaší vláken.</span><span class="sxs-lookup"><span data-stu-id="e20d7-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="e20d7-154">Škodlivý kód provádění na stejném počítači může použít jako základ útoku denial of service.</span><span class="sxs-lookup"><span data-stu-id="e20d7-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="e20d7-155">Použít zabezpečení řízení přístupu k ochraně <xref:System.Threading.EventWaitHandle> objekt, který představuje pojmenovanou událostí, pokud možno s využitím konstruktor, který určuje <xref:System.Security.AccessControl.EventWaitHandleSecurity> objektu.</span><span class="sxs-lookup"><span data-stu-id="e20d7-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="e20d7-156">Můžete taky použít přístupu k řízení zabezpečení pomocí <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metoda, ale ponechá okno ohrožení zabezpečení mezi časem popisovač čekání událostí je vytvořen a čas, který je chráněn.</span><span class="sxs-lookup"><span data-stu-id="e20d7-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="e20d7-157">Ochrana události pomocí řízení přístupu zabezpečení pomáhá zabránit útoky se zlými úmysly, ale nebyl vyřešen problém kolize neúmyslnému názvů.</span><span class="sxs-lookup"><span data-stu-id="e20d7-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e20d7-158">Na rozdíl od <xref:System.Threading.EventWaitHandle> třídu, odvozené třídy <xref:System.Threading.AutoResetEvent> a <xref:System.Threading.ManualResetEvent> můžete představují pouze místní obslužné rutiny čekání.</span><span class="sxs-lookup"><span data-stu-id="e20d7-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="e20d7-159">Nelze představují pojmenované systémové události.</span><span class="sxs-lookup"><span data-stu-id="e20d7-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e20d7-160">Viz také</span><span class="sxs-lookup"><span data-stu-id="e20d7-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="e20d7-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="e20d7-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
