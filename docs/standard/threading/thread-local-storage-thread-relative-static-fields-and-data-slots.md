---
title: 'Úložiště vláken Thread Local: statická pole a datové sloty ve vztahu k vláknům'
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a17bc509c8c82bfb30811ec3511207ca2d823e5b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2018
ms.locfileid: "33589851"
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a><span data-ttu-id="8381a-102">Úložiště vláken Thread Local: statická pole a datové sloty ve vztahu k vláknům</span><span class="sxs-lookup"><span data-stu-id="8381a-102">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span>
<span data-ttu-id="8381a-103">Můžete použít spravované úložiště thread local (TLS) k uložení dat které jsou jedinečné pro přístup z více vláken a aplikace domény.</span><span class="sxs-lookup"><span data-stu-id="8381a-103">You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.</span></span> <span data-ttu-id="8381a-104">Rozhraní .NET Framework poskytuje dva způsoby, jak používat spravované TLS: statická pole a datové sloty relativní vůči vláknu.</span><span class="sxs-lookup"><span data-stu-id="8381a-104">The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.</span></span>  
  
-   <span data-ttu-id="8381a-105">Použít statická pole relativní vůči vláknu (relativní vůči vláknu `Shared` pole v jazyce Visual Basic) Pokud očekáváte při kompilaci vašim konkrétním potřebám.</span><span class="sxs-lookup"><span data-stu-id="8381a-105">Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time.</span></span> <span data-ttu-id="8381a-106">Statická pole relativní vůči vláknu poskytovat nejlepší výkon.</span><span class="sxs-lookup"><span data-stu-id="8381a-106">Thread-relative static fields provide the best performance.</span></span> <span data-ttu-id="8381a-107">Také vám výhody kontrola typu v kompilaci.</span><span class="sxs-lookup"><span data-stu-id="8381a-107">They also give you the benefits of compile-time type checking.</span></span>  
  
-   <span data-ttu-id="8381a-108">Datové sloty ve vztahu použijte, pokud může být zjištěny skutečné požadavky jenom za běhu.</span><span class="sxs-lookup"><span data-stu-id="8381a-108">Use data slots when your actual requirements might be discovered only at run time.</span></span> <span data-ttu-id="8381a-109">Datové sloty ve vztahu je pomalejší a více nevhodných než statická pole relativní vůči vláknu a data se ukládají jako typ <xref:System.Object>, takže musíte vysílat na správný typ dříve, než ho použijete.</span><span class="sxs-lookup"><span data-stu-id="8381a-109">Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.</span></span>  
  
 <span data-ttu-id="8381a-110">V jazyce C++ nespravované použijete `TlsAlloc` dynamicky přidělit sloty a `__declspec(thread)` deklarovat, že by měla být proměnnou přidělená v relativní vůči vláknu úložiště.</span><span class="sxs-lookup"><span data-stu-id="8381a-110">In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage.</span></span> <span data-ttu-id="8381a-111">Statická pole a datové sloty relativní vůči vláknu zadejte spravovaná verze toto chování.</span><span class="sxs-lookup"><span data-stu-id="8381a-111">Thread-relative static fields and data slots provide the managed version of this behavior.</span></span>  
  
 <span data-ttu-id="8381a-112">V [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], můžete použít <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> třídy za účelem vytvoření místní objekty, které jsou inicializovány líné, když je objekt nejprve zpracován.</span><span class="sxs-lookup"><span data-stu-id="8381a-112">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed.</span></span> <span data-ttu-id="8381a-113">Další informace najdete v tématu [opožděné inicializace](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="8381a-113">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="uniqueness-of-data-in-managed-tls"></a><span data-ttu-id="8381a-114">Jedinečnost dat v spravované TLS</span><span class="sxs-lookup"><span data-stu-id="8381a-114">Uniqueness of Data in Managed TLS</span></span>  
 <span data-ttu-id="8381a-115">Jestli používáte statická pole relativní vůči vláknu nebo datové sloty ve vztahu, data ve spravovaných TLS je jedinečná kombinace domény přístup z více vláken a aplikace.</span><span class="sxs-lookup"><span data-stu-id="8381a-115">Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.</span></span>  
  
-   <span data-ttu-id="8381a-116">V doméně aplikace jedno vlákno nelze upravit data z jiného vlákna, i když obě vlákna používat stejné pole nebo slot.</span><span class="sxs-lookup"><span data-stu-id="8381a-116">Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.</span></span>  
  
-   <span data-ttu-id="8381a-117">Když vlákno přistupuje k stejné pole nebo slotu z několika domén aplikace, hodnotu samostatné se udržuje v každé doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="8381a-117">When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.</span></span>  
  
 <span data-ttu-id="8381a-118">Například pokud je nastaví vlákno hodnotu statická pole relativní vůči vláknu, vstoupí do jiné domény aplikace a pak načte hodnotu pole, hodnota načíst v druhé doméně aplikace se liší od hodnoty v prvním domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="8381a-118">For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.</span></span> <span data-ttu-id="8381a-119">Nastavením nové hodnoty pro pole v druhé doméně aplikace nemá vliv na hodnotu pole v první domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="8381a-119">Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.</span></span>  
  
 <span data-ttu-id="8381a-120">Podobně když vlákno získá stejný slot s názvem dat ve dvou různých aplikační domény, data v první doména aplikace zůstane nezávisle na datech v druhé doméně aplikace.</span><span class="sxs-lookup"><span data-stu-id="8381a-120">Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.</span></span>  
  
## <a name="thread-relative-static-fields"></a><span data-ttu-id="8381a-121">Statická pole relativní vůči vláknu</span><span class="sxs-lookup"><span data-stu-id="8381a-121">Thread-Relative Static Fields</span></span>  
 <span data-ttu-id="8381a-122">Pokud víte, že část dat je vždy jedinečné pro přístup z více vláken a kombinace doménu aplikace, budou použity <xref:System.ThreadStaticAttribute> atribut statické pole.</span><span class="sxs-lookup"><span data-stu-id="8381a-122">If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field.</span></span> <span data-ttu-id="8381a-123">Pomocí pole, jako by použít jiné statické pole.</span><span class="sxs-lookup"><span data-stu-id="8381a-123">Use the field as you would use any other static field.</span></span> <span data-ttu-id="8381a-124">Data v poli je jedinečné pro každé vlákno, které ji používají.</span><span class="sxs-lookup"><span data-stu-id="8381a-124">The data in the field is unique to each thread that uses it.</span></span>  
  
 <span data-ttu-id="8381a-125">Statická pole relativní vůči vláknu poskytují lepší výkon než datové sloty ve vztahu a mají výhodou kontrola typu v kompilaci.</span><span class="sxs-lookup"><span data-stu-id="8381a-125">Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.</span></span>  
  
 <span data-ttu-id="8381a-126">Mějte na paměti, všechny kód konstruktoru třídy bude spuštěn na prvním vlákno v první kontextu, který má přístup k poli.</span><span class="sxs-lookup"><span data-stu-id="8381a-126">Be aware that any class constructor code will run on the first thread in the first context that accesses the field.</span></span> <span data-ttu-id="8381a-127">Ve všech dalších vláken kontexty ve stejné doméně aplikace, budou inicializována pole na `null` (`Nothing` v jazyce Visual Basic) Pokud jsou odkazové typy, nebo na jejich výchozí hodnoty, pokud jsou hodnoty typů.</span><span class="sxs-lookup"><span data-stu-id="8381a-127">In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types.</span></span> <span data-ttu-id="8381a-128">Proto byste neměli spoléhat na třídu konstruktory k chybě při inicializaci statická pole relativní vůči vláknu.</span><span class="sxs-lookup"><span data-stu-id="8381a-128">Therefore, you should not rely on class constructors to initialize thread-relative static fields.</span></span> <span data-ttu-id="8381a-129">Místo toho vyhnout inicializace statická pole relativní vůči vláknu a předpokládá, že jsou inicializovány pro `null` (`Nothing`) nebo na výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="8381a-129">Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.</span></span>  
  
## <a name="data-slots"></a><span data-ttu-id="8381a-130">Datové sloty ve vztahu</span><span class="sxs-lookup"><span data-stu-id="8381a-130">Data Slots</span></span>  
 <span data-ttu-id="8381a-131">Rozhraní .NET Framework poskytuje dynamická data sloty, které jsou jedinečné pro kombinaci přístup z více vláken a domény aplikace.</span><span class="sxs-lookup"><span data-stu-id="8381a-131">The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.</span></span> <span data-ttu-id="8381a-132">Existují dva typy datové sloty ve vztahu: s názvem sloty a nepojmenované sloty.</span><span class="sxs-lookup"><span data-stu-id="8381a-132">There are two types of data slots: named slots and unnamed slots.</span></span> <span data-ttu-id="8381a-133">Jak jsou implementované pomocí <xref:System.LocalDataStoreSlot> struktura.</span><span class="sxs-lookup"><span data-stu-id="8381a-133">Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.</span></span>  
  
-   <span data-ttu-id="8381a-134">Chcete-li vytvořit slot s názvem dat, použijte <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> nebo <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="8381a-134">To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8381a-135">Pokud chcete získat odkaz na existující slot s názvem, předat jeho název <xref:System.Threading.Thread.GetNamedDataSlot%2A> metoda.</span><span class="sxs-lookup"><span data-stu-id="8381a-135">To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.</span></span>  
  
-   <span data-ttu-id="8381a-136">Chcete-li vytvořit nepojmenované datové oblasti, použijte <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> metoda.</span><span class="sxs-lookup"><span data-stu-id="8381a-136">To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8381a-137">Pro oba pojmenované a nepojmenované sloty, pomocí <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> a <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> metody nastavit a načíst informace ve slotu.</span><span class="sxs-lookup"><span data-stu-id="8381a-137">For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot.</span></span> <span data-ttu-id="8381a-138">Toto jsou statické metody, které vždy fungovat na základě dat pro vlákno, které je aktuálně spouští.</span><span class="sxs-lookup"><span data-stu-id="8381a-138">These are static methods that always act on the data for the thread that is currently executing them.</span></span>  
  
 <span data-ttu-id="8381a-139">Pojmenované sloty může být vhodné, protože přihrádky můžete načíst, pokud budete potřebovat předáním jeho název <xref:System.Threading.Thread.GetNamedDataSlot%2A> metody, místo zachování odkaz na nepojmenované slot.</span><span class="sxs-lookup"><span data-stu-id="8381a-139">Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot.</span></span> <span data-ttu-id="8381a-140">Ale pokud další komponentou používá stejný název pro jeho relativní vůči vláknu úložiště a vlákna spustí kód příslušné součásti a další součásti, dvě součásti může dojít k poškození dat druhé strany.</span><span class="sxs-lookup"><span data-stu-id="8381a-140">However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.</span></span> <span data-ttu-id="8381a-141">(Tento scénář předpokládá, že obě komponenty běží ve stejné doméně aplikace a že nejsou určený pro sdílení stejná data.)</span><span class="sxs-lookup"><span data-stu-id="8381a-141">(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8381a-142">Viz také</span><span class="sxs-lookup"><span data-stu-id="8381a-142">See Also</span></span>  
 <xref:System.ContextStaticAttribute>  
 <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>  
 <xref:System.ThreadStaticAttribute>  
 <xref:System.Runtime.Remoting.Messaging.CallContext>  
 [<span data-ttu-id="8381a-143">Dělení na vlákna</span><span class="sxs-lookup"><span data-stu-id="8381a-143">Threading</span></span>](../../../docs/standard/threading/index.md)
