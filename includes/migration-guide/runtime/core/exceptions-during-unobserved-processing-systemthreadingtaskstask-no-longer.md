### <a name="exceptions-during-unobserved-processing-in-systemthreadingtaskstask-no-longer-propagate-on-finalizer-thread"></a><span data-ttu-id="c2b4d-101">Výjimky při zmeškané zpracování v System.Threading.Tasks.Task už rozšíří na finalizační metodu přístup z více vláken</span><span class="sxs-lookup"><span data-stu-id="c2b4d-101">Exceptions during unobserved processing in System.Threading.Tasks.Task no longer propagate on finalizer thread</span></span>

|   |   |
|---|---|
|<span data-ttu-id="c2b4d-102">Podrobnosti</span><span class="sxs-lookup"><span data-stu-id="c2b4d-102">Details</span></span>|<span data-ttu-id="c2b4d-103">Protože <xref:System.Threading.Tasks.Task?displayProperty=name> třída reprezentuje asynchronní operaci, zachytávalo všechny-závažné výjimky, ke kterým došlo během asynchronního zpracování.</span><span class="sxs-lookup"><span data-stu-id="c2b4d-103">Because the <xref:System.Threading.Tasks.Task?displayProperty=name> class represents an asynchronous operation, it catches all non-severe exceptions that occur during asynchronous processing.</span></span> <span data-ttu-id="c2b4d-104">V rozhraní .NET Framework 4.5 Pokud není dodržen výjimku a kódu nikdy čeká na úlohy, výjimka již nebude možné rozšířit na vlákno finalizační metodu a havárií proces během uvolňování paměti.</span><span class="sxs-lookup"><span data-stu-id="c2b4d-104">In the .NET Framework 4.5, if an exception is not observed and your code never waits on the task, the exception will no longer propagate on the finalizer thread and crash the process during garbage collection.</span></span> <span data-ttu-id="c2b4d-105">Tato změna zlepšuje spolehlivost aplikací, které pomocí třídy úlohy provádět zmeškané asynchronní zpracování.</span><span class="sxs-lookup"><span data-stu-id="c2b4d-105">This change enhances the reliability of applications that use the Task class to perform unobserved asynchronous processing.</span></span>|
|<span data-ttu-id="c2b4d-106">Návrh</span><span class="sxs-lookup"><span data-stu-id="c2b4d-106">Suggestion</span></span>|<span data-ttu-id="c2b4d-107">Pokud aplikace závisí na zmeškané asynchronní výjimky šíření finalizační metodu vlákno, může být obnovena předchozí chování tím, že poskytuje příslušnou obslužnou rutinu pro <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> události, nebo nastavením [element konfigurace runtime ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md).</span><span class="sxs-lookup"><span data-stu-id="c2b4d-107">If an app depends on unobserved asynchronous exceptions propagating to the finalizer thread, the previous behavior can be restored by providing an appropriate handler for the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> event, or by setting a [runtime configuration element](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md).</span></span>|
|<span data-ttu-id="c2b4d-108">Rozsah</span><span class="sxs-lookup"><span data-stu-id="c2b4d-108">Scope</span></span>|<span data-ttu-id="c2b4d-109">Edge</span><span class="sxs-lookup"><span data-stu-id="c2b4d-109">Edge</span></span>|
|<span data-ttu-id="c2b4d-110">Version</span><span class="sxs-lookup"><span data-stu-id="c2b4d-110">Version</span></span>|<span data-ttu-id="c2b4d-111">4.5</span><span class="sxs-lookup"><span data-stu-id="c2b4d-111">4.5</span></span>|
|<span data-ttu-id="c2b4d-112">Typ</span><span class="sxs-lookup"><span data-stu-id="c2b4d-112">Type</span></span>|<span data-ttu-id="c2b4d-113">Modul runtime</span><span class="sxs-lookup"><span data-stu-id="c2b4d-113">Runtime</span></span>|
|<span data-ttu-id="c2b4d-114">Ovlivněné rozhraní API</span><span class="sxs-lookup"><span data-stu-id="c2b4d-114">Affected APIs</span></span>|<ul><li><xref:System.Threading.Tasks.Task.Run(System.Action)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{%60%600})?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{%60%600},System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{System.Threading.Tasks.Task{%60%600}})?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{System.Threading.Tasks.Task{%60%600}},System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Start?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)?displayProperty=nameWithType></li></ul>|

